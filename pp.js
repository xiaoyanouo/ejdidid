// ==========================================
// X Social App - 独立JS整合文件
// 版本: 1.0
// 使用方式:
// 1. 在HTML中引入: <script src="x-social-app.js" defer></script>
// 2. 调用初始化: window.renderXSocialScreenProxy()

(function (window) {
 ('use strict');

  // 第一部分: CSS样式注入
  // ============================================
  function injectStyles() {
    const styleId = "x-social-app-styles"; // 避免重复注入
    if (document.getElementById(styleId)) return;
    const style = document.createElement("style");
    style.id = styleId;
    style.textContent = `
 /* ========== X社交页面主题变量 ========== */
 /* 将CSS变量限定在X应用容器内,避免影响其他页面 */
 #x-social-screen {
 --x-bg-primary: #000; --x-bg-secondary: #1a1a1a; --x-bg-hover: rgba(255,255,255,0.03); --x-border-color: #2f3336; --x-text-primary: #fff; --x-text-secondary: #71767b; --x-text-tertiary: #8b98a5; --x-accent: #1d9bf0; --x-input-bg: #1a1a1a; --x-modal-overlay: rgba(91, 112, 131, 0.4); }
 /* 日间模式 */
 #x-social-screen.x-theme-light {
 --x-bg-primary: #fff; --x-bg-secondary: #f7f9f9; --x-bg-hover: rgba(0,0,0,0.03); --x-border-color: #eff3f4; --x-text-primary: #0f1419; --x-text-secondary: #536471; --x-text-tertiary: #5b7083; --x-accent: #1d9bf0; --x-input-bg: #f7f9f9; --x-modal-overlay: rgba(0, 0, 0, 0.4); }
 /* ========== X社交页面基础样式 ========== */
 /* 自定义滚动条样式 - X风格（细长短小亮蓝色） */
 .tab-content::-webkit-scrollbar,
 #x-comments-page::-webkit-scrollbar,
 .comments-container::-webkit-scrollbar,
 .settings-content::-webkit-scrollbar,
 .profile-content::-webkit-scrollbar,
 .tweets-container::-webkit-scrollbar,
 #detail-comments-container::-webkit-scrollbar,
 .modal-body::-webkit-scrollbar,
 #identity-characters-list::-webkit-scrollbar,
 #characters-list::-webkit-scrollbar,
 #x-presets-list::-webkit-scrollbar,
 .tweet-media-scrollable::-webkit-scrollbar {
 width: 3px; }
 .tab-content::-webkit-scrollbar-track,
 #x-comments-page::-webkit-scrollbar-track,
 .comments-container::-webkit-scrollbar-track,
 .settings-content::-webkit-scrollbar-track,
 .profile-content::-webkit-scrollbar-track,
 .tweets-container::-webkit-scrollbar-track,
 #detail-comments-container::-webkit-scrollbar-track,
 .modal-body::-webkit-scrollbar-track,
 #identity-characters-list::-webkit-scrollbar-track,
 #characters-list::-webkit-scrollbar-track,
 #x-presets-list::-webkit-scrollbar-track,
 .tweet-media-scrollable::-webkit-scrollbar-track {
 background: transparent; }
 .tab-content::-webkit-scrollbar-thumb,
 #x-comments-page::-webkit-scrollbar-thumb,
 .comments-container::-webkit-scrollbar-thumb,
 .settings-content::-webkit-scrollbar-thumb,
 .profile-content::-webkit-scrollbar-thumb,
 .tweets-container::-webkit-scrollbar-thumb,
 #detail-comments-container::-webkit-scrollbar-thumb,
 .modal-body::-webkit-scrollbar-thumb,
 #identity-characters-list::-webkit-scrollbar-thumb,
 #characters-list::-webkit-scrollbar-thumb,
 #x-presets-list::-webkit-scrollbar-thumb,
 .tweet-media-scrollable::-webkit-scrollbar-thumb {
 background-color: color-mix(in srgb, var(--x-accent) 50%, transparent); border-radius: 10px; min-height: 30px; max-height: 80px; }
 .tab-content::-webkit-scrollbar-thumb:hover,
 #x-comments-page::-webkit-scrollbar-thumb:hover,
 .comments-container::-webkit-scrollbar-thumb:hover,
 .settings-content::-webkit-scrollbar-thumb:hover,
 .profile-content::-webkit-scrollbar-thumb:hover,
 .tweets-container::-webkit-scrollbar-thumb:hover,
 #detail-comments-container::-webkit-scrollbar-thumb:hover,
 .modal-body::-webkit-scrollbar-thumb:hover,
 #identity-characters-list::-webkit-scrollbar-thumb:hover,
 #characters-list::-webkit-scrollbar-thumb:hover,
 #x-presets-list::-webkit-scrollbar-thumb:hover,
 .tweet-media-scrollable::-webkit-scrollbar-thumb:hover {
 background-color: color-mix(in srgb, var(--x-accent) , 0.8); }
 .tab-content::-webkit-scrollbar-thumb:active,
 #x-comments-page::-webkit-scrollbar-thumb:active,
 .comments-container::-webkit-scrollbar-thumb:active,
 .settings-content::-webkit-scrollbar-thumb:active,
 .profile-content::-webkit-scrollbar-thumb:active,
 .tweets-container::-webkit-scrollbar-thumb:active,
 #detail-comments-container::-webkit-scrollbar-thumb:active,
 .modal-body::-webkit-scrollbar-thumb:active,
 #identity-characters-list::-webkit-scrollbar-thumb:active,
 #characters-list::-webkit-scrollbar-thumb:active,
 #x-presets-list::-webkit-scrollbar-thumb:active,
 .tweet-media-scrollable::-webkit-scrollbar-thumb:active {
 background-color: var(--x-accent); }
 /* 修复X社交页面高度布局问题 */
 #x-social-screen {
 height: 100vh !important; overflow: hidden !important; background-color:var(--x-bg-primary) !important; color:var(--x-text-primary) !important; }
 #x-social-screen .x-pages-container {
 min-height: 0 !important; background-color:var(--x-bg-primary) !important; }
 #x-social-screen .x-page {
 min-height: 0 !important; background-color:var(--x-bg-primary) !important; }
 #x-social-screen .x-bottom-nav {
 flex-shrink: 0 !important; background-color:var(--x-bg-primary) !important; border-top: 1px solid var(--x-border-color) !important; }
 /* 所有页面容器使用主题背景色 */
 #x-home-page,
 #x-search-page,
 #x-notifications-page,
 #x-messages-page,
 #x-comments-page,
 #x-settings-page,
 #x-tweet-detail-page,
 #x-profile-page,
 #account-profile-page {
 background-color:var(--x-bg-primary) !important; }
 /* 顶部导航栏 - 限定在X应用内 */
 #x-social-screen .x-top-bar,
 #x-social-screen .comments-header,
 #x-social-screen .settings-header,
 #x-social-screen .profile-header,
 #x-social-screen .tweet-detail-header {
 background-color:var(--x-bg-primary) !important; border-bottom: 1px solid var(--x-border-color) !important; }
 /* 标签栏 - 限定在X应用内 */
 #x-social-screen .x-home-tabs,
 #x-social-screen .search-tabs,
 #x-social-screen .profile-tabs {
 background-color:var(--x-bg-primary) !important; border-bottom: 1px solid var(--x-border-color) !important; }
 /* 输入区域 - 限定在X应用内 */
 #x-social-screen .comment-input-area,
 #x-social-screen .detail-comment-input-area {
 background-color:var(--x-bg-primary) !important; border-top: 1px solid var(--x-border-color) !important; }
 /* 设置页面内容 - 限定在X应用内 */
 #x-social-screen .settings-content {
 background-color:var(--x-bg-primary) !important; }
 /* 搜索头部 - 限定在X应用内 */
 #x-social-screen .search-header {
 background-color:var(--x-bg-primary) !important; border-bottom: 1px solid var(--x-border-color) !important; }
 /* 搜索框 - 限定在X应用内 */
 #x-social-screen .search-box {
 background-color: var(--x-input-bg) !important; }
 /* 热搜视图 - 限定在X应用内 */
 #trending-view,
 #x-social-screen .trending-list {
 background-color:var(--x-bg-primary) !important; }
 /* 搜索结果内容 */
 #search-results-content {
 background-color:var(--x-bg-primary) !important; }
 /* 弹窗和模态框 - 限定在X应用内 */
 #x-social-screen .modal-content,
 #x-social-screen .compose-modal-content,
 #x-social-screen #edit-profile-modal .modal-content,
 #x-social-screen #compose-tweet-modal .compose-modal-content,
 #character-x-profile-modal > div > div,
 #relationship-modal > div > div,
 #category-manager-modal > div,
 #character-relationship-graph-modal > div > div,
 #edit-relationship-detail-modal > div > div,
 #npc-edit-modal > div > div {
 background-color:var(--x-bg-primary) !important; }
 /* 模态框头部 - 限定在X应用内 */
 #x-social-screen .modal-header,
 #x-social-screen .compose-header {
 background-color:var(--x-bg-primary) !important; border-bottom: 1px solid var(--x-border-color) !important; }
 /* 模态框主体内容区域 - 限定在X应用内 */
 #x-social-screen .modal-body,
 #x-social-screen .compose-body {
 background-color:var(--x-bg-primary) !important; }
 /* 表单元素 - 限定在X应用内 */
 #x-social-screen input[type="text"],
 #x-social-screen input[type="url"],
 #x-social-screen input[type="email"],
 #x-social-screen textarea,
 #x-social-screen select {
 background-color: var(--x-input-bg) !important; border-color: var(--x-border-color) !important; color:var(--x-text-primary) !important; }
 #x-social-screen input[type="text"]:focus,
 #x-social-screen input[type="url"]:focus,
 #x-social-screen input[type="email"]:focus,
 #x-social-screen textarea:focus,
 #x-social-screen select:focus {
 border-color: var(--x-accent) !important; }
 /* 引用推文 - 限定在X应用内 */
 #x-social-screen .quoted-tweet {
 border-color: var(--x-border-color) !important; background-color: var(--x-bg-hover) !important; }
 /* 回复连接线 - 限定在X应用内 */
 #x-social-screen .comment-item.has-replies::after,
 #x-social-screen .reply-item::before {
 background-color: var(--x-border-color) !important; border-color: var(--x-border-color) !important; }
 /* 卡片和容器 */
 #character-info-display,
 #character-relationships-list,
 #identity-characters-list,
 #characters-list,
 #npcs-list,
 #npc-bind-users {
 background-color: var(--x-input-bg) !important; border-color: var(--x-border-color) !important; }
 /* 内容容器 - 限定在X应用内 */
 #x-social-screen .tab-content,
 #x-social-screen .tweets-container,
 #x-social-screen .comments-container,
 #detail-comments-container,
 #tweet-detail-container,
 #x-profile-tweets-container,
 #account-tweets-container,
 #x-social-screen .profile-content {
 background-color:var(--x-bg-primary) !important; }
 /* 列表项悬停效果 - 限定在X应用内 */
 #x-social-screen .tweet-item:hover,
 #x-social-screen .comment-item:hover,
 #x-social-screen .trending-item:hover {
 background-color: var(--x-bg-hover) !important; }
 /* 账户资料页面 - 限定在X应用内 */
 #x-social-screen .user-info-section,
 #x-social-screen .edit-avatar-section,
 #x-social-screen .edit-form-section {
 background-color:var(--x-bg-primary) !important; }
 /* 设置区域的卡片 */
 #character-binding-area > div,
 #relationship-binding-area > div,
 #npc-binding-area > div {
 background-color: var(--x-input-bg) !important; border-color: var(--x-border-color) !important; }
 /* 热搜项目 - 限定在X应用内 */
 #x-social-screen .trending-item {
 background-color:var(--x-bg-primary) !important; }
 /* 推文详情页面 - 限定在X应用内 */
 #x-social-screen .tweet-detail-content {
 background-color:var(--x-bg-primary) !important; }
 /* 所有文本颜色 */
 #x-social-screen span,
 #x-social-screen div:not(.tweet-action):not(.comment-action) {
 color: inherit; }
 /* 标签文本 - 限定在X应用内 */
 #x-social-screen .x-tab {
 color:var(--x-text-secondary) !important; }
 #x-social-screen .x-tab.active {
 color:var(--x-text-primary) !important; }
 /* SVG图标颜色 - 非激活状态 */
 #x-social-screen .x-back-btn svg,
 #x-social-screen .x-settings svg,
 #x-social-screen .x-refresh-btn svg,
 #x-social-screen .settings-back-btn svg,
 #x-social-screen .comments-back-btn svg,
 #x-social-screen .profile-back-btn svg,
 #x-social-screen .tweet-detail-back-btn svg {
 fill: var(--x-text-primary) !important; }
 /* 次要SVG图标 */
 #x-social-screen .tweet-more {
 color:var(--x-text-secondary) !important; }
 /* 按钮文本颜色 */
 #x-social-screen button {
 color: inherit; }
 /* 占位符文本 */
 #x-social-screen ::placeholder {
 color:var(--x-text-secondary) !important; }
 /* 次要文本元素 */
 .tweet-time,
 .tweet-user-handle,
 .comment-time,
 .quoted-user-handle,
 .quoted-user-time {
 color:var(--x-text-secondary) !important; }
 /* 主要文本元素 */
 .tweet-user-name,
 .tweet-content,
 .comment-content,
 .quoted-user-name,
 .quoted-content {
 color:var(--x-text-primary) !important; }
 /* 热搜标题和类别 */
 .trending-title {
 color:var(--x-text-primary) !important; }
 .trending-category,
 .trending-count {
 color:var(--x-text-secondary) !important; }
 /* 关系预览区域 */
 #relationship-preview {
 background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; }
 /* 关系图编辑器 */
 #relationship-graph-canvas {
 background-color:var(--x-bg-primary) !important; }
 /* ========== 账户主页和详情页动态元素样式 ========== */
 /* 账户主页推文容器内的所有span（覆盖内联样式） */
 #account-tweets-container span[style*="color: #fff"],
 #account-tweets-container span[style*="color:#fff"],
 #account-tweets-container span[style*="color: rgb(255, 255, 255)"] {
 color:var(--x-text-primary) !important; }
 #account-tweets-container span[style*="color: #71767b"],
 #account-tweets-container span[style*="color:#71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 账户主页推文容器内的div文本颜色 */
 #account-tweets-container div[style*="color: #fff"],
 #account-tweets-container div[style*="color:#fff"],
 #account-tweets-container div[style*="color: #e7e9ea"],
 #account-tweets-container div[style*="color:#e7e9ea"] {
 color:var(--x-text-primary) !important; }
 #account-tweets-container div[style*="color: #71767b"],
 #account-tweets-container div[style*="color:#71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 账户主页推文容器内的边框 */
 #account-tweets-container > div[style*="border-bottom"] {
 border-bottom-color: var(--x-border-color) !important; }
 /* 账户主页推文容器内的背景卡片 */
 #account-tweets-container div[style*="background-color: #202327"],
 #account-tweets-container div[style*="background-color:#202327"] {
 background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; }
 /* 账户主页推文容器内的SVG图标 */
 #account-tweets-container svg[style*="fill: currentColor"] {
 fill: currentColor !important; }
 #account-tweets-container svg[style*="fill: #71767b"],
 #account-tweets-container svg[style*="fill:#71767b"] {
 fill: var(--x-text-secondary) !important; }
 /* 推文详情页评论容器内的所有文本 */
 #detail-comments-container span[style*="color: #fff"],
 #detail-comments-container span[style*="color:#fff"] {
 color:var(--x-text-primary) !important; }
 #detail-comments-container span[style*="color: #71767b"],
 #detail-comments-container span[style*="color:#71767b"] {
 color:var(--x-text-secondary) !important; }
 #detail-comments-container div[style*="color: #fff"],
 #detail-comments-container div[style*="color:#fff"] {
 color:var(--x-text-primary) !important; }
 #detail-comments-container div[style*="color: #71767b"],
 #detail-comments-container div[style*="color:#71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 推文详情页评论容器内的边框和连接线 */
 #detail-comments-container div[style*="border-bottom"] {
 border-bottom-color: var(--x-border-color) !important; }
 #detail-comments-container div[style*="background-color: #2f3336"],
 #detail-comments-container div[style*="background-color:#2f3336"] {
 background-color: var(--x-border-color) !important; }
 /* 推文详情页评论容器内的卡片背景 */
 #detail-comments-container div[style*="background-color: #202327"],
 #detail-comments-container div[style*="background-color:#202327"],
 #detail-comments-container div[style*="background-color: #1a1a1a"],
 #detail-comments-container div[style*="background-color:#1a1a1a"] {
 background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; }
 /* 推文详情容器内的所有文本 */
 #tweet-detail-container span[style*="color: #fff"],
 #tweet-detail-container span[style*="color:#fff"] {
 color:var(--x-text-primary) !important; }
 #tweet-detail-container span[style*="color: #71767b"],
 #tweet-detail-container span[style*="color:#71767b"] {
 color:var(--x-text-secondary) !important; }
 #tweet-detail-container div[style*="color: #fff"],
 #tweet-detail-container div[style*="color:#fff"] {
 color:var(--x-text-primary) !important; }
 #tweet-detail-container div[style*="color: #71767b"],
 #tweet-detail-container div[style*="color:#71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 推文详情容器内的边框 */
 #tweet-detail-container div[style*="border-bottom"],
 #tweet-detail-container div[style*="border-top"] {
 border-color: var(--x-border-color) !important; }
 /* 所有动态生成的互动按钮悬停效果 */
 #account-tweets-container div[style*="cursor: pointer"],
 #detail-comments-container div[style*="cursor: pointer"],
 #tweet-detail-container div[style*="cursor: pointer"] {
 color: inherit !important; }
 /* 蓝色高亮文本（@提及、链接等） */
 span[style*="color: var(--x-accent)"],
 span[style*="color:#1d9bf0"],
 div[style*="color: var(--x-accent)"],
 div[style*="color:#1d9bf0"] {
 color: var(--x-accent) !important; }
 /* 账户主页标签栏的"已置顶"文本 */
 #account-tweets-container span[style*="color: #71767b"][style*="font-size: 13px"][style*="font-weight: 700"] {
 color:var(--x-text-secondary) !important; }
 /* 账户主页的所有互动数字 */
 #account-tweets-container span[style*="font-size: 13px"]:not([style*="font-weight"]) {
 color:var(--x-text-secondary) !important; }
 /* ========== 角色X资料设置弹窗样式修复 ========== */
 /* 弹窗背景遮罩 */
 #character-x-profile-modal[style*="background-color: rgba(0,0,0,0.8)"],
 #relationship-modal[style*="background-color: rgba(0,0,0,0.8)"] {
 background-color: rgba(0,0,0,0.6) !important; }
 /* 弹窗主容器 */
 #character-x-profile-modal > div > div[style*="background-color:#000"],
 #relationship-modal > div > div[style*="background-color:#000"] {
 background-color:var(--x-bg-primary) !important; border-color: var(--x-border-color) !important; }
 /* 弹窗头部 */
 #character-x-profile-modal h2,
 #character-x-profile-modal h3,
 #relationship-modal h3 {
 color:var(--x-text-primary) !important; }
 /* 弹窗头部关闭按钮 */
 #character-x-profile-modal button[onclick*="close"] svg,
 #relationship-modal button[onclick*="close"] svg {
 fill: var(--x-text-secondary) !important; }
 /* 弹窗所有边框 */
 #character-x-profile-modal div[style*="border-bottom: 1px solid #333"],
 #character-x-profile-modal div[style*="border: 1px solid #333"],
 #relationship-modal div[style*="border-bottom: 1px solid #333"] {
 border-color: var(--x-border-color) !important; }
 /* 角色信息显示区域 */
 #character-info-display[style*="background-color: #0a0a0a"] {
 background-color:var(--x-bg-secondary) !important; }
 /* 弹窗内所有label文字 */
 #character-x-profile-modal label,
 #relationship-modal label {
 color:var(--x-text-primary) !important; }
 /* 弹窗内所有次要文字 */
 #character-x-profile-modal div[style*="color: #71767b"],
 #relationship-modal div[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 弹窗内所有输入框 */
 #character-x-profile-modal input[type="text"],
 #character-x-profile-modal input[type="url"],
 #character-x-profile-modal textarea,
 #character-x-profile-modal select,
 #relationship-modal input[type="text"],
 #relationship-modal textarea,
 #relationship-modal select {
 background-color: var(--x-input-bg) !important; border-color: var(--x-border-color) !important; color:var(--x-text-primary) !important; }
 /* 输入框焦点状态 */
 #character-x-profile-modal input:focus,
 #character-x-profile-modal textarea:focus,
 #character-x-profile-modal select:focus,
 #relationship-modal input:focus,
 #relationship-modal textarea:focus,
 #relationship-modal select:focus {
 border-color: var(--x-accent) !important; }
 /* 弹窗内的头像预览 */
 #character-x-avatar,
 #character-x-cover-preview {
 border-color: var(--x-border-color) !important; }
 /* 角色X资料弹窗头像填充 */
 #character-x-avatar {
 object-fit: cover !important; overflow: hidden !important; box-sizing: border-box !important; }
 /* 弹窗内的span文字 */
 #character-x-profile-modal span[style*="color: #fff"],
 #relationship-modal span[style*="color: #fff"] {
 color:var(--x-text-primary) !important; }
 #character-x-profile-modal span[style*="color: #71767b"],
 #relationship-modal span[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 提示框背景 */
 #character-x-profile-modal div[style*="background-color: color-mix(in srgb, var(--x-accent) , 0.1)"] {
 background-color: color-mix(in srgb, var(--x-accent) , 0.1) !important; border-color: var(--x-accent) !important; }
 /* 提示框内的文字 */
 #character-x-profile-modal div[style*="color: var(--x-accent)"] {
 color: var(--x-accent) !important; }
 /* 弹窗内的按钮 */
 #character-x-profile-modal button[type="button"][style*="background-color: transparent"],
 #relationship-modal button[type="button"][style*="background-color: transparent"] {
 border-color: var(--x-border-color) !important; color:var(--x-text-primary) !important; }
 /* ========== X设置页面样式修复 ========== */
 /* 设置页面头部 */
 .settings-header[style*="background-color:#000"] {
 background-color:var(--x-bg-primary) !important; border-bottom-color: var(--x-border-color) !important; }
 /* 设置页面标题和返回按钮 */
 .settings-header span[style*="color: #fff"] {
 color:var(--x-text-primary) !important; }
 .settings-back-btn svg[style*="fill: #fff"] {
 fill: var(--x-text-primary) !important; }
 /* 主题切换按钮图标 */
 #theme-icon-dark[style*="fill: #fff"] {
 fill: var(--x-text-primary) !important; }
 #theme-icon-light[style*="fill: #000"] {
 fill: var(--x-text-primary) !important; }
 /* 设置页面所有label */
 #x-settings-page label {
 color:var(--x-text-primary) !important; }
 /* 设置页面所有次要文字 */
 #x-settings-page p[style*="color: #71767b"],
 #x-settings-page div[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 设置页面所有输入框和文本域 */
 #x-settings-page textarea,
 #x-settings-page input[type="text"] {
 background-color: var(--x-input-bg) !important; border-color: var(--x-border-color) !important; color:var(--x-text-primary) !important; }
 /* 设置页面输入框焦点状态 */
 #x-settings-page textarea:focus,
 #x-settings-page input:focus {
 border-color: var(--x-accent) !important; }
 /* 设置页面所有容器背景 */
 #x-settings-page div[style*="background-color: #1a1a1a"] {
 background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; }
 /* 设置页面所有容器边框 */
#x-settings-page div[style*="border: 1px solid #333"],
#x-settings-page div[style*="border-bottom: 1px solid #333"],
#x-settings-page div[style*="border-top: 1px solid #333"] {
border-color: var(--x-border-color) !important; }
/* 世界事件分类标签 - 强制白色字体 */
#world-events-list span[style*="background-color: var(--x-accent)"] {
color: #ffffff !important; }
 /* 角色关系预览区域 */
 #relationship-preview[style*="background-color: #0a0a0a"] {
 background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; }
 /* 关系预览占位符文字 */
 #relationship-preview-placeholder {
 color:var(--x-text-secondary) !important; }
 /* 关系统计框 */
 #relationship-stats[style*="background-color: color-mix(in srgb, var(--x-accent) , 0.1)"] {
 background-color: color-mix(in srgb, var(--x-accent) , 0.1) !important; }
 #relationship-stats div[style*="color: var(--x-accent)"] {
 color: var(--x-accent) !important; }
 /* 切换开关背景 - 限定在X应用内 */
 #x-social-screen .toggle-switch[style*="background-color: #333"] {
 background-color: var(--x-border-color) !important; }
 /* 切换开关圆圈 - 限定在X应用内 */
 #x-social-screen .toggle-circle[style*="background-color:#fff"] {
 background-color:var(--x-text-primary) !important; }
 /* 设置页面标题文字 */
 #x-settings-page div[style*="color: #fff"] {
 color:var(--x-text-primary) !important; }
 /* 预设管理区域 - 限定在X应用内 */
 #x-social-screen .preset-management h3 {
 color:var(--x-text-primary) !important; }
 /* NPC列表和角色列表容器 */
 #npcs-list,
 #characters-list {
 background-color: transparent !important; }
 /* 底部导航栏图标颜色 - 限定在X应用内 */
 #x-social-screen .x-nav-item svg {
 fill: var(--x-text-secondary) !important; }
 #x-social-screen .x-nav-item.active svg {
 fill: var(--x-accent) !important; }
 /* 底部导航栏的高亮点 - 限定在X应用内 */
 #x-social-screen .x-nav-item .nav-highlight {
 background-color: var(--x-accent) !important; }
 /* 浮动按钮 - 限定在X应用内 */
 #x-social-screen .compose-btn {
 background-color: var(--x-accent) !important; }
 /* ========== 用户主页样式修复 ========== */
 /* 用户头像边框颜色和填充 - 更强制性地覆盖 */
 #x-profile-main-avatar {
 border: 5px solid var(--x-bg-primary) !important; object-fit: cover !important; background-color:var(--x-bg-primary) !important; box-sizing: border-box !important; overflow: hidden !important; }
 #edit-main-avatar {
 border: 4px solid var(--x-bg-primary) !important; object-fit: cover !important; background-color:var(--x-bg-primary) !important; box-sizing: border-box !important; overflow: hidden !important; }
 /* 用户头像在账户主页 */
 #account-avatar-image {
 border: 4px solid var(--x-bg-primary) !important; object-fit: cover !important; background-color:var(--x-bg-primary) !important; box-sizing: border-box !important; overflow: hidden !important; }
 /* 用户名和关注数据 */
 #x-profile-user-name,
 #x-profile-following-count,
 #x-profile-followers-count {
 color:var(--x-text-primary) !important; }
 /* 用户简介 */
 #x-profile-bio {
 color:var(--x-text-primary) !important; }
 /* 编辑资料按钮 */
 .user-info-section button {
 color:var(--x-text-primary) !important; border-color: var(--x-border-color) !important; }
 /* ========== 角色信息显示区域修复 ========== */
 /* 角色信息显示区域内的所有文字 */
 #character-info-display div[style*="color: #fff"] {
 color:var(--x-text-primary) !important; }
 #character-info-display div[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 /* ========== 搜索结果用户卡片修复 ========== */
 /* 搜索结果中的用户卡片边框 */
 #search-results-content > div[style*="border-bottom: 1px solid #2f3336"] {
 border-bottom-color: var(--x-border-color) !important; }
 /* 搜索结果中的用户名 */
 #search-results-content span[style*="color: #fff"] {
 color:var(--x-text-primary) !important; }
 /* 搜索结果中的用户句柄 */
 #search-results-content div[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 搜索结果中的用户简介 */
 #search-results-content div[style*="color: #e7e9ea"] {
 color:var(--x-text-primary) !important; }
 /* ========== NPC编辑弹窗修复 ========== */
 /* NPC弹窗背景 */
 #npc-edit-modal > div[style*="background-color:#000"] {
 background-color:var(--x-bg-primary) !important; }
 /* NPC弹窗头部边框 */
 #npc-edit-modal div[style*="border-bottom: 1px solid #2f3336"] {
 border-bottom-color: var(--x-border-color) !important; }
 /* NPC弹窗标题 */
 #npc-modal-title {
 color:var(--x-text-primary) !important; }
 /* NPC弹窗关闭按钮图标 */
 #npc-edit-modal svg[style*="fill: #fff"] {
 fill: var(--x-text-primary) !important; }
 /* NPC弹窗所有label */
 #npc-edit-modal label {
 color:var(--x-text-secondary) !important; }
 /* NPC弹窗所有输入框和文本域 */
 #npc-edit-modal input,
 #npc-edit-modal textarea {
 background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; color:var(--x-text-primary) !important; }
 /* NPC弹窗输入框焦点状态 */
 #npc-edit-modal input:focus,
 #npc-edit-modal textarea:focus {
 border-color: var(--x-accent) !important; }
 /* NPC绑定用户列表容器 */
 #npc-bind-users {
 background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; }
 /* ========== NPC列表修复 ========== */
 /* NPC列表项背景和边框 */
 #npcs-list > div[style*="background-color: #0a0a0a"] {
 background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; }
 /* NPC列表中的主要文字 */
 #npcs-list div[style*="color: #fff"] {
 color:var(--x-text-primary) !important; }
 /* NPC列表中的次要文字 */
 #npcs-list div[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 /* NPC列表项边框 */
 #npcs-list > div[style*="border: 1px solid #2f3336"] {
 border-color: var(--x-border-color) !important; }
 /* NPC列表空状态文字 */
 #npcs-list p[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 /* ========== 角色关系册修复 ========== */
 /* 角色关系册管理区域容器 */
 #relationship-binding-area > div[style*="background-color: #1a1a1a"] {
 background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; }
 /* 角色关系册标题 */
 #relationship-binding-area div[style*="color: #fff"] {
 color:var(--x-text-primary) !important; }
 /* 角色关系册次要文字 */
 #relationship-binding-area div[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 角色关系列表项 */
 #relationship-links-list > div[style*="background-color: #1a1a1a"] {
 background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; }
 /* 角色关系列表中的文字 */
 #relationship-links-list span[style*="color: #fff"] {
 color:var(--x-text-primary) !important; }
 #relationship-links-list span[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 #relationship-links-list div[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 角色关系列表项的边框 */
 #relationship-links-list div[style*="border-top: 1px solid #2f3336"] {
 border-top-color: var(--x-border-color) !important; }
 /* 角色关系列表空状态 */
 #relationship-links-list > div[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 角色关系详情弹窗背景 */
 #relationship-detail-modal > div > div[style*="background-color:#000"] {
 background-color:var(--x-bg-primary) !important; border-color: var(--x-border-color) !important; }
 /* 角色关系详情弹窗标题和label */
 #relationship-detail-modal h3,
 #relationship-detail-modal label {
 color:var(--x-text-primary) !important; }
 /* 角色关系详情弹窗次要文字 */
 #relationship-detail-modal div[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 角色关系详情弹窗输入框 */
 #relationship-detail-modal input,
 #relationship-detail-modal textarea,
 #relationship-detail-modal select {
 background-color: var(--x-input-bg) !important; border-color: var(--x-border-color) !important; color:var(--x-text-primary) !important; }
 /* 角色关系详情弹窗输入框焦点 */
 #relationship-detail-modal input:focus,
 #relationship-detail-modal textarea:focus,
 #relationship-detail-modal select:focus {
 border-color: var(--x-accent) !important; }
 /* 角色关系详情弹窗边框 */
 #relationship-detail-modal div[style*="border: 1px solid #333"],
 #relationship-detail-modal div[style*="border-bottom: 1px solid #333"] {
 border-color: var(--x-border-color) !important; }
 /* 角色关系详情弹窗关闭按钮 */
 #relationship-detail-modal button[onclick*="close"] svg {
 fill: var(--x-text-secondary) !important; }
 /* ========== 角色关系图编辑器弹窗修复 ========== */
 /* 角色关系图弹窗背景 */
 #character-relationship-graph-modal > div[style*="background-color:#000"] {
 background-color:var(--x-bg-primary) !important; border-color: var(--x-border-color) !important; }
 /* 角色关系图弹窗头部 */
 #character-relationship-graph-modal h2 {
 color:var(--x-text-primary) !important; }
 /* 角色关系图弹窗统计文字 */
 #character-relationship-graph-modal div[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 角色关系图弹窗关闭按钮图标 */
 #character-relationship-graph-modal svg[style*="fill: #fff"] {
 fill: var(--x-text-primary) !important; }
 /* 角色关系图工具栏 */
 #character-relationship-graph-modal div[style*="background-color: #0a0a0a"] {
 background-color:var(--x-bg-secondary) !important; }
 /* 角色关系图工具栏提示文字 */
 #character-relationship-graph-modal > div > div:nth-child(2) div[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 角色关系图画布区域背景 */
 #character-relationship-graph-modal div[style*="height: 500px"][style*="background-color:#000"] {
 background-color:var(--x-bg-primary) !important; }
 /* 角色关系图空状态图标 */
 #graph-empty-state svg {
 fill: var(--x-border-color) !important; }
 /* 角色关系图底部按钮区域 */
 #character-relationship-graph-modal > div > div:last-child[style*="background-color:#000"] {
 background-color:var(--x-bg-primary) !important; }
 /* 角色关系图底部取消按钮 */
 #character-relationship-graph-modal button[onclick*="closeCharacter"] {
 border-color: var(--x-border-color) !important; color:var(--x-text-primary) !important; }
 /* 关系列表区域标题 */
 #character-relationship-graph-modal div[style*="padding: 12px 20px"] div[style*="color: #fff"] {
 color:var(--x-text-primary) !important; }
 /* 角色关系图边框 */
 #character-relationship-graph-modal div[style*="border: 1px solid #333"],
 #character-relationship-graph-modal div[style*="border-bottom: 1px solid #333"] {
 border-color: var(--x-border-color) !important; }
 /* 角色关系图画布容器 */
 #character-relationship-graph-modal > div[style*="border: 1px solid #333"] {
 border-color: var(--x-border-color) !important; }
 /* 角色关系图空状态 */
 #graph-empty-state div[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 关系列表标题文字 */
 #relationship-links-list-container h3 {
 color:var(--x-text-primary) !important; }
 /* 关系列表空状态 */
 #relationship-links-list div[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 编辑关系详情弹窗背景遮罩 */
 #edit-relationship-detail-modal[style*="background-color: rgba(0, 0, 0"] {
 background-color: rgba(0, 0, 0, 0.85) !important; }
 /* 编辑关系详情弹窗主容器 */
 #edit-relationship-detail-modal > div > div[style*="background-color:#000"] {
 background-color:var(--x-bg-primary) !important; border-color: var(--x-border-color) !important; }
 /* 编辑关系详情弹窗标题 */
 #edit-relationship-detail-modal h3 {
 color:var(--x-text-primary) !important; }
 /* 编辑关系详情弹窗label */
 #edit-relationship-detail-modal label {
 color:var(--x-text-primary) !important; }
 /* 编辑关系详情弹窗次要文字 */
 #edit-relationship-detail-modal div[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 编辑关系详情弹窗角色信息区域 */
 #relationship-characters-info {
 background-color:var(--x-bg-secondary) !important; border-color: var(--x-border-color) !important; }
 /* 编辑关系详情弹窗角色名称 */
 #char-a-name,
 #char-b-name {
 color:var(--x-text-primary) !important; }
 /* 编辑关系详情弹窗箭头符号 */
 #relationship-characters-info div[style*="color: #71767b"] {
 color:var(--x-text-secondary) !important; }
 /* 编辑关系详情弹窗关闭按钮图标 */
 #edit-relationship-detail-modal svg[style*="fill: #fff"] {
 fill: var(--x-text-primary) !important; }
 /* 编辑关系详情弹窗输入框 */
 #edit-relationship-detail-modal input,
 #edit-relationship-detail-modal textarea {
 background-color: var(--x-input-bg) !important; border-color: var(--x-border-color) !important; color:var(--x-text-primary) !important; }
 /* 编辑关系详情弹窗输入框焦点 */
 #edit-relationship-detail-modal input:focus,
 #edit-relationship-detail-modal textarea:focus {
 border-color: var(--x-accent) !important; }
 /* 编辑关系详情弹窗边框 */
 #edit-relationship-detail-modal div[style*="border: 1px solid #333"],
 #edit-relationship-detail-modal div[style*="border-bottom: 1px solid #333"] {
 border-color: var(--x-border-color) !important; }
 /* 编辑关系详情弹窗关闭按钮 */
 #edit-relationship-detail-modal button[onclick*="close"] svg {
 fill: var(--x-text-secondary) !important; }
 /* 个人资料标签栏 - 激活状态 - 限定在X应用内 */
 #x-social-screen .profile-tab.active {
 color:var(--x-text-primary) !important; font-weight: 700 !important; }
 /* 个人资料标签栏 - 非激活状态 - 限定在X应用内 */
 #x-social-screen .profile-tab:not(.active) {
 color:var(--x-text-secondary) !important; }
 /* 个人资料页面的其他文本 */
 #x-profile-header-name {
 color:var(--x-text-primary) !important; }
 /* 用户主页顶部功能按钮图标 - 限定在X应用内 */
 #x-social-screen .profile-header svg {
 fill: var(--x-text-primary) !important; }
 /* 返回按钮 - 限定在X应用内 */
 #x-social-screen .profile-back-btn svg {
 fill: var(--x-text-primary) !important; }
 /* 提问箱和更多选项按钮的图标 */
 #x-profile-page .profile-header > div > div svg {
 fill: var(--x-text-primary) !important; }
 /* ========== 推文详情页样式修复 ========== */
 /* 详情页顶栏背景和边框 */
 .tweet-detail-header {
 background-color:var(--x-bg-primary) !important; border-bottom: 1px solid var(--x-border-color) !important; }
 /* 详情页顶栏标题和返回按钮 */
 .tweet-detail-header span {
 color:var(--x-text-primary) !important; }
 .tweet-detail-header svg,
 .tweet-detail-back-btn svg {
 fill: var(--x-text-primary) !important; }
 /* 详情页主要内容区域 */
 #x-tweet-detail-page {
 background-color:var(--x-bg-primary) !important; }
 #tweet-detail-container {
 background-color:var(--x-bg-primary) !important; }
 /* 详情页推文内容区域 */
 .tweet-detail-content {
 background-color:var(--x-bg-primary) !important; }
 /* 详情页推文用户名和内容 */
 #tweet-detail-container .tweet-user-name,
 #tweet-detail-container .tweet-content,
 #x-tweet-detail-page .tweet-user-name,
 #x-tweet-detail-page .tweet-content {
 color:var(--x-text-primary) !important; }
 /* 详情页评论区域背景 */
 #detail-comments-container {
 background-color:var(--x-bg-primary) !important; }
 /* 详情页评论内容 */
 #detail-comments-container .comment-content,
 #detail-comments-container .tweet-user-name,
 #x-tweet-detail-page .comment-user-name {
 color:var(--x-text-primary) !important; }
 /* 详情页时间和其他次要文本 */
 #tweet-detail-container .tweet-time,
 #tweet-detail-container .tweet-user-handle,
 #detail-comments-container .tweet-user-handle,
 #detail-comments-container .comment-time,
 #x-tweet-detail-page .tweet-time,
 #x-tweet-detail-page .tweet-user-handle {
 color:var(--x-text-secondary) !important; }
 /* 详情页评论输入区域 */
 .detail-comment-input-area {
 background-color:var(--x-bg-primary) !important; border-top: 1px solid var(--x-border-color) !important; }
 .detail-comment-input-area textarea {
 background-color: var(--x-input-bg) !important; color:var(--x-text-primary) !important; border-color: var(--x-border-color) !important; }
 /* 详情页按钮颜色 */
 #reroll-replies-btn svg,
 .refresh-btn svg,
 #x-tweet-detail-page .refresh-btn svg {
 fill: var(--x-text-primary) !important; }
 /* 详情页所有span元素 */
 #x-tweet-detail-page span,
 #tweet-detail-container span {
 color: inherit; }
 /* 确保所有可滚动容器都有正确的高度设置 */
 .comments-container,
 .settings-content,
 .profile-content,
 .tab-content {
 min-height: 0 !important; }
 /* 确保推文容器也有正确的滚动 */
 .tweets-container {
 overflow-y: auto; min-height: 0; }
 /* 用户评论删除功能样式 */
 .comment-user-info {
 display: flex !important; align-items: center !important; gap: 4px !important; }
 .comment-delete-btn:hover {
 background-color: rgba(239, 68, 68, 0.1) !important; }
 .comment-delete-btn svg {
 transition: fill 0.2s ease; }
 .comment-delete-btn:hover svg {
 fill: #dc2626 !important; }
 /* 用户人设设置按钮样式 */
 .persona-setting-btn {
 box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }
 .persona-setting-btn:hover {
 box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); }
 .persona-setting-btn:active {
 transform: scale(0.95) !important; }
 /* 推文项目 */
 #x-social-screen .tweet-item {
 padding: 15px; border-bottom: 1px solid var(--x-border-color); display: flex; gap: 12px; background-color:var(--x-bg-primary); }
 /* 用户头像 */
 #x-social-screen .tweet-avatar {
 width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0; }
 /* 推文主要内容区域 */
 #x-social-screen .tweet-main {
 flex: 1; min-width: 0; }
 /* 用户信息行 */
 #x-social-screen .tweet-user-info {
 display: flex; align-items: center; gap: 5px; margin-bottom: 5px; }
 #x-social-screen .tweet-user-name {
 font-weight: 700; color:var(--x-text-primary); font-size: 15px; }
 #x-social-screen .tweet-verified {
 width: 18px; height: 18px; fill: var(--x-accent); }
 #x-social-screen .tweet-user-handle {
 color:var(--x-text-secondary); font-size: 15px; }
 #x-social-screen .tweet-time {
 color:var(--x-text-secondary); font-size: 15px; }
 #x-social-screen .tweet-more {
 margin-left: auto; color: #71767b; cursor: pointer; padding: 5px; border-radius: 50%; }
 #x-social-screen .tweet-more:hover {
 background-color: color-mix(in srgb, var(--x-accent) , 0.1); color: var(--x-accent); }
 /* 推文内容 */
 #x-social-screen .tweet-content {
 color:var(--x-text-primary); font-size: 15px; line-height: 1.3; margin-bottom: 12px; word-wrap: break-word; }
 /* 话题标签和提及的高亮样式 */
 #x-social-screen .hashtag,
 #x-social-screen .mention {
 color: var(--x-accent); text-decoration: none; cursor: pointer; }
 #x-social-screen .hashtag:hover,
 #x-social-screen .mention:hover {
 text-decoration: underline; }
 /* 媒体内容 */
 #x-social-screen .tweet-media {
 margin-bottom: 12px; border-radius: 16px; overflow: hidden; position: relative; }
 #x-social-screen .tweet-image {
 width: 100%; max-height: 300px; object-fit: cover; display: block; }
 /* 敏感内容遮罩 */
 #x-social-screen .sensitive-overlay {
 position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; color: #fff; cursor: pointer; }
 #x-social-screen .sensitive-text {
 font-size: 15px; font-weight: 700; margin-bottom: 8px; }
 #x-social-screen .sensitive-description {
 font-size: 13px; color: #71767b; text-align: center; padding: 0 20px; }
 /* 互动按钮 - 限定在X应用内 */
 #x-social-screen .tweet-actions {
 display: flex; justify-content: space-between; max-width: 425px; margin-top: 5px; }
 #x-social-screen .tweet-action {
 display: flex; align-items: center; gap: 5px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; font-size: 13px; transition: all 0.2s; }
 #x-social-screen .tweet-action:hover {
 background-color: color-mix(in srgb, var(--x-accent) , 0.1); }
 #x-social-screen .tweet-action.comment:hover {
 color: var(--x-accent); }
 #x-social-screen .tweet-action.retweet:hover {
 color: #00ba7c; }
 #x-social-screen .tweet-action.like:hover,
 #x-social-screen .tweet-action.like.liked {
 color: #f91880; }
 #x-social-screen .tweet-action.bookmark:hover {
 color: var(--x-accent); }
 #x-social-screen .tweet-action.share:hover {
 color: var(--x-accent); }
 #x-social-screen .action-icon {
 width: 18px; height: 18px; }
 /* 点赞动画效果 */
 #x-social-screen .like-animation {
 animation: likeHeartbeat 0.6s ease-in-out; }
 @keyframes likeHeartbeat {
 0% {
 transform: scale(1); }
 25% {
 transform: scale(1.2); }
 50% {
 transform: scale(1.4); }
 75% {
 transform: scale(1.2); }
 100% {
 transform: scale(1); }
 }
 #x-social-screen .tweet-action.like.liked .like-icon {
 fill: #f91880; }
 #x-social-screen .tweet-action.like.liked .like-count {
 color: #f91880; }
 /* 评论样式 */
 #x-social-screen .comment-item {
 padding: 15px; border-bottom: 1px solid var(--x-border-color); display: flex; gap: 12px; position: relative; background-color:var(--x-bg-primary); }
 /* 主评论后有回复时的连接线 */
 #x-social-screen .comment-item.has-replies::after {
 content: ''; position: absolute; left: 35px; /* 头像中心位置 */
 bottom: -1px; width: 1px; height: 28px; background-color: #2f3336; }
 #x-social-screen .comment-main {
 flex: 1; min-width: 0; }
 #x-social-screen .comment-user-info {
 display: flex; align-items: center; gap: 5px; margin-bottom: 5px; }
 #x-social-screen .comment-content {
 color:var(--x-text-primary); font-size: 15px; line-height: 1.3; margin-bottom: 8px; word-wrap: break-word; }
 #x-social-screen .comment-actions {
 display: flex; justify-content: flex-start; gap: 60px; margin-top: 5px; }
 #x-social-screen .comment-action {
 display: flex; align-items: center; gap: 5px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; font-size: 13px; transition: all 0.2s; }
 /* 回复评论样式 */
 #x-social-screen .reply-item {
 margin-left: 50px; /* 精确对齐主评论的头像右侧 */
 padding-left: 0; padding-top: 8px; padding-bottom: 8px; border-left: none; position: relative; display: flex; align-items: flex-start; gap: 12px; }
 #x-social-screen .reply-item::before {
 content: ''; position: absolute; left: -30px; top: 16px; width: 14px; height: 14px; border-left: 1px solid #2f3336; border-bottom: 1px solid #2f3336; border-bottom-left-radius: 6px; }
 #x-social-screen .reply-to {
 color: var(--x-accent); margin-right: 5px; font-weight: 400; }
 /* 回复评论的头像稍小一些 */
 #x-social-screen .reply-item .tweet-avatar {
 width: 32px; height: 32px; }
 /* 引用推文样式 */
 #x-social-screen .quoted-tweet {
 border: 1px solid #2f3336; border-radius: 16px; margin: 12px 0; padding: 12px; background-color: rgba(0, 0, 0, 0.3); transition: background-color 0.2s ease; cursor: pointer; }
 #x-social-screen .quoted-tweet:hover {
 background-color: rgba(255, 255, 255, 0.03); }
 #x-social-screen .quoted-user-info {
 display: flex; align-items: center; gap: 5px; margin-bottom: 8px; }
 #x-social-screen .quoted-user-avatar {
 width: 20px; height: 20px; border-radius: 50%; flex-shrink: 0; }
 #x-social-screen .quoted-user-name {
 font-weight: 600; color: #fff; font-size: 13px; }
 #x-social-screen .quoted-user-handle {
 color: #71767b; font-size: 13px; }
 #x-social-screen .quoted-user-time {
 color: #71767b; font-size: 13px; }
 #x-social-screen .quoted-content {
 color: #fff; font-size: 14px; line-height: 1.3; word-wrap: break-word; }
 #x-social-screen .quote-indicator {
 color: #71767b; font-size: 13px; margin-bottom: 8px; display: flex; align-items: center; gap: 4px; }
 #x-social-screen .quote-indicator svg {
 width: 16px; height: 16px; fill: currentColor; }
 /* 搜索页面样式 */
 #x-social-screen .search-header {
 padding: 12px 16px; background: #000; border-bottom: 1px solid #2f3336; }
 #x-social-screen .search-box {
 display: flex; align-items: center; background: #202327; border-radius: 20px; padding: 10px 16px; gap: 12px; }
 #x-social-screen .search-box svg {
 width: 20px; height: 20px; fill: #71767b; flex-shrink: 0; }
 #x-social-screen .search-box input {
 flex: 1; background: transparent; border: none; outline: none; color: #fff; font-size: 15px; }
 #x-social-screen .search-box input::placeholder {
 color: #71767b; }
 #x-social-screen .search-tabs {
 display: flex; align-items: center; padding: 0 16px; border-bottom: 1px solid #2f3336; gap: 24px; overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
 #x-social-screen .search-tabs::-webkit-scrollbar {
 display: none; }
 #x-social-screen .search-tab {
 padding: 16px 0; cursor: pointer; color: #71767b; font-weight: 500; font-size: 15px; white-space: nowrap; position: relative; transition: color 0.2s; }
 #x-social-screen .search-tab.active {
 color: #fff; font-weight: 700; }
 #x-social-screen .search-tab.active::after {
 content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 4px; background: var(--x-accent); border-radius: 2px 2px 0 0; }
 #x-social-screen .search-tab:hover {
 color: #fff; }
 #x-social-screen .add-category-btn {
 display: flex; align-items: center; justify-content: center; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; transition: background 0.2s; }
 #x-social-screen .add-category-btn svg {
 width: 20px; height: 20px; fill: #71767b; }
 #x-social-screen .add-category-btn:hover {
 background: color-mix(in srgb, var(--x-accent) , 0.1); }
 #x-social-screen .add-category-btn:hover svg {
 fill: var(--x-accent); }
 #x-social-screen .trending-list {
 flex: 1; overflow-y: auto; }
 #x-social-screen .trending-item {
 padding: 12px 16px; cursor: pointer; transition: background 0.2s; position: relative; }
 #x-social-screen .trending-item:hover {
 background: rgba(255, 255, 255, 0.03); }
 #x-social-screen .trending-header {
 display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 2px; }
 #x-social-screen .trending-category {
 color: #71767b; font-size: 14px; font-weight: 800; line-height: 16px; }
 #x-social-screen .trending-more {
 padding: 4px; border-radius: 50%; cursor: pointer; transition: background 0.2s; }
 #x-social-screen .trending-more:hover {
 background: color-mix(in srgb, var(--x-accent) , 0.1); }
 #x-social-screen .trending-more svg {
 width: 18px; height: 18px; fill: #71767b; }
 #x-social-screen .trending-title {
 color: #fff; font-size: 15px; font-weight: 700; line-height: 20px; margin-bottom: 2px; }
 #x-social-screen .trending-count {
 color: #71767b; font-size: 13px; line-height: 16px; font-weight: 400; }
 #x-social-screen .refresh-trends-btn {
 position: fixed; right: 20px; bottom: 80px; width: 56px; height: 56px; background: var(--x-accent); border-radius: 50%; border: none; cursor: pointer; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4); display: none; align-items: center; justify-content: center; transition: transform 0.2s, background 0.2s; z-index: 100; }
 #x-social-screen .refresh-trends-btn:hover {
 background: #1a8cd8; transform: scale(1.05); }
 #x-social-screen .refresh-trends-btn:active {
 transform: scale(0.95); }
 #x-social-screen .refresh-trends-btn svg {
 width: 24px; height: 24px; fill: #fff; }
 #x-social-screen .refresh-trends-btn.spinning svg {
 animation: spin 1s linear infinite; }
 @keyframes spin {
 from { transform: rotate(0deg); }
 to { transform: rotate(360deg); }
 }
 /* 脉冲动画 */
 @keyframes pulse {
 0% {
 opacity: 1; transform: scale(1); }
 50% {
 opacity: 0.6; transform: scale(1.2); }
 100% {
 opacity: 1; transform: scale(1); }
 }
 /* 钱包成功弹窗入场动画 */
 @keyframes walletSuccessIn {
 from {
 opacity: 0; transform: scale(0.7) translateY(30px); }
 to {
 opacity: 1; transform: scale(1) translateY(0); }
 }
 /* 钱包成功图标检查动画 */
 @keyframes walletSuccessCheck {
 0% {
 opacity: 0; transform: scale(0.3); }
 50% {
 opacity: 1; transform: scale(1.1); }
 100% {
 opacity: 1; transform: scale(1); }
 }
 /* 钱包激活按钮加载动画 */
 @keyframes walletActivating {
 0% {
 background-position: 0% 50%; }
 50% {
 background-position: 100% 50%; }
 100% {
 background-position: 0% 50%; }
 }
/* 轮盘光晕脉动动画 */
@keyframes pulse {
  0% {
    opacity: 0.2;
    transform: scale(0.98);
  }
  30% {
    opacity: 0.4;
    transform: scale(1.03);
  }
  60% {
    opacity: 0.5;
    transform: scale(1.06);
  }
  100% {
    opacity: 0.2;
    transform: scale(0.98);
  }
}

/* 标签微脉动动画 */
@keyframes labelPulse {
  0%, 100% {
    opacity: 0.35;
  }
  50% {
    opacity: 0.5;
  }
}

/* 点赞上浮动画 */
@keyframes floatUp {
  0% {
    opacity: 1;
    transform: translateY(0) scale(0.8) rotate(0deg);
  }
  20% {
    opacity: 1;
    transform: translateY(-50px) scale(1) rotate(5deg);
  }
  50% {
    opacity: 0.8;
    transform: translateY(-125px) scale(1.2) rotate(-3deg);
  }
  80% {
    opacity: 0.3;
    transform: translateY(-200px) scale(1.35) rotate(2deg);
  }
  100% {
    opacity: 0;
    transform: translateY(-250px) scale(1.4) rotate(0deg);
  }
}

/* 标签悬停浮起效果 */
@keyframes tagFloat {
  0% {
    transform: translateY(0) scale(1);
  }
  50% {
    transform: translateY(-3px) scale(1.03);
  }
  100% {
    transform: translateY(-2px) scale(1.02);
  }
}

/* 按钮按下动画 */
@keyframes btnPress {
  0% {
    transform: translateY(-1px) scale(1);
  }
  50% {
    transform: translateY(3px) scale(0.95);
  }
  100% {
    transform: translateY(2px) scale(0.97);
  }
}

/* 弹幕列表初始化动画 */
@keyframes danmakuScroll {
  0% {
    transform: translateY(-15px);
    opacity: 0;
    filter: blur(3px);
  }
  100% {
    transform: translateY(0);
    opacity: 1;
    filter: blur(0);
  }
}

/* ========== 用户资料下拉菜单主题适配 ========== */
/* 下拉菜单背景和边框 */
#profile-dropdown-menu {
  background-color: var(--x-bg-secondary) !important;
  border-color: var(--x-border-color) !important;
}

/* 下拉菜单项文字颜色 */
#profile-dropdown-menu > div {
  color: var(--x-text-primary) !important;
}

/* 下拉菜单项SVG图标颜色 */
#profile-dropdown-menu svg {
  fill: var(--x-text-primary) !important;
}

/* 下拉菜单项悬停背景 */
#profile-dropdown-menu > div:hover {
  background-color: var(--x-bg-hover) !important;
}
`;
    document.head.appendChild(style);
    console.log("✅ X Social App: 样式已注入");
  }

  // 第二部分: HTML结构生成
  // ============================================
  function createXSocialHTML() {
    // 检查是否已经存在
    if (document.getElementById("x-social-screen")) {
      console.log("⚠️ X Social Screen 已存在，跳过创建");
      return;
    }
    const container = document.createElement("div");
    container.id = "x-social-screen";
    container.className = "screen";
    container.style.cssText =
      "background-color:var(--x-bg-primary); color:var(--x-text-primary); display: flex; flex-direction: column; height: 100vh; overflow: hidden;"; // 这里使用字符串模板或DOM操作创建完整的HTML结构
    container.innerHTML = `

<div class="x-top-bar"
 style="display: flex; justify-content: space-between; align-items: center; padding: 55px 15px 15px 15px; border-bottom: 1px solid #333; position: relative;">

 <div style="display: flex; align-items: center; gap: 12px;">
<div class="x-back-btn" onclick="showScreen('home-screen')" style="cursor: pointer;">
<svg viewBox="0 0 24 24" aria-hidden="true" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
<g>
<path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path>
</g>
</svg>
</div>

<!-- 添加直播按钮 -->
<div class="x-live-btn" onclick="switchXPage('live')" style="cursor: pointer;">
<svg viewBox="0 0 24 24" aria-hidden="true" style="width: 20px; height: 20px; fill: none; stroke: var(--x-text-primary); stroke-width: 1; stroke-linecap: round; stroke-linejoin: round;">
<path d="M10.5 20h-5.5a2 2 0 0 1 -2 -2v-9a2 2 0 0 1 2 -2h1a2 2 0 0 0 2 -2a1 1 0 0 1 1 -1h6a1 1 0 0 1 1 1a2 2 0 0 0 2 2h1a2 2 0 0 1 2 2v2.5" />
<path d="M14.569 11.45a3 3 0 1 0 -4.518 3.83" />
<path d="M17.8 20.817l-2.172 1.138a.392 .392 0 0 1 -.568 -.41l.415 -2.411l-1.757 -1.707a.389 .389 0 0 1 .217 -.665l2.428 -.352l1.086 -2.193a.392 .392 0 0 1 .702 0l1.086 2.193l2.428 .352a.39 .39 0 0 1 .217 .665l-1.757 1.707l.414 2.41a.39 .39 0 0 1 -.567 .411l-2.172 -1.138z" />
</svg>
</div>
</div>

 <div class="x-profile-pic"
 style="display: flex; justify-content: center; align-items: center; position: absolute; left: 50%; transform: translateX(-50%);">
 <img id="top-bar-avatar"
 src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg"
 alt="Profile"
 onclick="switchXPage('profile')"
 style="width: 36px; height: 36px; border-radius: 50%; cursor: pointer; transition: opacity 0.2s;"
 onmouseover="this.style.opacity='0.8'"
 onmouseout="this.style.opacity='1'">
 </div>

 <div style="display: flex; align-items: center; gap: 15px;">

 <div class="x-refresh-btn" onclick="refreshXTweets()" style="cursor: pointer;">
 <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 22px; height: 22px; fill: #fff;">
 <g>
 <path
 d="M19 8l-4 4h3c0 3.31-2.69 6-6 6-1.01 0-1.97-.25-2.8-.7l-1.46 1.46C8.97 19.54 10.43 20 12 20c4.42 0 8-3.58 8-8h3l-4-4zM6 12c0-3.31 2.69-6 6-6 1.01 0 1.97.25 2.8.7l1.46-1.46C15.03 4.46 13.57 4 12 4c-4.42 0-8 3.58-8 8H1l4 4 4-4H6z">
 </path>
 </g>
 </svg>
 </div>

 <div class="x-settings" onclick="switchXPage('settings')" style="cursor: pointer;">
 <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 24px; height: 24px; fill: #fff;">
 <g>
 <path
 d="M10.54 1.75h2.92l1.57 2.36c.11.17.32.25.53.21l2.53-.59 2.17 2.17-.58 2.54c-.05.2.04.41.21.53l2.36 1.57v2.92l-2.36 1.57c-.17.12-.26.33-.21.53l.58 2.54-2.17 2.17-2.53-.59c-.21-.04-.42.04-.53.21l-1.57 2.36h-2.92l-1.58-2.36c-.11-.17-.32-.25-.52-.21l-2.54.59-2.17-2.17.58-2.54c.05-.2-.03-.41-.21-.53l-2.35-1.57v-2.92L4.1 8.97c.18-.12.26-.33.21-.53L3.73 5.9 5.9 3.73l2.54.59c.2.04.41-.04.52-.21l1.58-2.36zm1.07 2l-.98 1.47C10.05 6.08 9 6.5 7.99 6.27l-1.46-.34-.6.6.33 1.46c.24 1.01-.18 2.07-1.05 2.64l-1.46.98v.78l1.46.98c.87.57 1.29 1.63 1.05 2.64l-.33 1.46.6.6 1.46-.34c1.01-.23 2.06.19 2.64 1.05l.98 1.47h.78l.97-1.47c.58-.86 1.63-1.28 2.65-1.05l1.45.34.61-.6-.34-1.46c-.23-1.01.18-2.07 1.05-2.64l1.47-.98v-.78l-1.47-.98c-.87-.57-1.28-1.63-1.05-2.64l.34-1.46-.61-.6-1.45.34c-1.02.23-2.07-.19-2.65-1.05l-.97-1.47h-.78zM12 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5c.82 0 1.5-.67 1.5-1.5s-.68-1.5-1.5-1.5zM8.5 12c0-1.93 1.56-3.5 3.5-3.5 1.93 0 3.5 1.57 3.5 3.5s-1.57 3.5-3.5 3.5c-1.94 0-3.5-1.57-3.5-3.5z">
 </path>
 </g>
 </svg>
 </div>
 </div>
</div>

<div class="x-pages-container"
 style="flex: 1; display: flex; flex-direction: column; overflow: hidden; min-height: 0; position: relative;">

 <div id="x-home-page" class="x-page active"
 style="flex: 1; display: flex; flex-direction: column; overflow: hidden; min-height: 0;">

 <div class="x-home-tabs" style="display: flex; border-bottom: 1px solid #333;">

 <div class="x-tab active" onclick="switchHomeTab('for-you')"
 style="flex: 1; text-align: center; padding: 15px 0; font-weight: 600; cursor: pointer; position: relative;">
 <span data-i18n="homeForYou">为你推荐</span>
 <div class="tab-indicator"
 style="position: absolute; bottom: 0; left: 10%; width: 80%; height: 2px; background-color: var(--x-accent); border-radius: 2px;">
 </div>
 </div>

 <div class="x-tab" onclick="switchHomeTab('following')"
 style="flex: 1; text-align: center; padding: 15px 0; font-weight: 600; cursor: pointer; position: relative; color: #71767b;">
 <span data-i18n="homeFollowing">正在关注</span>
 <div class="tab-indicator"
 style="position: absolute; bottom: 0; left: 10%; width: 80%; height: 2px; background-color: var(--x-accent); border-radius: 2px; display: none;">
 </div>
 </div>
 </div>

 <div id="for-you-content" class="tab-content active"
 style="flex: 1; display: flex; flex-direction: column; overflow-y: auto; min-height: 0;">

 <div class="tweets-container" style="padding: 0;">

 </div>
 </div>

 <div id="following-content" class="tab-content"
 style="flex: 1; display: none; flex-direction: column; overflow-y: auto; min-height: 0;">

 <div class="tweets-container" style="padding: 0;">

 </div>
 </div>

 <div class="compose-btn" onclick="openComposeTweetModal()"
 style="position: fixed; bottom: 80px; right: 20px; width: 56px; height: 56px; background-color: var(--x-accent); border-radius: 50%; display: flex; justify-content: center; align-items: center; box-shadow: 0 2px 10px rgba(0,0,0,0.3); cursor: pointer;">
 <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 24px; height: 24px; fill: #fff; stroke-width: 2;">
 <g>
 <path d="M12 4L12 20M4 12L20 12" stroke="white" stroke-linecap="round"></path>
 </g>
 </svg>
 </div>
 </div>

 <div id="character-x-profile-modal"
 style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); z-index: 30; backdrop-filter: blur(8px);">
 <div style="display: flex; justify-content: center; align-items: center; height: 100%; padding: 20px;">
 <div
 style="background-color:#000; border: 1px solid #333; border-radius: 16px; width: 100%; max-width: 600px; max-height: 90vh; overflow-y: auto;">

 <div
 style="display: flex; align-items: center; justify-content: space-between; padding: 20px 20px 16px 20px; border-bottom: 1px solid #333;">
 <h2 style="color: #fff; font-size: 20px; font-weight: 700; margin: 0;">设置X资料</h2>
 <button onclick="closeCharacterXProfileModal()"
 style="background: none; border: none; color: #71767b; cursor: pointer; padding: 8px;">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
 <path
 d="M18.36 6.64c.39.39.39 1.02 0 1.41L13.41 12l4.95 4.95c.39.39.39 1.02 0 1.41-.39.39-1.02.39-1.41 0L12 13.41l-4.95 4.95c-.39.39-1.02.39-1.41 0-.39-.39-.39-1.02 0-1.41L10.59 12 5.64 7.05c-.39-.39-.39-1.02 0-1.41.39-.39 1.02-.39 1.41 0L12 10.59l4.95-4.95c.39-.39 1.02-.39 1.41 0z" />
 </svg>
 </button>
 </div>

 <div id="character-info-display"
 style="padding: 20px; border-bottom: 1px solid #333; background-color: #0a0a0a;">

 </div>

 <div style="padding: 20px;">
 <form id="character-x-profile-form">

 <div style="margin-bottom: 24px;">
 <label
 style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 12px;">X头像</label>
 <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 12px;">
 <img id="character-x-avatar" src="" alt="X头像"
 style="width: 80px; height: 80px; border-radius: 50%; border: 3px solid #333; object-fit: cover; overflow: hidden; box-sizing: border-box;">
 <div style="flex: 1;">
 <div style="color: #71767b; font-size: 13px; margin-bottom: 8px;">头像链接</div>
 <input type="url" id="character-x-avatar-url" placeholder="https://example.com/avatar.jpg"
 style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; outline: none;"
 oninput="updateCharacterXAvatar(this.value)" onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='#333'">
 </div>
 </div>
 <div style="color: #71767b; font-size: 12px;">
 请输入图片链接URL，支持JPG、PNG、GIF格式
 </div>
 </div>

 <div style="margin-bottom: 20px;">
 <label
 style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">X用户名</label>
 <input type="text" id="character-x-name" placeholder="显示名称"
 style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; outline: none;"
 maxlength="50">
 </div>

 <div style="margin-bottom: 20px;">
 <label
 style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">X句柄</label>
 <div style="position: relative;">
 <span
 style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: #71767b; font-size: 15px;">@</span>
 <input type="text" id="character-x-handle" placeholder="username"
 style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px 12px 12px 30px; font-size: 15px; outline: none;"
 maxlength="15">
 </div>
 </div>

 <div style="margin-bottom: 20px;">
 <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
 <input type="checkbox" id="character-x-verified"
 style="width: 18px; height: 18px; accent-color: var(--x-accent);">
 <span style="color: #fff; font-size: 15px; font-weight: 600;">认证用户</span>
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);">
 <path
 d="M22.5 12.5c0-1.58-.875-2.95-2.148-3.6.154-.435.238-.905.238-1.4 0-2.21-1.71-3.998-3.818-3.998-.47 0-.92.084-1.336.25C14.818 2.415 13.51 1.5 12 1.5s-2.816.917-3.437 2.25c-.415-.165-.866-.25-1.336-.25-2.11 0-3.818 1.79-3.818 4 0 .494.083.964.237 1.4-1.272.65-2.147 2.018-2.147 3.6 0 1.495.782 2.798 1.942 3.486-.02.17-.032.34-.032.514 0 2.21 1.708 4 3.818 4 .47 0 .92-.086 1.335-.25.62 1.334 1.926 2.25 3.437 2.25 1.512 0 2.818-.916 3.437-2.25.415.163.865.248 1.336.248 2.11 0 3.818-1.79 3.818-4 0-.174-.012-.344-.033-.513 1.158-.687 1.943-1.99 1.943-3.484zm-6.616-3.334l-4.334 6.5c-.145.217-.382.334-.625.334-.143 0-.288-.04-.416-.126l-2.5-1.668c-.326-.217-.413-.656-.196-.982.217-.326.656-.414.982-.196l1.875 1.25 3.75-5.625c.22-.33.66-.418.99-.196.33.22.418.66.196.99z" />
 </svg>
 </label>
 </div>

 <div style="margin-bottom: 24px;">
 <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 12px;">背景图（封面图）</label>
 <div style="margin-bottom: 12px;">
 <img id="character-x-cover-preview" src="https://i.postimg.cc/qRzMB6nQ/default-cover.jpg" alt="背景图预览"
 style="width: 100%; height: 120px; border-radius: 8px; object-fit: cover; border: 1px solid #333;">
 </div>
 <div style="color: #71767b; font-size: 13px; margin-bottom: 8px;">背景图链接</div>
 <input type="url" id="character-x-cover-url" placeholder="https://example.com/cover.jpg"
 style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; outline: none;"
 oninput="updateCharacterXCover(this.value)" onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='#333'">
 <div style="color: #71767b; font-size: 12px; margin-top: 4px;">
 请输入图片链接URL，支持JPG、PNG、GIF格式
 </div>
 </div>

 <div style="margin-bottom: 24px;">
 <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">自定义标签1</label>
 <div style="display: flex; gap: 8px; margin-bottom: 8px;">
 <input type="text" id="character-tag1-icon" placeholder="✨" maxlength="2" style="width: 50px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 17px; outline: none; text-align: center; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
 <input type="text" id="character-custom-tag1" placeholder="例如：科技博主" maxlength="30" style="flex: 1; background-color: #1a1a1a; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 15px; outline: none; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
 </div>
 <div style="display: flex; gap: 8px; align-items: center;">
 <label style="color: #71767b; font-size: 12px; min-width: 40px;">颜色:</label>
 <input type="color" id="character-tag1-color" value="#71767b" style="width: 40px; height: 32px; border: 1px solid #333; border-radius: 4px; background: transparent; cursor: pointer; outline: none; ">
 </div>
 </div>

 <div style="margin-bottom: 24px;">
 <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">自定义标签2</label>
 <div style="display: flex; gap: 8px; margin-bottom: 8px;">
 <input type="text" id="character-tag2-icon" placeholder="📅" maxlength="2" style="width: 50px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 17px; outline: none; text-align: center; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
 <input type="text" id="character-custom-tag2" placeholder="例如：2024年加入" maxlength="30" style="flex: 1; background-color: #1a1a1a; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 15px; outline: none; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
 </div>
 <div style="display: flex; gap: 8px; align-items: center;">
 <label style="color: #71767b; font-size: 12px; min-width: 40px;">颜色:</label>
 <input type="color" id="character-tag2-color" value="#71767b" style="width: 40px; height: 32px; border: 1px solid #333; border-radius: 4px; background: transparent; cursor: pointer; outline: none; ">
 </div>
 </div>

 <div style="margin-bottom: 20px;">
 <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">正在关注数量</label>
 <input type="text" id="character-following-count" placeholder="156, 1.2K, 2.5M等" maxlength="20" style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; outline: none; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
 <div style="color: #71767b; font-size: 12px; margin-top: 4px;">可输入任意数字、字母、符号组合</div>
 </div>

 <div style="margin-bottom: 20px;">
 <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">关注者数量</label>
 <input type="text" id="character-followers-count" placeholder="89, 1.5K, 3.2M等" maxlength="20" style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; outline: none; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
 <div style="color: #71767b; font-size: 12px; margin-top: 4px;">可输入任意数字、字母、符号组合</div>
 </div>

 <div style="margin-bottom: 20px;">
 <label
 style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">X简介</label>
 <textarea id="character-x-bio" placeholder="介绍一下这个角色在X上的身份..."
 style="width: 100%; min-height: 80px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; resize: vertical; outline: none; font-family: inherit;"
 maxlength="160"></textarea>
 <div style="text-align: right; color: #71767b; font-size: 13px; margin-top: 4px;">
 <span id="character-bio-count">0</span>/160
 </div>
 </div>

 <div style="margin-bottom: 20px;">
 <label
 style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">公众身份</label>
 <div style="color: #71767b; font-size: 13px; margin-bottom: 8px; line-height: 1.4;">
 描述角色在X平台的公众身份（如明星、网红、博主等）。这将影响其他用户对该角色的讨论几率，身份越知名可能引起更多关注和讨论。此信息完全公开。
 </div>

 <div
 style="background-color: color-mix(in srgb, var(--x-accent) , 0.1); border: 1px solid var(--x-accent); border-radius: 8px; padding: 12px; margin-bottom: 12px;">
 <div style="color: var(--x-accent); font-size: 13px; line-height: 1.4;">
 <strong>📌 重要提醒：</strong>角色将根据完整人设进行扮演，但<strong
 style="color: var(--x-accent);">X平台其他用户无法读取角色人设</strong>，仅能看到此公众身份信息。如需让其他用户了解的角色特点、背景故事等内容，请全部详细填写至公众身份中。
 </div>
 </div>
 <textarea id="character-public-identity"
 placeholder="例如：知名演员、歌手、网络红人、专业博主等... 可详细描述角色的公开背景、成就、特点等，无字数限制"
 style="width: 100%; min-height: 120px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; resize: vertical; outline: none; font-family: inherit;"></textarea>
 <div style="color: #71767b; font-size: 12px; margin-top: 4px;">
 💡 无字数限制，可详细描述角色的公开信息
 </div>
 </div>

 <div style="margin-bottom: 20px;">
 <label
 style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">真名设置</label>
 <div style="color: #71767b; font-size: 13px; margin-bottom: 12px; line-height: 1.4;">
 选择是否公开角色的真实姓名。公开后，其他用户都能看到角色真名，情侣认证时也会显示双方真名。
 </div>

 <div style="margin-bottom: 12px;">
 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
 <input type="checkbox" id="character-show-real-name" style="width: 16px; height: 16px; accent-color: var(--x-accent); " onchange="toggleCharacterRealNameInput()">
 <span style="color: #fff; font-size: 15px;">公开真实姓名</span>
 </label>
 </div>

 <div id="character-real-name-input-container" style="display: none;">
 <input type="text" id="character-real-name" placeholder="请输入角色的真实姓名"
 style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; outline: none;"
 maxlength="50">
 <div style="text-align: right; color: #71767b; font-size: 13px; margin-top: 4px;">
 <span id="character-real-name-count">0</span>/50
 </div>
 </div>
 </div>

 <div style="margin-bottom: 20px;">
 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
 <label style="color: #fff; font-size: 15px; font-weight: 600;">NPC关系绑定</label>
 <button type="button" onclick="openAddRelationshipModal()"
 style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 16px; padding: 6px 12px; font-size: 12px; cursor: pointer;">
 + 添加关系
 </button>
 </div>
 <div style="color: #71767b; font-size: 13px; margin-bottom: 12px;">
 绑定NPC角色作为朋友、亲人等，让角色能够识别和互动
 </div>

 <div id="character-relationships-list" style="max-height: 200px; overflow-y: auto;">

 </div>
 </div>

 <div style="margin-bottom: 20px; border-top: 1px solid #333; padding-top: 20px;">
 <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px;">🤖 后台自动活动</label>
 <div style="color: #71767b; font-size: 13px; margin-bottom: 12px; line-height: 1.4;">
 启用后，当与该角色在X平台私信达到设定的无互动时间后，角色将主动在后台发送消息和推文
 </div>

 <div style="margin-bottom: 16px;">
 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
 <input type="checkbox" id="character-auto-message-enabled" style="width: 16px; height: 16px; accent-color: var(--x-accent); " onchange="toggleAutoMessageSettings()">
 <span style="color: #fff; font-size: 15px;">启用后台自动发消息</span>
 </label>
 </div>

 <div id="auto-message-time-settings" style="display: none;">
 <label style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">无互动触发时间</label>
 <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
 <input type="number" id="character-auto-message-interval" placeholder="60" min="10" max="3600" style="width: 100px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 8px 12px; font-size: 14px; outline: none; ">
 <span style="color:var(--x-text-primary); font-size: 14px;">秒</span>
 </div>
 <div style="color: #71767b; font-size: 12px; line-height: 1.4;">
 设置无互动多少秒后角色会主动发消息（建议60-300秒，最少10秒，最多3600秒）
 </div>
 </div>
 </div>

 <div style="display: flex; gap: 12px; margin-top: 32px;">
 <button type="button" onclick="closeCharacterXProfileModal()"
 style="flex: 1; background-color: transparent; color: #fff; border: 1px solid #536471; border-radius: 20px; padding: 12px 24px; font-size: 15px; font-weight: 700; cursor: pointer;">
 取消
 </button>
 <button type="submit"
 style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 12px 24px; font-size: 15px; font-weight: 700; cursor: pointer;">
 保存X资料
 </button>
 </div>
 </form>
 </div>
 </div>
 </div>
 </div>

 <div id="relationship-modal"
 style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); z-index: 40; backdrop-filter: blur(8px);">
 <div style="display: flex; justify-content: center; align-items: center; height: 100%; padding: 20px;">
 <div
 style="background-color:#000; border: 1px solid #333; border-radius: 16px; width: 100%; max-width: 500px;">

 <div
 style="display: flex; align-items: center; justify-content: space-between; padding: 20px 20px 16px 20px; border-bottom: 1px solid #333;">
 <h3 id="relationship-modal-title" style="color: #fff; font-size: 18px; font-weight: 700; margin: 0;">
 添加NPC关系</h3>
 <button onclick="closeRelationshipModal()"
 style="background: none; border: none; color: #71767b; cursor: pointer; padding: 8px;">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
 <path
 d="M18.36 6.64c.39.39.39 1.02 0 1.41L13.41 12l4.95 4.95c.39.39.39 1.02 0 1.41-.39.39-1.02.39-1.41 0L12 13.41l-4.95 4.95c-.39.39-1.02.39-1.41 0-.39-.39-.39-1.02 0-1.41L10.59 12 5.64 7.05c-.39-.39-.39-1.02 0-1.41.39-.39 1.02-.39 1.41 0L12 10.59l4.95-4.95c.39-.39 1.02-.39 1.41 0z" />
 </svg>
 </button>
 </div>

 <div style="padding: 20px;">
 <form id="relationship-form">

 <div style="margin-bottom: 16px;">
 <label
 style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">NPC名称</label>
 <input type="text" id="relationship-npc-name" placeholder="输入NPC的名称"
 style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; outline: none;"
 maxlength="30">
 </div>

 <div style="margin-bottom: 16px;">
 <label
 style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">NPC句柄</label>
 <div style="position: relative;">
 <span
 style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: #71767b; font-size: 14px;">@</span>
 <input type="text" id="relationship-npc-handle" placeholder="npc_username"
 style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px 12px 12px 30px; font-size: 14px; outline: none;"
 maxlength="15">
 </div>
 </div>

 <div style="margin-bottom: 16px;">
 <label
 style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">关系类型</label>
 <select id="relationship-type"
 style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; outline: none;">
 <option value="朋友">朋友</option>
 <option value="亲人">亲人</option>
 <option value="恋人">恋人</option>
 <option value="同事">同事</option>
 <option value="同学">同学</option>
 <option value="邻居">邻居</option>
 <option value="其他">其他</option>
 </select>
 </div>

 <div style="margin-bottom: 20px;">
 <label
 style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">关系描述</label>
 <textarea id="relationship-description" placeholder="详细描述两人的关系，如何认识的，相处模式等..."
 style="width: 100%; min-height: 80px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; resize: vertical; outline: none; font-family: inherit;"
 maxlength="200"></textarea>
 <div style="text-align: right; color: #71767b; font-size: 12px; margin-top: 4px;">
 <span id="relationship-desc-count">0</span>/200
 </div>
 </div>

 <div style="display: flex; gap: 12px;">
 <button type="button" onclick="closeRelationshipModal()"
 style="flex: 1; background-color: transparent; color: #fff; border: 1px solid #536471; border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 700; cursor: pointer;">
 取消
 </button>
 <button type="submit"
 style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 700; cursor: pointer;">
 保存关系
 </button>
 </div>
 </form>
 </div>
 </div>
 </div>
 </div>

 <div id="x-search-page" class="x-page"
 style="flex: 1; display: none; flex-direction: column; overflow: hidden; min-height: 0;">

 <div class="search-header">
 <button id="search-back-btn" onclick="backToTrending()" style="display: none; background: none; border: none; padding: 8px; cursor: pointer; margin-right: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
 <g><path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path></g>
 </svg>
 </button>
 <div class="search-box">
 <button onclick="openMapPage()" style="display: flex; align-items: center; justify-content: center; background: none; border: none; padding: 4px; cursor: pointer; border-radius: 50%; transition: background-color 0.2s; flex-shrink: 0; " onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'" title="地图">
  <svg viewBox="0 0 32 32" style="width: 20px; height: 20px; stroke: #71767b; fill: none; stroke-width: 1.5;">
   <path d="M16 2C11.5817 2 8 5.58172 8 10C8 15.5 16 26 16 26C16 26 24 15.5 24 10C24 5.58172 20.4183 2 16 2Z"/>
   <circle cx="16" cy="10" r="3"/>
  </svg>
 </button>
 <svg viewBox="0 0 24 24" aria-hidden="true">
 <g><path d="M10.25 3.75c-3.59 0-6.5 2.91-6.5 6.5s2.91 6.5 6.5 6.5c1.795 0 3.419-.726 4.596-1.904 1.178-1.177 1.904-2.801 1.904-4.596 0-3.59-2.91-6.5-6.5-6.5zm-8.5 6.5c0-4.694 3.806-8.5 8.5-8.5s8.5 3.806 8.5 8.5c0 1.986-.682 3.815-1.824 5.262l4.781 4.781-1.414 1.414-4.781-4.781c-1.447 1.142-3.276 1.824-5.262 1.824-4.694 0-8.5-3.806-8.5-8.5z"></path></g>
 </svg>
 <input type="text" placeholder="搜索 X" id="search-input"
 oninput="toggleSearchButton()"
 onkeydown="if(event.key==='Enter') performSearch()">
 <button id="search-submit-btn" onclick="performSearch()" style="display: none; background: none; border: none; padding: 8px; cursor: pointer; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
 <g><path d="M2.504 21.866l.526-2.108C3.04 19.719 4 15.823 4 12s-.96-7.719-.97-7.757l-.527-2.109L22.236 12 2.504 21.866zM5.981 13c-.072 1.962-.34 3.833-.583 5.183L17.764 12 5.398 5.818c.242 1.349.51 3.221.583 5.183H10v2H5.981z"></path></g>
 </svg>
 </button>
 </div>
 </div>

 <div id="trending-view" style="display: flex; flex-direction: column; flex: 1; overflow: hidden;">

 <div class="search-tabs">
 <div class="search-tab active" onclick="switchSearchTab('recommended')">为你推荐</div>
 <div class="search-tab" onclick="switchSearchTab('trending')">当前趋势</div>
 <div class="add-category-btn" onclick="openAddCategoryModal()" title="添加自定义分类">
 <svg viewBox="0 0 24 24" aria-hidden="true">
 <g><path d="M19.5 12.75h-6.75V19.5h-1.5v-6.75H4.5v-1.5h6.75V4.5h1.5v6.75h6.75v1.5z"></path></g>
 </svg>
 </div>
 </div>

 <div class="trending-list" id="trending-list">

 </div>
 </div>

 <div id="search-results-view" style="display: none; flex-direction: column; flex: 1; overflow: hidden;">

 <div class="search-tabs">
 <div class="search-tab active" onclick="switchSearchResultTab('top')">热门</div>
 <div class="search-tab" onclick="switchSearchResultTab('latest')">最新</div>
 <div class="search-tab" onclick="switchSearchResultTab('users')">用户</div>
 </div>

 <div id="search-results-content" style="flex: 1; overflow-y: auto; background: #000; ">

 </div>
 </div>

 <button class="refresh-trends-btn" onclick="refreshTrends()" title="刷新热搜">
 <svg viewBox="0 0 24 24" aria-hidden="true">
 <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.79-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.79 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g>
 </svg>
 </button>
 </div>

 <div id="category-manager-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 30; overflow-y: auto; backdrop-filter: blur(8px); " onclick="closeCategoryModal(event)">
 <div style="background-color:#000; margin: 40px auto; border-radius: 16px; max-width: 600px; width: calc(100% - 40px); border: 1px solid #333; " onclick="event.stopPropagation()">

 <div style="display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid #333; ">
 <h2 style="color: #fff; font-size: 20px; font-weight: 700; margin: 0;">管理热搜分类</h2>
 <div onclick="closeCategoryModal()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>
 </div>

 <div style="padding: 20px; max-height: calc(100vh - 200px); overflow-y: auto;">

 <div style="background-color: color-mix(in srgb, var(--x-accent) , 0.1); border: 1px solid var(--x-accent); border-radius: 8px; padding: 12px; margin-bottom: 20px; ">
 <p style="color: var(--x-accent); font-size: 13px; line-height: 1.4; margin: 0;">
 💡 自定义分类将在刷新热搜时生成相应内容。可以添加任意分类（如"动漫"、"二次元"等），并描述该分类下的内容类型。
 </p>
 </div>

 <div style="margin-bottom: 20px;">
 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; ">
 <h3 style="color: #fff; font-size: 16px; font-weight: 600; margin: 0;">自定义分类</h3>
 <button onclick="addNewCategory()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 6px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'"
 onmouseout="this.style.backgroundColor='var(--x-accent)'">
 + 添加分类
 </button>
 </div>

 <div id="custom-categories-list" style="display: flex; flex-direction: column; gap: 12px;">

 </div>
 </div>

 <button onclick="saveCustomCategories()" style="width: 100%; background-color: var(--x-accent); color: #fff; border: none; border-radius: 25px; padding: 14px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'"
 onmouseout="this.style.backgroundColor='var(--x-accent)'">
 保存设置
 </button>
 </div>
 </div>
 </div>

 <div id="x-notifications-page" class="x-page"
 style="flex: 1; display: none; flex-direction: column; overflow: hidden; min-height: 0;">

 <div class="notifications-tabs" style="display: flex; border-bottom: 1px solid var(--x-border-color); background-color:var(--x-bg-primary);">

 <div class="notification-tab active" onclick="switchNotificationTab('all')" style="flex: 1; text-align: center; padding: 15px 0; font-weight: 700; font-size: 15px; cursor: pointer; position: relative; color:var(--x-text-primary); transition: background-color 0.2s; ">
 <span data-i18n="notificationsTabAll">全部</span>
 <div class="tab-indicator" style="position: absolute; bottom: 0; left: 0; right: 0; height: 4px; background-color: var(--x-accent); border-radius: 2px; "></div>
 </div>

 <div class="notification-tab" onclick="switchNotificationTab('mentions')" style="flex: 1; text-align: center; padding: 15px 0; font-weight: 700; font-size: 15px; cursor: pointer; position: relative; color:var(--x-text-secondary); transition: background-color 0.2s; ">
 <span data-i18n="notificationsTabMentions">提及</span>
 <div class="tab-indicator" style="position: absolute; bottom: 0; left: 0; right: 0; height: 4px; background-color: var(--x-accent); border-radius: 2px; display: none; "></div>
 </div>
 </div>

 <div id="notifications-all-content" class="notification-content" style="flex: 1; overflow-y: auto; background-color:var(--x-bg-primary); ">

 <div id="notifications-all-list" class="notifications-list">

 </div>
 </div>

 <div id="notifications-mentions-content" class="notification-content" style="flex: 1; overflow-y: auto; background-color:var(--x-bg-primary); display: none; ">

 <div id="notifications-mentions-list" class="notifications-list">

 </div>
 </div>

 <div id="refresh-messages-btn" class="refresh-messages-btn" onclick="refreshStrangerMessages()" style="position: fixed; bottom: 80px; right: 16px; width: 56px; height: 56px; background-color: var(--x-accent); border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); transition: all 0.2s; z-index: 100; " onmouseover="this.style.transform='scale(1.1)'"
 onmouseout="this.style.transform='scale(1)'">
 <svg viewBox="0 0 24 24" style="width: 24px; height: 24px; fill: #fff;">
 <g><path d="M8.8 7.2H5.6V3.9c0-.4-.3-.8-.8-.8s-.7.4-.7.8v3.3H.8c-.4 0-.8.3-.8.8s.3.8.8.8h3.3v3.3c0 .4.3.8.8.8s.8-.3.8-.8V8.7H9c.4 0 .8-.3.8-.8s-.5-.7-1-.7zm15-4.9v-.1h-.1c-.1 0-9.2 1.2-14.4 11.7-3.8 7.6-3.6 9.9-3.3 9.9.3.1 3.4-6.5 6.7-9.2 5.2-1.1 6.6-3.6 6.6-3.6s-1.5.2-2.1.2c-.8 0-1.4-.2-1.7-.3 1.3-1.2 2.4-1.5 3.5-1.7.9-.2 1.8-.4 3-1.2 2.2-1.6 1.9-5.5 1.8-5.7z"></path></g>
 </svg>
 </div>
 </div>

 <div id="x-messages-page" class="x-page"
 style="flex: 1; display: none; flex-direction: column; overflow: hidden; min-height: 0;">

 <div id="messages-list-container" class="messages-list-container" style="flex: 1; overflow-y: auto; background-color:var(--x-bg-primary); ">

 </div>

 <div id="compose-message-btn" class="compose-message-btn" onclick="openNewMessageModal()" style="position: fixed; bottom: 80px; right: 16px; width: 56px; height: 56px; background-color: var(--x-accent); border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); transition: all 0.2s; z-index: 100; " onmouseover="this.style.transform='scale(1.1)'"
 onmouseout="this.style.transform='scale(1)'">
 <svg viewBox="0 0 24 24" style="width: 24px; height: 24px; fill: #fff;">
 <g><path d="M1.998 5.5c0-1.381 1.119-2.5 2.5-2.5h15c1.381 0 2.5 1.119 2.5 2.5v13c0 1.381-1.119 2.5-2.5 2.5h-15c-1.381 0-2.5-1.119-2.5-2.5v-13zm2.5-.5c-.276 0-.5.224-.5.5v2.764l8 3.638 8-3.636V5.5c0-.276-.224-.5-.5-.5h-15zm15.5 5.463l-8 3.636-8-3.638V18.5c0 .276.224.5.5.5h15c.276 0 .5-.224.5-.5v-8.037z"></path></g>
 </svg>
 </div>
 </div>

 <div id="x-message-detail-page" class="x-page"
 style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; display: none; flex-direction: column; overflow: hidden; z-index: 20; background-color:var(--x-bg-primary);">

 <div class="message-detail-header" style="display: flex; align-items: center; padding: 55px 16px 12px 16px; background-color:var(--x-bg-primary); ">

 <div onclick="closeMessageDetail()" style="cursor: pointer; margin-right: 20px; display: flex; align-items: center; justify-content: center; width: 34px; height: 34px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path></g>
 </svg>
 </div>

 <div style="flex: 1; display: flex; align-items: center; gap: 12px; min-width: 0;">
 <img id="message-detail-top-avatar" src="https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg"
 alt="User"
 style="width: 32px; height: 32px; border-radius: 50%; cursor: pointer; transition: opacity 0.2s;"
 onmouseover="this.style.opacity='0.8'"
 onmouseout="this.style.opacity='1'"
 onclick="handleMessageDetailAvatarClick()">
 <span id="message-detail-top-name" style="font-size: 16px; font-weight: 700; color:var(--x-text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">用户名</span>
 </div>

 <div style="display: flex; gap: 8px;">

 <div style="width: 34px; height: 34px; display: flex; align-items: center; justify-content: center; border-radius: 50%; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M3 5.5C3 4.119 4.119 3 5.5 3h6C12.881 3 14 4.119 14 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-6C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v13c0 .276.224.5.5.5h6c.276 0 .5-.224.5-.5v-13c0-.276-.224-.5-.5-.5h-6zM15.5 6l5.5-3v18l-5.5-3v-12z"></path></g>
 </svg>
 </div>

 <div style="width: 34px; height: 34px; display: flex; align-items: center; justify-content: center; border-radius: 50%; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z"></path></g>
 </svg>
 </div>
 </div>
 </div>

 <div id="message-detail-scrollable" style="flex: 1; overflow-y: auto; background-color:var(--x-bg-primary); ">

 <div style="display: flex; flex-direction: column; align-items: center; padding: 20px 16px; background-color:var(--x-bg-primary); border-bottom: 1px solid var(--x-border-color); ">

 <img id="message-detail-avatar" src="https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg"
 alt="User"
 style="width: 64px; height: 64px; border-radius: 50%; margin-bottom: 12px;">

 <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 4px;">
 <span id="message-detail-name" style="font-size: 20px; font-weight: 700; color:var(--x-text-primary); ">用户名</span>
 </div>

 <div id="message-detail-handle" style="font-size: 15px; color:var(--x-text-secondary); margin-bottom: 12px; ">@handle</div>

 <div id="message-detail-bio" style="font-size: 15px; color:var(--x-text-primary); text-align: center; line-height: 1.4; margin-bottom: 12px; display: none; "></div>

 <div id="message-detail-followers" style="font-size: 14px; color:var(--x-text-secondary); " data-i18n-template="messageFollowers">0 位关注者</div>
 </div>

 <div id="message-detail-content" class="message-detail-content" style="padding: 16px; background-color:var(--x-bg-primary); min-height: 300px; ">

 </div>
 </div>

 <div class="message-input-area" style="padding: 12px 16px; background-color:var(--x-bg-primary); ">

 <div style="display: flex; align-items: center; gap: 8px; background-color:var(--x-bg-secondary); border-radius: 20px; padding: 8px 12px; position: relative; ">

 <div style="position: relative;">

 <div id="message-add-btn" onclick="toggleMessageFunctionMenu()" style="cursor: pointer; padding: 4px; border-radius: 50%; transition: all 0.2s; display: flex; align-items: center; justify-content: center; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent); transition: transform 0.2s;">
 <g><path d="M12 4C11.4477 4 11 4.44772 11 5V11H5C4.44772 11 4 11.4477 4 12C4 12.5523 4.44772 13 5 13H11V19C11 19.5523 11.4477 20 12 20C12.5523 20 13 19.5523 13 19V13H19C19.5523 13 20 12.5523 20 12C20 11.4477 19.5523 11 19 11H13V5C13 4.44772 12.5523 4 12 4Z"></path></g>
 </svg>
 </div>

 <div id="message-function-menu" style="position: absolute; bottom: 100%; left: 0; margin-bottom: 8px; background-color:var(--x-bg-primary); border: 1px solid var(--x-border-color); border-radius: 12px; padding: 4px; display: none; flex-direction: row; gap: 4px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 100; ">

 <div onclick="openImageTypeSelector(); toggleMessageFunctionMenu();" style="cursor: pointer; padding: 8px; border-radius: 8px; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
 <g><path d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z"></path></g>
 </svg>
 </div>

 <div onclick="openStickerPicker(); toggleMessageFunctionMenu();" style="cursor: pointer; padding: 8px; border-radius: 8px; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
 <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"></path></g>
 </svg>
 </div>

 <div onclick="regenerateAIResponse(); toggleMessageFunctionMenu();" style="cursor: pointer; padding: 8px; border-radius: 8px; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: none; stroke: var(--x-accent); stroke-width: 2; stroke-linecap: round; stroke-linejoin: round;">
 <path d="M20 11a8.1 8.1 0 0 0 -15.5 -2m-.5 -4v4h4" />
 <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4" />
 </svg>
 </div>

 <div onclick="openVoiceMessageDialog(); toggleMessageFunctionMenu();" style="cursor: pointer; padding: 8px; border-radius: 8px; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
 <g><path d="M12 3c-1.66 0-3 1.34-3 3v6c0 1.66 1.34 3 3 3s3-1.34 3-3V6c0-1.66-1.34-3-3-3zm0 2c.55 0 1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1V6c0-.55.45-1 1-1zm5 7c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-2.08c3.39-.49 6-3.39 6-6.92h-2z"></path></g>
 </svg>
 </div>

 <div onclick="openTransferDialog(); toggleMessageFunctionMenu();" style="cursor: pointer; padding: 8px; border-radius: 8px; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
 <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM6.64 15.748L12 10.388l5.36 5.36c-.48.32-1.04.56-1.68.72L12 12.78l-3.68 3.69c-.64-.16-1.2-.4-1.68-.72zM12 4c4.41 0 8 3.59 8 8 0 1.85-.63 3.55-1.69 4.9L12 10.59 5.69 16.9C4.63 15.55 4 13.85 4 12c0-4.41 3.59-8 8-8z"></path></g>
 </svg>
 </div>

<div id="fangroup-announcement-btn" onclick="openFanGroupAnnouncementModal(); toggleMessageFunctionMenu();" style="cursor: pointer; padding: 8px; border-radius: 8px; transition: background-color 0.2s; display: none; align-items: center; justify-content: center; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
onmouseout="this.style.backgroundColor='transparent'">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: none; stroke: var(--x-accent); stroke-width: 2; stroke-linecap: round; stroke-linejoin: round;">
<path d="M3 3m0 2a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2z" />
<path d="M9 15h-2" />
<path d="M13 12h-6" />
<path d="M11 9h-4" />
 </svg>
 </div>

 <div id="fangroup-files-btn" onclick="openFanGroupFilesModal(); toggleMessageFunctionMenu();" style="cursor: pointer; padding: 8px; border-radius: 8px; transition: background-color 0.2s; display: none; align-items: center; justify-content: center; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
onmouseout="this.style.backgroundColor='transparent'">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: none; stroke: var(--x-accent); stroke-width: 2; stroke-linecap: round; stroke-linejoin: round;">
<path d="M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2" />
 </svg>
 </div>
 </div>
 </div>

 <textarea id="message-input" placeholder="开始写私信"
 data-i18n-placeholder="messageInputPlaceholder"
 style="flex: 1; min-height: 36px; max-height: 100px; background-color: transparent; border: none; color:var(--x-text-primary); font-size: 15px; resize: none; outline: none; font-family: inherit; padding: 4px 0; line-height: 1.4; "
 oninput="autoResizeMessageInput(this)"
 onkeydown="handleMessageInputKeydown(event)"></textarea>

 <button id="fangroup-auto-reaction-btn" onclick="triggerFanGroupAutoReaction()" style="display: none; background-color:var(--x-bg-secondary); color: var(--x-accent); border: 1px solid var(--x-accent); border-radius: 50%; width: 32px; height: 32px; cursor: pointer; transition: all 0.2s; padding: 0; align-items: center; justify-content: center; flex-shrink: 0; margin-right: 4px; "
 onmouseover="this.style.backgroundColor='var(--x-accent)'; this.style.color='#fff'; this.querySelector('svg').style.stroke='#fff'"
 onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'; this.style.color='var(--x-accent)'; this.querySelector('svg').style.stroke='var(--x-accent)'">
 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="var(--x-accent)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="transition: stroke 0.2s;">
 <path d="M3 12h4.5l1.5 -6l4 12l2 -9l1.5 3h4.5" />
 </svg>
 </button>

 <button id="message-send-btn" onclick="getAIResponse()" style="display: flex; background-color: var(--x-accent); color: #fff; border: none; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; transition: opacity 0.2s; padding: 0; align-items: center; justify-content: center; flex-shrink: 0; ">
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #fff;">
 <g><path d="M2.504 21.866l.526-2.108C3.04 19.719 4 15.823 4 12s-.96-7.719-.97-7.757l-.527-2.109L22.236 12 2.504 21.866zM5.981 13c-.072 1.962-.34 3.833-.583 5.183L17.764 12 5.398 5.818c.242 1.349.51 3.221.583 5.183H10v2H5.981z"></path></g>
 </svg>
 </button>
 </div>

 <input type="file" id="message-image-input" accept="image/*" multiple style="display: none;" onchange="handleMessageImageUpload(event)">
 </div>

 

 <div id="sticker-manager-dialog" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 32; " onclick="closeStickerManager()">
 <div style="background-color:var(--x-bg-primary); border-radius: 16px; max-width: 600px; width: 90%; max-height: 80vh; display: flex; flex-direction: column; box-shadow: 0 8px 32px rgba(0,0,0,0.4); " onclick="event.stopPropagation()">
 <div style="padding: 16px; border-bottom: 1px solid var(--x-border-color); display: flex; align-items: center; justify-content: space-between; ">
 <div style="font-size: 18px; font-weight: 700; color:var(--x-text-primary);">表情包管理</div>
 <div onclick="closeStickerManager()" style="cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>
 </div>
 <div id="sticker-manager-list" style="flex: 1; overflow-y: auto; padding: 16px; ">

 </div>
 <div style="padding: 16px; border-top: 1px solid var(--x-border-color); display: flex; gap: 8px; justify-content: flex-end; ">
 <button onclick="clearAllStickers()" style="background-color: rgba(239, 68, 68, 0.1); color: rgb(239, 68, 68); border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; ">清空全部</button>
 </div>
 </div>
 </div>

 <div id="voice-message-dialog" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 31; " onclick="closeVoiceMessageDialog()">
 <div style="background-color:var(--x-bg-primary); border-radius: 16px; max-width: 500px; width: 90%; padding: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.4); " onclick="event.stopPropagation()">
 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
 <div style="font-size: 18px; font-weight: 700; color:var(--x-text-primary);">发送语音消息</div>
 <div onclick="closeVoiceMessageDialog()" style="cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>
 </div>
 <div style="font-size: 13px; color:var(--x-text-secondary); margin-bottom: 12px;">
 输入要转换为语音的文字内容
 </div>
 <div style="margin-bottom: 16px;">
 <textarea id="voice-message-text-input" placeholder="输入文字内容..." style="width: 100%; min-height: 100px; padding: 12px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; color:var(--x-text-primary); font-size: 14px; outline: none; resize: vertical; font-family: inherit; line-height: 1.5; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'"></textarea>
 </div>
 <div style="display: flex; gap: 8px; justify-content: flex-end;">
 <button onclick="closeVoiceMessageDialog()" style="background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; ">取消</button>
 <button onclick="sendVoiceMessage()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; ">发送语音</button>
 </div>
 </div>
 </div>

 <div id="transfer-dialog" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 31; overflow-y: auto; " onclick="closeTransferDialog()">
 <div style="background-color:var(--x-bg-primary); border-radius: 16px; max-width: 400px; width: 90%; max-height: 85vh; margin: 20px auto; box-shadow: 0 8px 32px rgba(0,0,0,0.4); display: flex; flex-direction: column; " onclick="event.stopPropagation()">

 <div style="display: flex; align-items: center; justify-content: space-between; padding: 20px 20px 16px; flex-shrink: 0;">
 <div style="font-size: 18px; font-weight: 700; color:var(--x-text-primary);">发起转账</div>
 <div onclick="closeTransferDialog()" style="cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>
 </div>

 <div style="flex: 1; overflow-y: auto; padding: 0 20px; min-height: 0;">

 <div style="margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--x-border-color);">
 <div style="display: flex; gap: 8px;">
 <button id="transfer-type-normal-btn" onclick="switchTransferType('normal')" style="flex: 1; padding: 8px 16px; border: 1px solid var(--x-border-color); background-color: var(--x-accent); color: #fff; border-radius: 8px; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 6px; ">
 <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: currentColor;">
 <g><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></g>
 </svg>
 普通转账
 </button>
 <button id="transfer-type-business-btn" onclick="switchTransferType('business')" style="flex: 1; padding: 8px 16px; border: 1px solid var(--x-border-color); background-color: transparent; color:var(--x-text-primary); border-radius: 8px; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 6px; ">
 <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: currentColor;">
 <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path><path d="M12 10L14.5 14L17 10L14.5 12L12 10ZM10 10L7.5 12L10 14L7.5 14L10 10Z"></path></g>
 </svg>
 商业转账
 </button>
 </div>
 </div>

 <div style="margin-bottom: 16px;">
 <label style="display: block; font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 8px;">
 转账金额
 </label>
 <div style="position: relative;">
 <input type="number" id="transfer-amount-input" placeholder="0.00" min="0.01" step="0.01" style="width: 100%; padding: 12px 16px 12px 36px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; color:var(--x-text-primary); font-size: 16px; outline: none; font-family: inherit; " onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='var(--x-border-color)'">
 <div style="position: absolute; left: 16px; top: 50%; transform: translateY(-50%); color:var(--x-text-secondary); font-weight: 600; font-size: 16px; ">$</div>
 </div>
 </div>

 <div style="margin-bottom: 16px;">
 <label style="display: block; font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 8px;">
 转账备注（可选）
 </label>
 <textarea id="transfer-note-input" placeholder="添加转账说明..." maxlength="100" style="width: 100%; min-height: 60px; padding: 12px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; color:var(--x-text-primary); font-size: 14px; outline: none; resize: vertical; font-family: inherit; line-height: 1.5; " onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='var(--x-border-color)'"
 oninput="updateTransferNoteCounter()"></textarea>
 <div style="text-align: right; margin-top: 4px;">
 <span id="transfer-note-counter" style="font-size: 12px; color:var(--x-text-secondary);">0 / 100</span>
 </div>
 </div>

 <div id="business-transfer-section" style="display: none;">

 <div style="margin-bottom: 16px;">
 <label style="display: block; font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 8px;">
 定金比例
 </label>
 <select id="transfer-deposit-ratio" style="width: 100%; padding: 12px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; color:var(--x-text-primary); font-size: 14px; outline: none; font-family: inherit; " onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='var(--x-border-color)'">
 <option value="0">0% - 无定金（任务完成后全额支付）</option>
 <option value="20" selected>20% - 先付20%定金</option>
 <option value="30">30% - 先付30%定金</option>
 <option value="50">50% - 先付50%定金</option>
 </select>
 <div style="font-size: 12px; color:var(--x-text-secondary); margin-top: 4px;">
 定金会在对方接受转账时立即支付，余款在任务完成后支付
 </div>
 </div>

 <div style="margin-bottom: 16px;">
 <label style="display: block; font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 8px;">
 任务描述 <span style="color: #ef4444;">*</span>
 </label>
 <textarea id="transfer-task-description" placeholder="例如：发布一条关于XX产品的宣传推文，需包含产品链接..." maxlength="500" style="width: 100%; min-height: 100px; padding: 12px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; color:var(--x-text-primary); font-size: 14px; outline: none; resize: vertical; font-family: inherit; line-height: 1.5; " onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='var(--x-border-color)'"
 oninput="updateTaskDescriptionCounter()"></textarea>
 <div style="text-align: right; margin-top: 4px;">
 <span id="transfer-task-counter" style="font-size: 12px; color:var(--x-text-secondary);">0 / 500</span>
 </div>
 </div>

 <div style="margin-bottom: 16px;">
 <label style="display: block; font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 8px;">
 任务期限 <span style="color: #ef4444;">*</span>
 </label>
 <input type="number" id="transfer-task-deadline" placeholder="小时数" min="1" max="720" value="24" style="width: 100%; padding: 12px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; color:var(--x-text-primary); font-size: 14px; outline: none; font-family: inherit; " onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='var(--x-border-color)'">
 <div style="font-size: 12px; color:var(--x-text-secondary); margin-top: 4px;">
 从对方接受转账起计算，建议1-72小时（最长30天）
 </div>
 </div>

 <div style="background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 12px; margin-bottom: 16px; ">
 <div style="display: flex; gap: 8px; align-items: flex-start;">
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-text-secondary); flex-shrink: 0; margin-top: 2px;">
 <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path></g>
 </svg>
 <div style="font-size: 12px; color:var(--x-text-primary); line-height: 1.5;">
 <strong>商业转账说明：</strong><br>
 • 对方接受后必须完成任务才能获得全款<br>
 • AI会自动检测任务完成情况<br>
 • 对方也可能拒绝或接受但不完成任务
 </div>
 </div>
 </div>
 </div>
 </div>

 <div style="padding: 16px 20px 20px; border-top: 1px solid var(--x-border-color); flex-shrink: 0;">
 <div style="display: flex; gap: 8px; justify-content: flex-end;">
 <button onclick="closeTransferDialog()" style="background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer; ">取消</button>
 <button onclick="sendTransfer()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer; ">发送转账</button>
 </div>
 </div>
 </div>
 </div>

 <div id="transfer-details-modal" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 32; " onclick="closeTransferDetails()">
 <div style="background-color:var(--x-bg-primary); border-radius: 16px; max-width: 360px; width: 90%; box-shadow: 0 8px 32px rgba(0,0,0,0.4); overflow: hidden; " onclick="event.stopPropagation()">

 <div id="transfer-details-content">

 </div>
 </div>
 </div>

 <div id="image-type-selector-dialog" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 31; " onclick="closeImageTypeSelector()">
 <div style="background-color:var(--x-bg-primary); border-radius: 16px; max-width: 360px; width: 90%; padding: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.4); " onclick="event.stopPropagation()">
 <div style="font-size: 18px; font-weight: 700; color:var(--x-text-primary); margin-bottom: 16px;">选择图片类型</div>
 <div style="display: flex; flex-direction: column; gap: 12px;">

 <div onclick="selectImageType('real')" style="padding: 16px; border: 2px solid var(--x-border-color); border-radius: 12px; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 12px; " onmouseover="this.style.borderColor='var(--x-accent)'; this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.borderColor='var(--x-border-color)'; this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 24px; height: 24px; fill: var(--x-accent); flex-shrink: 0;">
 <g><path d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z"></path></g>
 </svg>
 <div>
 <div style="font-size: 15px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 4px;">上传真实图片</div>
 <div style="font-size: 13px; color:var(--x-text-secondary);">从设备中选择图片文件</div>
 </div>
 </div>

 <div onclick="selectImageType('text')" style="padding: 16px; border: 2px solid var(--x-border-color); border-radius: 12px; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 12px; " onmouseover="this.style.borderColor='var(--x-accent)'; this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.borderColor='var(--x-border-color)'; this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 24px; height: 24px; fill: var(--x-accent); flex-shrink: 0;">
 <g><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></g>
 </svg>
 <div>
 <div style="font-size: 15px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 4px;">发送文字图片</div>
 <div style="font-size: 13px; color:var(--x-text-secondary);">用文字描述图片内容</div>
 </div>
 </div>
 </div>
 <div style="margin-top: 16px; display: flex; justify-content: flex-end;">
 <button onclick="closeImageTypeSelector()" style="background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; ">取消</button>
 </div>
 </div>
 </div>

 <div id="text-image-dialog" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 32; " onclick="closeTextImageDialog()">
 <div style="background-color:var(--x-bg-primary); border-radius: 16px; max-width: 500px; width: 90%; padding: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.4); " onclick="event.stopPropagation()">
 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
 <div style="font-size: 18px; font-weight: 700; color:var(--x-text-primary);">发送文字图片</div>
 <div onclick="closeTextImageDialog()" style="cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>
 </div>
 <div style="font-size: 13px; color:var(--x-text-secondary); margin-bottom: 12px;">
 用文字描述你想发送的图片内容（例如：一张美丽的日落照片）
 </div>
 <div style="margin-bottom: 16px;">
 <textarea id="text-image-description-input" placeholder="输入图片描述..." maxlength="500" style="width: 100%; min-height: 120px; padding: 12px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; color:var(--x-text-primary); font-size: 14px; outline: none; resize: vertical; font-family: inherit; line-height: 1.5; " onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='var(--x-border-color)'"
 oninput="updateTextImageCounter()"></textarea>
 <div style="text-align: right; margin-top: 4px;">
 <span id="text-image-counter" style="font-size: 12px; color:var(--x-text-secondary);">0 / 500</span>
 </div>
 </div>
 <div style="display: flex; gap: 8px; justify-content: flex-end;">
 <button onclick="closeTextImageDialog()" style="background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; ">取消</button>
 <button onclick="sendTextImage()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; ">发送</button>
 </div>
 </div>
 </div>

 <div id="add-sticker-dialog" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 31; " onclick="closeAddStickerDialog()">
 <div style="background-color:var(--x-bg-primary); border-radius: 16px; max-width: 500px; width: 90%; padding: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.4); " onclick="event.stopPropagation()">
 <div style="font-size: 18px; font-weight: 700; color:var(--x-text-primary); margin-bottom: 8px;">批量导入表情包</div>
 <div style="font-size: 13px; color:var(--x-text-secondary); margin-bottom: 16px;">
 每行一个表情包，格式：描述 链接<br>
 例如：开心 https://example.com/happy.gif
 </div>
 <div style="margin-bottom: 16px;">
 <textarea id="sticker-batch-input" placeholder="开心 https://example.com/happy.gif
难过 https://example.com/sad.gif
惊讶 https://example.com/wow.gif" style="width: 100%; min-height: 150px; padding: 12px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; color:var(--x-text-primary); font-size: 14px; outline: none; resize: vertical; font-family: inherit; line-height: 1.5; "></textarea>
 </div>
 <div style="display: flex; gap: 8px; justify-content: flex-end;">
 <button onclick="closeAddStickerDialog()" style="background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; ">取消</button>
 <button onclick="batchAddStickers()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; ">批量导入</button>
 </div>
 </div>
</div>
</div>

<div id="fangroup-announcement-modal" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.6); display: none; align-items: center; justify-content: center; z-index: 35; backdrop-filter: blur(8px); padding: 0 8px; box-sizing: border-box; " onclick="closeFanGroupAnnouncementModal()">
<div style="background-color:var(--x-bg-primary); border-radius: 20px; width: 100%; max-width: 600px; max-height: 85vh; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0,0,0,0.3); overflow: hidden; " onclick="event.stopPropagation()">

<div style="padding: 24px 24px 16px; border-bottom: 1px solid var(--x-border-color); flex-shrink: 0;">
<div style="display: flex; align-items: center; justify-content: space-between;">
<div style="display: flex; align-items: center; gap: 12px;">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width: 28px; height: 28px; fill: none; stroke: var(--x-accent); stroke-width: 2; stroke-linecap: round; stroke-linejoin: round;">
<path d="M3 3m0 2a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2z" />
<path d="M9 15h-2" />
<path d="M13 12h-6" />
<path d="M11 9h-4" />
</svg>
<h3 style="margin: 0; color:var(--x-text-primary); font-size: 24px; font-weight: 700;">群公告</h3>
</div>
<button onclick="closeFanGroupAnnouncementModal()" style="background: transparent; border: none; color:var(--x-text-secondary); cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
onmouseout="this.style.backgroundColor='transparent'">
<svg viewBox="0 0 24 24" style="width: 24px; height: 24px; fill: currentColor;">
<g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
</svg>
</button>
</div>
</div>

<div id="fangroup-announcements-container" style="flex: 1; overflow-y: auto; overflow-x: hidden; padding: 24px 16px; display: grid; grid-template-columns: repeat(auto-fit, minmax(min(100%, 280px), 1fr)); gap: 24px 16px; align-content: flex-start; justify-items: center; min-height: 200px; background: radial-gradient(circle at 20% 30%, rgba(29, 155, 240, 0.03) 0%, transparent 50%), radial-gradient(circle at 80% 70%, rgba(249, 24, 128, 0.02) 0%, transparent 50%), var(--x-bg-secondary); ">

<div style="width: 100%; text-align: center; color:var(--x-text-secondary); font-size: 14px; padding: 40px 20px; grid-column: 1 / -1;">
📌 暂无公告，点击下方按钮创建第一条公告
</div>
</div>

<div style="padding: 16px 24px; border-top: 1px solid var(--x-border-color); flex-shrink: 0; display: flex; gap: 12px;">
<button onclick="openCreateAnnouncementDialog()" style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 24px; padding: 14px 24px; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 8px rgba(29, 155, 240, 0.3); " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(29, 155, 240, 0.4)'"
onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(29, 155, 240, 0.3)'">
+ 新建公告
</button>
</div>
</div>
</div>

<div id="create-announcement-dialog" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.7); display: none; align-items: center; justify-content: center; z-index: 36; backdrop-filter: blur(4px); " onclick="closeCreateAnnouncementDialog()">
<div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 500px; box-shadow: 0 12px 40px rgba(0,0,0,0.4); overflow: hidden; " onclick="event.stopPropagation()">
<div style="padding: 20px 24px; border-bottom: 1px solid var(--x-border-color);">
<h3 style="margin: 0; color:var(--x-text-primary); font-size: 20px; font-weight: 700;">新建公告</h3>
</div>
<div style="padding: 24px;">
<label style="display: block; font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 8px;">
公告内容 <span style="color: #ef4444;">*</span>
</label>
<textarea id="announcement-content-input" placeholder="输入公告内容..." maxlength="500" style="width: 100%; min-height: 150px; padding: 12px; background-color:var(--x-bg-secondary); border: 2px solid var(--x-border-color); border-radius: 12px; color:var(--x-text-primary); font-size: 14px; outline: none; resize: vertical; font-family: inherit; line-height: 1.6; transition: border-color 0.2s; " onfocus="this.style.borderColor='var(--x-accent)'"
onblur="this.style.borderColor='var(--x-border-color)'"
oninput="updateAnnouncementCounter()"></textarea>
<div style="text-align: right; margin-top: 6px;">
<span id="announcement-counter" style="font-size: 12px; color:var(--x-text-secondary);">0 / 500</span>
</div>

<div style="margin-top: 20px; padding: 16px; background-color:var(--x-bg-secondary); border-radius: 12px; border: 1px solid var(--x-border-color);">
<label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
<input type="checkbox" id="mention-all-checkbox" style="width: 18px; height: 18px; cursor: pointer; accent-color: var(--x-accent);">
<div style="flex: 1;">
<div style="color:var(--x-text-primary); font-size: 14px; font-weight: 600; margin-bottom: 4px;">
@全体成员
</div>
<div style="color:var(--x-text-secondary); font-size: 12px; line-height: 1.4;">
勾选后将通知所有成员并触发AI反应
</div>
</div>
</label>
</div>
</div>
<div style="padding: 16px 24px; border-top: 1px solid var(--x-border-color); display: flex; gap: 12px; justify-content: flex-end;">
<button onclick="closeCreateAnnouncementDialog()" style="background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
取消
</button>
<button onclick="saveFanGroupAnnouncement()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 10px 24px; font-size: 14px; font-weight: 700; cursor: pointer; transition: opacity 0.2s; " onmouseover="this.style.opacity='0.9'"
onmouseout="this.style.opacity='1'">
发布公告
</button>
 </div>
 </div>
 </div>

 <div id="x-comments-page" class="x-page"
 style="flex: 1; display: none; flex-direction: column; overflow: hidden; min-height: 0;">
 </div>

 <div id="x-settings-page" class="x-page"
 style="flex: 1; display: none; flex-direction: column; overflow: hidden; min-height: 0;">

 <div class="settings-header"
 style="display: flex; align-items: center; justify-content: space-between; padding: 10px 15px; border-bottom: 1px solid #333; background-color:#000;">
 <div style="display: flex; align-items: center;">
 <div class="settings-back-btn" onclick="switchXPage('home')" style="cursor: pointer; margin-right: 15px;">
 <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 20px; height: 20px; fill: #fff;">
 <g>
 <path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path>
 </g>
 </svg>
 </div>
 <span style="font-size: 20px; font-weight: 700; color: #fff;">设置</span>
 </div>
 <div style="display: flex; align-items: center; gap: 8px;">

 <div id="review-toggle-btn" onclick="openReviewPage()"
 style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center;"
 onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'"
 title="审核">
 <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="var(--x-accent)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
 <path d="M5 10v-4a3 3 0 0 1 3 -3h8a3 3 0 0 1 3 3v4" />
 <path d="M16 15v-2a3 3 0 1 1 3 3v3h-14v-3a3 3 0 1 1 3 -3v2" />
 <path d="M8 12h8" />
 <path d="M7 19v2" />
 <path d="M17 19v2" />
 </svg>
 </div>
 
 <div id="help-toggle-btn" onclick="openHelpPage()"
 style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center;"
 onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'"
 title="答疑">
 <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="var(--x-accent)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
 <path d="M15.02 19.52c-2.341 .736 -5 .606 -7.32 -.52l-4.7 1l1.3 -3.9c-2.324 -3.437 -1.426 -7.872 2.1 -10.374c3.526 -2.501 8.59 -2.296 11.845 .48c1.649 1.407 2.575 3.253 2.742 5.152" />
 <path d="M19 22v.01" />
 <path d="M19 19a2.003 2.003 0 0 0 .914 -3.782a1.98 1.98 0 0 0 -2.414 .483" />
 </svg>
 </div>

 <div id="accent-color-toggle-btn" onclick="openAccentColorPicker()"
 style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center;"
 onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
 onmouseout="this.style.backgroundColor='transparent''"
 title="更改主题色">
 <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="var(--x-accent)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
 <path d="M12 21a9 9 0 0 1 0 -18c4.97 0 9 3.582 9 8c0 1.06 -.474 2.078 -1.318 2.828c-.844 .75 -1.989 1.172 -3.182 1.172h-2.5a2 2 0 0 0 -1 3.75a1.3 1.3 0 0 1 -1 2.25" />
 <path d="M8.5 10.5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" />
 <path d="M12.5 7.5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" />
 <path d="M16.5 10.5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" />
 </svg>
 </div>

 <div id="language-toggle-btn" onclick="toggleXLanguage()"
 style="cursor: pointer; padding: 8px 12px; border-radius: 20px; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; gap: 4px; background-color: rgba(255,255,255,0.05);"
 onmouseover="this.style.backgroundColor='rgba(255,255,255,0.15)'"
 onmouseout="this.style.backgroundColor='rgba(255,255,255,0.05)'"
 title="切换语言">
 <span id="language-text" style="font-size: 13px; font-weight: 600; color:var(--x-text-primary);">中文</span>
 </div>

 <div id="theme-toggle-btn" onclick="toggleXTheme()"
 style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center;"
 onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'"
 title="切换主题">

 <svg id="theme-icon-dark" viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff; display: block;">
 <g><path d="M20.742 13.045a8.088 8.088 0 0 1-2.077.271c-2.135 0-4.14-.83-5.646-2.336a8.025 8.025 0 0 1-2.064-7.723A1 1 0 0 0 9.73 2.034a10.014 10.014 0 0 0-4.489 2.582c-3.898 3.898-3.898 10.243 0 14.143a9.937 9.937 0 0 0 7.072 2.93 9.93 9.93 0 0 0 7.07-2.929 10.007 10.007 0 0 0 2.583-4.491 1.001 1.001 0 0 0-1.224-1.224zm-2.772 4.301a7.947 7.947 0 0 1-5.656 2.343 7.953 7.953 0 0 1-5.658-2.344c-3.118-3.119-3.118-8.195 0-11.314a7.923 7.923 0 0 1 2.06-1.483 10.027 10.027 0 0 0 2.89 7.848 9.972 9.972 0 0 0 7.848 2.891 8.036 8.036 0 0 1-1.484 2.059z"></path></g>
 </svg>

 <svg id="theme-icon-light" viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #000; display: none;">
 <g><path d="M12 2.5a1 1 0 0 1 1 1V5a1 1 0 1 1-2 0V3.5a1 1 0 0 1 1-1zm0 15a4.5 4.5 0 1 0 0-9 4.5 4.5 0 0 0 0 9zm0 2a6.5 6.5 0 1 1 0-13 6.5 6.5 0 0 1 0 13zM12 18a1 1 0 0 1 1 1v1.5a1 1 0 1 1-2 0V19a1 1 0 0 1 1-1zm9.5-6a1 1 0 0 1-1 1H19a1 1 0 1 1 0-2h1.5a1 1 0 0 1 1 1zM5 12a1 1 0 0 1-1 1H2.5a1 1 0 1 1 0-2H4a1 1 0 0 1 1 1zm12.864-6.864a1 1 0 0 1 0 1.414l-1.06 1.06a1 1 0 1 1-1.415-1.414l1.061-1.06a1 1 0 0 1 1.414 0zm-11.728 0a1 1 0 0 1 1.414 0l1.061 1.06A1 1 0 1 1 7.197 7.61l-1.06-1.06a1 1 0 0 1 0-1.415zM18.925 17.804a1 1 0 0 1 0 1.414l-1.061 1.061a1 1 0 0 1-1.414-1.414l1.06-1.061a1 1 0 0 1 1.415 0zm-13.85 0a1 1 0 0 1 1.414 0l1.061 1.061a1 1 0 0 1-1.414 1.414l-1.061-1.06a1 1 0 0 1 0-1.415z"></path></g>
 </svg>
 </div>
 </div>
 </div>

 <div class="settings-content"
 style="flex: 1; padding: 15px; width: 100%; box-sizing: border-box; overflow-y: auto; min-height: 0;">

 <div class="settings-section" style="margin-bottom: 30px;">
 <label style="display: block; color: #fff; font-size: 17px; font-weight: 600; margin-bottom: 10px;" data-i18n="settingsPrompt">
 提示词
 </label>
 <textarea id="x-system-prompt" placeholder="输入系统提示词..." data-i18n="settingsPromptPlaceholder"
 style="width: 100%; min-height: 120px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; resize: vertical; outline: none; font-family: inherit; line-height: 1.4;"
 onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>
 </div>

 <div class="settings-section" style="margin-bottom: 30px;">
 <label style="display: block; color: #fff; font-size: 17px; font-weight: 600; margin-bottom: 10px;" data-i18n="settingsWorldView">
 世界观设定
 </label>
 <textarea id="x-world-setting" placeholder="描述角色所在的世界观、背景设定..." data-i18n="settingsWorldViewPlaceholder"
 style="width: 100%; min-height: 100px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; resize: vertical; outline: none; font-family: inherit; line-height: 1.4;"
 onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>
 </div>

             <div class="settings-section" style="margin-bottom: 30px;">
              <label style="color: #fff; font-size: 17px; font-weight: 600; display: block; margin-bottom: 10px;" data-i18n="settingsWorldBooks">
                世界书管理
              </label>
              <p style="color: #71767b; font-size: 14px; margin: 0 0 15px 0; line-height: 1.4;" data-i18n="settingsWorldBooksDesc">
                世界书可以为AI提供额外的知识库，支持绑定到不同场景和角色
              </p>
              <button onclick="openWorldBooksManageModal()" style="width: 100%; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 12px; padding: 16px; color:var(--x-text-primary); font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 8px; " onmouseover="this.style.borderColor='var(--x-accent)'" onmouseout="this.style.borderColor='var(--x-border-color)'">
                <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
                  <g><path d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v13c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-13c0-.276-.224-.5-.5-.5h-13zM16 10H13V7h-2v3H8v2h3v3h2v-3h3v-2z"></path></g>
                </svg>
                <span data-i18n="settingsWorldBooksButton">打开世界书管理面板</span>
              </button>
            </div>

            <div class="settings-section" style="margin-bottom: 30px;">
              <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                <label style="color: #fff; font-size: 17px; font-weight: 600;" data-i18n="settingsWorldEvents">
                  世界运转大事件
                </label>
                <div class="x-toggle" onclick="toggleWorldEvents()" style="cursor: pointer;">
                  <div id="world-events-toggle" class="toggle-switch"
                    style="width: 50px; height: 30px; background-color: #333; border-radius: 15px; position: relative; transition: all 0.3s ease;">
                    <div class="toggle-circle"
                      style="width: 26px; height: 26px; background-color:#fff; border-radius: 50%; position: absolute; top: 2px; left: 2px; transition: all 0.3s ease;">
                    </div>
                  </div>
                </div>
              </div>
              <p style="color: #71767b; font-size: 14px; margin: 0 0 15px 0; line-height: 1.4;" data-i18n="settingsWorldEventsDesc">
                开启后，AI将根据世界观生成地点、天气和近期大事件，让推文生成更真实连贯
              </p>

              <div id="world-events-area" style="display: none;">
                <!-- 事件信息卡片 -->
                <div id="world-events-info" style="background-color: var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 12px; padding: 16px; margin-bottom: 12px;">
                  <!-- 地点和天气 -->
                  <div style="display: flex; gap: 16px; margin-bottom: 16px; flex-wrap: wrap;">
                    <div style="flex: 1; min-width: 200px;">
                      <div style="color: var(--x-text-secondary); font-size: 13px; margin-bottom: 4px; display: flex; align-items: center; gap: 4px;">
                        <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: var(--x-text-secondary);">
                          <g><path d="M12 7c-1.93 0-3.5 1.57-3.5 3.5S10.07 14 12 14s3.5-1.57 3.5-3.5S13.93 7 12 7zm0 5c-.827 0-1.5-.673-1.5-1.5S11.173 9 12 9s1.5.673 1.5 1.5S12.827 12 12 12zm0-10c-4.687 0-8.5 3.813-8.5 8.5 0 5.967 7.621 11.116 7.945 11.332l.555.37.555-.37c.324-.216 7.945-5.365 7.945-11.332C20.5 5.813 16.687 2 12 2zm0 17.77c-1.665-1.241-6.5-5.196-6.5-9.27C5.5 6.916 8.416 4 12 4s6.5 2.916 6.5 6.5c0 4.073-4.835 8.028-6.5 9.27z"></path></g>
                        </svg>
                        <span data-i18n="settingsWorldEventsLocation">所在地点</span>
                      </div>
                      <div id="world-location" style="color: var(--x-text-primary); font-size: 16px; font-weight: 600;">--</div>
                    </div>
                    <div style="flex: 1; min-width: 200px;">
                      <div style="color: var(--x-text-secondary); font-size: 13px; margin-bottom: 4px; display: flex; align-items: center; gap: 4px;">
                        <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: var(--x-text-secondary);">
                          <g><path d="M12 2C8.14 2 5 5.14 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.86-3.14-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z M16 12c1.1 0 2 .9 2 2v8H6v-8c0-1.1.9-2 2-2h8z"></path></g>
                        </svg>
                        <span data-i18n="settingsWorldEventsWeather">天气状况</span>
                      </div>
                      <div id="world-weather" style="color: var(--x-text-primary); font-size: 15px;">
                        <span id="weather-condition">--</span> <span id="weather-temp" style="color: var(--x-accent);">--</span>
                      </div>
                      <div id="weather-tip" style="color: var(--x-text-secondary); font-size: 12px; margin-top: 2px;">--</div>
                    </div>
                  </div>

                  <!-- 生成时间 -->
                  <div style="color: var(--x-text-secondary); font-size: 12px; padding-top: 12px; border-top: 1px solid var(--x-border-color);">
                    <span data-i18n="settingsWorldEventsLastGenerated">上次生成</span>: <span id="last-generated-time">--</span>
                    <span style="margin-left: 16px;" data-i18n="settingsWorldEventsLastProgressed">上次推进</span>: <span id="last-progressed-time">--</span>
                  </div>
                </div>

                <!-- 大事件列表 -->
                <div style="background-color: var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 12px; padding: 16px; margin-bottom: 12px;">
                  <div style="color: var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 12px;" data-i18n="settingsWorldEventsRecentEvents">近期大事件</div>
                  <div id="world-events-list" style="max-height: 400px; overflow-y: auto;">
                    <p style="color: var(--x-text-secondary); text-align: center; padding: 20px;" data-i18n="settingsWorldEventsNoEvents">暂无事件</p>
                  </div>
                </div>

                <!-- 操作按钮 -->
                <div style="display: flex; gap: 12px;">
                  <button onclick="refreshWorldEvents()" style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 12px 20px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 6px;" onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'">
                    <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #fff;">
                      <g><path d="M4.5 12c0-4.14 3.36-7.5 7.5-7.5 1.47 0 2.84.43 4 1.16V3.5c0-.28.22-.5.5-.5s.5.22.5.5v3.5c0 .28-.22.5-.5.5H13c-.28 0-.5-.22-.5-.5s.22-.5.5-.5h2.23c-.93-.59-2.02-.93-3.23-.93-3.59 0-6.5 2.91-6.5 6.5s2.91 6.5 6.5 6.5c2.49 0 4.64-1.39 5.75-3.45.11-.2.36-.27.56-.16.2.11.27.36.16.56C16.74 17.53 14.49 19 12 19c-4.14 0-7.5-3.36-7.5-7.5z"></path></g>
                    </svg>
                    <span data-i18n="settingsWorldEventsRefresh">更新事件</span>
                  </button>
                  <button id="progress-world-events-btn" onclick="progressWorldEvents()" style="flex: 1; background-color: #10b981; color: #fff; border: none; border-radius: 20px; padding: 12px 20px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 6px;" onmouseover="this.style.backgroundColor='#059669'" onmouseout="this.style.backgroundColor='#10b981'">
                    <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #fff;">
                      <g><path d="M8 5.14v14l11-7-11-7z"></path></g>
                    </svg>
                    <span data-i18n="settingsWorldEventsProgress">推进事件</span>
                  </button>
                </div>
                <p id="progress-cooldown-tip" style="color: var(--x-text-secondary); font-size: 12px; margin-top: 8px; text-align: center; display: none;" data-i18n="settingsWorldEventsCooldownTip">
                  推进功能需要间隔3小时使用
                </p>
              </div>
            </div>

 <div class="settings-section" style="margin-bottom: 30px;">
 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
 <label style="color: #fff; font-size: 17px; font-weight: 600;" data-i18n="settingsAutoTweetDetection">
 智能发推检测
 </label>
 <div class="x-toggle" onclick="toggleChatHistoryDetection()" style="cursor: pointer;">
 <div id="chat-history-detection-toggle" class="toggle-switch"
 style="width: 50px; height: 30px; background-color: #333; border-radius: 15px; position: relative; transition: all 0.3s ease;">
 <div class="toggle-circle"
 style="width: 26px; height: 26px; background-color:#fff; border-radius: 50%; position: absolute; top: 2px; left: 2px; transition: all 0.3s ease;">
 </div>
 </div>
 </div>
 </div>
 <p style="color: #71767b; font-size: 14px; margin: 0 0 15px 0; line-height: 1.4;">
 <span data-i18n="settingsAutoTweetDetectionDesc">开启后，每隔5分钟自动检测已绑定角色的聊天记忆，生成New Tweet通知</span><br>
 <span style="color: var(--x-accent); font-size: 13px;" data-i18n="settingsAutoTweetDetectionNote">仅对设置了"角色身份识别"和"专属用户人设"的角色生效</span>
 </p>
 <div id="chat-history-detection-status" style="padding: 12px; border-radius: 8px; background-color: #1a1a1a; border: 1px solid #333; color: #71767b; font-size: 14px; display: none; ">
 <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
 <div id="detection-status-indicator" style="width: 8px; height: 8px; border-radius: 50%; background-color: #10b981; animation: pulse 2s infinite; "></div>
 <span style="color: var(--x-accent); font-weight: 600;" data-i18n="settingsDetectionRunning">检测服务运行中</span>
 </div>
 <div style="font-size: 13px;">
 <span data-i18n="settingsNextDetectionTime">下次检测时间</span>: <span id="next-detection-time">--</span>
 </div>
 </div>
 </div>

 <div class="settings-section" style="margin-bottom: 30px;">
 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
 <label style="color: #fff; font-size: 17px; font-weight: 600;" data-i18n="settingsAutoRefreshFeed">
 智能刷新主页
 </label>
 <div class="x-toggle" onclick="toggleAutoRefreshFeed()" style="cursor: pointer;">
 <div id="auto-refresh-feed-toggle" class="toggle-switch"
 style="width: 50px; height: 30px; background-color: #333; border-radius: 15px; position: relative; transition: all 0.3s ease;">
 <div class="toggle-circle"
 style="width: 26px; height: 26px; background-color:#fff; border-radius: 50%; position: absolute; top: 2px; left: 2px; transition: all 0.3s ease;">
 </div>
 </div>
 </div>
 </div>
 <p style="color: #71767b; font-size: 14px; margin: 0 0 15px 0; line-height: 1.4;">
 <span data-i18n="settingsAutoRefreshFeedDesc">开启后，每隔10分钟自动刷新主页推文</span>
 </p>
 <div id="auto-refresh-feed-status" style="padding: 12px; border-radius: 8px; background-color: #1a1a1a; border: 1px solid #333; color: #71767b; font-size: 14px; display: none; ">
 <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
 <div id="refresh-status-indicator" style="width: 8px; height: 8px; border-radius: 50%; background-color: #10b981; animation: pulse 2s infinite; "></div>
 <span style="color: var(--x-accent); font-weight: 600;" data-i18n="settingsRefreshRunning">刷新服务运行中</span>
 </div>
 <div style="font-size: 13px;">
 <span data-i18n="settingsNextRefreshTime">下次刷新时间</span>: <span id="next-refresh-time">--</span>
 </div>
 </div>
 </div>

 <div class="settings-section" style="margin-bottom: 40px;">
 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
 <label style="color: #fff; font-size: 17px; font-weight: 600;" data-i18n="settingsCharacterBinding">
 绑定角色
 </label>
 <div class="x-toggle" onclick="toggleCharacterBinding()" style="cursor: pointer;">
 <div id="x-character-toggle" class="toggle-switch"
 style="width: 50px; height: 30px; background-color: #333; border-radius: 15px; position: relative; transition: all 0.3s ease;">
 <div class="toggle-circle"
 style="width: 26px; height: 26px; background-color:#fff; border-radius: 50%; position: absolute; top: 2px; left: 2px; transition: all 0.3s ease;">
 </div>
 </div>
 </div>
 </div>
 <p style="color: #71767b; font-size: 14px; margin: 0 0 15px 0; line-height: 1.4;" data-i18n="settingsCharacterBindingDesc">
 开启后，绑定的角色可以在X上发布推文
 </p>

 <div id="character-binding-area" style="display: none;">
 <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 12px; padding: 16px;">
 <div style="color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 12px;" data-i18n="settingsSelectCharacter">选择要绑定的角色</div>
 <div id="characters-list" style="max-height: 300px; overflow-y: auto;">

 </div>
 </div>
 </div>
 </div>

 <div class="settings-section" style="margin-bottom: 40px;">
 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
 <label style="color: #fff; font-size: 17px; font-weight: 600;" data-i18n="settingsRelationship">
 角色关系册
 </label>
 <div class="x-toggle" onclick="toggleCharacterRelationship()" style="cursor: pointer;">
 <div id="x-relationship-toggle" class="toggle-switch"
 style="width: 50px; height: 30px; background-color: #333; border-radius: 15px; position: relative; transition: all 0.3s ease;">
 <div class="toggle-circle"
 style="width: 26px; height: 26px; background-color:#fff; border-radius: 50%; position: absolute; top: 2px; left: 2px; transition: all 0.3s ease;">
 </div>
 </div>
 </div>
 </div>
 <p style="color: #71767b; font-size: 14px; margin: 0 0 15px 0; line-height: 1.4;" data-i18n="settingsRelationshipDesc">
 开启后，可以为已绑定的角色建立关系网络，设置角色之间的双向关系
 </p>

 <div id="relationship-binding-area" style="display: none;">
 <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 12px; padding: 16px;">
 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
 <div style="color: #fff; font-size: 15px; font-weight: 600;" data-i18n="settingsRelationshipGraph">角色关系图</div>
 <button onclick="openCharacterRelationshipGraph()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 6px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'" data-i18n="settingsEditGraph">
 编辑关系图
 </button>
 </div>

 <div id="relationship-preview" style="background-color: #0a0a0a; border: 1px solid #2f3336; border-radius: 8px; padding: 20px; min-height: 150px; display: flex; align-items: center; justify-content: center; position: relative; ">
 <canvas id="relationship-preview-canvas" width="400" height="150" style="width: 100%; height: 100%;"></canvas>
 <div id="relationship-preview-placeholder" style="color: #71767b; font-size: 14px; text-align: center; ">
 <span data-i18n="relationshipNoData">暂无关系数据</span><br>
 <span style="font-size: 12px;" data-i18n="relationshipNoDataHint">点击上方按钮开始创建角色关系</span>
 </div>
 </div>

 <div id="relationship-stats" style="margin-top: 12px; padding: 12px; background-color: color-mix(in srgb, var(--x-accent) , 0.1); border-radius: 8px; display: none; ">
 <div style="color: var(--x-accent); font-size: 13px; display: flex; justify-content: space-around;">
 <div style="text-align: center;">
 <div style="font-weight: 700; font-size: 18px;" id="relationship-character-count">0</div>
 <div style="opacity: 0.8;" data-i18n="relationshipCharacterCount">角色数</div>
 </div>
 <div style="text-align: center;">
 <div style="font-weight: 700; font-size: 18px;" id="relationship-link-count">0</div>
 <div style="opacity: 0.8;" data-i18n="relationshipLinkCount">关系数</div>
 </div>
 </div>
 </div>
 </div>
 </div>
 </div>

 <div class="settings-section" style="margin-bottom: 40px;">
 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
 <label style="color: #fff; font-size: 17px; font-weight: 600;" data-i18n="settingsNPCBinding">
 绑定NPC
 </label>
 <div class="x-toggle" onclick="toggleNPCBinding()" style="cursor: pointer;">
 <div id="x-npc-toggle" class="toggle-switch"
 style="width: 50px; height: 30px; background-color: #333; border-radius: 15px; position: relative; transition: all 0.3s ease;">
 <div class="toggle-circle"
 style="width: 26px; height: 26px; background-color:#fff; border-radius: 50%; position: absolute; top: 2px; left: 2px; transition: all 0.3s ease;">
 </div>
 </div>
 </div>
 </div>
 <p style="color: #71767b; font-size: 14px; margin: 0 0 15px 0; line-height: 1.4;" data-i18n="settingsNPCBindingDesc">
 开启后，可以创建和管理自定义NPC，设置其人设、发帖习惯和绑定用户
 </p>

 <div id="npc-binding-area" style="display: none;">
 <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 12px; padding: 16px;">
 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
 <div style="color: #fff; font-size: 15px; font-weight: 600;" data-i18n="settingsNPCList">NPC列表</div>
 <button onclick="openCreateNPCModal()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 6px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'" data-i18n="settingsCreateNPC">
 + 创建NPC
 </button>
 </div>
 <div id="npcs-list" style="max-height: 300px; overflow-y: auto;">

 </div>
 </div>
 </div>
 </div>

 <div class="settings-buttons" style="display: flex; flex-direction: column; gap: 12px;">

 <button onclick="saveXSettings()"
 style="width: 100%; background-color: var(--x-accent); color: #fff; border: none; border-radius: 25px; padding: 12px 24px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.2s;"
 onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'" data-i18n="settingsSave">
 保存设置
 </button>

 <button onclick="saveXPreset()"
 style="width: 100%; background-color: var(--x-accent); color: #fff; border: none; border-radius: 25px; padding: 12px 24px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.2s;"
 onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'" data-i18n="settingsSavePreset">
 保存为预设
 </button>

 <div style="display: flex; gap: 12px;">
 <button onclick="importXData()"
 style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 25px; padding: 12px 20px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s;"
 onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'" data-i18n="settingsImport">
 导入数据
 </button>
 <button onclick="exportXData()"
 style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 25px; padding: 12px 20px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s;"
 onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'" data-i18n="settingsExport">
 导出数据
 </button>
 </div>
 </div>

 <div class="preset-management" style="margin-top: 40px; padding-top: 30px; border-top: 1px solid #333;">
 <h3 style="color: #fff; font-size: 18px; font-weight: 700; margin-bottom: 15px;" data-i18n="settingsPresetManagement">预设管理</h3>
 <div id="x-presets-list" style="display: flex; flex-direction: column;">

 </div>
 </div>
 </div>
 </div>

 <div id="x-tweet-detail-page" class="x-page"
 style="flex: 1; display: none; flex-direction: column; overflow: hidden;">

 <div class="tweet-detail-header"
 style="display: flex; align-items: center; justify-content: space-between; padding: 10px 15px; border-bottom: 1px solid #333; background-color: rgba(0,0,0,0.8); backdrop-filter: blur(12px); position: sticky; top: 0; z-index: 5;">
 <div style="display: flex; align-items: center;">
 <div class="tweet-detail-back-btn" onclick="goBackFromTweetDetail()"
 style="cursor: pointer; margin-right: 15px;">
 <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 20px; height: 20px; fill: #fff;">
 <g>
 <path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path>
 </g>
 </svg>
 </div>
 <span style="font-size: 20px; font-weight: 700; color: #fff;" data-i18n="tweetDetailTitle">帖子</span>
 </div>

 <div id="reroll-replies-btn"
 onclick="rerollAIReplies()"
 onmousedown="handleTweetRerollButtonMouseDown()"
 onmouseup="handleTweetRerollButtonMouseUp()"
 onmouseleave="handleTweetRerollButtonMouseUp()"
 ontouchstart="handleTweetRerollButtonMouseDown()"
 ontouchend="handleTweetRerollButtonMouseUp()"
 ontouchcancel="handleTweetRerollButtonMouseUp()"
 style="display: flex; align-items: center; justify-content: center; width: 32px; height: 32px; background-color: transparent; border: none; border-radius: 50%; cursor: pointer; transition: all 0.2s; user-select: none; -webkit-user-select: none; "
 onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'"
 title="重新生成回复">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g>
 <path
 d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
 </g>
 </svg>
 </div>
 </div>

 <div class="tweet-detail-content" style="flex: 1; overflow-y: auto;">
 <div id="tweet-detail-container" style="padding: 0;">

 </div>

 <div style="border-top: 1px solid var(--x-border-color);">

 <div id="detail-comments-container" style="padding: 0; padding-bottom: 70px;">

 </div>
 </div>

 <div class="detail-comment-input-area"
 style="border-top: 1px solid var(--x-border-color); padding: 10px 15px; background-color:var(--x-bg-primary); position: fixed; bottom: 0; left: 0; right: 0; z-index: 10;">
 <div style="display: flex; align-items: flex-start; gap: 12px; max-width: 100%;">

 <img id="detail-comment-user-avatar" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg" alt="Your avatar"
 style="width: 32px; height: 32px; border-radius: 50%; flex-shrink: 0;">

 <div style="flex: 1;">
 <textarea id="detail-comment-input" placeholder="发布你的回复" data-i18n="tweetDetailReplyPlaceholder"
 style="width: 100%; min-height: 18px; max-height: 100px; background: transparent; border: none; color: #fff; font-size: 15px; resize: none; outline: none; font-family: inherit; line-height: 1.3;"
 onkeydown="handleDetailCommentInput(event)" oninput="autoResizeDetail(this)"></textarea>

 <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">

 <div style="display: flex; gap: 12px;">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent); cursor: pointer;" onclick="triggerDetailCommentImageUpload()">
 <g>
 <path
 d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z">
 </path>
 </g>
 </svg>
                 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent); cursor: pointer; opacity: 0.5;">
                    <g>
                        <path
                            d="M3 5.5C3 4.119 4.12 3 5.5 3h13C19.88 3 21 4.119 21 5.5v13c0 1.381-1.12 2.5-2.5 2.5h-13C4.12 21 3 19.881 3 18.5v-13zM5.5 5c-.28 0-.5.224-.5.5v13c0 .276.22.5.5.5h13c.28 0 .5-.224.5-.5v-13c0-.276-.22-.5-.5-.5h-13zM18 10.711V9.25h-3.74v5.5h1.44v-1.719h1.7V11.57h-1.7v-.859H18zM11.79 9.25h1.44v5.5h-1.44v-5.5zm-3.07 1.375c.34 0 .77.172 1.02.43l1.03-.86c-.51-.601-1.28-.945-2.05-.945C7.19 9.25 6 10.453 6 12s1.19 2.75 2.72 2.75c.77 0 1.54-.344 2.05-.945l-1.03-.86c-.25.258-.68.43-1.02.43-.76 0-1.29-.546-1.29-1.375S8.03 10.625 8.79 10.625z">
                        </path>
                    </g>
                </svg>
                <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent); cursor: pointer;" onclick="openCommentStickers()">
                    <g>
                        <path
                            d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z">
                        </path>
                    </g>
                </svg>
 </div>

 <button id="detail-reply-btn" onclick="submitDetailComment()"
 style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 18px; padding: 6px 16px; font-size: 14px; font-weight: 700; cursor: pointer; opacity: 0.5;"
 disabled data-i18n="tweetDetailReply">
 回复
 </button>
 </div>

 <div id="detail-comment-image-preview" style="display: none; margin-top: 10px; position: relative;">
 <img id="detail-comment-image-preview-img" src="" style="max-width: 180px; max-height: 180px; border-radius: 12px; display: block;">
 <button onclick="removeDetailCommentImage()"
 style="position: absolute; top: 4px; right: 4px; background: rgba(0,0,0,0.75); border: none; border-radius: 50%; width: 26px; height: 26px; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center;">
 <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: #fff;">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </button>
 </div>

 <input type="file" id="detail-comment-image-input" accept="image/*" style="display: none;" onchange="handleDetailCommentImageUpload(event)">
 </div>
 </div>
 </div>
 </div>
 </div>

 <div id="x-profile-page" class="x-page" style="flex: 1; display: none; flex-direction: column; overflow-y: auto; padding: 0; margin: 0;">

 <div class="profile-header"
 style="display: flex; align-items: center; padding: 10px 15px; background-color: rgba(0,0,0,0.8); backdrop-filter: blur(12px); position: relative; z-index: 5; margin: 0;">
 <div class="profile-back-btn" onclick="switchXPage('home')" style="cursor: pointer; margin-right: 15px;">
 <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 20px; height: 20px; fill: #fff;">
 <g>
 <path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path>
 </g>
 </svg>
 </div>
 <div style="flex: 1;">
 <div id="x-profile-header-name" style="font-size: 20px; font-weight: 700; color: #fff;">我</div>
 <div id="x-profile-header-count" style="font-size: 13px; color: #71767b;">0 帖子</div>
 </div>
 <div style="display: flex; gap: 15px;">

 <div onclick="switchXPage('askbox')" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s;"
 onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'"
 title="提问箱">
 <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 20px; height: 20px; fill: #fff;">
 <g>
 <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/>
 </g>
 </svg>
 </div>

 <div id="profile-menu-btn" onclick="toggleProfileMenu()"
 style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; position: relative;"
 onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 20px; height: 20px; fill: #fff;">
 <g>
 <path
 d="M3 12c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2zm9 2c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm7 0c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2z">
 </path>
 </g>
 </svg>

 <div id="profile-dropdown-menu" style="display: none; position: absolute; top: 100%; right: 0; background-color: #1a1a1a; border: 1px solid #333; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); min-width: 200px; z-index: 50; margin-top: 8px; overflow: hidden; ">
 <div onclick="openAccountManager()" style="padding: 12px 16px; color: #fff; font-size: 15px; cursor: pointer; transition: background-color 0.2s; display: flex; align-items: center; gap: 12px; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;">
 <g>
 <path
 d="M12 2C13.1 2 14 2.9 14 4C14 5.1 13.1 6 12 6C10.9 6 10 5.1 10 4C10 2.9 10.9 2 12 2ZM21 9V7L19 6.5C18.5 4.4 16.6 2.5 14.5 2L14 0H10L9.5 2C7.4 2.5 5.5 4.4 5 6.5L3 7V9L5 9.5C5.5 11.6 7.4 13.5 9.5 14L10 16H14L14.5 14C16.6 13.5 18.5 11.6 19 9.5L21 9ZM12 8C13.66 8 15 9.34 15 11C15 12.66 13.66 14 12 14C10.34 14 9 12.66 9 11C9 9.34 10.34 8 12 8ZM19 17H5V19H19V17ZM12 20C10.9 20 10 20.9 10 22H14C14 20.9 13.1 20 12 20Z">
 </path>
 </g>
 </svg>
 <span data-i18n="profileAccountManager">账号管理</span>
 </div>
 <div onclick="openAccountWallet()" style="padding: 12px 16px; color: #fff; font-size: 15px; cursor: pointer; transition: background-color 0.2s; display: flex; align-items: center; gap: 12px; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;">
 <g>
 <path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/>
 </g>
 </svg>
 <span data-i18n="profileAccountWallet">账户钱包</span>
 </div>
 <div onclick="openToolModal()" style="padding: 12px 16px; color: #fff; font-size: 15px; cursor: pointer; transition: background-color 0.2s; display: flex; align-items: center; gap: 12px; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;">
 <g>
 <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-5.5-2.5l7.51-3.49L17.5 6.5 9.99 9.99 6.5 17.5zm5.5-6.6c.61 0 1.1.49 1.1 1.1s-.49 1.1-1.1 1.1-1.1-.49-1.1-1.1.49-1.1 1.1-1.1z"/>
 </g>
 </svg>
 <span data-i18n="profileAccountTools">账户道具</span>
 </div>
 </div>
 </div>
 </div>
 </div>

 <div class="cover-section" style="position: relative; height: 140px; background-color: #333; margin: 0; padding: 0; margin-top: -1px;">
 <img id="x-profile-cover-image" src="https://i.postimg.cc/qRzMB6nQ/default-cover.jpg"
 style="width: 100%; height: 100%; object-fit: cover; display: block; margin: 0; padding: 0; vertical-align: top;" alt="封面图">
 </div>

 <div class="user-info-section" style="padding: 8px 16px 0; position: relative;">

 <div style="position: relative; margin-bottom: 8px;">
 <img id="x-profile-main-avatar" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg"
 style="width: 88px; height: 88px; border-radius: 50%; border: 5px solid #000; position: absolute; top: -44px; left: 0; object-fit: cover; overflow: hidden; box-sizing: border-box;"
 alt="用户头像">
 </div>

 <div style="display: flex; justify-content: flex-end; margin: 8px 0;">
 <button onclick="editProfile()"
 style="background-color: transparent; color: #fff; border: 1px solid #536471; border-radius: 20px; padding: 6px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s;"
 onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'" data-i18n="profileEditProfile">
 编辑个人资料
 </button>
 </div>

 <div style="margin-top: 8px; margin-bottom: 0px; padding-left: 8px;">
 <div style="display: flex; align-items: center; gap: 2px; margin-bottom: 4px;">
 <span id="x-profile-user-name" style="font-size: 20px; font-weight: 700; color: #fff;">我</span>
 <svg id="x-profile-verified-badge" viewBox="0 0 24 24"
 style="width: 20px; height: 20px; fill: var(--x-accent); display: none;">
 <g>
 <path
 d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z">
 </path>
 </g>
 </svg>
 </div>
 <div id="x-profile-user-handle" style="font-size: 15px; color: #71767b; margin-bottom: 8px;">@me</div>
 </div>

 <div id="x-profile-bio" style="font-size: 15px; color: #fff; line-height: 1.3; margin-bottom: 8px; padding-left: 8px;">
 欢迎来到我的X主页！
 </div>

 <div class="profile-tags"
 style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px; flex-wrap: wrap; padding-left: 8px;">
 <div style="display: flex; align-items: center; gap: 4px;">
 <span id="x-profile-tag1-icon" style="font-size: 14px;">✨</span>
 <span id="x-profile-tag1" style="color: #71767b; font-size: 14px;">科技爱好者</span>
 </div>
 <div style="display: flex; align-items: center; gap: 4px;">
 <span id="x-profile-tag2-icon" style="font-size: 14px;">📅</span>
 <span id="x-profile-tag2" style="color: #71767b; font-size: 14px;">2024年加入</span>
 </div>
 </div>

 <div style="display: flex; gap: 16px; margin-bottom: 8px; padding-left: 8px;">
 <div style="cursor: pointer;" onmouseover="this.querySelector('span').style.textDecoration='underline'"
 onmouseout="this.querySelector('span').style.textDecoration='none'">
 <span id="x-profile-following-count" style="color: #fff; font-weight: 700; font-size: 14px;">156</span>
 <span style="color: #71767b; margin-left: 2px; font-size: 14px; font-weight: 400;" data-i18n="profileFollowing">正在关注</span>
 </div>
 <div style="cursor: pointer;" onmouseover="this.querySelector('span').style.textDecoration='underline'"
 onmouseout="this.querySelector('span').style.textDecoration='none'">
 <span id="x-profile-followers-count" style="color: #fff; font-weight: 700; font-size: 14px;">89</span>
 <span style="color: #71767b; margin-left: 2px; font-size: 14px; font-weight: 400;" data-i18n="profileFollowers">关注者</span>
 </div>
 </div>
 </div>

 <div class="profile-tabs" style="display: flex; border-bottom: 1px solid #2f3336;">
 <div class="profile-tab active" onclick="switchProfileTab('posts')"
 style="flex: 1; text-align: center; padding: 14px 0; font-weight: 600; font-size: 15px; cursor: pointer; position: relative; color: #fff;">
 <span data-i18n="profilePosts">帖子</span>
 <div class="tab-indicator"
 style="position: absolute; bottom: 0; left: 25%; width: 50%; height: 3px; background-color: var(--x-accent); border-radius: 2px;">
 </div>
 </div>
 <div class="profile-tab" onclick="switchProfileTab('likes')"
 style="flex: 1; text-align: center; padding: 14px 0; font-weight: 500; font-size: 15px; cursor: pointer; position: relative; color: #71767b;">
 <span data-i18n="profileLikes">喜欢</span>
 <div class="tab-indicator"
 style="position: absolute; bottom: 0; left: 25%; width: 50%; height: 3px; background-color: var(--x-accent); border-radius: 2px; display: none;">
 </div>
 </div>
 <div class="profile-tab" onclick="switchProfileTab('highlights')"
 style="flex: 1; text-align: center; padding: 14px 0; font-weight: 500; font-size: 15px; cursor: pointer; position: relative; color: #71767b;">
 <span data-i18n="profileHighlights">亮点</span>
 <div class="tab-indicator"
 style="position: absolute; bottom: 0; left: 25%; width: 50%; height: 3px; background-color: var(--x-accent); border-radius: 2px; display: none;">
 </div>
 </div>
 <div class="profile-tab" onclick="switchProfileTab('articles')"
 style="flex: 1; text-align: center; padding: 14px 0; font-weight: 500; font-size: 15px; cursor: pointer; position: relative; color: #71767b;">
 <span data-i18n="profileArticles">文章</span>
 <div class="tab-indicator"
 style="position: absolute; bottom: 0; left: 25%; width: 50%; height: 3px; background-color: var(--x-accent); border-radius: 2px; display: none;">
 </div>
 </div>
 <div class="profile-tab" onclick="switchProfileTab('media')"
 style="flex: 1; text-align: center; padding: 14px 0; font-weight: 500; font-size: 15px; cursor: pointer; position: relative; color: #71767b;">
 <span data-i18n="profileMedia">媒体</span>
 <div class="tab-indicator"
 style="position: absolute; bottom: 0; left: 25%; width: 50%; height: 3px; background-color: var(--x-accent); border-radius: 2px; display: none;">
 </div>
 </div>
 </div>

 <div class="profile-content" style="flex: 1;">

 <div id="profile-posts-content" class="profile-tab-content" style="display: block;">
 <div id="x-profile-tweets-container" style="padding: 0;">

 </div>
 </div>

 <div id="profile-likes-content" class="profile-tab-content" style="display: none;">
 <div style="padding: 60px 32px; text-align: center;">
 <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;" data-i18n="profileNoLikes">还没有喜欢的推文</div>
 <div style="color: #71767b; font-size: 15px;" data-i18n="profileNoLikesDesc">当你喜欢一条推文时，它会显示在这里。</div>
 </div>
 </div>
 <div id="profile-highlights-content" class="profile-tab-content" style="display: none;">
 <div style="padding: 60px 32px; text-align: center;">
 <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;" data-i18n="profileNoHighlights">还没有亮点</div>
 <div style="color: #71767b; font-size: 15px;" data-i18n="profileNoHighlightsDesc">点赞最多的推文会显示在这里。</div>
 </div>
 </div>
 <div id="profile-articles-content" class="profile-tab-content" style="display: none;">
 <div style="padding: 60px 32px; text-align: center;">
 <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;" data-i18n="profileNoArticles">还没有文章</div>
 <div style="color: #71767b; font-size: 15px;" data-i18n="profileNoArticlesDesc">发布的文章会显示在这里。</div>
 </div>
 </div>
 <div id="profile-media-content" class="profile-tab-content" style="display: none;">
 <div style="padding: 60px 32px; text-align: center;">
 <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;" data-i18n="profileNoMedia">还没有媒体</div>
 <div style="color: #71767b; font-size: 15px;" data-i18n="profileNoMediaDesc">包含照片和视频的推文会显示在这里。</div>
 </div>
 </div>
 </div>
 </div>
</div>

<div id="edit-profile-modal" class="profile-modal" onclick="closeEditProfileModal(event)" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(91, 112, 131, 0.4); z-index: 20; overflow-y: auto;
">
 <div class="modal-content" onclick="event.stopPropagation()" style="background-color:#000; margin: 40px auto; border-radius: 16px; max-width: 600px; width: calc(100% - 40px); max-height: calc(100vh - 80px); position: relative; overflow: hidden; ">

 <div class="modal-header" style="display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid #2f3336; position: sticky; top: 0; background-color:#000; z-index: 25; ">
 <div style="display: flex; align-items: center; gap: 24px;">

 <div class="modal-close-btn" onclick="closeEditProfileModal()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
 <g>
 <path
 d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z">
 </path>
 </g>
 </svg>
 </div>

 <h2 style="color: #fff; font-size: 20px; font-weight: 700; margin: 0; ">编辑个人资料</h2>
 </div>

 <button id="save-profile-btn" onclick="saveProfileChanges()" style="background-color:#fff; color: #000; border: none; border-radius: 20px; padding: 6px 16px; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#d7dbdc'" onmouseout="this.style.backgroundColor='#fff'">
 保存
 </button>
 </div>

 <div class="modal-body" style="padding: 0; overflow-y: auto; max-height: calc(100vh - 140px); ">

 <div class="edit-cover-section" style="position: relative; height: 200px; background-color: #333; overflow: hidden; ">
 <img id="edit-cover-image" src="https://i.postimg.cc/qRzMB6nQ/default-cover.jpg"
 style="width: 100%; height: 100%; object-fit: cover;" alt="封面图">

 <div class="cover-edit-overlay" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.4); display: flex; justify-content: center; align-items: center; gap: 12px; ">

 <div class="cover-edit-btn" onclick="editCoverImage()" style="background-color: rgba(0, 0, 0, 0.75); border-radius: 50%; padding: 12px; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(0,0,0,0.85)'"
 onmouseout="this.style.backgroundColor='rgba(0,0,0,0.75)'">
 <svg viewBox="0 0 24 24" style="width: 22px; height: 22px; fill: #fff;">
 <g>
 <path
 d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z">
 </path>
 </g>
 </svg>
 </div>

 <div class="cover-remove-btn" onclick="removeCoverImage()" style="background-color: rgba(0, 0, 0, 0.75); border-radius: 50%; padding: 12px; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(0,0,0,0.85)'"
 onmouseout="this.style.backgroundColor='rgba(0,0,0,0.75)'">
 <svg viewBox="0 0 24 24" style="width: 22px; height: 22px; fill: #fff;">
 <g>
 <path
 d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z">
 </path>
 </g>
 </svg>
 </div>
 </div>
 </div>

 <div class="edit-avatar-section" style="padding: 12px 16px; position: relative; margin-top: -67px; z-index: 3; ">
 <div style="position: relative; width: 134px;">
 <img id="edit-main-avatar" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg"
 style="width: 134px; height: 134px; border-radius: 50%; border: 4px solid #000; object-fit: cover; overflow: hidden; box-sizing: border-box;" alt="用户头像">

 <div class="avatar-edit-btn" onclick="editAvatarImage()" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.75); border-radius: 50%; padding: 12px; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(0,0,0,0.85)'"
 onmouseout="this.style.backgroundColor='rgba(0,0,0,0.75)'">
 <svg viewBox="0 0 24 24" style="width: 22px; height: 22px; fill: #fff;">
 <g>
 <path
 d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z">
 </path>
 </g>
 </svg>
 </div>
 </div>
 </div>

 <div class="edit-form-section" style="padding: 24px 16px;">

 <div class="form-group" style="margin-bottom: 20px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; font-weight: 400; margin-bottom: 2px; ">名称</label>
 <input type="text" id="edit-user-name" placeholder="名称" style="width: 100%; background-color: transparent; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 17px; outline: none; transition: border-color 0.2s; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'" maxlength="50"
 oninput="updateCharacterCounts()">
 <div style="color: #8b98a5; font-size: 13px; margin-top: 4px;">0 / 50</div>
 </div>

 <div class="form-group" style="margin-bottom: 20px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; font-weight: 400; margin-bottom: 2px; ">用户名</label>
 <input type="text" id="edit-user-handle" placeholder="用户名" style="width: 100%; background-color: transparent; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 17px; outline: none; transition: border-color 0.2s; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'" maxlength="15"
 oninput="updateCharacterCounts()">
 <div style="color: #8b98a5; font-size: 13px; margin-top: 4px;">0 / 15</div>
 </div>

 <div class="form-group" style="margin-bottom: 20px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; font-weight: 400; margin-bottom: 2px; ">自我介绍</label>
 <textarea id="edit-user-bio" placeholder="自我介绍" style="width: 100%; background-color: transparent; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 17px; outline: none; transition: border-color 0.2s; box-sizing: border-box; resize: vertical; min-height: 80px; max-height: 150px; font-family: inherit; line-height: 1.3; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'" maxlength="160"
 oninput="updateCharacterCounts()"></textarea>
 <div style="color: #8b98a5; font-size: 13px; margin-top: 4px;">0 / 160</div>
 </div>

 <div class="form-group" style="margin-bottom: 25px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; font-weight: 400; margin-bottom: 8px; ">自定义标签1</label>

 <div style="display: flex; gap: 8px; margin-bottom: 8px;">

 <input type="text" id="edit-tag1-icon" placeholder="✨" maxlength="2" style="width: 50px; background-color: transparent; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 17px; outline: none; transition: border-color 0.2s; box-sizing: border-box; text-align: center; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">

 <input type="text" id="edit-custom-tag1" placeholder="例如：科技爱好者" style="flex: 1; background-color: transparent; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 17px; outline: none; transition: border-color 0.2s; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'" maxlength="30"
 oninput="updateCharacterCounts()">
 </div>

 <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 4px;">
 <label style="color: #8b98a5; font-size: 12px; min-width: 40px;">颜色:</label>
 <input type="color" id="edit-tag1-color" value="#71767b" style="width: 40px; height: 32px; border: 1px solid #333; border-radius: 4px; background: transparent; cursor: pointer; outline: none; " onchange="updateTag1ColorFromPicker()">
 <input type="text" id="edit-tag1-color-text" placeholder="#71767b" maxlength="7" style="flex: 1; background-color: transparent; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 8px 12px; font-size: 14px; outline: none; font-family: monospace; transition: border-color 0.2s; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"
 oninput="updateTag1ColorFromText()" onchange="updateTag1ColorFromText()">
 </div>
 <div style="color: #8b98a5; font-size: 13px;">0 / 30</div>
 </div>

 <div class="form-group" style="margin-bottom: 25px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; font-weight: 400; margin-bottom: 8px; ">自定义标签2</label>

 <div style="display: flex; gap: 8px; margin-bottom: 8px;">

 <input type="text" id="edit-tag2-icon" placeholder="📅" maxlength="2" style="width: 50px; background-color: transparent; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 17px; outline: none; transition: border-color 0.2s; box-sizing: border-box; text-align: center; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">

 <input type="text" id="edit-custom-tag2" placeholder="例如：2024年加入" style="flex: 1; background-color: transparent; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 17px; outline: none; transition: border-color 0.2s; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'" maxlength="30"
 oninput="updateCharacterCounts()">
 </div>

 <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 4px;">
 <label style="color: #8b98a5; font-size: 12px; min-width: 40px;">颜色:</label>
 <input type="color" id="edit-tag2-color" value="#71767b" style="width: 40px; height: 32px; border: 1px solid #333; border-radius: 4px; background: transparent; cursor: pointer; outline: none; " onchange="updateTag2ColorFromPicker()">
 <input type="text" id="edit-tag2-color-text" placeholder="#71767b" maxlength="7" style="flex: 1; background-color: transparent; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 8px 12px; font-size: 14px; outline: none; font-family: monospace; transition: border-color 0.2s; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"
 oninput="updateTag2ColorFromText()" onchange="updateTag2ColorFromText()">
 </div>
 <div style="color: #8b98a5; font-size: 13px;">0 / 30</div>
 </div>

 <div class="form-group" style="margin-bottom: 20px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; font-weight: 400; margin-bottom: 2px; ">正在关注数量</label>
 <input type="text" id="edit-following-count" placeholder="156, 1.2K, 2.5M等" maxlength="20" style="width: 100%; background-color: transparent; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 17px; outline: none; transition: border-color 0.2s; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
 <div style="color: #8b98a5; font-size: 13px; margin-top: 4px;">可输入任意数字、字母、符号组合</div>
 </div>

 <div class="form-group" style="margin-bottom: 20px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; font-weight: 400; margin-bottom: 2px; ">关注者数量</label>
 <input type="text" id="edit-followers-count" placeholder="89, 1.5K, 3.2M等" maxlength="20" style="width: 100%; background-color: transparent; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 17px; outline: none; transition: border-color 0.2s; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
 <div style="color: #8b98a5; font-size: 13px; margin-top: 4px;">可输入任意数字、字母、符号组合</div>
 </div>

 <div class="form-group" style="margin-bottom: 25px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; font-weight: 400; margin-bottom: 8px; ">认证类型</label>
 <div style="color: #71767b; font-size: 12px; margin-bottom: 12px; line-height: 1.4;">
 选择您的认证类型，不同认证类型会显示不同的图标和含义。
 </div>

 <div style="margin-bottom: 12px;">
 <select id="edit-verification-type" style="width: 100%; background-color:#000; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 17px; outline: none; transition: border-color 0.2s; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"
 onchange="updateVerificationTypeUI()">
 <option value="none" style="background-color:#000; color: #fff;">无认证</option>
 <option value="verified" style="background-color:#000; color: #fff;">已认证 - 蓝色勾标</option>
 <option value="couple" style="background-color:#000; color: #fff;">情侣认证 - 白色心形</option>
 <option value="married" style="background-color:#000; color: #fff;">已婚认证 - 白色圆环</option>
 <option value="vip" style="background-color:#000; color: #fff;">VIP认证 - 白色菱形</option>
 </select>
 </div>

 <div id="couple-binding-section" style="display: none;">
 <label style="display: block; color: #8b98a5; font-size: 13px; font-weight: 400; margin-bottom: 8px; ">情侣对象角色</label>
 <div style="color: #71767b; font-size: 12px; margin-bottom: 8px; line-height: 1.4;">
 选择与您是情侣关系的角色。绑定后，其他推特观众都会知道你们的情侣关系。
 </div>
 <select id="edit-couple-character" style="width: 100%; background-color:#000; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 17px; outline: none; transition: border-color 0.2s; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
 <option value="" style="background-color:#000; color: #fff;">未选择角色</option>

 </select>
 </div>
 </div>

 <div class="form-group" style="margin-bottom: 25px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; font-weight: 400; margin-bottom: 8px; ">公众身份</label>
 <div style="color: #71767b; font-size: 12px; margin-bottom: 8px; line-height: 1.4;">
 描述您在X平台的公众身份（如明星、网红、博主等）。这将影响其他用户对您的讨论几率，身份越知名可能引起更多关注和讨论。此信息完全公开。
 </div>

 <div
 style="background-color: color-mix(in srgb, var(--x-accent) , 0.1); border: 1px solid var(--x-accent); border-radius: 6px; padding: 12px; margin-bottom: 12px;">
 <div style="color: var(--x-accent); font-size: 12px; line-height: 1.4;">
 <strong>📌 重要提醒：</strong>您将以完整身份进行互动，但<strong
 style="color: var(--x-accent);">X平台其他用户无法读取您的个人设定</strong>，仅能看到此公众身份信息。如需让其他用户了解的个人特点、背景经历等内容，请全部详细填写至公众身份中。
 </div>
 </div>
 <textarea id="edit-public-identity" placeholder="例如：知名科技博主、演员、歌手、网络红人等... 可详细描述您的公开背景、成就、特点等，无字数限制" style="width: 100%; background-color: transparent; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 17px; outline: none; transition: border-color 0.2s; box-sizing: border-box; resize: vertical; min-height: 120px; max-height: 200px; font-family: inherit; line-height: 1.3; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>
 <div style="color: #8b98a5; font-size: 12px; margin-top: 4px;">💡 无字数限制，可详细描述您的公开信息</div>
 </div>

 <div class="form-group" style="margin-bottom: 25px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; font-weight: 400; margin-bottom: 8px; ">真名设置</label>
 <div style="color: #71767b; font-size: 12px; margin-bottom: 12px; line-height: 1.4;">
 选择是否公开您的真实姓名。公开后，其他用户和角色都能看到您的真名，情侣认证时也会显示双方真名。
 </div>

 <div style="margin-bottom: 12px;">
 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
 <input type="checkbox" id="edit-show-real-name" style="width: 16px; height: 16px; accent-color: var(--x-accent); " onchange="toggleRealNameInput()">
 <span style="color: #fff; font-size: 15px;">公开真实姓名</span>
 </label>
 </div>

 <div id="real-name-input-container" style="display: none;">
 <input type="text" id="edit-real-name" placeholder="请输入您的真实姓名" style="width: 100%; background-color: transparent; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 12px; font-size: 17px; outline: none; transition: border-color 0.2s; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'" maxlength="50"
 oninput="updateCharacterCounts()">
 <div style="color: #8b98a5; font-size: 13px; margin-top: 4px;">0 / 50</div>
 </div>
 </div>

 <div class="form-group" style="margin-bottom: 20px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; font-weight: 400; margin-bottom: 8px; ">角色身份识别</label>
 <div style="color: #71767b; font-size: 12px; margin-bottom: 12px; line-height: 1.4;">
 选择哪些角色知道您的真实身份。被选中的角色会认识您，在互动时会表现得像朋友一样。
 <br><br>
 <strong style="color: var(--x-accent);">功能说明：</strong><br>
 • 知道您身份的角色会在评论区与您自然互动<br>
 • 您发帖时，这些角色可能会来留言<br>
 • 只有已绑定X资料的角色才能被选择<br>
 • <strong style="color: var(--x-accent);">点击右侧按钮</strong>可设置专属的用户人设<br>
 • 🔵 蓝色<strong>+</strong>按钮：未设置 | 🟢 绿色<strong>✏️</strong>按钮：已设置
 </div>

 <div id="identity-characters-list" style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 12px; max-height: 200px; overflow-y: auto; ">

 </div>
 </div>
 </div>
 </div>
 </div>
</div>

<div id="compose-tweet-modal" class="compose-modal" onclick="closeComposeTweetModal(event)" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(91, 112, 131, 0.4); z-index: 20; overflow-y: auto;
">
 <div class="compose-modal-content" onclick="event.stopPropagation()" style="background-color:#000; margin: 40px auto; border-radius: 16px; max-width: 600px; width: calc(100% - 40px); max-height: calc(100vh - 80px); position: relative; overflow: hidden; ">

 <div class="compose-header" style="display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid #2f3336; position: sticky; top: 0; background-color:#000; z-index: 25; ">
 <div style="display: flex; align-items: center; gap: 24px;">

 <div class="compose-close-btn" onclick="closeComposeTweetModal()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
 <g>
 <path
 d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z">
 </path>
 </g>
 </svg>
 </div>
 </div>

 <button id="compose-tweet-btn" onclick="publishTweet()" disabled style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 8px 20px; font-size: 15px; font-weight: 700; cursor: pointer; opacity: 0.5; transition: all 0.2s; ">
 发帖
 </button>
 </div>

 <div class="compose-body" style="padding: 16px; overflow-y: auto; max-height: calc(100vh - 200px); ">

 <div style="display: flex; gap: 12px; margin-bottom: 20px;">

 <img id="compose-user-avatar" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg" alt="用户头像"
 style="width: 48px; height: 48px; border-radius: 50%; flex-shrink: 0;">

 <div style="flex: 1; min-width: 0;">

 <textarea id="compose-text-input" placeholder="有什么新鲜事？" style="width: 100%; min-height: 120px; max-height: 300px; background: transparent; border: none; color: #fff; font-size: 20px; resize: none; outline: none; font-family: inherit; line-height: 1.3; box-sizing: border-box; " oninput="handleComposeInput()" onkeyup="processHashtagsAndMentions()"></textarea>

 <div id="quote-content-preview"
 style="display: none; margin-top: 16px; border: 1px solid #2f3336; border-radius: 16px; padding: 12px; background-color: rgba(0,0,0,0.3);">
 <div
 style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
 <div style="display: flex; align-items: center; gap: 4px;">
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #71767b;">
 <g>
 <path
 d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z">
 </path>
 </g>
 </svg>
 <span id="quote-type-text" style="color: #71767b; font-size: 13px;">引用推文</span>
 </div>
 <div onclick="removeQuoteContent()"
 style="cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color 0.2s;"
 onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #71767b;">
 <g>
 <path
 d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z">
 </path>
 </g>
 </svg>
 </div>
 </div>
 <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
 <img id="quote-user-avatar" style="width: 20px; height: 20px; border-radius: 50%;" alt="用户头像">
 <span id="quote-user-name" style="font-weight: 600; color: #fff; font-size: 13px;"></span>
 <svg id="quote-user-verified" viewBox="0 0 24 24"
 style="width: 14px; height: 14px; fill: var(--x-accent); display: none;">
 <g>
 <path
 d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z">
 </path>
 </g>
 </svg>
 <span id="quote-user-handle" style="color: #71767b; font-size: 13px;"></span>
 <span id="quote-user-time" style="color: #71767b; font-size: 13px;"></span>
 </div>
 <div id="quote-content-text"
 style="color: #fff; font-size: 14px; line-height: 1.3; word-wrap: break-word;"></div>

 <div id="quote-image-container" style="display: none;"></div>
 </div>

 <div style="display: flex; justify-content: flex-end; margin-top: 8px;">
 <div id="compose-char-count" style="color: #71767b; font-size: 13px; ">0 / 280</div>
 </div>

 <div id="business-task-selection" style="display: none; margin-top: 16px; margin-bottom: 16px;">
 <div style="background-color: #1a1a1a; border: 2px solid #f59e0b; border-radius: 12px; padding: 16px;">
 <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #f59e0b;">
 <g><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" /></g>
 </svg>
 <div style="color: #f59e0b; font-size: 15px; font-weight: 700;">选择商业任务</div>
 </div>
 <div id="business-tasks-list" style="display: flex; flex-direction: column; gap: 8px;">

 </div>
 </div>
 </div>

 <div style="margin-top: 16px;">

 <div id="compose-image-section" style="display: none; margin-bottom: 16px;">
 <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 12px; padding: 16px;">
 <div style="color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 12px;">添加图片</div>

 <div style="display: flex; gap: 12px; margin-bottom: 16px;">
 <button onclick="selectImageMethod('description')" id="img-desc-btn" style="flex: 1; background-color: #333; color: #fff; border: 1px solid #536471; border-radius: 8px; padding: 8px 12px; font-size: 13px; cursor: pointer; transition: all 0.2s; ">文字描述</button>
 <button onclick="selectImageMethod('upload')" id="img-upload-btn" style="flex: 1; background-color: #333; color: #fff; border: 1px solid #536471; border-radius: 8px; padding: 8px 12px; font-size: 13px; cursor: pointer; transition: all 0.2s; ">本地上传</button>
 </div>

 <div id="image-description-input" style="display: none;">
 <textarea placeholder="描述图片内容..." style="width: 100%; min-height: 80px; background-color:#000; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; resize: vertical; outline: none; font-family: inherit; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>
 </div>

 <div id="image-upload-area" style="display: none;">
 <div style="border: 2px dashed #333; border-radius: 8px; padding: 20px; text-align: center; cursor: pointer; transition: all 0.2s; " onclick="triggerImageUpload()" onmouseover="this.style.borderColor='var(--x-accent)'"
 onmouseout="this.style.borderColor='#333'">
 <svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: #71767b; margin-bottom: 8px;">
 <g>
 <path
 d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z">
 </path>
 </g>
 </svg>
 <div style="color: #71767b; font-size: 15px;">点击选择图片文件</div>
 <div style="color: #71767b; font-size: 13px; margin-top: 4px;">支持 JPG、PNG、GIF，最多4张，每张最大 5MB</div>
 </div>
 <input type="file" id="image-file-input" accept="image/*" multiple style="display: none;"
 onchange="handleImageUpload(event)">
 <div id="uploaded-image-preview" style="display: none; margin-top: 12px;">
 <div id="preview-images-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 8px;"></div>
 </div>
 </div>

 <div style="display: flex; gap: 8px; margin-top: 12px;">
 <button onclick="saveImageData()" style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 8px; padding: 8px; font-size: 13px; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'"
 onmouseout="this.style.backgroundColor='var(--x-accent)'">
 保存图片
 </button>
 <button onclick="removeImage()" style="flex: 1; background-color: transparent; color: #f4212e; border: 1px solid #f4212e; border-radius: 8px; padding: 8px; font-size: 13px; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='rgba(244,33,46,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 移除图片
 </button>
 </div>
 </div>
 </div>

 <div id="compose-location-section" style="display: none; margin-bottom: 16px;">
 <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 12px; padding: 16px;">
 <div style="color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 12px;">添加位置</div>
 <input type="text" id="location-input" placeholder="输入位置信息..." style="width: 100%; background-color:#000; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; outline: none; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
 <div style="display: flex; gap: 8px; margin-top: 12px;">
 <button onclick="saveLocationData()" style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 8px; padding: 8px; font-size: 13px; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'"
 onmouseout="this.style.backgroundColor='var(--x-accent)'">
 保存位置
 </button>
 <button onclick="removeLocation()" style="flex: 1; background-color: transparent; color: #f4212e; border: 1px solid #f4212e; border-radius: 8px; padding: 8px; font-size: 13px; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='rgba(244,33,46,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 移除位置
 </button>
 </div>
 </div>
 </div>

 <div id="compose-link-section" style="display: none; margin-bottom: 16px;">
 <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 12px; padding: 16px;">
 <div style="color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 12px;">附带链接</div>

 <input type="text" id="link-title-input" placeholder="链接标题..." style="width: 100%; background-color:#000; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; outline: none; box-sizing: border-box; margin-bottom: 12px; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">

 <input type="text" id="link-url-input" placeholder="example.com" style="width: 100%; background-color:#000; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; outline: none; box-sizing: border-box; margin-bottom: 12px; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">

 <textarea id="link-description-input" placeholder="简述链接内容..." style="width: 100%; min-height: 60px; background-color:#000; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; resize: vertical; outline: none; font-family: inherit; box-sizing: border-box; margin-bottom: 12px; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>

 <div style="margin-bottom: 12px;">
 <label
 style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 8px;">链接首图（可选）</label>
 <div style="border: 2px dashed #333; border-radius: 8px; padding: 16px; text-align: center; cursor: pointer; transition: all 0.2s; " onclick="triggerLinkImageUpload()" onmouseover="this.style.borderColor='var(--x-accent)'"
 onmouseout="this.style.borderColor='#333'">
 <svg viewBox="0 0 24 24" style="width: 24px; height: 24px; fill: #71767b; margin-bottom: 4px;">
 <g>
 <path
 d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z">
 </path>
 </g>
 </svg>
 <div style="color: #71767b; font-size: 13px;">点击上传链接首图</div>
 </div>
 <input type="file" id="link-image-input" accept="image/*" style="display: none;"
 onchange="handleLinkImageUpload(event)">
 <div id="link-image-preview" style="display: none; margin-top: 8px;">
 <img id="link-preview-image"
 style="width: 100%; max-height: 120px; object-fit: cover; border-radius: 8px;" alt="链接首图预览">
 </div>
 </div>
 <div style="display: flex; gap: 8px;">
 <button onclick="saveLinkData()" style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 8px; padding: 8px; font-size: 13px; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'"
 onmouseout="this.style.backgroundColor='var(--x-accent)'">
 保存链接
 </button>
 <button onclick="removeLink()" style="flex: 1; background-color: transparent; color: #f4212e; border: 1px solid #f4212e; border-radius: 8px; padding: 8px; font-size: 13px; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='rgba(244,33,46,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 移除链接
 </button>
 </div>
 </div>
 </div>

 <div
 style="display: flex; align-items: center; justify-content: space-between; border-top: 1px solid #2f3336; padding-top: 16px;">

 <div style="display: flex; gap: 16px;">

 <div id="image-btn" onclick="toggleImageSection()" style="padding: 8px; border-radius: 50%; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
 <g>
 <path
 d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z">
 </path>
 </g>
 </svg>
 </div>

 <div id="location-btn" onclick="toggleLocationSection()" style="padding: 8px; border-radius: 50%; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
 <g>
 <path
 d="M12 7c-1.93 0-3.5 1.57-3.5 3.5S10.07 14 12 14s3.5-1.57 3.5-3.5S13.93 7 12 7zm0 5c-.827 0-1.5-.673-1.5-1.5S11.173 9 12 9s1.5.673 1.5 1.5S12.827 12 12 12zm0-10c-4.687 0-8.5 3.813-8.5 8.5 0 5.967 7.621 11.116 7.945 11.332l.555.37.555-.37C12.879 21.616 20.5 16.467 20.5 10.5 20.5 5.813 16.687 2 12 2zm0 17.77c-1.665-1.241-6.5-5.196-6.5-9.27C5.5 6.916 8.416 4 12 4s6.5 2.916 6.5 6.5c0 4.073-4.835 8.028-6.5 9.27z">
 </path>
 </g>
 </svg>
 </div>

 <div id="attach-btn" onclick="toggleLinkSection()" style="padding: 8px; border-radius: 50%; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
 <g>
 <path
 d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z">
 </path>
 </g>
 </svg>
 </div>
 </div>

 <div id="privacy-setting-btn" onclick="togglePrivacySettings()" style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; border-radius: 20px; cursor: pointer; border: 1px solid #536471; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg id="privacy-icon" viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);">
 <g>
 <path id="privacy-icon-path"
 d="M12 1.75C6.34 1.75 1.75 6.34 1.75 12S6.34 22.25 12 22.25 22.25 17.66 22.25 12 17.66 1.75 12 1.75zm-.81 14.68l-4.1-3.27 1.25-1.57 2.47 1.98 3.97-5.47 1.62 1.18-5.21 7.15z">
 </path>
 </g>
 </svg>
 <span id="privacy-text" style="color: var(--x-accent); font-size: 13px; font-weight: 600;">所有人可以回复</span>
 </div>
 </div>
 </div>
 </div>
 </div>
 </div>
 </div>
</div>

<div id="character-relationship-graph-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); z-index: 25; overflow-y: auto; backdrop-filter: blur(8px);
" onclick="closeCharacterRelationshipGraph(event)">
 <div style="background-color:#000; margin: 20px auto; border-radius: 16px; max-width: min(900px, calc(100vw - 20px)); width: calc(100% - 40px); max-height: calc(100vh - 40px); position: relative; overflow: hidden; border: 1px solid #333; " onclick="event.stopPropagation()">

 <div style="display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid #333; background-color:#000; ">
 <div style="display: flex; align-items: center; gap: 12px;">
 <h2 style="color: #fff; font-size: 20px; font-weight: 700; margin: 0;">角色关系图编辑器</h2>
 <div style="color: #71767b; font-size: 13px; display: flex; align-items: center; gap: 8px;">
 <span id="graph-character-count">0 角色</span>
 <span>·</span>
 <span id="graph-link-count">0 关系</span>
 </div>
 </div>
 <div onclick="closeCharacterRelationshipGraph()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>
 </div>

 <div style="display: flex; align-items: center; gap: 12px; padding: 12px 20px; border-bottom: 1px solid #333; background-color: #0a0a0a; ">
 <button onclick="addRelationshipLink()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 6px; " onmouseover="this.style.backgroundColor='#1a8cd8'"
 onmouseout="this.style.backgroundColor='var(--x-accent)'">
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;">
 <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
 </svg>
 添加关系
 </button>
 <button onclick="clearAllRelationships()" style="background-color: transparent; color: #f4212e; border: 1px solid #f4212e; border-radius: 20px; padding: 8px 16px; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 6px; " onmouseover="this.style.backgroundColor='rgba(244,33,46,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;">
 <path d="M5 20a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V8h2V6h-4V4a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v2H3v2h2zM9 4h6v2H9zM8 8h9v12H7V8z"/>
 </svg>
 清空所有
 </button>
 <div style="margin-left: auto; color: #71767b; font-size: 12px;">
 点击角色头像连线，点击连线编辑关系
 </div>
 </div>

 <div style="height: min(500px, 60vh); background-color:#000; position: relative; overflow: hidden; ">
 <canvas id="relationship-graph-canvas" style="width: 100%; height: 100%; display: block; cursor: grab; "></canvas>

 <div id="graph-empty-state" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #71767b; pointer-events: none; ">
 <svg viewBox="0 0 24 24" style="width: 64px; height: 64px; fill: #2f3336; margin-bottom: 12px;">
 <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
 </svg>
 <div style="font-size: 15px; margin-bottom: 4px;">暂无角色关系</div>
 <div style="font-size: 13px; opacity: 0.7;">请先绑定角色，然后点击"添加关系"</div>
 </div>
 </div>

 <div style="max-height: 200px; overflow-y: auto; background-color: #0a0a0a; border-top: 1px solid #333; ">
 <div style="padding: 12px 20px; border-bottom: 1px solid #333;">
 <div style="color: #fff; font-size: 15px; font-weight: 600;">关系列表</div>
 </div>
 <div id="relationship-links-list" style="padding: 12px 20px;">

 </div>
 </div>

 <div style="display: flex; gap: 12px; padding: 16px 20px; border-top: 1px solid #333; background-color:#000; ">
 <button onclick="closeCharacterRelationshipGraph()" style="flex: 1; background-color: transparent; color: #fff; border: 1px solid #536471; border-radius: 20px; padding: 12px; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 取消
 </button>
 <button onclick="saveRelationshipGraph()" style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 12px; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'"
 onmouseout="this.style.backgroundColor='var(--x-accent)'">
 保存关系图
 </button>
 </div>
 </div>
</div>

<div id="edit-relationship-detail-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 30; backdrop-filter: blur(4px);
" onclick="closeEditRelationshipDetail(event)">
 <div style="background-color:#000; margin: 60px auto; border-radius: 16px; max-width: min(500px, calc(100vw - 20px)); width: calc(100% - 40px); border: 1px solid #333; " onclick="event.stopPropagation()">

 <div style="display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid #333; ">
 <h3 style="color: #fff; font-size: 18px; font-weight: 700; margin: 0;">编辑关系</h3>
 <div onclick="closeEditRelationshipDetail()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #fff;">
 <path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"/>
 </svg>
 </div>
 </div>

 <div style="padding: 20px;">

 <div id="relationship-characters-info" style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; margin-bottom: 20px; ">
 <div style="flex: 1; text-align: center;">
 <div id="char-a-name" style="color: #fff; font-size: 14px; font-weight: 600;"></div>
 </div>
 <div style="color: #71767b; font-size: 20px; margin: 0 12px;">⇆</div>
 <div style="flex: 1; text-align: center;">
 <div id="char-b-name" style="color: #fff; font-size: 14px; font-weight: 600;"></div>
 </div>
 </div>

 <div style="margin-bottom: 20px;">
 <label style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">
 <span id="char-a-to-b-label"></span>
 </label>
 <input type="text" id="relationship-a-to-b" placeholder="例如：好朋友、同事、哥哥等" style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; outline: none; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
 </div>

 <div style="margin-bottom: 20px;">
 <label style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">
 <span id="char-b-to-a-label"></span>
 </label>
 <input type="text" id="relationship-b-to-a" placeholder="例如：好朋友、同事、妹妹等" style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; outline: none; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
 </div>

 <div style="margin-bottom: 24px;">
 <label style="display: block; color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 8px;">
 关系情节 (可选)
 </label>
 <textarea id="relationship-story" placeholder="补充背景故事、相识经历等..." style="width: 100%; min-height: 80px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 14px; outline: none; box-sizing: border-box; resize: vertical; font-family: inherit; line-height: 1.4; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>
 <div style="color: #71767b; font-size: 12px; margin-top: 4px;">
 例如：如何相识、共同经历、特殊事件等
 </div>
 </div>

 <div style="display: flex; gap: 12px;">
 <button onclick="deleteRelationshipLink()" style="flex: 1; background-color: transparent; color: #f4212e; border: 1px solid #f4212e; border-radius: 20px; padding: 10px; font-size: 14px; font-weight: 700; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='rgba(244,33,46,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 删除关系
 </button>
 <button onclick="saveRelationshipDetail()" style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 10px; font-size: 14px; font-weight: 700; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'"
 onmouseout="this.style.backgroundColor='var(--x-accent)'">
 保存
 </button>
 </div>
 </div>
 </div>
</div>

<div id="npc-edit-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(91, 112, 131, 0.4); z-index: 20; overflow-y: auto;
" onclick="closeNPCEditModal(event)">
 <div style="background-color:#000; margin: 40px auto; border-radius: 16px; max-width: 600px; width: calc(100% - 40px); max-height: calc(100vh - 80px); position: relative; overflow: hidden; " onclick="event.stopPropagation()">

 <div style="display: flex; align-items: center; justify-content: space-between; padding: 16px; border-bottom: 1px solid #2f3336; ">
 <div style="display: flex; align-items: center; gap: 24px;">
 <div onclick="closeNPCEditModal()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>
 <h2 style="color: #fff; font-size: 20px; font-weight: 700; margin: 0;" id="npc-modal-title">编辑NPC</h2>
 </div>
 </div>

 <div style="padding: 20px; overflow-y: auto; max-height: calc(100vh - 200px);">

 <div style="margin-bottom: 20px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 8px;">NPC姓名</label>
 <input type="text" id="npc-name" placeholder="输入NPC姓名" style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; outline: none; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'" maxlength="50">
 </div>

 <div style="margin-bottom: 20px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 8px;">NPC句柄</label>
 <input type="text" id="npc-handle" placeholder="@句柄" style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; outline: none; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'" maxlength="30">
 </div>

 <div style="margin-bottom: 20px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 8px;">NPC头像URL</label>
 <input type="text" id="npc-avatar" placeholder="输入头像URL" style="width: 100%; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; outline: none; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'">
 </div>

 <div style="margin-bottom: 20px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 8px;">NPC人设</label>
 <textarea id="npc-personality" placeholder="描述NPC的性格、背景、行为特征..." style="width: 100%; min-height: 120px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; resize: vertical; outline: none; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>
 </div>

 <div style="margin-bottom: 20px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 8px;">发帖习惯</label>
 <textarea id="npc-posting-habits" placeholder="描述NPC的发帖风格、频率、内容偏好..." style="width: 100%; min-height: 100px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; resize: vertical; outline: none; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>
 </div>

 <div style="margin-bottom: 20px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 8px;">主页内容设置</label>
 <textarea id="npc-homepage" placeholder="描述NPC主页的展示内容、简介等..." style="width: 100%; min-height: 80px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #fff; padding: 12px; font-size: 15px; resize: vertical; outline: none; box-sizing: border-box; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='#333'"></textarea>
 </div>

 <div style="margin-bottom: 20px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 8px;">绑定用户（可多选）</label>
 <div id="npc-bind-users" style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 12px; max-height: 200px; overflow-y: auto; ">

 </div>
 </div>

 <button onclick="saveNPC()" style="width: 100%; background-color: var(--x-accent); color: #fff; border: none; border-radius: 25px; padding: 14px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'">
 保存NPC
 </button>
 </div>
 </div>
</div>

<div id="x-askbox-page" class="x-page" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; display: none; flex-direction: column; overflow: hidden; z-index: 15;">

 <div id="askbox-background" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: url('https://i.postimg.cc/7LqVqxt4/mmexport1759588659314.jpg'); background-size: cover; background-position: center; z-index: 0; "></div>

 <div style="position: relative; z-index: 1; width: 100%; height: 100%; display: flex; flex-direction: column; overflow-y: auto; padding-top: 20px;">

 <div style="display: flex; justify-content: space-between; align-items: center; padding: 20px 16px 12px 16px;">

 <div onclick="switchXPage('profile')" style="cursor: pointer; padding: 8px; border-radius: 50%; background-color: rgba(255,255,255,0.2); backdrop-filter: blur(10px); transition: all 0.2s;"
 onmouseover="this.style.backgroundColor='rgba(255,255,255,0.3)'"
 onmouseout="this.style.backgroundColor='rgba(255,255,255,0.2)'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
 <path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"/>
 </svg>
 </div>

 <div onclick="openAskboxSettings()" style="cursor: pointer; padding: 8px; border-radius: 50%; background-color: rgba(255,255,255,0.2); backdrop-filter: blur(10px); transition: all 0.2s;"
 onmouseover="this.style.backgroundColor='rgba(255,255,255,0.3)'"
 onmouseout="this.style.backgroundColor='rgba(255,255,255,0.2)'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
 <path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/>
 </svg>
 </div>
 </div>

 <div style="display: flex; flex-direction: column; align-items: center; padding: 20px 16px;">

 <div onclick="changeAskboxAvatar()" style="cursor: pointer; margin-bottom: 12px; position: relative; transition: transform 0.2s;"
 onmouseover="this.style.transform='scale(1.05)'"
 onmouseout="this.style.transform='scale(1)'">
 <img id="askbox-avatar" src="https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg"
 style="width: 80px; height: 80px; border-radius: 50%; border: 3px solid rgba(255,255,255,0.8); box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
 </div>

 <div style="display: flex; align-items: center; gap: 8px; background-color: rgba(255,255,255,0.15); backdrop-filter: blur(10px); padding: 6px 12px; border-radius: 20px;">
 <span id="askbox-nickname"
 contenteditable="true"
 style="color: #fff; font-size: 14px; font-weight: 500; outline: none; cursor: text; min-width: 20px;"
 onblur="saveAskboxNickname()"
 onkeydown="if(event.key==='Enter'){event.preventDefault();this.blur();}">= =</span>
 </div>
 </div>

 <div style="margin: 0 20px 24px 20px; background-color: rgba(255,255,255,0.9); backdrop-filter: blur(10px); border-radius: 16px; padding: 32px 24px; box-shadow: 0 4px 16px rgba(0,0,0,0.1); transition: all 0.2s; min-height: 120px; display: flex; align-items: center; justify-content: center; ">
 <div id="askbox-prompt"
 contenteditable="true"
 style="color: #333; font-size: 16px; line-height: 1.6; text-align: center; word-break: break-word; outline: none; cursor: text; width: 100%; "
 onblur="saveAskboxPrompt()"
 onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();this.blur();}">请向我匿名提问!waiting...</div>
 </div>

 <div onclick="getNewQuestion()" style="margin: 0 20px 32px 20px; background-color: rgba(255,255,255,0.85); backdrop-filter: blur(10px); border-radius: 24px; padding: 14px 24px; text-align: center; cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 8px rgba(0,0,0,0.1); " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.95)'; this.style.transform='translateY(-1px)'"
 onmouseout="this.style.backgroundColor='rgba(255,255,255,0.85)'; this.style.transform='translateY(0)'">
 <span style="color: #333; font-size: 15px; font-weight: 600;">获取新的提问</span>
 </div>

 <div style="padding: 0 20px 20px 20px;">
 <div id="answered-questions-title" style="color: rgba(255,255,255,0.8); font-size: 15px; font-weight: 500; margin-bottom: 16px; text-align: center; display: none; ">最新提问如下</div>
 <div id="answered-questions-list">

 </div>
 </div>
 </div>
</div>

<!-- 直播页面 -->
<div id="x-live-page" class="x-page" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; display: none; flex-direction: column; overflow: hidden; z-index: 21; background-color:#0f0f0f;">

<!-- 顶部导航栏 -->
<div style="display: flex; justify-content: space-between; align-items: center; padding: 55px 16px 12px 16px; position: sticky; top: 0; background-color:#0f0f0f; z-index: 10;">
  <div style="display: flex; align-items: center; gap: 16px;">
    <div onclick="switchXPage('home')" style="cursor: pointer;">
      <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
        <path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"/>
      </svg>
    </div>
    
    <div style="color: #fff; font-size: 20px; font-weight: 700;" data-i18n="liveTitle">直播</div>
  </div>
  
  <div style="display: flex; align-items: center; gap: 16px;">
    <div style="cursor: pointer;">
      <svg viewBox="0 0 24 24" style="width: 22px; height: 22px; fill: #fff;">
        <path d="M10.25 3.75c-3.59 0-6.5 2.91-6.5 6.5s2.91 6.5 6.5 6.5c1.795 0 3.419-.726 4.596-1.904 1.178-1.177 1.904-2.801 1.904-4.596 0-3.59-2.91-6.5-6.5-6.5zm-8.5 6.5c0-4.694 3.806-8.5 8.5-8.5s8.5 3.806 8.5 8.5c0 1.986-.682 3.815-1.824 5.262l4.781 4.781-1.414 1.414-4.781-4.781c-1.447 1.142-3.276 1.824-5.262 1.824-4.694 0-8.5-3.806-8.5-8.5z"></path>
      </svg>
    </div>
    <div style="width: 32px; height: 32px; border-radius: 50%; overflow: hidden;">
      <img id="live-page-user-avatar" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg" style="width: 100%; height: 100%; object-fit: cover;">
    </div>
  </div>
</div>

<!-- 用户频道栏 -->
<div style="overflow-x: auto; padding: 8px 16px; display: flex; gap: 16px; background-color:#0f0f0f;">
  <div style="display: flex; flex-direction: column; align-items: center; gap: 6px; min-width: 64px;">
    <div style="width: 56px; height: 56px; border-radius: 50%; overflow: hidden; position: relative;">
      <img src="https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg" style="width: 100%; height: 100%; object-fit: cover;">
      <div style="position: absolute; top: 0; right: 0; width: 18px; height: 18px; background-color: var(--x-accent); border-radius: 50%; display: flex; justify-content: center; align-items: center; border: 2px solid #0f0f0f;">
        <span style="color: white; font-size: 10px; font-weight: bold;">+</span>
      </div>
    </div>
    <span style="color: #fff; font-size: 12px; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; max-width: 60px;">直播达人</span>
  </div>
</div>

<!-- 分类标签栏 -->
<div style="overflow-x: auto; white-space: nowrap; padding: 4px 16px; background-color:#0f0f0f;">
  <div id="live-categories-container" style="display: inline-flex; gap: 8px; padding-bottom: 4px;">
    <div class="live-tab live-tab-active" onclick="switchLiveTab('audio')" 
      style="padding: 8px 12px; background-color: rgba(255,255,255,0.1); border-radius: 16px; font-size: 14px; font-weight: 500; cursor: pointer; color: #fff;">
      <span data-i18n="liveAudioTab">语音直播</span>
    </div>
    <div class="live-tab" onclick="switchLiveTab('video')" 
      style="padding: 8px 12px; background-color: rgba(255,255,255,0.1); border-radius: 16px; font-size: 14px; font-weight: 500; cursor: pointer; color: #71767b;">
      <span data-i18n="liveVideoTab">视频直播</span>
    </div>
    <!-- 自定义分类将动态插入到这里 -->
    <div class="live-add-category-btn" onclick="openLiveCategoryModal()" 
      style="padding: 8px 10px; background-color: rgba(255,255,255,0.1); border-radius: 16px; font-size: 14px; font-weight: 500; cursor: pointer; color: #71767b; display: flex; align-items: center; min-width: 36px; justify-content: center;"
      onmouseover="this.style.backgroundColor='rgba(255,255,255,0.2)'"
      onmouseout="this.style.backgroundColor='rgba(255,255,255,0.1)'">
      <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;">
        <path d="M19.5 12.75h-6.75V19.5h-1.5v-6.75H4.5v-1.5h6.75V4.5h1.5v6.75h6.75v1.5z"></path>
      </svg>
    </div>
  </div>
</div>

<!-- 直播列表内容区域 -->
<div style="flex: 1; overflow-y: auto; padding: 0; background-color:#0f0f0f; position: relative;">
  <!-- 语音直播内容 -->
  <div id="live-audio-content" class="live-tab-content" style="display: block; padding: 16px 16px 80px 16px;">
    <div id="live-audio-list" style="display: flex; flex-direction: column; gap: 16px;">
      <!-- 动态生成的语音直播卡片将插入到这里 -->
    </div>
  </div>
  
  <!-- 视频直播内容 -->
  <div id="live-video-content" class="live-tab-content" style="display: none; padding: 16px 16px 80px 16px;">
    <div id="live-video-list" style="display: flex; flex-direction: column; gap: 16px;">
      <!-- 动态生成的视频直播卡片将插入到这里 -->
    </div>
  </div>
  
  <!-- 直播收纳按钮区域 -->
  <div id="live-action-container" style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 15; display: flex; align-items: center; justify-content: center; pointer-events: none;">
        <!-- 刷新直播按钮 (左侧) -->
    <div id="live-refresh-btn" class="live-action-btn" onclick="refreshLiveStreams()" 
      style="position: absolute; right: 80px; top: 4px; width: 48px; height: 48px; border-radius: 50%; background-color: var(--x-accent); display: flex; justify-content: center; align-items: center; cursor: pointer; transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); transform: scale(0); opacity: 0; box-shadow: 0 4px 12px rgba(0,0,0,0.3); pointer-events: auto;"
      onmouseover="handleLiveSubBtnMouseOver(this)"
      onmouseout="handleLiveSubBtnMouseOut(this)"
      ontouchstart="handleLiveSubBtnTouchStart(this)"
      ontouchend="handleLiveSubBtnTouchEnd(this)">
      <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: none; stroke: #fff; stroke-width: 1.5; stroke-linecap: round; stroke-linejoin: round;">
        <path d="M10.09 4.01l.496 -.495a2 2 0 0 1 2.828 0l7.071 7.07a2 2 0 0 1 0 2.83l-7.07 7.07a2 2 0 0 1 -2.83 0l-7.07 -7.07a2 2 0 0 1 0 -2.83l3.535 -3.535h-3.988" />
        <path d="M7.05 11.038v-3.988" />
      </svg>
    </div>
    
    <!-- 主收纳按钮 (中央) -->
    <div id="live-main-btn" class="live-action-btn" onclick="toggleLiveActionButtons()" 
      style="width: 56px; height: 56px; border-radius: 50%; background-color: var(--x-accent); display: flex; justify-content: center; align-items: center; cursor: pointer; transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); box-shadow: 0 6px 20px rgba(0,0,0,0.4); position: relative; z-index: 16; pointer-events: auto;"
      onmouseover="handleLiveMainBtnMouseOver()"
      onmouseout="handleLiveMainBtnMouseOut()"
      ontouchstart="handleLiveMainBtnTouchStart()"
      ontouchend="handleLiveMainBtnTouchEnd()">
      <svg id="live-main-icon" viewBox="0 0 24 24" style="width: 24px; height: 24px; fill: none; stroke: #fff; stroke-width: 1.5; stroke-linecap: round; stroke-linejoin: round; transition: transform 0.3s ease;">
        <path d="M17.891 10.132a1.2 1.2 0 0 0 -.309 -2.228l-13.582 -3.904l3.904 13.563a1.2 1.2 0 0 0 2.228 .308" />
        <path d="M17.8 20.817l-2.172 1.138a.392 .392 0 0 1 -.568 -.41l.415 -2.411l-1.757 -1.707a.389 .389 0 0 1 .217 -.665l2.428 -.352l1.086 -2.193a.392 .392 0 0 1 .702 0l1.086 2.193l2.428 .352a.39 .39 0 0 1 .217 .665l-1.757 1.707l.414 2.41a.39 .39 0 0 1 -.567 .411l-2.172 -1.138z" />
      </svg>
    </div>
    
    <!-- 开启直播按钮 (右侧) -->
    <div id="live-start-btn" class="live-action-btn" onclick="startLiveStream()" 
      style="position: absolute; left: 80px; top: 4px; width: 48px; height: 48px; border-radius: 50%; background-color: var(--x-accent); display: flex; justify-content: center; align-items: center; cursor: pointer; transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); transform: scale(0); opacity: 0; box-shadow: 0 4px 12px rgba(0,0,0,0.3); pointer-events: auto;"
      onmouseover="handleLiveSubBtnMouseOver(this)"
      onmouseout="handleLiveSubBtnMouseOut(this)"
      ontouchstart="handleLiveSubBtnTouchStart(this)"
      ontouchend="handleLiveSubBtnTouchEnd(this)">
      <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: none; stroke: #fff; stroke-width: 1.5; stroke-linecap: round; stroke-linejoin: round;">
        <path d="M7 4v16l13 -8z" />
      </svg>
    </div>
  </div>
</div>

</div>

<!-- 直播分类管理模态框 -->
<div id="live-category-manager-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 30; overflow-y: auto; backdrop-filter: blur(8px);" onclick="closeLiveCategoryModal(event)">
  <div style="background-color:#0f0f0f; margin: 40px auto; border-radius: 16px; max-width: 600px; width: calc(100% - 40px); border: 1px solid #333;" onclick="event.stopPropagation()">
    
    <div style="display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid #333;">
      <h2 style="color: #fff; font-size: 20px; font-weight: 700; margin: 0;">管理直播分类</h2>
      <div onclick="closeLiveCategoryModal()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s;" 
        onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
        onmouseout="this.style.backgroundColor='transparent'">
        <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
          <path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path>
        </svg>
      </div>
    </div>
    
    <div style="padding: 20px; max-height: calc(100vh - 200px); overflow-y: auto;">
      
      <div style="background-color: rgba(29,155,240,0.1); border: 1px solid var(--x-accent); border-radius: 8px; padding: 12px; margin-bottom: 20px;">
        <p style="color: var(--x-accent); font-size: 13px; line-height: 1.4; margin: 0;">
          💡 自定义直播分类将显示在标签栏中。可以添加任意分类（如"游戏"、"音乐"、"教育"等），并描述该分类下的内容类型。
        </p>
      </div>
      
      <div style="margin-bottom: 20px;">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
          <h3 style="color: #fff; font-size: 16px; font-weight: 600; margin: 0;">自定义分类</h3>
          <button onclick="addNewLiveCategory()" 
            style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 6px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s;" 
            onmouseover="this.style.opacity='0.9'"
            onmouseout="this.style.opacity='1'">
            + 添加分类
          </button>
        </div>
        
        <div id="live-custom-categories-list" style="display: flex; flex-direction: column; gap: 12px;">
          <!-- 动态生成的分类列表 -->
        </div>
      </div>
      
      <button onclick="saveLiveCustomCategories()" 
        style="width: 100%; background-color: var(--x-accent); color: #fff; border: none; border-radius: 25px; padding: 14px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.2s;" 
        onmouseover="this.style.opacity='0.9'"
        onmouseout="this.style.opacity='1'">
        保存设置
      </button>
    </div>
  </div>
</div>

<div id="x-article-page" class="x-page" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; display: none; flex-direction: column; overflow: hidden; z-index: 21; background-color:var(--x-bg-primary);">
 <style>
 @import url("https://fontsapi.zeoseven.com/256/main/result.css"); @import url("data:text/css,%40font-face%7Bfont-family%3A%22ZSFT-685%22%3Bsrc%3Aurl(%22https%3A%2F%2Ffontsapi.zeoseven.com%2F685%2Fmain.woff2%22)%20format(%22woff2%22)%2Curl(%22https%3A%2F%2Ffontsapi-storage.zeoseven.com%2F685%2Fmain.woff2%22)%20format(%22woff2%22)%3Bfont-style%3Anormal%3Bfont-weight%3A400%3Bfont-display%3Aswap%3B%7D"); .article-title {
 font-family: "Huiwen-mincho", serif; }
 .article-title-en {
 font-family: "ZSFT-685", serif; }
 .article-content {
 line-height: 1.8; word-break: break-word; }
 .article-content strong {
 font-weight: 600; color: var(--x-accent); word-break: break-word; }
 .article-content em {
 font-style: italic; border-bottom: 2px solid var(--x-accent); padding-bottom: 2px; word-break: break-word; }
 @media (max-width: 600px) {
 .article-title {
 font-size: 22px !important; }
 .article-content {
 font-size: 14px !important; }
 }
 </style>

 <div style="position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; overflow-y: auto;">

 <div style="display: flex; justify-content: space-between; align-items: center; padding: 40px 16px 12px 16px; position: sticky; top: 0; background-color:var(--x-bg-primary); z-index: 10; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">

 <div onclick="closeArticlePage()" style="cursor: pointer; padding: 8px; border-radius: 50%; background-color:var(--x-bg-secondary); transition: all 0.2s;"
 onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"/>
 </svg>
 </div>

 <div onclick="shareArticle()" style="cursor: pointer; padding: 8px; border-radius: 50%; background-color:var(--x-bg-secondary); transition: all 0.2s;"
 onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M17.53 7.47l-5-5c-.293-.293-.768-.293-1.06 0l-5 5c-.294.293-.294.768 0 1.06s.767.294 1.06 0l3.72-3.72V15c0 .414.336.75.75.75s.75-.336.75-.75V4.81l3.72 3.72c.146.147.338.22.53.22s.384-.072.53-.22c.293-.293.293-.767 0-1.06z"></path><path d="M19.708 21.944H4.292C3.028 21.944 2 20.916 2 19.652V14c0-.414.336-.75.75-.75s.75.336.75.75v5.652c0 .437.355.792.792.792h15.416c.437 0 .792-.355.792-.792V14c0-.414.336-.75.75-.75s.75.336.75.75v5.652c0 1.264-1.028 2.292-2.292 2.292z"></path></g>
 </svg>
 </div>
 </div>

 <div id="article-cover" style="width: 100%; height: 35vh; min-height: 250px; max-height: 400px; background-size: cover; background-position: center; background-repeat: no-repeat; margin-bottom: 20px; "></div>

 <div style="padding: 0 16px 40px 16px; max-width: 800px; margin: 0 auto; width: 100%; box-sizing: border-box;">

 <h1 id="article-title" class="article-title" style="font-size: 24px; font-weight: 700; color:var(--x-text-primary); margin-bottom: 16px; line-height: 1.3; word-wrap: break-word; "></h1>

 <div style="display: flex; align-items: center; gap: 8px; padding-bottom: 12px; margin-bottom: 20px; border-bottom: 1px solid var(--x-border-color); flex-wrap: wrap; ">
 <span id="article-author" style="color:var(--x-text-secondary); font-size: 13px; "></span>
 <span style="color:var(--x-text-secondary);">·</span>
 <span id="article-source" style="color:var(--x-text-secondary); font-size: 13px; word-break: break-all; "></span>
 </div>

 <div id="article-body" class="article-content" style="color:var(--x-text-primary); font-size: 15px; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; "></div>
 </div>
 </div>
</div>

<div id="account-profile-page" class="x-page" style="display: none; flex-direction: column; height: 100%; overflow: hidden;">

 <div style="display: flex; align-items: center; justify-content: space-between; padding: 10px 15px; border-bottom: 1px solid var(--x-border-color); background-color:var(--x-bg-primary); backdrop-filter: blur(12px); position: sticky; top: 0; z-index: 10;">
 <div style="display: flex; align-items: center;">
 <div onclick="closeAccountProfile()" style="cursor: pointer; padding: 8px; margin-right: 30px; border-radius: 50%; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'" onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path></g>
 </svg>
 </div>
 <div>
 <div id="account-profile-nav-name" style="color:var(--x-text-primary); font-size: 20px; font-weight: 700; line-height: 1.2;"></div>
 <div id="account-profile-nav-count" style="color:var(--x-text-secondary); font-size: 13px; margin-top: 2px;">0 个帖子</div>
 </div>
 </div>

 <div style="display: flex; align-items: center; gap: 8px;">

 <div onclick="openAccountAskbox()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'" onmouseout="this.style.backgroundColor='transparent'" title="提问箱">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/>
 </svg>
 </div>

 <div onclick="refreshAccountProfile()" onmousedown="handleRefreshButtonMouseDown()" onmouseup="handleRefreshButtonMouseUp()" ontouchstart="handleRefreshButtonMouseDown()" ontouchend="handleRefreshButtonMouseUp()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'" onmouseout="this.style.backgroundColor='transparent'" title="刷新账户主页">
 <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="var(--x-text-primary)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
 <path d="M9 4.55a8 8 0 0 1 6 14.9m0 -4.45v5h5" />
 <path d="M5.63 7.16l0 .01" />
 <path d="M4.06 11l0 .01" />
 <path d="M4.63 15.1l0 .01" />
 <path d="M7.16 18.37l0 .01" />
 <path d="M11 19.94l0 .01" />
 </svg>
 </div>
 </div>
 </div>

 <div style="flex: 1; overflow-y: auto;">

 <div id="account-cover-image" style="width: 100%; height: 140px; background-color:var(--x-bg-secondary); background-size: cover; background-position: center; position: relative;"></div>

 <div style="padding: 8px 16px 0 16px;">

 <div style="display: flex; justify-content: space-between; align-items: flex-start; position: relative; margin-bottom: 12px;">

 <img id="account-avatar-image" src="" alt="账户头像" style="width: 68px; height: 68px; border-radius: 50%; border: 4px solid var(--x-bg-primary); background-color:var(--x-bg-primary); position: absolute; top: -34px; left: 0; object-fit: cover; overflow: hidden; box-sizing: border-box;">

 <div style="display: flex; gap: 8px; margin-left: auto; margin-top: 8px;">

 <button onclick="sendMessageToAccount()" style="width: 36px; height: 36px; border-radius: 50%; border: 1px solid var(--x-border-color); background: transparent; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'" onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-primary);">
 <g><path d="M1.998 5.5c0-1.381 1.119-2.5 2.5-2.5h15c1.381 0 2.5 1.119 2.5 2.5v13c0 1.381-1.119 2.5-2.5 2.5h-15c-1.381 0-2.5-1.119-2.5-2.5v-13zm2.5-.5c-.276 0-.5.224-.5.5v2.764l8 3.638 8-3.636V5.5c0-.276-.224-.5-.5-.5h-15zm15.5 5.463l-8 3.636-8-3.638V18.5c0 .276.224.5.5.5h15c.276 0 .5-.224.5-.5v-8.037z"></path></g>
 </svg>
 </button>

 <button id="account-notify-btn" onclick="toggleAccountNotifications()" style="width: 36px; height: 36px; border-radius: 50%; border: 1px solid var(--x-border-color); background: transparent; display: none; align-items: center; justify-content: center; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(239,243,244,0.1)'" onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-primary);">
 <g><path d="M19.993 9.042C19.48 5.017 16.054 2 11.996 2s-7.49 3.021-7.999 7.051L2.866 18H7.1c.463 2.282 2.481 4 4.9 4s4.437-1.718 4.9-4h4.236l-1.143-8.958zM12 20c-1.306 0-2.417-.835-2.829-2h5.658c-.412 1.165-1.523 2-2.829 2zm-6.866-4l.847-6.698C6.364 6.272 8.941 4 11.996 4s5.627 2.268 6.013 5.295L18.864 16H5.134z"></path></g>
 </svg>
 </button>

 <button id="account-follow-btn" onclick="toggleAccountFollow()" style="min-width: 110px; height: 36px; border-radius: 18px; border: none; background: var(--x-text-primary); color: var(--x-bg-primary); font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; padding: 0 16px; " onmouseover="if(this.textContent.includes('关注')||this.textContent.includes('Follow')){this.style.opacity='0.9';}" onmouseout="this.style.opacity='1';">
 关注
 </button>
 </div>
 </div>

 <div style="margin-bottom: 4px; margin-top: 8px; padding-left: 8px;">
 <div style="display: flex; align-items: center; gap: 4px;">
 <span id="account-display-name" style="color:var(--x-text-primary); font-size: 20px; font-weight: 800; line-height: 1.2;"></span>
 <div id="account-verified-badge" style="display: none;"></div>
 </div>
 </div>

 <div style="margin-bottom: 8px; padding-left: 8px;">
 <span id="account-handle-text" style="color:var(--x-text-secondary); font-size: 15px;"></span>
 </div>

 <div id="account-bio-text" style="color:var(--x-text-primary); font-size: 15px; line-height: 20px; margin-bottom: 8px; padding-left: 8px; display: none;"></div>

 <div id="account-tags-container" style="display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 12px; padding-left: 8px;"></div>

 <div style="display: flex; gap: 20px; margin-bottom: 16px; padding-left: 8px;">
 <div style="cursor: pointer;" onmouseover="this.querySelector('span').style.textDecoration='underline'" onmouseout="this.querySelector('span').style.textDecoration='none'">
 <span id="account-following-count" style="color:var(--x-text-primary); font-weight: 700; font-size: 14px;">0</span>
 <span style="color:var(--x-text-secondary); margin-left: 4px; font-size: 14px;" data-i18n="accountFollowingLabel">正在关注</span>
 </div>
 <div style="cursor: pointer;" onmouseover="this.querySelector('span').style.textDecoration='underline'" onmouseout="this.querySelector('span').style.textDecoration='none'">
 <span id="account-followers-count" style="color:var(--x-text-primary); font-weight: 700; font-size: 14px;">0</span>
 <span style="color:var(--x-text-secondary); margin-left: 4px; font-size: 14px;" data-i18n="accountFollowersLabel">关注者</span>
 </div>
 </div>

 <div id="account-follows-you" style="display: none; color:var(--x-text-secondary); font-size: 13px; margin-bottom: 16px; padding-left: 8px;" data-i18n="accountFollowsYou">
 关注你
 </div>
 </div>

 <div style="display: flex; border-bottom: 1px solid var(--x-border-color);">
 <div class="account-tab active" onclick="switchAccountTab('posts')" style="flex: 1; text-align: center; padding: 16px 0; font-size: 15px; font-weight: 700; color:var(--x-text-primary); cursor: pointer; position: relative; border-bottom: 4px solid var(--x-accent);">
 <span data-i18n="accountPostsTab">帖子</span>
 </div>
 <div class="account-tab" onclick="switchAccountTab('replies')" style="flex: 1; text-align: center; padding: 16px 0; font-size: 15px; font-weight: 500; color:var(--x-text-secondary); cursor: pointer; position: relative; border-bottom: 4px solid transparent;">
 <span data-i18n="accountRepliesTab">回复</span>
 </div>
 <div class="account-tab" onclick="switchAccountTab('likes')" style="flex: 1; text-align: center; padding: 16px 0; font-size: 15px; font-weight: 500; color:var(--x-text-secondary); cursor: pointer; position: relative; border-bottom: 4px solid transparent;">
 <span data-i18n="accountLikesTab">喜欢</span>
 </div>
 </div>

 <div id="account-tweets-container">

 </div>
 </div>
</div>

<div id="account-askbox-page" class="x-page" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; display: none; flex-direction: column; overflow: hidden; z-index: 15;">

 <div id="account-askbox-background" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: url('https://i.postimg.cc/tJvBC00j/mmexport1759642131681.jpg'); background-size: cover; background-position: center; z-index: 0; "></div>

 <div style="position: relative; z-index: 1; width: 100%; height: 100%; display: flex; flex-direction: column; overflow-y: auto; padding-top: 20px;">

 <div style="display: flex; justify-content: space-between; align-items: center; padding: 20px 16px 12px 16px;">

 <div onclick="closeAccountAskbox()" style="cursor: pointer; padding: 8px; border-radius: 50%; background-color: rgba(255,255,255,0.2); backdrop-filter: blur(10px); transition: all 0.2s;"
 onmouseover="this.style.backgroundColor='rgba(255,255,255,0.3)'"
 onmouseout="this.style.backgroundColor='rgba(255,255,255,0.2)'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
 <path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"/>
 </svg>
 </div>

 <div onclick="openAccountAskboxSettings()" style="cursor: pointer; padding: 8px; border-radius: 50%; background-color: rgba(255,255,255,0.2); backdrop-filter: blur(10px); transition: all 0.2s;"
 onmouseover="this.style.backgroundColor='rgba(255,255,255,0.3)'"
 onmouseout="this.style.backgroundColor='rgba(255,255,255,0.2)'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;">
 <path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22l-1.92 3.32c-.12.22.07.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/>
 </svg>
 </div>
 </div>

 <div style="display: flex; flex-direction: column; align-items: center; padding: 20px 16px;">

 <div onclick="changeAccountAskboxAvatar()" style="cursor: pointer; margin-bottom: 12px; position: relative; transition: transform 0.2s;"
 onmouseover="this.style.transform='scale(1.05)'"
 onmouseout="this.style.transform='scale(1)'">
 <img id="account-askbox-avatar" src="https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg"
 style="width: 80px; height: 80px; border-radius: 50%; border: 3px solid rgba(255,255,255,0.8); box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
 </div>

 <div style="display: flex; align-items: center; gap: 8px; background-color: rgba(255,255,255,0.15); backdrop-filter: blur(10px); padding: 6px 12px; border-radius: 20px;">
 <span id="account-askbox-nickname"
 contenteditable="true"
 style="color: #fff; font-size: 14px; font-weight: 500; outline: none; cursor: text; min-width: 20px;"
 onblur="saveAccountAskboxNickname()"
 onkeydown="if(event.key==='Enter'){event.preventDefault();this.blur();}">⩌⌯⩌</span>
 </div>
 </div>

 <div style="margin: 0 20px 24px 20px; background-color: rgba(255,255,255,0.9); backdrop-filter: blur(10px); border-radius: 16px; padding: 32px 24px; box-shadow: 0 4px 16px rgba(0,0,0,0.1); transition: all 0.2s; min-height: 120px; display: flex; align-items: center; justify-content: center; ">
 <div id="account-askbox-prompt"
 contenteditable="true"
 style="color: #333; font-size: 16px; line-height: 1.6; text-align: center; word-break: break-word; outline: none; cursor: text; width: 100%; "
 onblur="saveAccountAskboxPrompt()"
 onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();this.blur();}">在这里输入你的匿名提问，或点击下方按钮生成随机提问...</div>
 </div>

 <div onclick="getNewAccountQuestion()" style="margin: 0 20px 32px 20px; background-color: rgba(255,255,255,0.85); backdrop-filter: blur(10px); border-radius: 24px; padding: 14px 24px; text-align: center; cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 8px rgba(0,0,0,0.1); " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.95)'; this.style.transform='translateY(-1px)'"
 onmouseout="this.style.backgroundColor='rgba(255,255,255,0.85)'; this.style.transform='translateY(0)'">
 <span style="color: #333; font-size: 15px; font-weight: 600;">获取回答 / 生成随机提问</span>
 </div>

 <div style="padding: 0 20px 20px 20px;">
 <div id="account-answered-questions-title" style="color: rgba(255,255,255,0.8); font-size: 15px; font-weight: 500; margin-bottom: 16px; text-align: center; display: none; ">最新提问如下</div>
 <div id="account-answered-questions-list">

 </div>
 </div>
 </div>
</div>
</div>

<div id="sticker-picker-modal" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 40; " onclick="closeStickerPicker()">
<div style="background-color:var(--x-bg-primary); border-radius: 16px; max-width: 500px; width: 95%; max-height: 75vh; display: flex; flex-direction: column; box-shadow: 0 8px 32px rgba(0,0,0,0.4); " onclick="event.stopPropagation()">

<div style="padding: 16px; border-bottom: 1px solid var(--x-border-color); display: flex; align-items: center; justify-content: space-between; ">
<div style="font-size: 18px; font-weight: 700; color:var(--x-text-primary);">选择表情包</div>
<div onclick="closeStickerPicker()" style="cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
onmouseout="this.style.backgroundColor='transparent'">
<svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
<g><path d="M10.59 12L4.54 5.96l1.06-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
</svg>
</div>
</div>

<div style="padding: 12px 16px 0 16px; display: flex; gap: 8px; border-bottom: 1px solid var(--x-border-color); ">
<div id="sticker-tab-frequent" onclick="switchStickerTab('frequent')" style="padding: 8px 16px; cursor: pointer; border-bottom: 2px solid var(--x-accent); color:var(--x-text-primary); font-size: 14px; font-weight: 600; transition: all 0.2s; ">常用</div>
<div id="sticker-tab-all" onclick="switchStickerTab('all')" style="padding: 8px 16px; cursor: pointer; border-bottom: 2px solid transparent; color:var(--x-text-secondary); font-size: 14px; font-weight: 600; transition: all 0.2s; ">全部</div>
</div>

<div id="sticker-list" style="flex: 1; overflow-y: auto; overflow-x: hidden; padding: 16px; display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 12px; align-content: start; align-items: start; ">

</div>

<div style="padding: 16px; border-top: 1px solid var(--x-border-color); display: flex; justify-content: space-between; gap: 8px; ">
<button onclick="openAddStickerDialog()" style="background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: background-color 0.2s; flex: 1; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
+ 导入表情包
</button>
<button onclick="openStickerManager()" style="background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
管理
</button>
</div>
</div>
</div>

<div class="x-bottom-nav"
style="display: flex; justify-content: space-around; padding: 10px 0; border-top: 1px solid #333; background-color:#000;">

<div class="x-nav-item active" onclick="switchXPage('home')"
style="display: flex; justify-content: center; align-items: center; position: relative; padding: 5px 15px; cursor: pointer;">
<svg viewBox="0 0 24 24" aria-hidden="true" style="width: 26px; height: 26px; fill: var(--x-accent);">
<g>
<path
d="M12 1.696L.622 8.807l1.06 1.696L3 9.679V19.5C3 20.881 4.119 22 5.5 22h13c1.381 0 2.5-1.119 2.5-2.5V9.679l1.318.824 1.06-1.696L12 1.696zM12 16.5c-1.933 0-3.5-1.567-3.5-3.5s1.567-3.5 3.5-3.5 3.5 1.567 3.5 3.5-1.567 3.5-3.5 3.5z">
</path>
</g>
</svg>

<div id="home-notification-dot" style="position: absolute; top: 2px; right: 8px; width: 8px; height: 8px; background-color: var(--x-accent); border-radius: 50%; border: 2px solid var(--x-bg-primary); display: none; "></div>

<div class="nav-highlight"
style="position: absolute; width: 5px; height: 5px; background-color: var(--x-accent); border-radius: 50%; bottom: -8px;">
</div>
</div>

 <div class="x-nav-item" onclick="switchXPage('search')"
 style="display: flex; justify-content: center; align-items: center; position: relative; padding: 5px 15px; cursor: pointer;">
 <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 26px; height: 26px; fill: #fff;">
 <g>
 <path
 d="M10.25 3.75c-3.59 0-6.5 2.91-6.5 6.5s2.91 6.5 6.5 6.5c1.795 0 3.419-.726 4.596-1.904 1.178-1.177 1.904-2.801 1.904-4.596 0-3.59-2.91-6.5-6.5-6.5zm-8.5 6.5c0-4.694 3.806-8.5 8.5-8.5s8.5 3.806 8.5 8.5c0 1.986-.682 3.815-1.824 5.262l4.781 4.781-1.414 1.414-4.781-4.781c-1.447 1.142-3.276 1.824-5.262 1.824-4.694 0-8.5-3.806-8.5-8.5z">
 </path>
 </g>
 </svg>
 <div class="nav-highlight"
 style="position: absolute; width: 5px; height: 5px; background-color: var(--x-accent); border-radius: 50%; bottom: -8px; display: none;">
 </div>
 </div>

 <div class="x-nav-item" onclick="switchXPage('notifications')"
 style="display: flex; justify-content: center; align-items: center; position: relative; padding: 5px 15px; cursor: pointer;">
 <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 26px; height: 26px; fill: #fff;">
 <g>
 <path
 d="M19.993 9.042C19.48 5.017 16.054 2 11.996 2s-7.49 3.021-7.999 7.051L2.866 18H7.1c.463 2.282 2.481 4 4.9 4s4.437-1.718 4.9-4h4.236l-1.143-8.958zM12 20c-1.306 0-2.417-.835-2.829-2h5.658c-.412 1.165-1.523 2-2.829 2zm-6.866-4l.847-6.698C6.364 6.272 8.941 4 11.996 4s5.627 2.268 6.013 5.295L18.864 16H5.134z">
 </path>
 </g>
 </svg>

 <div id="notifications-notification-dot" style="position: absolute; top: 2px; right: 8px; width: 8px; height: 8px; background-color: var(--x-accent); border-radius: 50%; border: 2px solid var(--x-bg-primary); display: none; "></div>
 <div class="nav-highlight"
 style="position: absolute; width: 5px; height: 5px; background-color: var(--x-accent); border-radius: 50%; bottom: -8px; display: none;">
 </div>
 </div>

 <div class="x-nav-item" onclick="switchXPage('messages')"
 style="display: flex; justify-content: center; align-items: center; position: relative; padding: 5px 15px; cursor: pointer;">
 <svg viewBox="0 0 24 24" aria-hidden="true" style="width: 26px; height: 26px; fill: #fff;">
 <g>
 <path
 d="M1.998 5.5c0-1.381 1.119-2.5 2.5-2.5h15c1.381 0 2.5 1.119 2.5 2.5v13c0 1.381-1.119 2.5-2.5 2.5h-15c-1.381 0-2.5-1.119-2.5-2.5v-13zm2.5-.5c-.276 0-.5.224-.5.5v2.764l8 3.638 8-3.636V5.5c0-.276-.224-.5-.5-.5h-15zm15.5 5.463l-8 3.636-8-3.638V18.5c0 .276.224.5.5.5h15c.276 0 .5-.224.5-.5v-8.037z">
 </path>
 </g>
 </svg>

 <div id="messages-notification-dot" style="position: absolute; top: 2px; right: 8px; width: 8px; height: 8px; background-color: var(--x-accent); border-radius: 50%; border: 2px solid var(--x-bg-primary); display: none; "></div>
 <div class="nav-highlight"
 style="position: absolute; width: 5px; height: 5px; background-color: var(--x-accent); border-radius: 50%; bottom: -8px; display: none;">
 </div>
 </div>
</div>
`; // 将创建的HTML添加到body
    document.body.appendChild(container);
    console.log("✅ X Social App: HTML结构已创建");
  }

  function getXDB() {
    const db = new Dexie("XSocialDB");
    // 版本1：初始表结构
    db.version(1).stores({
      xTweetsData: "&id",
      xSettings: "&id",
      xPresets: "++id, name, createdAt",
      xUserProfile: "&id",
      xUserTweets: "&id",
      xCharacterProfiles: "&characterId",
      xActiveAccount: "&id",
      xAccountList: "&accountId, name, createdAt",
      xNPCs: "&id",
      xAskbox: "&id",
    });
    // 版本2：添加账户主页和账户提问箱表
    db.version(2).stores({
      xTweetsData: "&id",
      xSettings: "&id",
      xPresets: "++id, name, createdAt",
      xUserProfile: "&id",
      xUserTweets: "&id",
      xCharacterProfiles: "&characterId",
      xActiveAccount: "&id",
      xAccountList: "&accountId, name, createdAt",
      xNPCs: "&id",
      xAskbox: "&id",
      xAccountProfiles: "&handle, name, updatedAt",
      xAccountAskbox: "&id",
    });
    // 版本3：添加角色关系册表
    db.version(3).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
      xAccountProfiles: '&handle, name, updatedAt',
      xAccountAskbox: '&id',
      xCharacterRelationships: '&id, accountId, lastUpdated',
    });
    // 版本4：确保所有表都存在
    db.version(4).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
      xAccountProfiles: '&handle, name, updatedAt',
      xAccountAskbox: '&id',
      xCharacterRelationships: '&id, accountId, lastUpdated',
    });
    // 版本5：添加书签表（多账户隔离）
    db.version(5).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
      xAccountProfiles: '&handle, name, updatedAt',
      xAccountAskbox: '&id',
      xCharacterRelationships: '&id, accountId, lastUpdated',
      xBookmarks: '&id, accountId, tweetId, bookmarkedAt',
    });
    // 版本6：添加喜欢表（多账户隔离）
    db.version(6).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
      xAccountProfiles: '&handle, name, updatedAt',
      xAccountAskbox: '&id',
      xCharacterRelationships: '&id, accountId, lastUpdated',
      xBookmarks: '&id, accountId, tweetId, bookmarkedAt',
      xLikes: '&id, accountId, tweetId, likedAt',
    });
    // 版本7：添加世界运转大事件表（多账户隔离）
    db.version(7).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
      xAccountProfiles: '&handle, name, updatedAt',
      xAccountAskbox: '&id',
      xCharacterRelationships: '&id, accountId, lastUpdated',
      xBookmarks: '&id, accountId, tweetId, bookmarkedAt',
      xLikes: '&id, accountId, tweetId, likedAt',
      xWorldEvents: '&id, accountId, lastGenerated, lastProgressed',
    });
    // 版本8：添加自定义礼物系统表（分类+礼物）
    db.version(8).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
      xAccountProfiles: '&handle, name, updatedAt',
      xAccountAskbox: '&id',
      xCharacterRelationships: '&id, accountId, lastUpdated',
      xBookmarks: '&id, accountId, tweetId, bookmarkedAt',
      xLikes: '&id, accountId, tweetId, likedAt',
      xWorldEvents: '&id, accountId, lastGenerated, lastProgressed',
      xCustomGiftCategories: '&id, accountId, name, enabled, createdAt',
      xCustomGifts: '&id, categoryId, accountId, name, points, createdAt',
    });
    // 版本9：添加粉丝团表
    db.version(9).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
      xAccountProfiles: '&handle, name, updatedAt',
      xAccountAskbox: '&id',
      xCharacterRelationships: '&id, accountId, lastUpdated',
      xBookmarks: '&id, accountId, tweetId, bookmarkedAt',
      xLikes: '&id, accountId, tweetId, likedAt',
      xWorldEvents: '&id, accountId, lastGenerated, lastProgressed',
      xCustomGiftCategories: '&id, accountId, name, enabled, createdAt',
      xCustomGifts: '&id, categoryId, accountId, name, points, createdAt',
      xFanClubs: '&handle, createdAt, updatedAt',
    });

    // Version 10: 粉丝团会员系统（添加新表，保留所有已有表）
    db.version(10).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
      xAccountProfiles: '&handle, name, updatedAt',
      xAccountAskbox: '&id',
      xCharacterRelationships: '&id, accountId, lastUpdated',
      xBookmarks: '&id, accountId, tweetId, bookmarkedAt',
      xLikes: '&id, accountId, tweetId, likedAt',
      xWorldEvents: '&id, accountId, lastGenerated, lastProgressed',
      xCustomGiftCategories: '&id, accountId, name, enabled, createdAt',
      xCustomGifts: '&id, categoryId, accountId, name, points, createdAt',
      xFanClubs: '&handle, createdAt, updatedAt',
      xFanClubMemberships: '&streamerHandle, joined, joinedAt, lastCheckinDate, points, level',
    });

    // Version 11: 地图约会数据表（第十五个情景）
    db.version(11).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
      xAccountProfiles: '&handle, name, updatedAt',
      xAccountAskbox: '&id',
      xCharacterRelationships: '&id, accountId, lastUpdated',
      xBookmarks: '&id, accountId, tweetId, bookmarkedAt',
      xLikes: '&id, accountId, tweetId, likedAt',
      xWorldEvents: '&id, accountId, lastGenerated, lastProgressed',
      xCustomGiftCategories: '&id, accountId, name, enabled, createdAt',
      xCustomGifts: '&id, categoryId, accountId, name, points, createdAt',
      xFanClubs: '&handle, createdAt, updatedAt',
      xFanClubMemberships: '&streamerHandle, joined, joinedAt, lastCheckinDate, points, level',
      xMapDatingData: '&id, accountId, lastGenerated, lastUpdated',
    });

    // Version 12: 用户地图约会个人资料表
    db.version(12).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
      xAccountProfiles: '&handle, name, updatedAt',
      xAccountAskbox: '&id',
      xCharacterRelationships: '&id, accountId, lastUpdated',
      xBookmarks: '&id, accountId, tweetId, bookmarkedAt',
      xLikes: '&id, accountId, tweetId, likedAt',
      xWorldEvents: '&id, accountId, lastGenerated, lastProgressed',
      xCustomGiftCategories: '&id, accountId, name, enabled, createdAt',
      xCustomGifts: '&id, categoryId, accountId, name, points, createdAt',
      xFanClubs: '&handle, createdAt, updatedAt',
      xFanClubMemberships: '&streamerHandle, joined, joinedAt, lastCheckinDate, points, level',
      xMapDatingData: '&id, accountId, lastGenerated, lastUpdated',
      xMapUserProfile: '&id, lastUpdated',
    });
    // 版本13：添加地图约会聊天记录表
    db.version(13).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
      xAccountProfiles: '&handle, name, updatedAt',
      xAccountAskbox: '&id',
      xCharacterRelationships: '&id, accountId, lastUpdated',
      xBookmarks: '&id, accountId, tweetId, bookmarkedAt',
      xLikes: '&id, accountId, tweetId, likedAt',
      xWorldEvents: '&id, accountId, lastGenerated, lastProgressed',
      xCustomGiftCategories: '&id, accountId, name, enabled, createdAt',
      xCustomGifts: '&id, categoryId, accountId, name, points, createdAt',
      xFanClubs: '&handle, createdAt, updatedAt',
      xFanClubMemberships: '&streamerHandle, joined, joinedAt, lastCheckinDate, points, level',
      xMapDatingData: '&id, accountId, lastGenerated, lastUpdated',
      xMapUserProfile: '&id, lastUpdated',
      xMapChats: '&id, accountId, userId, lastUpdated',
    });
    // 版本14：添加道具系统
    db.version(13).stores({
      xTweetsData: '&id',
      xSettings: '&id',
      xPresets: '++id, name, createdAt',
      xUserProfile: '&id',
      xUserTweets: '&id',
      xCharacterProfiles: '&characterId',
      xActiveAccount: '&id',
      xAccountList: '&accountId, name, createdAt',
      xNPCs: '&id',
      xAskbox: '&id',
      xAccountProfiles: '&handle, name, updatedAt',
      xAccountAskbox: '&id',
      xCharacterRelationships: '&id, accountId, lastUpdated',
      xBookmarks: '&id, accountId, tweetId, bookmarkedAt',
      xLikes: '&id, accountId, tweetId, likedAt',
      xWorldEvents: '&id, accountId, lastGenerated, lastProgressed',
      xCustomGiftCategories: '&id, accountId, name, enabled, createdAt',
      xCustomGifts: '&id, categoryId, accountId, name, points, createdAt',
      xFanClubs: '&handle, createdAt, updatedAt',
      xFanClubMemberships: '&streamerHandle, joined, joinedAt, lastCheckinDate, points, level',
      xMapDatingData: '&id, accountId, lastGenerated, lastUpdated',
      xMapUserProfile: '&id, lastUpdated',
      xMapChats: '&id, accountId, userId, lastUpdated',
      xTools: '&id, accountId, updatedAt',
    });
    
    return db;
  }
  // 原有全局数据库配置函数 - 用于访问API配置和角色信息
  function getDB() {
    return window.db; // 通过window访问
  }
  // 常用DOM操作工具函数
  const DOMUtils = {
    hide: (selector) =>
      document
        .querySelectorAll(selector)
        .forEach((el) => (el.style.display = "none")),
    show: (selector, display = "block") =>
      document
        .querySelectorAll(selector)
        .forEach((el) => (el.style.display = display)),
    removeClass: (selector, className) =>
      document
        .querySelectorAll(selector)
        .forEach((el) => el.classList.remove(className)),
    addClass: (selector, className) =>
      document
        .querySelectorAll(selector)
        .forEach((el) => el.classList.add(className)),
    setStyle: (selector, property, value) =>
      document
        .querySelectorAll(selector)
        .forEach((el) => (el.style[property] = value)),
  };
  // 句柄处理工具函数
  const HandleUtils = {
    // 清理并标准化句柄（移除@符号，转小写）
    clean: (handle) => {
      if (!handle) return "";
      return handle.replace("@", "").toLowerCase();
    },
    // 确保句柄以@开头
    ensureAt: (handle) => {
      if (!handle) return "";
      return handle.startsWith("@") ? handle : `@${handle}`;
    },
    // 比较两个句柄是否相同（忽略大小写和@符号）
    equals: (handle1, handle2) => {
      if (!handle1 || !handle2) return false;
      return HandleUtils.clean(handle1) === HandleUtils.clean(handle2);
    },
  }; // 字符串构建工具函数 - 简化重复的拼接逻辑
  const StringBuilders = {
    // 构建角色信息字符串
    buildCharacterInfo(char, xProfile, userXProfileInfo) {
      let info = `\n角色名：${char.name}`;
      info += `\n本名：${char.originalName}`;
      info += `\n人设：${char.settings.aiPersona || "无特定人设"}`; // 情侣认证关系
      if (
        userXProfileInfo.verificationType === "couple" &&
        userXProfileInfo.coupleCharacterId === char.id
      ) {
        info += `\n【特殊关系】：该角色是用户的情侣认证对象，所有X平台观众都知道这层关系`;
      }
      // X平台身份信息
      info += `\n【X平台身份（必须严格使用）】：`;
      info += `\n- X用户名：${xProfile.xName}`;
      info += `\n- X句柄：@${xProfile.xHandle}`;
      info += `\n- X头像：${xProfile.xAvatar}`;
      info += `\n- 认证状态：${xProfile.xVerified ? "是" : "否"}`;
      if (xProfile.xBio) info += `\n- X简介：${xProfile.xBio}`;
      if (xProfile.publicIdentity)
        info += `\n- 公众身份：${xProfile.publicIdentity}`;
      if (xProfile.showRealName && xProfile.realName) {
        info += `\n- 真实姓名：${xProfile.realName}（已公开）`;
      }
      return info;
    },
    // 构建用户身份识别信息
    buildUserIdentityInfo(char, xProfile, userXProfileInfo) {
      const knowsUserIdentity =
        userXProfileInfo.knownIdentityCharacters.includes(char.id);
      let info = `\n【用户身份识别】：${
        knowsUserIdentity ? "知道用户身份" : "不知道用户身份"
      }`;
      if (knowsUserIdentity) {
        info += `\n- 该角色可以识别用户账号 ${userXProfileInfo.handle}（${userXProfileInfo.name}）`;
        info += `\n- 可以根据角色特定的用户人设与用户自然互动，回复时表现出认识`;
        const characterUserPersona =
          xProfile && xProfile.userPersona ? xProfile.userPersona : "";
        if (characterUserPersona.trim()) {
          info += `\n- 该角色了解的用户信息：${characterUserPersona.substring(
            0,
            150
          )}${characterUserPersona.length > 150 ? "..." : ""}`;
        } else {
          info += `\n- 该角色尚未设置用户人设信息，按基础认识模式互动`;
        }
      } else {
        info += `\n- 该角色完全不知道用户的真实身份，按照陌生人模式回复`;
      }
      return info;
    },
    // 构建NPC关系信息
    buildNPCRelationships(xProfile) {
      if (!xProfile.relationships || xProfile.relationships.length === 0)
        return "";
      let info = `\n【已绑定NPC关系】：`;
      xProfile.relationships.forEach((rel) => {
        info += `\n- ${rel.npcName} (${rel.npcHandle}): ${rel.relationshipType}`;
        if (rel.description) info += ` | ${rel.description}`;
      });
      info += `\n注意：当该角色参与回复时，其绑定的NPC也可能出现在回复中，要体现相应的关系特点。`;
      return info;
    },
    // 构建记忆信息
    buildMemoryInfo(char) {
      let info = "";
      if (char.history && char.history.length > 0) {
        const recentHistory = char.history.slice(-10);
        info += "\n最近聊天记忆：";
        recentHistory.forEach((msg) => {
          if (msg.role === "assistant" && msg.content) {
            info += `\n- ${char.name}: ${msg.content.substring(0, 100)}...`;
          }
        });
      }
      if (char.longTermMemory && char.longTermMemory.length > 0) {
        info += "\n长期记忆：";
        char.longTermMemory.forEach((mem) => {
          info += `\n- ${mem.content}`;
        });
      }
      return info;
    },
    // 构建完整角色信息（需要从数据库获取数据）
    // scenario: 'tweet' | 'reaction' | 'reply'
    // 🎯 优化版：使用统一资料获取系统
    async buildCompleteCharacterInfo(
      boundCharacters,
      userXProfileInfo,
      scenario = "reply"
    ) {
      if (!boundCharacters || boundCharacters.length === 0) return "";
      const mainDB = getDB();
      const xDB = getXDB(); // 获取所有角色的X资料（用于提取句柄）
      const allXProfiles = await xDB.xCharacterProfiles.toArray();
      const characterHandles = [];
      for (const charId of boundCharacters) {
        const xProfile = allXProfiles.find((p) => p.characterId === charId);
        if (xProfile && xProfile.xHandle) {
          characterHandles.push(xProfile.xHandle);
        }
      }
      if (characterHandles.length === 0) return ""; // 🎯 使用统一资料获取系统批量获取角色资料（传递用户信息以正确读取私信等数据）
      const profiles = await this.getBatchProfiles(characterHandles, {
        userProfileInfo: userXProfileInfo,
      });
      if (profiles.length === 0) return ""; // 根据场景选择合适的描述
      let scenarioTitle = "";
      if (scenario === "tweet") {
        scenarioTitle =
          "\n\n【绑定角色信息】以下绑定角色可以作为推文发布者，根据其设定和兴趣发布推文：\n";
      } else if (scenario === "reaction") {
        scenarioTitle =
          "\n\n【绑定角色信息】以下绑定角色可以对推文进行互动（评论、点赞等），根据角色设定和话题相关性决定是否互动：\n";
      } else {
        scenarioTitle =
          "\n\n【绑定角色信息】以下绑定角色可以参与回复，根据角色设定和话题相关性决定是否回复：\n";
      }
      let charactersInfo = scenarioTitle; // 遍历每个角色资料，格式化输出
      for (const profile of profiles) {
        if (profile.type !== "character") continue;
        charactersInfo += this.formatProfileForPrompt(profile, {
          includeType: false, // 不显示类型标识（已经在scenarioTitle中说明）
          includeTweets: true,
          includeRelationships: true,
        });
        // 用户身份识别信息已经在formatProfileForPrompt中包含，无需重复添加
        charactersInfo += "\n";
      }
      // 根据场景添加不同的要求说明
      if (scenario === "tweet") {
        charactersInfo += `
【角色发推要求】：
- 角色发推内容要符合其人设、兴趣和性格特点
- 知道用户身份的角色：可以在推文中自然地@用户或提及用户相关话题
- 不知道用户身份的角色：发布独立推文，不涉及用户
- 推文内容应该多样化：日常生活、兴趣爱好、工作学习、情感分享等
【NPC关系互动】：
- 有绑定NPC关系的角色，其NPC可能在其推文下评论互动
- NPC用户名、句柄与关系设定保持一致，头像统一使用默认头像，认证状态为"否"
- 同一NPC保持身份和性格一致性`;
      } else if (scenario === "reaction") {
        charactersInfo += `
【角色互动要求】：
- 角色互动（评论/点赞）要符合其人设和兴趣，与推文内容相关
- 知道用户身份的角色：在用户发布的推文下可以表现出认识，自然互动
- 不知道用户身份的角色：按照陌生人模式互动，不知道发布者身份
- 互动应该自然真实，就像普通用户一样
【NPC关系互动】：
- 有绑定NPC关系的角色，其NPC可在评论中出现，体现关系特点
- NPC用户名、句柄与关系设定保持一致，头像统一使用默认头像，认证状态为"否"
- 同一NPC保持身份和性格一致性`;
      } else {
        charactersInfo += `
【角色回复要求】：
- 角色回复要自然真实，就像普通用户回复一样
- 知道用户身份的角色：回复时可表现出认识，体现对用户的了解
- 不知道用户身份的角色：按照陌生人模式回复，不知道用户账号信息
【NPC关系互动】：
- 有绑定NPC关系的角色，其NPC可在回复中出现，体现关系特点
- NPC用户名、句柄与关系设定保持一致，头像统一使用默认头像，认证状态为"否"
- 同一NPC保持身份和性格一致性，不认识的NPC间不互相@或提及`;
      }
      return charactersInfo;
    },
    // 构建基础系统提示词（通用版本）- 只包含提示词+世界书
    buildBaseSystemPrompt({ userPrompt, worldSetting }) {
      let systemPrompt = ""; // 1. 用户自定义提示词
      if (userPrompt.trim()) systemPrompt += userPrompt.trim() + "\n\n"; // 2. 世界观设定
      systemPrompt += "【世界观设定约束】：";
      if (worldSetting.trim()) {
        systemPrompt += `
${worldSetting.trim()}
上述世界观设定是最高优先级的约束条件，必须严格遵守。`;
      } else {
        systemPrompt += `
无特殊世界观限制，但内容需健康正面，符合社交平台规范。`;
      }
      return systemPrompt;
    },
    // 构建用户X个人资料信息
    buildUserXProfileInfo(userProfileData) {
      return {
        name: userProfileData.name,
        handle: userProfileData.handle,
        avatar: userProfileData.avatar,
        bio: userProfileData.bio,
        verified: userProfileData.verified,
        verificationType: userProfileData.verificationType || "none",
        coupleCharacterId: userProfileData.coupleCharacterId || "",
        coupleCharacterName: userProfileData.coupleCharacterName || "",
        publicIdentity: userProfileData.publicIdentity || "",
        showRealName: userProfileData.showRealName || false,
        realName: userProfileData.realName || "",
        knownIdentityCharacters: userProfileData.knownIdentityCharacters || [],
      };
    },
    // 构建通用约束条件
    buildUniversalConstraints(userXProfileInfo) {
      const verificationDesc =
        this.getUserVerificationTypeDescription(userXProfileInfo);
      return `
🚫🚫🚫 【核心禁令 - 最高优先级】 🚫🚫🚫
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
**绝对禁止以用户身份生成任何内容！**
用户身份标识（禁止使用）：
- 用户名：${userXProfileInfo.name}
- 用户句柄：${userXProfileInfo.handle}
- 🚨 警告：用户是独立的个体，不要与任何绑定角色混淆！
- 🚨 警告：不要将绑定角色误认为用户！
- 用户信息：仅供理解上下文，严禁在生成内容中使用
**你只能生成以下身份的内容**：
✅ 绑定角色（使用提供的xName、xHandle、xAvatar等）
✅ 虚构的普通X平台用户（自创用户名和句柄）
❌ 绝对不能生成用户本人发表的任何推文/评论/回复
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【用户X平台公开身份】（所有观众都知道的公开信息）：
- 用户名：${userXProfileInfo.name}（这是用户，不是角色！）
- 用户句柄：${userXProfileInfo.handle}（这是用户的唯一标识！）
- 认证状态：${userXProfileInfo.verified ? "已认证" : "未认证"}
- 认证类型：${verificationDesc}
${
  userXProfileInfo.verificationType === "couple" &&
  userXProfileInfo.coupleCharacterName
    ? `- 情侣关系：与${userXProfileInfo.coupleCharacterName}为公开情侣（观众可知）`
    : ""
}
${
  userXProfileInfo.publicIdentity
    ? `- 公众身份：${userXProfileInfo.publicIdentity}`
    : ""
}
${userXProfileInfo.bio ? `- 个人简介：${userXProfileInfo.bio}` : ""}
【身份识别关键点】：
🚨 用户 vs 角色的区别：
- 用户（${userXProfileInfo.name} / ${
        userXProfileInfo.handle
      }）：真实操作者，你绝对不能模拟其发言
- 绑定角色：已设定的虚拟角色，有各自的X平台身份（xName、xHandle），你可以生成他们的内容
- 🚨 特别注意：即使某个角色与用户有关系（如情侣），也不要将该角色当成用户本人！
【权限分级 - 路人评论者的认知范围】：
🔓 路人可见（X平台公开信息）：
- 用户/角色的X姓名、X句柄、认证状态
- X简介、公众身份、公开的情侣关系
- X平台上发布的推文内容
🔒 路人禁知（私密信息）：
- 真实姓名、真实职业、真实身份
- 角色人设描述、性格细节、AI人格设定
- 聊天记忆、私人对话、用户专属人设
- 只有亲密关系才知道的信息（除非是已绑定的关系NPC）
⚠️ 路人评论规则：
- 路人只能基于🔓公开信息进行评论
- 禁止在评论中提及🔒私密信息
- 禁止使用只有亲密关系才知道的称呼（如"老师"、"同学"等，除非是公开身份）`;
    },
    // 获取认证类型描述
    getUserVerificationTypeDescription(userXProfileInfo) {
      switch (userXProfileInfo.verificationType) {
        case "verified":
          return "蓝色勾标认证";
        case "couple":
          return "情侣认证";
        case "married":
          return "已婚认证";
        case "vip":
          return "VIP认证";
        default:
          return "无认证";
      }
    },
    // 构建场景分支提示词
    buildScenarioPrompt({
      isOwnPost,
      commentType,
      pageType,
      parentComment,
      targetCommentEl,
    }) {
      let scenarioPrompt = "\n\n【场景识别】：";
      if (isOwnPost && commentType === "main_comment") {
        scenarioPrompt += `用户在自己发布的推文下方发表了评论。
【任务】：生成其他用户对她评论的反应回复，或新的话题相关评论。`;
      } else if (isOwnPost && commentType === "reply_comment") {
        scenarioPrompt += `用户在自己发布的推文的评论区楼中楼发表了回复。
【任务】：生成其他用户对这条楼中楼回复的反应，或话题相关的新回复。`;
      } else if (!isOwnPost && commentType === "main_comment") {
        scenarioPrompt += `用户在别人发布的推文下方发表了评论。
【任务】：生成其他用户（包括原推作者）对此评论的互动回复。`;
      } else if (!isOwnPost && commentType === "reply_comment") {
        scenarioPrompt += `用户在别人发布的推文的评论区楼中楼发表了回复。
【任务】：生成其他用户对此楼中楼回复的反应，可能包括被回复者本人。`;
      }
      // 添加通用生成要求
      scenarioPrompt += `
【生成要求】：
1. 社交真实性：模拟真实的X平台用户互动，语言自然流畅
2. 情绪共鸣：根据原推内容和用户评论，生成有情感共鸣的回应
3. 多样化互动：可以是赞同、反对、补充、提问、调侃等多种类型
4. 身份一致：每个角色回复都要符合其设定的身份和性格特点
5. 避免重复：多个回复之间保持内容和表达方式的差异性
【格式要求】：
- 每条回复独立成段，以"【回复X】"开头标记
- 严格按照角色的X平台身份信息生成，不得擅自修改用户名、句柄等
- 回复长度适中，符合社交媒体特点（一般20-200字）
- 可以适当使用emoji表情，但不要过度`;
      return scenarioPrompt;
    },
    // ========== 统一资料获取工具 ==========
    // 通过句柄获取任何类型的完整资料（角色/账户/陌生人）
    // options: { userProfileInfo, messageId } - 传入用户资料以检查身份识别，messageId用于读取陌生人自定义设置
    async getUnifiedProfile(handle, options = {}) {
      try {
        const cleanHandle = HandleUtils.clean(handle);
        if (!cleanHandle) return null;
        console.log(`🔍 [统一资料] 查询句柄: ${cleanHandle}`); // 0. 🆕 检查是否是用户自己
        // 用户句柄可能存储在多个字段中，按优先级尝试
        let userXHandle =
          window.userProfileData?.xHandle ||
          window.userProfileData?.handle ||
          window.userProfileData?.username;
        const cleanUserHandle = HandleUtils.clean(userXHandle);
        console.log(
          `🔍 [统一资料] 用户句柄对比: 查询="${cleanHandle}" vs 用户="${cleanUserHandle}" (来源: xHandle=${window.userProfileData?.xHandle}, handle=${window.userProfileData?.handle}, username=${window.userProfileData?.username})`
        ); // 不区分大小写比较句柄
        if (HandleUtils.equals(handle, userXHandle)) {
          // 用户资料字段映射（兼容不同的字段名）
          const userName =
            window.userProfileData.name ||
            window.userProfileData.xName ||
            "用户";
          const userHandle =
            window.userProfileData.handle ||
            window.userProfileData.xHandle ||
            `@${userXHandle}`;
          const userAvatar =
            window.userProfileData.avatar ||
            window.userProfileData.xAvatar ||
            "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg";
          const userVerified =
            window.userProfileData.verified ||
            window.userProfileData.xVerified ||
            false;
          const userBio =
            window.userProfileData.bio || window.userProfileData.xBio || "";
          const userCover =
            window.userProfileData.cover || window.userProfileData.xCover || "";
          console.log(
            `✅ [统一资料] 找到用户自己: ${userName} (${userHandle})`
          ); // 返回用户的X资料
          const userProfile = {
            type: "user",
            name: userName,
            handle: userHandle,
            avatar: userAvatar,
            verified: userVerified,
            publicIdentity: window.userProfileData.publicIdentity || "",
            bio: userBio,
            xProfile: {
              xName: userName,
              xHandle: userHandle,
              xAvatar: userAvatar,
              xVerified: userVerified,
              xBio: userBio,
              xCover: userCover,
            },
            // 用户没有"认识用户"这个概念
            knowsUserIdentity: false,
            xMessageHistory: [],
            recentTweets: [],
          };
          return userProfile;
        }
        // 1. 尝试作为角色查询
        const characterProfile = await this._getCharacterProfileByHandle(
          cleanHandle,
          options.userProfileInfo
        );
        if (characterProfile) {
          console.log(`✅ [统一资料] 找到角色: ${characterProfile.name}`);
          return characterProfile;
        }
        // 2. 尝试作为绑定NPC查询
        const npcProfile = await this._getNPCProfileByHandle(cleanHandle);
        if (npcProfile) {
          console.log(`✅ [统一资料] 找到绑定NPC: ${npcProfile.name}`);
          return npcProfile;
        }
        // 3. 尝试作为关系NPC查询
        const relationshipNpcProfile =
          await this._getRelationshipNPCProfileByHandle(cleanHandle);
        if (relationshipNpcProfile) {
          console.log(
            `✅ [统一资料] 找到关系NPC: ${relationshipNpcProfile.name}`
          );
          return relationshipNpcProfile;
        }
        // 4. 尝试作为账户查询
        const accountProfile = await this._getAccountProfileByHandle(
          cleanHandle
        );
        if (accountProfile) {
          console.log(`✅ [统一资料] 找到账户: ${accountProfile.name}`);
          return accountProfile;
        }
        // 5. 作为陌生人返回（传入messageId以读取自定义设置）
        console.log(`ℹ️ [统一资料] 未找到匹配，创建陌生人模板`);
        return await this._createStrangerProfile(handle, options.messageId);
      } catch (error) {
        console.error("[统一资料] 查询失败:", error);
        return null;
      }
    },
    // 内部方法：通过句柄获取角色资料
    // userProfileInfo: 用户资料信息，用于检查该角色是否识别用户身份
    async _getCharacterProfileByHandle(cleanHandle, userProfileInfo = null) {
      try {
        const xDB = getXDB();
        const mainDB = getDB(); // 从 xCharacterProfiles 查找
        const allXProfiles = await xDB.xCharacterProfiles.toArray();
        const xProfile = allXProfiles.find((p) =>
          HandleUtils.equals(p.xHandle, cleanHandle)
        );
        if (!xProfile) return null; // 获取角色详细信息
        const allChats = await mainDB.chats.toArray();
        const character = allChats.find((c) => c.id === xProfile.characterId);
        if (!character) return null; // 获取角色的推文和直播数据
        const accountProfile = await xDB.xAccountProfiles.get(cleanHandle);
        const tweets = accountProfile?.tweets || [];

        // 🆕 读取直播间数据（如果存在）
        let liveRoomData = null;
        if (accountProfile?.liveRoomData) {
          liveRoomData = accountProfile.liveRoomData;
          console.log(
            `🎤 [直播数据] 角色 ${xProfile.xName}: 找到直播间数据 "${
              liveRoomData.title || "无标题"
            }"`
          );
        }

        // 🆕 读取粉丝团配置和用户会员状态
        let fanClubConfig = null;
        let userFanClubMembership = null;
        try {
          // 读取粉丝团配置
          const fanClubRecord = await xDB.xFanClubs.get(cleanHandle);
          if (fanClubRecord && fanClubRecord.data) {
            fanClubConfig = fanClubRecord.data;
            console.log(
              `🎖️ [粉丝团] 角色 ${xProfile.xName}: 找到粉丝团配置 "${
                fanClubConfig.clubName || "无名称"
              }"`
            );
          }

          // 读取用户在该粉丝团的会员状态
          userFanClubMembership = await xDB.xFanClubMemberships.get(
            cleanHandle
          );
          if (userFanClubMembership) {
            console.log(
              `🎖️ [粉丝团] 用户在 ${xProfile.xName} 的粉丝团中: LV${userFanClubMembership.level} (${userFanClubMembership.points}积分)`
            );
          }
        } catch (error) {
          console.warn(
            `⚠️ [粉丝团] 角色 ${xProfile.xName} 粉丝团数据读取失败:`,
            error
          );
        }

        // 🔧 检查该角色是否识别用户身份
        let knowsUserIdentity = false;
        if (userProfileInfo && userProfileInfo.knownIdentityCharacters) {
          knowsUserIdentity = userProfileInfo.knownIdentityCharacters.includes(
            character.id
          );
        }
        console.log(
          `👤 [身份识别] 角色 ${xProfile.xName} ${
            knowsUserIdentity ? "✅ 知道" : "❌ 不知道"
          }用户身份${
            knowsUserIdentity && xProfile.userPersona
              ? " (有专属人设)"
              : knowsUserIdentity
              ? " (无专属人设)"
              : ""
          }`
        ); // 🆕 读取X平台私信记忆
        let xMessageHistory = [];
        try {
          const currentAccount = window.currentAccountId || "main"; // 尝试在多个账户下查找（当前账户优先，然后是main账户）
          const accountsToTry = [currentAccount];
          if (currentAccount !== "main") {
            accountsToTry.push("main");
          }
          let messageConversation = null; // 尝试查找角色的私信对话
          for (const accountId of accountsToTry) {
            const messageConversationId = `messageConversation_${accountId}_msg_${character.id}`;
            const data = await xDB.xAccountProfiles.get(messageConversationId);
            if (data && data.data && data.data.messages) {
              messageConversation = data;
              break;
            }
          }
          if (
            messageConversation &&
            messageConversation.data &&
            messageConversation.data.messages
          ) {
            // 提取最近的私信对话（最多30条）
            const messages = messageConversation.data.messages.slice(-50);
            xMessageHistory = messages.map((msg) => ({
              type: msg.type,
              content: msg.content || "",
              isOwn: msg.isOwn || false,
              time: msg.time || "",
              timestamp: msg.timestamp || "",
            }));
            console.log(
              `✅ [私信数据] 角色 ${xProfile.xName}: ${xMessageHistory.length} 条记忆`
            );
          }
        } catch (error) {
          console.error(
            `❌ [私信数据] 角色 ${xProfile.xName} 读取失败:`,
            error
          );
        }
        return {
          type: "character",
          // 基础信息
          name: xProfile.xName,
          handle: xProfile.xHandle,
          avatar: xProfile.xAvatar,
          bio: xProfile.xBio || "",
          verified: xProfile.xVerified || false,
          publicIdentity: xProfile.publicIdentity || "",
          // 角色特有数据
          characterData: {
            id: character.id,
            originalName: character.originalName,
            aiPersona: character.settings?.aiPersona || "",
            history: character.history || [],
            longTermMemory: character.longTermMemory || [],
            userPersona: xProfile.userPersona || "",
            xMessageHistory: xMessageHistory, // 🆕 X平台私信记忆
          },
          // 🔧 用户身份识别信息
          knowsUserIdentity: knowsUserIdentity,
          // 推文数据
          tweets: tweets,
          // 关系数据
          relationships: xProfile.relationships || [],
          // 🆕 直播数据
          liveRoomData: liveRoomData,
          // 🆕 粉丝团数据
          fanClubConfig: fanClubConfig,
          userFanClubMembership: userFanClubMembership,
          // 原始对象（保留用于兼容性）
          xProfile: xProfile,
          character: character,
          characterId: character.id,
          // 元信息
          _source: "character",
          _characterId: character.id,
          _loadedAt: Date.now(),
        };
      } catch (error) {
        console.error("[统一资料] 角色查询失败:", error);
        return null;
      }
    },
    // 内部方法：通过句柄获取账户资料
    async _getAccountProfileByHandle(cleanHandle) {
      try {
        const xDB = getXDB();
        const accountProfile = await xDB.xAccountProfiles.get(cleanHandle);
        if (!accountProfile) return null;
        const accountInfo = accountProfile.accountInfo || accountProfile; // 🆕 读取X平台私信记忆
        const xMessageHistory = await this._loadXMessageHistory(
          accountInfo.handle
        );

        // 🆕 读取直播间数据（如果存在）
        let liveRoomData = null;
        if (accountProfile.liveRoomData) {
          liveRoomData = accountProfile.liveRoomData;
          console.log(
            `🎤 [直播数据] 账户 ${accountInfo.name}: 找到直播间数据 "${
              liveRoomData.title || "无标题"
            }"`
          );
        }

        // 🆕 读取粉丝团配置和用户会员状态
        let fanClubConfig = null;
        let userFanClubMembership = null;
        try {
          const xDB = getXDB();
          // 读取粉丝团配置
          const fanClubRecord = await xDB.xFanClubs.get(cleanHandle);
          if (fanClubRecord && fanClubRecord.data) {
            fanClubConfig = fanClubRecord.data;
            console.log(
              `🎖️ [粉丝团] 账户 ${accountInfo.name}: 找到粉丝团配置 "${
                fanClubConfig.clubName || "无名称"
              }"`
            );
          }

          // 读取用户在该粉丝团的会员状态
          userFanClubMembership = await xDB.xFanClubMemberships.get(
            cleanHandle
          );
          if (userFanClubMembership) {
            console.log(
              `🎖️ [粉丝团] 用户在 ${accountInfo.name} 的粉丝团中: LV${userFanClubMembership.level} (${userFanClubMembership.points}积分)`
            );
          }
        } catch (error) {
          console.warn(
            `⚠️ [粉丝团] 账户 ${accountInfo.name} 粉丝团数据读取失败:`,
            error
          );
        }

        return {
          type: "account",
          // 基础信息
          name: accountInfo.name,
          handle: accountInfo.handle,
          avatar: accountInfo.avatar,
          bio: accountInfo.bio || "",
          verified: accountInfo.verified || false,
          publicIdentity: accountInfo.publicIdentity || "",
          // 账户信息（用于 queryAccountData）
          accountInfo: {
            name: accountInfo.name,
            handle: accountInfo.handle,
            avatar: accountInfo.avatar,
            bio: accountInfo.bio || "",
            verified: accountInfo.verified || false,
            verificationType: accountInfo.verificationType || "none",
            cover:
              accountInfo.cover ||
              accountProfile.cover ||
              "https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg",
            publicIdentity: accountInfo.publicIdentity || "",
            customTag1:
              accountInfo.customTag1 || accountProfile.customTag1 || null,
            customTag2:
              accountInfo.customTag2 || accountProfile.customTag2 || null,
            followersCount: accountInfo.followersCount || "0",
            followingCount: accountInfo.followingCount || "0",
          },
          // 账户特有数据
          accountData: {
            accountType: accountProfile.accountType || "unknown",
            personality: accountProfile.personality || "",
            postingHabits: accountProfile.postingHabits || "",
            sourceContext: accountProfile.sourceContext || null,
            followersCount: accountInfo.followersCount || "0",
            followingCount: accountInfo.followingCount || "0",
            xMessageHistory: xMessageHistory, // 🆕 X平台私信记忆
          },
          // 推文数据
          tweets: accountProfile.tweets || [],
          // 关系数据（NPC账户可能有）
          relationships: accountProfile.relationships || [],
          // 🆕 直播数据
          liveRoomData: liveRoomData,
          // 🆕 粉丝团数据
          fanClubConfig: fanClubConfig,
          userFanClubMembership: userFanClubMembership,
          // 元信息
          _source: "account",
          _accountHandle: cleanHandle,
          _loadedAt: Date.now(),
        };
      } catch (error) {
        console.error("[统一资料] 账户查询失败:", error);
        return null;
      }
    },
    // 🆕 内部辅助方法：通过句柄读取X平台私信记忆
    async _loadXMessageHistory(handle) {
      try {
        const xDB = getXDB();
        const currentAccount = window.currentAccountId || "main";
        const cleanHandle = HandleUtils.clean(handle); // 尝试在多个账户下查找（当前账户优先，然后是main账户）
        const accountsToTry = [currentAccount];
        if (currentAccount !== "main") {
          accountsToTry.push("main");
        }
        let messagesListData = null;
        let messagesListAccount = null; // 1. 首先尝试从私信列表中查找
        for (const accountId of accountsToTry) {
          const messagesListId = `messagesList_${accountId}`;
          const data = await xDB.xAccountProfiles.get(messagesListId);
          if (data && data.data && data.data.length > 0) {
            messagesListData = data;
            messagesListAccount = accountId;
            break;
          }
        }
        if (!messagesListData) {
          return [];
        }
        // 2. 在私信列表中查找对应句柄的对话
        const conversation = messagesListData.data.find((msg) =>
          HandleUtils.equals(msg.userHandle, handle)
        );
        let conversationId, conversationData;
        if (!conversation) {
          // 3. 如果私信列表中没有，尝试备用查找（直接通过ID格式查找对话数据）
          const possibleIds = [
            `msg_account_${cleanHandle}`,
            `msg_npc_${cleanHandle}`,
            `msg_relationship_${cleanHandle}`,
            cleanHandle,
          ];
          for (const accountId of accountsToTry) {
            for (const possibleId of possibleIds) {
              const testConversationId = `messageConversation_${accountId}_${possibleId}`;
              const testData = await xDB.xAccountProfiles.get(
                testConversationId
              );
              if (testData && testData.data && testData.data.messages) {
                conversationId = testConversationId;
                conversationData = testData;
                break;
              }
            }
            if (conversationData) break;
          }
          if (!conversationData) {
            return [];
          }
        } else {
          // 4. 找到对话ID，读取对话详细消息
          conversationId = `messageConversation_${messagesListAccount}_${conversation.id}`;
          conversationData = await xDB.xAccountProfiles.get(conversationId);
        }
        if (
          !conversationData ||
          !conversationData.data ||
          !conversationData.data.messages
        ) {
          return [];
        }
        // 5. 提取最近50条私信
        const messages = conversationData.data.messages.slice(-50);
        const history = messages.map((msg) => ({
          type: msg.type,
          content: msg.content || "",
          isOwn: msg.isOwn || false,
          time: msg.time || "",
          timestamp: msg.timestamp || "",
          // 保留其他字段供特殊消息类型使用
          amount: msg.amount,
          note: msg.note,
          imageDescription: msg.imageDescription,
          voiceText: msg.voiceText,
          title: msg.title,
          url: msg.url,
          tweet: msg.tweet,
          profile: msg.profile,
        }));
        console.log(`✅ [私信数据] ${handle}: ${history.length} 条记忆`);
        return history;
      } catch (error) {
        console.error(`❌ [私信数据] ${handle}: 读取失败`, error);
        return [];
      }
    },
    // 内部方法：通过句柄获取绑定NPC资料
    async _getNPCProfileByHandle(cleanHandle) {
      try {
        const xDB = getXDB();
        const npcDataId = "xNPCs_global";
        const npcData = await xDB.xNPCs.get(npcDataId);
        const allNPCs = npcData?.npcs || [];
        for (const npc of allNPCs) {
          if (HandleUtils.equals(npc.handle, cleanHandle)) {
            // 🆕 读取X平台私信记忆
            const xMessageHistory = await this._loadXMessageHistory(npc.handle);
            return {
              type: "npc",
              // 基础信息
              name: npc.name,
              handle: npc.handle,
              avatar: npc.avatar,
              bio: "",
              verified: false,
              publicIdentity: "",
              // NPC特有数据
              npcData: {
                personality: npc.personality || "",
                postingHabits: npc.postingHabits || "",
                homepage: npc.homepage || "",
                xMessageHistory: xMessageHistory, // 🆕 X平台私信记忆
              },
              // 原始对象（保留用于兼容性）
              npc: npc,
              // 推文数据
              tweets: [],
              // 关系数据
              relationships: [],
              // 元信息
              _source: "npc",
              _loadedAt: Date.now(),
            };
          }
        }
        return null;
      } catch (error) {
        console.error("[统一资料] 绑定NPC查询失败:", error);
        return null;
      }
    },
    // 内部方法：通过句柄获取关系NPC资料
    async _getRelationshipNPCProfileByHandle(cleanHandle) {
      try {
        const xDB = getXDB();
        const mainDB = getDB(); // 获取所有角色的X资料
        const allXProfiles = await xDB.xCharacterProfiles.toArray();
        const allChats = await mainDB.chats.toArray(); // 遍历所有角色的关系列表
        for (const xProfile of allXProfiles) {
          if (!xProfile.relationships || xProfile.relationships.length === 0)
            continue;
          for (const relationship of xProfile.relationships) {
            if (HandleUtils.equals(relationship.npcHandle, cleanHandle)) {
              // 找到对应的角色数据
              const ownerCharacter = allChats.find(
                (chat) => chat.id === xProfile.characterId
              );
              if (ownerCharacter) {
                // 🆕 读取X平台私信记忆
                const xMessageHistory = await this._loadXMessageHistory(
                  relationship.npcHandle
                );
                return {
                  type: "relationshipNpc",
                  // 基础信息
                  name: relationship.npcName,
                  handle: relationship.npcHandle,
                  avatar:
                    "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
                  bio: "",
                  verified: false,
                  publicIdentity: "",
                  // 关系NPC特有数据
                  relationshipData: {
                    relationshipType: relationship.relationshipType,
                    description: relationship.description || "",
                    ownerCharacterId: ownerCharacter.id,
                    ownerCharacterName: ownerCharacter.name,
                    xMessageHistory: xMessageHistory, // 🆕 X平台私信记忆
                  },
                  // 原始对象（保留用于兼容性）
                  relationship: relationship,
                  ownerCharacter: ownerCharacter,
                  ownerXProfile: xProfile,
                  // 推文数据
                  tweets: [],
                  // 关系数据
                  relationships: [],
                  // 元信息
                  _source: "relationshipNpc",
                  _ownerId: ownerCharacter.id,
                  _loadedAt: Date.now(),
                };
              }
            }
          }
        }
        return null;
      } catch (error) {
        console.error("[统一资料] 关系NPC查询失败:", error);
        return null;
      }
    },
    // 内部方法：创建陌生人模板（支持读取自定义设置）
    async _createStrangerProfile(handle, messageId = null) {
      const cleanHandle = HandleUtils.clean(handle); // 默认头像
      let customAvatar =
        "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg"; // 尝试读取陌生人的自定义设置
      if (messageId) {
        try {
          const xDB = getXDB();
          const currentAccount = window.currentAccountId || "main";
          const strangerSettingsId = `strangerSettings_${currentAccount}_${messageId}`;
          const strangerSettings = await xDB.xAccountProfiles.get(
            strangerSettingsId
          );
          if (strangerSettings && strangerSettings.customAvatar) {
            customAvatar = strangerSettings.customAvatar;
            console.log(`✅ [陌生人资料] 读取到自定义头像: ${customAvatar}`);
          }
        } catch (error) {
          console.error("[陌生人资料] 读取自定义设置失败:", error);
        }
      }
      // 🆕 读取X平台私信记忆
      const xMessageHistory = await this._loadXMessageHistory(
        `@${cleanHandle}`
      );
      return {
        type: "stranger",
        // 基础信息
        name: cleanHandle,
        handle: `@${cleanHandle}`,
        avatar: customAvatar,
        bio: "",
        verified: false,
        publicIdentity: "",
        // 空数据（但包含私信记忆）
        characterData: null,
        accountData: {
          xMessageHistory: xMessageHistory, // 🆕 X平台私信记忆
        },
        tweets: [],
        relationships: [],
        // 元信息
        _source: "stranger",
        _messageId: messageId,
        _loadedAt: Date.now(),
      };
    },
    // 🆕 内部辅助方法：格式化单条私信消息的内容
    _formatMessageContent(msg) {
      if (msg.type === "text") {
        return msg.content || "";
      } else if (msg.type === "image") {
        return msg.isOwn
          ? "[用户发送了图片]"
          : `[图片: ${msg.imageDescription || "图片"}]`;
      } else if (msg.type === "voice") {
        return `[语音: ${msg.voiceText || "语音消息"}]`;
      } else if (msg.type === "sticker") {
        return "[表情包]";
      } else if (msg.type === "transfer") {
        const amount = msg.amount ? `$${msg.amount}` : "";
        const note = msg.note ? ` (${msg.note})` : "";
        return `[转账${amount}${note}]`;
      } else if (msg.type === "link") {
        return `[分享链接: ${msg.title || "链接"}]`;
      } else if (msg.type === "quoteTweet") {
        return `[转发推文: ${msg.tweet?.content || ""}]`;
      } else if (msg.type === "quoteProfile") {
        return `[分享主页: ${msg.profile?.name || ""}]`;
      } else {
        return `[${msg.type}消息]`;
      }
    },
    // 🆕 内部辅助方法：格式化直播间数据为提示词文本
    _formatLiveRoomData(liveRoomData, profileName, profileType = "character") {
      if (!liveRoomData) {
        return { text: "", tokenCount: 0 };
      }

      let promptText = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎤 直播间信息（该${
        profileType === "character" ? "角色" : "账户"
      }的直播间上下文）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

      // 基础直播间信息
      if (liveRoomData.title) {
        promptText += `直播间标题：${liveRoomData.title}\n`;
      }
      if (liveRoomData.description) {
        promptText += `直播间简介：${liveRoomData.description}\n`;
      }
      if (liveRoomData.announcement) {
        promptText += `直播公告：${liveRoomData.announcement}\n`;
      }

      // 直播间性格和主题
      if (liveRoomData.streamerPersonality) {
        promptText += `\n【主播性格】：${liveRoomData.streamerPersonality}\n`;
      }
      if (liveRoomData.contentTheme) {
        promptText += `【直播内容主题】：${liveRoomData.contentTheme}\n`;
      }
      if (liveRoomData.targetAudience) {
        promptText += `【目标观众】：${liveRoomData.targetAudience}\n`;
      }

      // 主播最近发言
      if (
        liveRoomData.danmakuMessages &&
        liveRoomData.danmakuMessages.length > 0
      ) {
        const streamerMessages = liveRoomData.danmakuMessages
          .filter((msg) => msg.isStreamer)
          .slice(-30) // 最近30条主播发言
          .reverse();

        if (streamerMessages.length > 0) {
          promptText += `\n【主播最近发言】（展现主播真实性格和表达方式）：\n`;
          streamerMessages.slice(0, 20).forEach((msg, idx) => {
            const content = msg.content || msg.message || "";
            if (content) {
              const displayContent =
                content.length > 80
                  ? `${content.substring(0, 80)}...`
                  : content;
              promptText += `${idx + 1}. ${displayContent}\n`;
            }
          });
        }

        // 弹幕互动记录
        const recentDanmaku = liveRoomData.danmakuMessages.slice(-30).reverse();
        if (recentDanmaku.length > 0) {
          promptText += `\n【直播间最近互动】（主播与观众的互动氛围）：\n`;
          recentDanmaku.slice(0, 15).forEach((msg) => {
            const sender = msg.isStreamer ? profileName : msg.sender;
            const content = msg.content || msg.message || "";
            if (content && sender) {
              const displayContent =
                content.length > 60
                  ? `${content.substring(0, 60)}...`
                  : content;
              promptText += `${sender}: ${displayContent}\n`;
            }
          });
        }
      }

      promptText += `
⚠️ 重要说明：
- 以上是该${profileType === "character" ? "角色" : "账户"}的直播间上下文信息
- 主播的发言和互动方式能准确反映其真实性格和表达习惯
- 在生成私信、推文、账户主页等内容时，应保持与直播间表现的一致性
- 不要在不合适的场景（如公开推文）中直接提及直播间内的具体互动细节
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

      const tokenCount = TokenUtils.estimateTokens(promptText);
      console.log(
        `📊 [直播] ${profileType} ${profileName}: ~${tokenCount} tokens`
      );
      return { text: promptText, tokenCount };
    },
    // 🆕 内部辅助方法：格式化粉丝团数据为提示词文本
    _formatFanClubData(
      fanClubConfig,
      userMembership,
      profileName,
      profileType = "character"
    ) {
      if (!fanClubConfig) {
        return { text: "", tokenCount: 0 };
      }

      let promptText = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎖️ 粉丝团信息（该${profileType === "character" ? "角色" : "账户"}的粉丝团系统）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

      // 粉丝团基本信息
      promptText += `
📋 粉丝团基本信息：
- 粉丝团名称：${fanClubConfig.clubName || "未设置"}
- 粉丝团简介：${
        fanClubConfig.clubDescription || fanClubConfig.description || "无简介"
      }
`;

      // 粉丝团等级系统
      if (
        fanClubConfig.levelSystem &&
        Array.isArray(fanClubConfig.levelSystem)
      ) {
        promptText += `
🏆 粉丝团等级系统（共 ${fanClubConfig.levelSystem.length} 个等级）：
`;
        // 显示前5级和后5级，中间省略
        const showLevels = [];
        if (fanClubConfig.levelSystem.length <= 10) {
          showLevels.push(...fanClubConfig.levelSystem);
        } else {
          showLevels.push(...fanClubConfig.levelSystem.slice(0, 5));
          showLevels.push({
            level: "...",
            levelName: "...",
            requiredPoints: "...",
            benefit: "（省略中间等级）",
          });
          showLevels.push(...fanClubConfig.levelSystem.slice(-5));
        }

        showLevels.forEach((level) => {
          if (level.level === "...") {
            promptText += `${level.benefit}\n`;
          } else {
            promptText += `LV${level.level} ${level.levelName}：需要${
              level.requiredPoints
            }积分 - ${level.benefit || level.description || "无描述"}\n`;
          }
        });
      }

      // 用户在该粉丝团的会员状态
      if (userMembership) {
        promptText += `
👤 用户在该粉丝团的会员状态：
- ✅ 用户已加入该粉丝团
- 当前等级：LV${userMembership.level || 1}
- 当前积分：${userMembership.points || 0}
- 连续签到：${userMembership.consecutiveDays || 0}天
- 加入时间：${userMembership.joinedAt || "未知"}
- 最后签到：${userMembership.lastCheckIn || "未签到"}
`;

        // 根据用户等级显示对应的等级名称和福利
        if (
          fanClubConfig.levelSystem &&
          Array.isArray(fanClubConfig.levelSystem)
        ) {
          const userLevelData = fanClubConfig.levelSystem.find(
            (l) => l.level === userMembership.level
          );
          if (userLevelData) {
            promptText += `- 等级称号：${userLevelData.levelName}\n`;
            promptText += `- 当前福利：${
              userLevelData.benefit || userLevelData.description || "无描述"
            }\n`;
          }

          // 显示下一等级信息
          const nextLevel = fanClubConfig.levelSystem.find(
            (l) => l.level === userMembership.level + 1
          );
          if (nextLevel) {
            const pointsNeeded =
              nextLevel.requiredPoints - (userMembership.points || 0);
            promptText += `- 距离下一级（LV${nextLevel.level} ${nextLevel.levelName}）还需：${pointsNeeded}积分\n`;
          } else {
            promptText += `- 🎉 已达到最高等级！\n`;
          }
        }
      } else {
        promptText += `
👤 用户在该粉丝团的会员状态：
- ❌ 用户尚未加入该粉丝团
- 用户可以通过签到、送礼、互动等方式加入并升级
`;
      }

      // 主播私联配置（如果存在）
      if (fanClubConfig.fanClubContactConfig) {
        const contactConfig = fanClubConfig.fanClubContactConfig;
        promptText += `
💬 主播粉丝团私联规则：
- 主播是否会主动私联高等级粉丝：${
          contactConfig.willContactPrivately ? "是" : "否"
        }
`;
        if (contactConfig.willContactPrivately) {
          promptText += `- 触发私联的等级门槛：LV${contactConfig.contactLevelThreshold}及以上\n`;
          promptText += `- 被拒绝后是否持续私联：${
            contactConfig.persistAfterRejection ? "是" : "否"
          }\n`;

          if (
            userMembership &&
            userMembership.level >= contactConfig.contactLevelThreshold
          ) {
            promptText += `⚠️ 用户当前等级（LV${userMembership.level}）已达到私联门槛，主播可能会主动私信用户\n`;
          }
        }
      }

      promptText += `
⚠️ 重要说明：
- 粉丝团等级反映了用户对该${
        profileType === "character" ? "角色" : "账户"
      }的支持程度
- 等级越高，说明用户对该${
        profileType === "character" ? "角色" : "账户"
      }的投入越多（时间、金钱、互动）
- 在生成${
        profileType === "character" ? "角色" : "账户"
      }的回复时，应根据用户的粉丝团等级调整亲密度和态度
- 高等级粉丝通常会获得更热情、更特殊的对待
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

      const tokenCount = TokenUtils.estimateTokens(promptText);
      console.log(
        `📊 [粉丝团] ${profileType} ${profileName}: ~${tokenCount} tokens`
      );
      return { text: promptText, tokenCount };
    },
    // 🆕 内部辅助方法：格式化X平台私信记忆为提示词文本
    _formatXMessageHistory(
      xMessageHistory,
      profileName,
      profileType = "character"
    ) {
      if (!xMessageHistory || xMessageHistory.length === 0) {
        return { text: "", tokenCount: 0, messageCount: 0 };
      }
      const startLength = 0;
      let promptText = `
【X平台私信记忆】（该${
        profileType === "character"
          ? "角色"
          : profileType === "account"
          ? "账户"
          : profileType === "npc"
          ? "NPC"
          : profileType === "relationshipNpc"
          ? "关系NPC"
          : "陌生人"
      }与用户在X平台私信中的对话记录${
        profileType === "character" ? "" : "，仅供参考"
      }）：
`;
      const recentXMessages = xMessageHistory.slice(-50);
      let xMemCount = 0;
      for (const msg of recentXMessages) {
        const sender = msg.isOwn ? "用户" : profileName;
        const content = this._formatMessageContent(msg);
        if (content) {
          const displayContent =
            content.length > 80 ? `${content.substring(0, 80)}...` : content;
          promptText += `${sender}: ${displayContent}\n`;
          xMemCount++;
        }
        if (xMemCount >= 50) break;
      }
      // 根据不同类型添加不同的说明
      if (profileType === "character") {
        promptText += `
⚠️ 重要说明：
- 这些是在X平台私信功能中的真实对话记录
- 无论角色是否"认识用户身份"（其他场景的身份），这些X平台对话都是客观存在的
- 根据当前场景（推文/评论/私信）自然使用，不要在公开推文中直接提及私信内容
`;
      } else {
        promptText += `⚠️ 以上是X平台私信对话记录，仅供理解该${
          profileType === "account"
            ? "账户"
            : profileType === "npc"
            ? "NPC"
            : profileType === "relationshipNpc"
            ? "关系NPC"
            : "陌生人"
        }与用户的关系和沟通风格
⚠️ 根据当前场景（推文/评论）自然使用，不要在公开推文中直接提及私信内容
`;
      }
      const tokenCount = TokenUtils.estimateTokens(promptText);
      console.log(
        `📊 [私信] ${profileType} ${profileName}: ${xMemCount}条, ~${tokenCount} tokens`
      );
      return { text: promptText, tokenCount, messageCount: xMemCount };
    },
    // 格式化资料为提示词文本
    formatProfileForPrompt(profile, options = {}) {
      if (!profile) return "";
      const {
        includeType = true,
        includeTweets = true,
        includeRelationships = true,
      } = options;
      let promptText = ""; // 类型标识
      if (includeType) {
        const typeLabels = {
          character: "【角色资料】",
          account: "【账户资料】",
          stranger: "【陌生人资料】",
        };
        promptText += `${typeLabels[profile.type] || "【资料】"}\n`;
      }
      // 🔧 空值保护：确保基本字段存在
      if (!profile.name || !profile.handle) {
        console.warn("⚠️ [格式化资料] profile 缺少必需字段 name 或 handle:", {
          type: profile.type,
          name: profile.name,
          handle: profile.handle,
        });
        return "";
      }
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      // 📱 X平台公开信息（所有X用户都能看到）
      // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      promptText += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📱 X平台公开信息（路人可见）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
X姓名：${profile.name}
X句柄：${profile.handle}
认证状态：${profile.verified ? "已认证" : "未认证"}
${profile.bio ? `X简介：${profile.bio}` : ""}
${profile.publicIdentity ? `公开身份：${profile.publicIdentity}` : ""}
🚨 重要：以上信息是X平台上的公开资料，所有X用户（包括路人、陌生人）都能看到。
路人评论时只能基于这些公开信息，不能提及下方的私密信息！
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`; // 角色特有信息
      if (profile.type === "character" && profile.characterData) {
        const cd = profile.characterData; // 🔧 确保角色关键数据存在
        const originalName = cd.originalName || profile.name || "未知";
        const aiPersona = cd.aiPersona || "无特定人设";
        promptText += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔒 角色私密资料（仅供AI理解角色，路人不知道）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
真实姓名：${originalName}
人设描述：${aiPersona}
⚠️ 隐私规则：
- 真实姓名"${originalName}"是私密信息，路人评论中禁止提及！
- 路人只能称呼X姓名"${profile.name}"或使用句柄"${profile.handle}"
- 只有该角色本人或关系NPC（已绑定的私人关系）才知道真实姓名
- 人设描述仅供AI理解角色性格，路人不知道这些细节
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`; // 🔧 用户身份识别信息
        if (profile.knowsUserIdentity !== undefined) {
          promptText += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👤 用户身份识别
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
该角色${profile.knowsUserIdentity ? "知道" : "不知道"}用户的真实身份
`;
          if (profile.knowsUserIdentity) {
            promptText += `✅ 该角色可以识别用户，回复时应该表现出认识
`;
            if (cd.userPersona && cd.userPersona.trim()) {
              promptText += `
【角色了解的用户信息】（专属用户人设）：
${cd.userPersona}
⚠️ 该角色应该根据这些信息与用户互动
`;
            } else {
              promptText += `⚠️ 该角色尚未设置专属用户人设，按基础认识模式互动
`;
            }
          } else {
            promptText += `❌ 该角色完全不知道用户的真实身份，必须按照陌生人模式回复
⚠️ 不要让角色猜测、暗示或表现出任何对用户的认识
`;
          }
          promptText += `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        }
        // 🆕 X平台私信记忆（无论角色是否认识用户身份，只要有私信记录就显示）
        if (cd.xMessageHistory && cd.xMessageHistory.length > 0) {
          const xMessageResult = this._formatXMessageHistory(
            cd.xMessageHistory,
            profile.name,
            "character"
          );
          promptText += xMessageResult.text;
        }

        // 🆕 直播间数据（如果存在）
        if (profile.liveRoomData) {
          const liveRoomResult = this._formatLiveRoomData(
            profile.liveRoomData,
            profile.name,
            "character"
          );
          promptText += liveRoomResult.text;
        }

        // 🆕 粉丝团数据（如果存在）
        if (profile.fanClubConfig) {
          const fanClubResult = this._formatFanClubData(
            profile.fanClubConfig,
            profile.userFanClubMembership,
            profile.name,
            "character"
          );
          promptText += fanClubResult.text;
        }

        // 记忆信息（只有知道用户身份且有专属人设时才显示）
        if (
          profile.knowsUserIdentity &&
          cd.userPersona &&
          cd.userPersona.trim() &&
          cd.history &&
          cd.history.length > 0
        ) {
          promptText += `
【其他聊天记忆】（与用户在其他场景的对话，仅供参考）：
`;
          const recentHistory = cd.history.slice(-10);
          let memCount = 0;
          for (const msg of recentHistory) {
            // 🔧 空值保护：确保 msg.content 存在
            if (msg.role === "user" && msg.content) {
              const content = String(msg.content); // 确保是字符串
              promptText += `用户: ${content.substring(0, 100)}${
                content.length > 100 ? "..." : ""
              }\n`;
              memCount++;
            } else if (msg.role === "assistant" && msg.content) {
              const content = String(msg.content); // 确保是字符串
              promptText += `${profile.name}: ${content.substring(0, 100)}${
                content.length > 100 ? "..." : ""
              }\n`;
              memCount++;
            }
            if (memCount >= 10) break;
          }
          promptText += `⚠️ 以上记忆仅供理解角色与用户关系，根据当前场景自然使用
`;
        }
        // 长期记忆
        if (cd.longTermMemory && cd.longTermMemory.length > 0) {
          promptText += `
【长期记忆】（仅供AI参考，路人不知道）：
`;
          cd.longTermMemory.forEach((mem, idx) => {
            promptText += `${idx + 1}. ${mem.content}\n`;
          });
        }
      }
      // 账户特有信息
      if (profile.type === "account" && profile.accountData) {
        const ad = profile.accountData;
        promptText += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔒 账户资料（仅供AI理解，路人不知道）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
账户类型：${ad.accountType}
${ad.personality ? `人设描述：${ad.personality}` : ""}
${ad.postingHabits ? `发帖习惯：${ad.postingHabits}` : ""}
${ad.followersCount ? `关注者：${ad.followersCount}` : ""}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`; // 🆕 X平台私信记忆（如果有）
        if (ad.xMessageHistory && ad.xMessageHistory.length > 0) {
          const xMessageResult = this._formatXMessageHistory(
            ad.xMessageHistory,
            profile.name,
            "account"
          );
          promptText += xMessageResult.text;
        }

        // 🆕 直播间数据（如果存在）
        if (profile.liveRoomData) {
          const liveRoomResult = this._formatLiveRoomData(
            profile.liveRoomData,
            profile.name,
            "account"
          );
          promptText += liveRoomResult.text;
        }

        // 🆕 粉丝团数据（如果存在）
        if (profile.fanClubConfig) {
          const fanClubResult = this._formatFanClubData(
            profile.fanClubConfig,
            profile.userFanClubMembership,
            profile.name,
            "account"
          );
          promptText += fanClubResult.text;
        }
      }
      // 绑定NPC特有信息
      if (profile.type === "npc" && profile.npcData) {
        const nd = profile.npcData;
        promptText += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔒 NPC资料（仅供AI理解角色，路人不知道）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
${nd.personality ? `人设描述：${nd.personality}` : ""}
${nd.postingHabits ? `发帖习惯：${nd.postingHabits}` : ""}
${nd.homepage ? `主页链接：${nd.homepage}` : ""}
⚠️ 该NPC是全局绑定的虚拟角色，按照人设描述进行互动
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`; // 🆕 X平台私信记忆（如果有）
        if (nd.xMessageHistory && nd.xMessageHistory.length > 0) {
          const xMessageResult = this._formatXMessageHistory(
            nd.xMessageHistory,
            profile.name,
            "npc"
          );
          promptText += xMessageResult.text;
        }
      }
      // 关系NPC特有信息
      if (profile.type === "relationshipNpc" && profile.relationshipData) {
        const rd = profile.relationshipData;
        promptText += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔒 关系NPC资料（仅供AI理解角色，路人不知道）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
关系类型：${rd.relationshipType}
${rd.description ? `关系描述：${rd.description}` : ""}
所属角色：${rd.ownerCharacterName}（该NPC是 ${
          rd.ownerCharacterName
        } 的专属关系角色）
⚠️ 该NPC与角色 ${rd.ownerCharacterName} 有绑定关系，互动时应体现这种关系
⚠️ 该NPC只与其所属角色有特殊关系，与其他角色/用户按照普通关系互动
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`; // 🆕 X平台私信记忆（如果有）
        if (rd.xMessageHistory && rd.xMessageHistory.length > 0) {
          const xMessageResult = this._formatXMessageHistory(
            rd.xMessageHistory,
            profile.name,
            "relationshipNpc"
          );
          promptText += xMessageResult.text;
        }
      }
      // 陌生人特有提示
      if (profile.type === "stranger") {
        promptText += `
⚠️ 该用户是陌生人（未在系统中绑定），回复应该自然真实，符合普通X平台用户的特点
⚠️ 如果没有特殊设定，按照一般性格进行回复
`; // 🆕 X平台私信记忆（如果有）
        if (
          profile.accountData &&
          profile.accountData.xMessageHistory &&
          profile.accountData.xMessageHistory.length > 0
        ) {
          const xMessageResult = this._formatXMessageHistory(
            profile.accountData.xMessageHistory,
            profile.name,
            "stranger"
          );
          promptText += xMessageResult.text;
        }
      }
      // 推文信息
      if (includeTweets && profile.tweets && profile.tweets.length > 0) {
        promptText += `\n【最近推文】（参考发帖风格）：\n`;
        const recentTweets = profile.tweets.slice(0, 3);
        recentTweets.forEach((tweet, idx) => {
          promptText += `${idx + 1}. "${tweet.content}"\n`;
          promptText += ` 互动：${tweet.stats?.likes || 0}喜欢，${
            tweet.stats?.comments || 0
          }评论\n`;
        });
      }
      // 关系信息
      if (
        includeRelationships &&
        profile.relationships &&
        profile.relationships.length > 0
      ) {
        promptText += `\n【已绑定关系】：\n`;
        profile.relationships.forEach((rel) => {
          promptText += `- ${rel.npcName} (${rel.npcHandle}): ${rel.relationshipType}`;
          if (rel.description) promptText += ` | ${rel.description}`;
          promptText += "\n";
        });
      }
      return promptText;
    },
    // 批量获取多个资料
    async getBatchProfiles(handles, options = {}) {
      if (!Array.isArray(handles) || handles.length === 0) return [];
      const profiles = await Promise.all(
        handles.map((handle) => this.getUnifiedProfile(handle, options))
      );
      return profiles.filter((p) => p !== null);
    },
    // ========== 用户身份冒用筛选工具 ==========
    // 删除所有冒充用户身份的内容
    async filterUserImpersonation(data, userHandle = null, userName = null) {
      console.log("═══════════════════════════════════════");
      console.log("🚫 [身份筛选] 开始检查用户身份冒用...");

      // 🔧 修复：如果未提供用户信息，从数据库实时读取
      let actualUserHandle = userHandle;
      let actualUserName = userName;

      if (!actualUserHandle || !actualUserName) {
        console.log("🔍 [身份筛选] 未提供用户信息，从数据库读取最新数据...");
        try {
          const xDB = getXDB();
          const currentAccountId = window.currentAccountId || "main";
          const userProfile = await xDB.xUserProfile.get(currentAccountId);

          if (userProfile) {
            actualUserHandle = userProfile.handle;
            actualUserName = userProfile.name;
            console.log(
              `✅ [身份筛选] 已从数据库读取用户信息: ${actualUserName} (@${actualUserHandle})`
            );
          } else {
            console.warn("⚠️ [身份筛选] 数据库中未找到用户资料，跳过筛选");
            console.log("═══════════════════════════════════════");
            return data;
          }
        } catch (error) {
          console.error("❌ [身份筛选] 读取用户资料失败:", error);
          console.log("═══════════════════════════════════════");
          return data;
        }
      } else {
        console.log(
          `📋 [身份筛选] 使用提供的用户信息: ${actualUserName} (@${actualUserHandle})`
        );
      }

      const cleanUserHandle = HandleUtils.clean(actualUserHandle);
      const cleanUserName = actualUserName.toLowerCase();
      let removedCount = 0; // 检查用户对象是否冒用了用户身份
      const isUserImpersonation = (user) => {
        if (!user || !user.handle) return false;

        // 句柄完全匹配
        if (HandleUtils.equals(user.handle, actualUserHandle)) {
          console.warn(
            `  🚫 检测到句柄冒用: @${user.handle} (假扮: ${actualUserName})`
          );
          return true;
        }

        // 姓名完全匹配
        const cleanName = (user.name || "").toLowerCase();
        if (cleanName === cleanUserName) {
          console.warn(
            `  🚫 检测到姓名冒用: ${user.name} (假扮: ${actualUserName})`
          );
          return true;
        }

        return false;
      }; // 筛选推文数组
      const filterTweets = (tweets) => {
        if (!Array.isArray(tweets)) return tweets;
        return tweets.filter((tweet) => {
          // 检查推文作者是否冒用（这是真正的冒用：假扮用户发推文）
          if (isUserImpersonation(tweet.user)) {
            console.warn(
              `  🗑️ 删除冒用推文: "${(tweet.content || "").substring(
                0,
                50
              )}..."`
            );
            removedCount++;
            return false;
          }
          // 筛选评论（删除假扮用户的评论）
          if (tweet.comments && Array.isArray(tweet.comments)) {
            tweet.comments = filterComments(tweet.comments);
          }
          // ⚠️ 不删除引用推文中的用户内容
          // 引用用户的推文是合法的，只有假扮用户才是冒用
          // 如果 quotedTweet.user 是用户，这是正常的转发引用，不是冒用
          return true;
        });
      }; // 筛选评论数组（递归）
      const filterComments = (comments) => {
        if (!Array.isArray(comments)) return comments;
        return comments.filter((comment) => {
          // 检查评论作者
          if (isUserImpersonation(comment.user)) {
            console.warn(
              `  🗑️ 删除冒用评论: "${(comment.content || "").substring(
                0,
                50
              )}..."`
            );
            removedCount++;
            return false;
          }
          // 递归筛选回复
          if (comment.replies && Array.isArray(comment.replies)) {
            comment.replies = filterComments(comment.replies);
          }
          return true;
        });
      }; // 处理不同的数据结构
      if (data.forYouTweets) {
        data.forYouTweets = filterTweets(data.forYouTweets);
      }
      if (data.followingTweets) {
        data.followingTweets = filterTweets(data.followingTweets);
      }
      if (data.tweets && Array.isArray(data.tweets)) {
        data.tweets = filterTweets(data.tweets);
      }
      if (data.comments && Array.isArray(data.comments)) {
        data.comments = filterComments(data.comments);
      }
      if (data.replies && Array.isArray(data.replies)) {
        data.replies = filterComments(data.replies);
      }
      // 处理 Mentions 数据
      if (data.likes && Array.isArray(data.likes)) {
        data.likes = data.likes.filter((like) => {
          const allUsers = like.users || [];
          like.users = allUsers.filter((user) => !isUserImpersonation(user));
          if (like.users.length === 0) {
            console.warn(`  🗑️ 删除全冒用点赞通知`);
            removedCount++;
            return false;
          }
          return true;
        });
      }
      if (data.retweets && Array.isArray(data.retweets)) {
        data.retweets = data.retweets.filter((retweet) => {
          // 检查转推者
          if (isUserImpersonation(retweet.user)) {
            console.warn(`  🗑️ 删除冒用转推通知`);
            removedCount++;
            return false;
          }
          // 筛选转推的评论
          if (retweet.comments) {
            retweet.comments = filterComments(retweet.comments);
          }
          return true;
        });
      }
      console.log("═══════════════════════════════════════");
      if (removedCount > 0) {
        console.log(
          `✅ [身份筛选] 筛选完成，共删除 ${removedCount} 个冒用身份的内容`
        );
      } else {
        console.log(`✅ [身份筛选] 筛选完成，未检测到身份冒用`);
      }
      console.log("═══════════════════════════════════════");

      return data;
    },
    // ========== 头像强制修正工具 ==========
    // 🆕 内部辅助方法：构建头像映射表
    async _buildAvatarMap() {
      const xDB = getXDB();
      const mainDB = getDB();
      const avatarMap = new Map();
      const defaultAvatar =
        "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg";

      console.log("🔍 [头像修正] 开始从数据库加载最新头像数据...");

      // 辅助函数：添加头像映射
      const addAvatarMapping = (handle, avatar, type, name) => {
        const cleanHandle = HandleUtils.clean(handle);
        if (!cleanHandle) return;
        avatarMap.set(cleanHandle, { avatar, type, name });
      };

      // 🔧 修复：从数据库实时读取用户头像（最高优先级）
      try {
        const currentAccountId = window.currentAccountId || "main";
        const userProfile = await xDB.xUserProfile.get(currentAccountId);

        if (userProfile?.handle && userProfile?.avatar) {
          addAvatarMapping(
            userProfile.handle,
            userProfile.avatar,
            "user",
            userProfile.name
          );
          console.log(
            `👤 [头像修正] 已加载用户头像（数据库）: ${userProfile.name} (@${
              userProfile.handle
            }) -> ${userProfile.avatar.substring(0, 50)}...`
          );
        } else {
          console.warn("⚠️ [头像修正] 未找到用户资料或头像为空");
        }
      } catch (error) {
        console.error("❌ [头像修正] 读取用户头像失败:", error);
      }
      // 加载所有角色的X资料
      const allXProfiles = await xDB.xCharacterProfiles.toArray();
      let characterCount = 0;
      let relationshipNpcCount = 0;

      for (const xProfile of allXProfiles) {
        if (xProfile.xHandle && xProfile.xAvatar) {
          addAvatarMapping(
            xProfile.xHandle,
            xProfile.xAvatar,
            "character",
            xProfile.xName
          );
          characterCount++;
        }

        // 加载关系NPC（使用默认头像）
        if (xProfile.relationships?.length > 0) {
          for (const rel of xProfile.relationships) {
            if (rel.npcHandle) {
              addAvatarMapping(
                rel.npcHandle,
                defaultAvatar,
                "relationshipNpc",
                rel.npcName
              );
              relationshipNpcCount++;
            }
          }
        }
      }

      if (characterCount > 0) {
        console.log(`🎭 [头像修正] 已加载 ${characterCount} 个角色头像`);
      }
      if (relationshipNpcCount > 0) {
        console.log(
          `👥 [头像修正] 已加载 ${relationshipNpcCount} 个关系NPC头像（默认）`
        );
      }
      // 加载所有绑定NPC
      const npcDataId = "xNPCs_global";
      const npcData = await xDB.xNPCs.get(npcDataId);
      const allNPCs = npcData?.npcs || [];
      let npcCount = 0;

      for (const npc of allNPCs) {
        if (npc.handle && npc.avatar) {
          addAvatarMapping(npc.handle, npc.avatar, "npc", npc.name);
          npcCount++;
        }
      }

      if (npcCount > 0) {
        console.log(`🤖 [头像修正] 已加载 ${npcCount} 个绑定NPC头像`);
      }
      // 加载所有陌生人的自定义头像
      const allProfiles = await xDB.xAccountProfiles.toArray();
      const strangerSettings = allProfiles.filter(
        (item) =>
          item.handle?.startsWith("strangerSettings_") && item.customAvatar
      );
      const messagesLists = allProfiles.filter(
        (item) => item.name === "messagesList"
      );

      let strangerCount = 0;
      for (const setting of strangerSettings) {
        if (!setting.messageId) continue;

        // 优化：在所有私信列表中查找该陌生人
        let found = false;
        for (const msgList of messagesLists) {
          if (!msgList.data || !Array.isArray(msgList.data)) continue;
          const stranger = msgList.data.find(
            (msg) => msg.id === setting.messageId
          );

          if (stranger?.userHandle) {
            addAvatarMapping(
              stranger.userHandle,
              setting.customAvatar,
              "stranger",
              stranger.userName || "陌生人"
            );
            strangerCount++;
            found = true;
            break;
          }
        }

        if (!found) {
          console.warn(
            `⚠️ [头像修正] 陌生人设置存在但未找到对应私信: ${setting.messageId}`
          );
        }
      }

      if (strangerCount > 0) {
        console.log(`👻 [头像修正] 已加载 ${strangerCount} 个陌生人自定义头像`);
      }

      console.log(
        `✅ [头像修正] 头像映射表构建完成，共 ${avatarMap.size} 个用户`
      );
      return avatarMap;
    },
    // 强制修正所有用户头像，确保遵守头像规则
    async enforceAvatarRules(data, userHandle = null) {
      console.log("═══════════════════════════════════════");
      console.log("🔧 [头像修正] 开始修正头像数据...");
      console.log("═══════════════════════════════════════");

      const avatarMap = await this._buildAvatarMap();
      const defaultAvatar =
        "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg";

      // 统计修正的数量（按类型分类）
      const fixStats = {
        user: 0,
        character: 0,
        npc: 0,
        relationshipNpc: 0,
        stranger: 0,
        passerby: 0, // 路人
        total: 0,
      };
      const fixUser = (user) => {
        if (!user || !user.handle) return;
        const cleanHandle = HandleUtils.clean(user.handle);

        // 检查是否是已知用户/角色/NPC/陌生人
        if (avatarMap.has(cleanHandle)) {
          const correctInfo = avatarMap.get(cleanHandle);
          if (user.avatar !== correctInfo.avatar) {
            const typeLabel =
              {
                user: "用户",
                character: "角色",
                npc: "NPC",
                relationshipNpc: "关系NPC",
                stranger: "陌生人",
              }[correctInfo.type] || correctInfo.type;

            console.log(`  🔄 ${typeLabel}: ${user.name} (@${cleanHandle})`);
            console.log(`     旧头像: ${user.avatar.substring(0, 60)}...`);
            console.log(
              `     新头像: ${correctInfo.avatar.substring(0, 60)}...`
            );

            user.avatar = correctInfo.avatar;
            fixStats[correctInfo.type]++;
            fixStats.total++;
          }
        } else {
          // 未知用户（路人），强制使用默认头像
          if (user.avatar !== defaultAvatar) {
            console.log(
              `  🔄 路人: ${user.name} (@${cleanHandle}) -> 默认头像`
            );
            user.avatar = defaultAvatar;
            fixStats.passerby++;
            fixStats.total++;
          }
        }
      }; // 3. 递归修正所有用户对象
      const fixDataRecursively = (obj) => {
        if (!obj || typeof obj !== "object") return; // 如果是数组，递归处理每个元素
        if (Array.isArray(obj)) {
          obj.forEach((item) => fixDataRecursively(item));
          return;
        }
        // 如果有user字段，修正它
        if (obj.user && obj.user.handle) {
          fixUser(obj.user);
        }
        // 🎯 粉丝群消息格式：修正 senderHandle 和 senderAvatar
        if (obj.senderHandle && obj.senderAvatar) {
          const cleanHandle = HandleUtils.clean(obj.senderHandle);
          if (avatarMap.has(cleanHandle)) {
            const correctInfo = avatarMap.get(cleanHandle);
            if (obj.senderAvatar !== correctInfo.avatar) {
              const typeLabel =
                {
                  user: "用户",
                  character: "角色",
                  npc: "NPC",
                  relationshipNpc: "关系NPC",
                  stranger: "陌生人",
                }[correctInfo.type] || correctInfo.type;

              console.log(
                `  🔄 ${typeLabel}[粉丝群]: ${obj.senderName} (@${cleanHandle})`
              );
              console.log(
                `     旧头像: ${obj.senderAvatar.substring(0, 60)}...`
              );
              console.log(
                `     新头像: ${correctInfo.avatar.substring(0, 60)}...`
              );

              obj.senderAvatar = correctInfo.avatar;
              fixStats[correctInfo.type]++;
              fixStats.total++;
            }
          } else {
            // 未知用户（路人），强制使用默认头像
            if (obj.senderAvatar !== defaultAvatar) {
              console.log(
                `  🔄 路人[粉丝群]: ${obj.senderName} (@${cleanHandle}) -> 默认头像`
              );
              obj.senderAvatar = defaultAvatar;
              fixStats.passerby++;
              fixStats.total++;
            }
          }
        }
        // 递归处理所有属性
        for (const key in obj) {
          if (obj.hasOwnProperty(key) && typeof obj[key] === "object") {
            fixDataRecursively(obj[key]);
          }
        }
      };

      // 4. 开始修正
      fixDataRecursively(data);

      // 5. 输出修正统计
      console.log("═══════════════════════════════════════");
      if (fixStats.total > 0) {
        console.log(
          `✅ [头像修正] 修正完成，共修正 ${fixStats.total} 个头像：`
        );
        if (fixStats.user > 0) console.log(`   👤 用户: ${fixStats.user} 个`);
        if (fixStats.character > 0)
          console.log(`   🎭 角色: ${fixStats.character} 个`);
        if (fixStats.npc > 0) console.log(`   🤖 NPC: ${fixStats.npc} 个`);
        if (fixStats.relationshipNpc > 0)
          console.log(`   👥 关系NPC: ${fixStats.relationshipNpc} 个`);
        if (fixStats.stranger > 0)
          console.log(`   👻 陌生人: ${fixStats.stranger} 个`);
        if (fixStats.passerby > 0)
          console.log(`   🚶 路人: ${fixStats.passerby} 个`);
      } else {
        console.log(`✅ [头像修正] 所有头像都正确，无需修正`);
      }
      console.log("═══════════════════════════════════════");

      return data;
    },
    // 🔧 JSON修复工具 - 尝试修复AI返回的常见JSON格式错误
    repairJSON(jsonString) {
      console.log("🔧 [JSON修复] 开始尝试修复JSON格式错误...");

      if (!jsonString || typeof jsonString !== "string") {
        console.error("❌ [JSON修复] 输入不是有效的字符串");
        return null;
      }

      let repairedString = jsonString;
      let fixCount = 0;

      try {
        // 1. 清理JSON外部的代码块标记和多余文字
        repairedString = repairedString
          .replace(/^[\s\S]*?```json\s*/i, "") // 移除开头的```json
          .replace(/```\s*[\s\S]*$/i, "") // 移除结尾的```及其后的内容
          .replace(/^[^{\[]*/, "") // 移除JSON开始前的非JSON字符
          .replace(/[^}\]]*$/, "") // 移除JSON结束后的非JSON字符
          .trim();

        // 2. 修复对象/数组末尾的多余逗号
        const trailingCommaPattern = /,(\s*[}\]])/g;
        if (trailingCommaPattern.test(repairedString)) {
          repairedString = repairedString.replace(trailingCommaPattern, "$1");
          fixCount++;
          console.log("✅ [JSON修复] 已移除末尾多余逗号");
        }

        // 3. 修复未转义的换行符（在字符串值中）
        const unescapedNewlinePattern = /("(?:\\.|[^"\\])*?")/g;
        repairedString = repairedString.replace(
          unescapedNewlinePattern,
          (match) => {
            if (match.includes("\n") && !match.includes("\\n")) {
              fixCount++;
              return match.replace(/\n/g, "\\n");
            }
            return match;
          }
        );

        // 4. 尝试修复缺少引号的键名（简单情况）
        const unquotedKeyPattern = /([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g;
        if (unquotedKeyPattern.test(repairedString)) {
          repairedString = repairedString.replace(
            unquotedKeyPattern,
            '$1"$2":'
          );
          fixCount++;
          console.log("✅ [JSON修复] 已为键名添加引号");
        }

        // 5. 修复单引号（替换为双引号）
        // 注意：这个修复比较激进，可能会误伤字符串内容中的单引号
        const singleQuotePattern = /'/g;
        if (repairedString.includes("'")) {
          // 只在疑似键值对的地方替换单引号
          repairedString = repairedString.replace(/:\s*'([^']*?)'/g, ': "$1"');
          repairedString = repairedString.replace(
            /{\s*'([^']*?)'\s*:/g,
            '{"$1":'
          );
          fixCount++;
          console.log("✅ [JSON修复] 已替换部分单引号为双引号");
        }

        // 6. 修复未转义的内部引号（在字符串值中）
        // 例如: "content": "他说"你好""  -> "content": "他说\"你好\""
        repairedString = repairedString.replace(
          /"([^"]*)":\s*"([^"]*)"/g,
          (match, key, value) => {
            // 检查value中是否有未转义的引号（通过检查\"的数量）
            const escapedQuotes = (value.match(/\\"/g) || []).length;
            const totalQuotes = (value.match(/"/g) || []).length;

            if (totalQuotes > escapedQuotes) {
              // 有未转义的引号，尝试修复
              const fixedValue = value.replace(/(?<!\\)"/g, '\\"');
              fixCount++;
              return `"${key}": "${fixedValue}"`;
            }
            return match;
          }
        );

        // 7. 尝试验证修复后的JSON
        try {
          JSON.parse(repairedString);
          if (fixCount > 0) {
            console.log(
              `✅ [JSON修复] 成功修复 ${fixCount} 处错误，JSON现在有效`
            );
          } else {
            console.log("ℹ️ [JSON修复] JSON原本就是有效的，无需修复");
          }
          return repairedString;
        } catch (parseError) {
          // 8. 如果还是无法解析，尝试更激进的修复
          console.warn("⚠️ [JSON修复] 基础修复后仍无法解析，尝试深度修复...");

          // 移除所有控制字符（除了\n, \r, \t）
          repairedString = repairedString.replace(
            /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g,
            ""
          );

          // 尝试修复常见的数组/对象不匹配
          const openBraces = (repairedString.match(/{/g) || []).length;
          const closeBraces = (repairedString.match(/}/g) || []).length;
          const openBrackets = (repairedString.match(/\[/g) || []).length;
          const closeBrackets = (repairedString.match(/\]/g) || []).length;

          if (openBraces > closeBraces) {
            repairedString += "}".repeat(openBraces - closeBraces);
            console.log(
              `✅ [JSON修复] 添加了 ${openBraces - closeBraces} 个缺失的 }`
            );
            fixCount++;
          }
          if (openBrackets > closeBrackets) {
            repairedString += "]".repeat(openBrackets - closeBrackets);
            console.log(
              `✅ [JSON修复] 添加了 ${openBrackets - closeBrackets} 个缺失的 ]`
            );
            fixCount++;
          }

          // 最后一次验证
          try {
            JSON.parse(repairedString);
            console.log(
              `✅ [JSON修复] 深度修复成功，共修复 ${fixCount} 处错误`
            );
            return repairedString;
          } catch (finalError) {
            console.error(
              "❌ [JSON修复] 修复失败，JSON仍然无效:",
              finalError.message
            );
            console.error(
              "修复后的内容:",
              repairedString.substring(0, 500) + "..."
            );
            return null;
          }
        }
      } catch (error) {
        console.error("❌ [JSON修复] 修复过程中发生错误:", error);
        return null;
      }
    },
    // 获取适用的世界书内容
    async getApplicableWorldBooks(scene, options = {}) {
      try {
        const xDB = getXDB(); // 🔧 从全局设置读取世界书（所有账户共享）
        const globalSettings = await xDB.xSettings.get("globalWorldBooks");
        if (
          !globalSettings ||
          !globalSettings.worldBooks ||
          globalSettings.worldBooks.length === 0
        ) {
          console.log(`🔍 [世界书] 未找到全局世界书数据`);
          return "";
        }
        console.log(
          `🔍 [世界书] 当前场景: ${scene}, 总世界书数: ${globalSettings.worldBooks.length}`
        );
        const { boundCharacters = [] } = options; // 筛选适用的世界书
        const applicableBooks = globalSettings.worldBooks.filter((book) => {
          const hasSceneBinding = book.scenes && book.scenes.length > 0; // 是否绑定了场景
          const hasTargetBinding =
            book.targetType && book.targetType !== "none"; // 是否绑定了目标
          // 真正的闲置状态：既没有场景绑定，也没有目标绑定
          const isTrulyIdle = !hasSceneBinding && !hasTargetBinding;
          if (isTrulyIdle) {
            console.log(`⏸️ [世界书] "${book.name}" - 闲置状态，跳过应用`);
            return false;
          }
          const isMessagesScene = scene === "messages"; // 私信详情页
          // 【指定角色】：该角色出现的任何地方都使用，无视场景
          if (book.targetType === "specific" && book.selectedCharacters) {
            const applicable =
              boundCharacters &&
              boundCharacters.some((charId) =>
                book.selectedCharacters.includes(charId)
              );
            console.log(
              `${applicable ? "✅" : "❌"} [世界书] "${
                book.name
              }" - 指定角色 (当前: [${boundCharacters.join(
                ", "
              )}], 需要: [${book.selectedCharacters.join(", ")}])`
            );
            return applicable;
          }
          // 【私信详情页场景】：通过绑定目标（全局对话/仅角色对话）判断
          if (isMessagesScene) {
            // 如果绑定了场景（且不包含全局），则不适用于私信场景
            if (hasSceneBinding && !book.scenes.includes("global")) {
              console.log(
                `❌ [世界书] "${
                  book.name
                }" - 私信场景但绑定了其他场景 (${book.scenes.join(", ")})`
              );
              return false;
            }
            // 如果包含全局场景，直接适用
            if (book.scenes && book.scenes.includes("global")) {
              console.log(
                `✅ [世界书] "${book.name}" - 全局场景，适用于所有场景`
              );
              return true;
            }
            // 全局对话：所有私信详情页
            if (book.targetType === "all") {
              console.log(
                `✅ [世界书] "${book.name}" - 全局对话，适用于所有私信`
              );
              return true;
            }
            // 仅角色对话：所有角色私信详情页
            if (book.targetType === "characterOnly") {
              const applicable = boundCharacters && boundCharacters.length > 0;
              console.log(
                `${applicable ? "✅" : "❌"} [世界书] "${
                  book.name
                }" - 仅角色对话 (当前角色数: ${boundCharacters.length})`
              );
              return applicable;
            }
            console.log(
              `❌ [世界书] "${book.name}" - 私信场景但目标类型不适用`
            );
            return false;
          }
          // 【其他场景】：必须检查场景绑定
          if (!hasSceneBinding) {
            console.log(`❌ [世界书] "${book.name}" - 非私信场景且未绑定场景`);
            return false;
          }
          // 检查场景是否匹配
          const sceneMatches =
            book.scenes.includes("global") || book.scenes.includes(scene);
          if (!sceneMatches) {
            console.log(
              `❌ [世界书] "${
                book.name
              }" - 场景不匹配 (需要: ${book.scenes.join(", ")}, 当前: ${scene})`
            );
            return false;
          }
          console.log(
            `✅ [世界书] "${book.name}" - 场景匹配 (${book.scenes.join(", ")})`
          ); // 场景匹配后，如果是全局场景，直接适用
          if (book.scenes.includes("global")) {
            console.log(
              `✅ [世界书] "${book.name}" - 全局场景，无需检查目标类型`
            );
            return true;
          }
          // 其他场景需要检查目标类型
          if (book.targetType === "all") {
            console.log(`✅ [世界书] "${book.name}" - 目标: 全局对话，适用`);
            return true;
          } else if (book.targetType === "characterOnly") {
            const applicable = boundCharacters && boundCharacters.length > 0;
            console.log(
              `${applicable ? "✅" : "❌"} [世界书] "${
                book.name
              }" - 目标: 仅角色 (角色数: ${boundCharacters.length})`
            );
            return applicable;
          } else if (book.targetType === "none") {
            // targetType为none但有场景绑定，也应该适用（只要场景匹配）
            console.log(
              `✅ [世界书] "${book.name}" - 场景绑定，无特定目标限制`
            );
            return true;
          }
          console.log(
            `❌ [世界书] "${book.name}" - 未知目标类型: ${book.targetType}`
          );
          return false;
        }); // 合并世界书内容
        if (applicableBooks.length === 0) {
          console.log(`🔍 [世界书] 没有适用的世界书`);
          return "";
        }
        console.log(
          `✅ [世界书] 找到 ${
            applicableBooks.length
          } 个适用的世界书: ${applicableBooks.map((b) => b.name).join(", ")}`
        );
        let worldBooksContent =
          "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n📚 世界书（额外知识库）📚\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n";
        applicableBooks.forEach((book) => {
          worldBooksContent += `\n【${book.name}】\n${book.content}\n`;
        });
        return worldBooksContent;
      } catch (error) {
        console.error("获取世界书内容失败:", error);
        return "";
      }
    },
    // 构建角色关系信息
    async buildCharacterRelationships(boundCharacters, currentAccountId) {
      if (!boundCharacters || boundCharacters.length === 0) return "";
      try {
        const xDB = getXDB();
        const currentAccount = currentAccountId || "main";
        const dataId = `xCharacterRelationships_${currentAccount}`; // 加载角色关系数据
        const relationshipRecord = await xDB.xCharacterRelationships.get(
          dataId
        );
        if (!relationshipRecord || !relationshipRecord.data) {
          return "";
        }
        const relationshipData = relationshipRecord.data;
        const links = relationshipData.links || [];
        if (links.length === 0) {
          return "";
        }
        // 获取角色名称和X资料映射
        const mainDB = getDB();
        const allChats = await mainDB.chats.toArray();
        const allXProfiles = await xDB.xCharacterProfiles.toArray();
        const charMap = new Map();
        const xProfileMap = new Map();
        allChats.forEach((chat) => {
          if (!chat.isGroup) {
            charMap.set(chat.id, chat.name);
          }
        });
        allXProfiles.forEach((profile) => {
          xProfileMap.set(profile.characterId, profile);
        }); // 构建关系信息
        let relationshipsInfo = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💞 角色关系网络（角色之间的关系）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🚨 重要提示：以下是已绑定角色彼此之间的关系，这些关系与用户无关！
- 用户是独立的个体，不要将任何角色误认为用户
- 这些关系描述的是角色A与角色B之间的互动，而非用户参与的关系
`;
        links.forEach((link, index) => {
          const charAName = charMap.get(link.charA) || "未知角色A";
          const charBName = charMap.get(link.charB) || "未知角色B";
          const xProfileA = xProfileMap.get(link.charA);
          const xProfileB = xProfileMap.get(link.charB);
          relationshipsInfo += `【角色关系 ${
            index + 1
          }】（角色之间的关系，与用户无关）\n`; // 角色A的基本身份信息
          relationshipsInfo += `- 角色A：${charAName}\n`;
          if (xProfileA) {
            relationshipsInfo += ` X平台身份：${xProfileA.xName} (${xProfileA.xHandle})\n`;
          }
          // 角色B的基本身份信息
          relationshipsInfo += `- 角色B：${charBName}\n`;
          if (xProfileB) {
            relationshipsInfo += ` X平台身份：${xProfileB.xName} (${xProfileB.xHandle})\n`;
          }
          relationshipsInfo += `- ${charAName}对${charBName}的关系：${
            link.relationshipAtoB || "未设置"
          }\n`;
          relationshipsInfo += `- ${charBName}对${charAName}的关系：${
            link.relationshipBtoA || "未设置"
          }\n`;
          if (link.story && link.story.trim()) {
            relationshipsInfo += `- 关系情节：${link.story}\n`;
          }
          relationshipsInfo += `\n`;
        });
        relationshipsInfo += `
【角色关系互动规则】：
🚨 核心原则：这些是角色之间的关系，不要与用户关系混淆！
1. 角色互动对象识别：
- 当角色A与角色B互动时，使用上述列出的X平台身份（xName和xHandle）
- 绝对不要将角色B误认为用户
- 用户有独立的用户名和句柄，不要与角色身份混淆
2. 互动频率和类型根据关系亲密度决定：
- 亲密关系（情侣、挚友、家人等）：互动频率较高（30-50%），可以亲昵称呼、开玩笑
- 普通关系（朋友、同事、熟人等）：互动频率中等（15-30%），保持礼貌友好
- 紧张关系（竞争、冷战、敌对等）：互动频率较低（5-15%），可能带有暗讽、针锋相对
3. 互动内容要符合关系设定和情节背景
4. 避免强行制造互动，保持自然真实
5. 如果关系情节中有具体故事，可以在互动中体现相关细节
6. 🚨 再次强调：所有上述关系都是"角色↔角色"的关系，不是"角色↔用户"的关系！
`;
        return relationshipsInfo;
      } catch (error) {
        console.error("构建角色关系信息失败:", error);
        return "";
      }
    },
  }; // HTML模板生成工具 - 简化重复的DOM创建
  const TemplateBuilders = {
    // 构建角色选择项模板
    buildCharacterItem(character, isChecked = false) {
      const itemId = `character-item-${character.id}`;
      const avatarId = `character-avatar-${character.id}`;
      setTimeout(() => {
        // 添加事件处理器
        const item = document.getElementById(itemId);
        const avatar = document.getElementById(avatarId);
        if (item) {
          EventUtils.addHoverEffect(
            item,
            { backgroundColor: "rgba(255,255,255,0.05)" },
            { backgroundColor: "transparent" }
          );
          EventUtils.safeAddEventListener(item, "click", () =>
            toggleCharacterSelection(character.id)
          );
        }
        if (avatar) {
          EventUtils.safeAddEventListener(avatar, "contextmenu", (e) => {
            e.preventDefault();
            openCharacterXProfile(character.id);
            return false;
          }); // 长按事件
          let longPressTimer;
          EventUtils.safeAddEventListener(avatar, "mousedown", () => {
            longPressTimer = setTimeout(
              () => openCharacterXProfile(character.id),
              500
            );
          });
          EventUtils.safeAddEventListener(avatar, "mouseup", () =>
            clearTimeout(longPressTimer)
          );
          EventUtils.safeAddEventListener(avatar, "mouseleave", () =>
            clearTimeout(longPressTimer)
          );
          EventUtils.safeAddEventListener(avatar, "touchstart", () => {
            longPressTimer = setTimeout(
              () => openCharacterXProfile(character.id),
              500
            );
          });
          EventUtils.safeAddEventListener(avatar, "touchend", () =>
            clearTimeout(longPressTimer)
          );
        }
      }, 0);
      return `
 <div id="${itemId}" class="character-item" style="display: flex; align-items: center; gap: 12px; padding: 12px; border: 1px solid #333; border-radius: 8px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s;">
 <img id="${avatarId}" src="${character.settings.aiAvatar}" alt="${
        character.name
      }"
 style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0; cursor: pointer;"
 title="长按设置X资料">
 <div style="flex: 1; min-width: 0;">
 <div style="color: #fff; font-weight: 600; font-size: 15px; margin-bottom: 2px;">${
   character.name
 }</div>
 <div style="color: #71767b; font-size: 13px; text-overflow: ellipsis; overflow: hidden; white-space: nowrap;">
 ${character.originalName}
 </div>
 <div style="color: var(--x-accent); font-size: 11px; margin-top: 2px;">
 长按头像设置X资料
 </div>
 </div>
 ${this.buildCheckbox(character.id, isChecked)}
 </div>
 `;
    },
    // 构建复选框
    buildCheckbox(characterId, isChecked) {
      return `
 <div class="character-checkbox" data-character-id="${characterId}" style="width: 20px; height: 20px; border: 2px solid ${
        isChecked ? "var(--x-accent)" : "#71767b"
      }; border-radius: 4px; display: flex; align-items: center; justify-content: center; background-color: ${
        isChecked ? "var(--x-accent)" : "#71767b"
      }; transition: all 0.2s; ">
 ${
   isChecked
     ? '<svg viewBox="0 0 24 24" style="width: 12px; height: 12px; fill: #fff;"><path d="M9 16.17L5.53 12.7l-1.06 1.06L9 18.3l9.54-9.54-1.06-1.06L9 16.17z"/></svg>'
     : ""
 }
 </div>
 `;
    },
    // 构建角色信息显示
    buildCharacterInfoDisplay(character) {
      return `
 <div style="display: flex; align-items: center; gap: 16px;">
 <img src="${character.settings.aiAvatar}" alt="${character.name}" style="width: 60px; height: 60px; border-radius: 50%;">
 <div>
 <div style="color: #fff; font-size: 18px; font-weight: 600; margin-bottom: 4px;">${character.name}</div>
 <div style="color: #71767b; font-size: 14px;">本名：${character.originalName}</div>
 <div style="color: #71767b; font-size: 14px;">设置该角色在X平台的专属身份资料</div>
 </div>
 </div>
 `;
    },
    // 构建空状态提示
    buildEmptyState(message) {
      return `<p style="color: #71767b; text-align: center; padding: 20px;">${message}</p>`;
    },
    // 构建错误状态提示
    buildErrorState(message) {
      return `<p style="color: #f4212e; text-align: center; padding: 20px;">${message}</p>`;
    },
  }; // 验证和错误处理工具 - 简化重复验证逻辑
  const ValidationUtils = {
    // 验证必需字段
    validateRequired(fields) {
      const missing = [];
      for (const [key, value] of Object.entries(fields)) {
        if (!value || value.trim() === "") {
          missing.push(key);
        }
      }
      return {
        isValid: missing.length === 0,
        missing: missing,
      };
    },
    // 验证句柄格式
    validateHandle(handle) {
      if (!handle) return { isValid: false, error: "句柄不能为空" };
      if (handle.length > 15)
        return { isValid: false, error: "句柄长度不能超过15个字符" };
      if (!/^[a-zA-Z0-9_]+$/.test(handle))
        return { isValid: false, error: "句柄只能包含字母、数字和下划线" };
      return { isValid: true };
    },
    // 验证名称长度
    validateName(name, maxLength = 30) {
      if (!name) return { isValid: false, error: "名称不能为空" };
      if (name.length > maxLength)
        return { isValid: false, error: `名称长度不能超过${maxLength}个字符` };
      return { isValid: true };
    },
    // 安全的数据解析
    safeParseJSON(jsonString, defaultValue = null) {
      try {
        return JSON.parse(jsonString);
      } catch (error) {
        console.error("JSON解析失败:", error);
        return defaultValue;
      }
    },
    // 安全的DOM操作
    safeGetElement(id) {
      const element = document.getElementById(id);
      if (!element) {
        console.warn(`未找到元素: ${id}`);
      }
      return element;
    },
    // 统一错误处理
    handleError(error, context = "") {
      console.error(`${context} 错误:`, error);
      showXToast(`${context}失败: ${error.message}`, "error");
    },
  }; // Token计数工具 - 用于监控AI调用的token使用量
  const TokenUtils = {
    // 估算文本的token数量（粗略估计：1个token ≈ 4个字符）
    estimateTokens(text) {
      if (!text) return 0; // 对于中文，大约2个汉字=1个token；对于英文，大约4个字符=1个token
      const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
      const otherChars = text.length - chineseChars;
      return Math.ceil(chineseChars / 2 + otherChars / 4);
    },
    // 记录token使用情况
    logTokenUsage(sceneName, step, content, cumulativeTokens = 0) {
      const tokens = this.estimateTokens(content);
      const newTotal = cumulativeTokens + tokens;
      console.log(
        `📊 [${sceneName}] ${step}: ${tokens.toLocaleString()} tokens | 累计: ${newTotal.toLocaleString()} tokens`
      );
      return newTotal;
    },
    // 记录完整prompt的token使用情况
    logFinalPrompt(
      sceneName,
      systemPrompt,
      userMessage = "",
      contextInfo = ""
    ) {
      const systemTokens = this.estimateTokens(systemPrompt);
      const userTokens = this.estimateTokens(userMessage);
      const contextTokens = this.estimateTokens(contextInfo);
      const totalTokens = systemTokens + userTokens + contextTokens;
      console.log(`
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 [${sceneName}] Token使用统计
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
系统提示词: ${systemTokens.toLocaleString()} tokens
用户消息: ${userTokens.toLocaleString()} tokens
上下文信息: ${contextTokens.toLocaleString()} tokens
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
总计: ${totalTokens.toLocaleString()} tokens
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 `);
      return {
        systemTokens,
        userTokens,
        contextTokens,
        totalTokens,
      };
    },
  }; // 事件处理工具 - 简化重复的事件处理逻辑
  const EventUtils = {
    // 添加悬停效果
    addHoverEffect(element, hoverStyle = {}, defaultStyle = {}) {
      if (!element) return;
      element.addEventListener("mouseover", () => {
        Object.assign(element.style, hoverStyle);
      });
      element.addEventListener("mouseout", () => {
        Object.assign(element.style, defaultStyle);
      });
    },
    // 批量添加悬停效果
    addHoverEffectBatch(selector, hoverStyle = {}, defaultStyle = {}) {
      document.querySelectorAll(selector).forEach((element) => {
        this.addHoverEffect(element, hoverStyle, defaultStyle);
      });
    },
    // 添加按钮悬停效果（通用样式）
    addButtonHover(element) {
      this.addHoverEffect(
        element,
        {
          backgroundColor: "rgba(255,255,255,0.1)",
        },
        {
          backgroundColor: "transparent",
        }
      );
    },
    // 添加链接下划线悬停效果
    addLinkUnderlineHover(element, targetSelector = "span") {
      if (!element) return;
      element.addEventListener("mouseover", () => {
        const target = targetSelector
          ? element.querySelector(targetSelector)
          : element;
        if (target) target.style.textDecoration = "underline";
      });
      element.addEventListener("mouseout", () => {
        const target = targetSelector
          ? element.querySelector(targetSelector)
          : element;
        if (target) target.style.textDecoration = "none";
      });
    },
    // 安全的事件监听器添加
    safeAddEventListener(element, event, handler) {
      if (element && typeof handler === "function") {
        element.addEventListener(event, handler);
      }
    },
    // 防抖函数
    debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    },
    // 节流函数
    throttle(func, limit) {
      let inThrottle;
      return function executedFunction(...args) {
        if (!inThrottle) {
          func.apply(this, args);
          inThrottle = true;
          setTimeout(() => (inThrottle = false), limit);
        }
      };
    },
  }; // API工具 - 统一API配置读取和请求处理
  const APIUtils = {
    // Gemini辅助函数
    _getGeminiResponseText(data) {
      if (
        data.candidates &&
        data.candidates[0] &&
        data.candidates[0].content &&
        data.candidates[0].content.parts
      ) {
        return data.candidates[0].content.parts[0].text || "";
      }
      return "";
    },
    // 加载API配置和X设置
    async loadConfigAndSettings(accountId = null) {
      const db = getDB();
      const xDb = getXDB();
      // 读取API配置
      const apiConfig = await db.apiConfig.get("main");
      if (
        !apiConfig ||
        !apiConfig.proxyUrl ||
        !apiConfig.apiKey ||
        !apiConfig.model
      ) {
        throw new Error("请先配置API设置");
      }
      // 读取X设置
      const settingsId = `xSettings_${accountId || currentAccountId || "main"}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      return {
        db,
        xDb,
        apiConfig,
        xSettings: {
          userPrompt: xSettings?.systemPrompt || "",
          worldSetting: xSettings?.worldSetting || "",
          boundCharacters: xSettings?.boundCharacters || [],
        },
      };
    },
    // 加载绑定的NPC数据
    async loadBoundNPCs(accountId = null) {
      const xDb = getXDB();
      const npcDataId = "xNPCs_global";
      const npcData = await xDb.xNPCs.get(npcDataId);
      const allNPCs = npcData?.npcs || [];
      const currentAccount = accountId || currentAccountId || "main";
      const boundNPCs = allNPCs.filter(
        (npc) => npc.boundUsers && npc.boundUsers.includes(currentAccount)
      );
      if (boundNPCs.length > 0) {
        console.log(
          `📋 已加载 ${boundNPCs.length} 个绑定NPC:`,
          boundNPCs.map((n) => `${n.name}(${n.handle})`).join(", ")
        );
      }
      return boundNPCs;
    },
    // 发送AI请求（统一处理Gemini和OpenAI）
    async sendAIRequest({
      apiConfig,
      systemPrompt,
      messages,
      temperature = 0.8,
    }) {
      const { proxyUrl, apiKey, model } = apiConfig;
      const isGemini = proxyUrl.includes("generativelanguage");
      let response;
      if (isGemini) {
        const GEMINI_API_URL =
          "https://generativelanguage.googleapis.com/v1beta/models";
        const geminiConfig = {
          url: `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(
            apiKey
          )}`,
          data: {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text:
                        systemPrompt +
                        "\n\n" +
                        messages
                          .map((m) =>
                            Array.isArray(m.content)
                              ? m.content
                                  .map((c) => c.text || "[图片]")
                                  .join(" ")
                              : m.content
                          )
                          .join("\n"),
                    },
                  ],
                },
              ],
              generationConfig: {
                temperature,
              },
            }),
          },
        };
        response = await fetch(geminiConfig.url, geminiConfig.data);
      } else {
        const openAiPayload = {
          model: model,
          messages: [{ role: "system", content: systemPrompt }, ...messages],
          temperature,
          stream: false,
        };
        response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify(openAiPayload),
        });
      }
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(
          `API错误: ${response.status} - ${
            errorData.error?.message || response.statusText
          }`
        );
      }
      const data = await response.json();
      let aiResponseContent;
      if (isGemini) {
        aiResponseContent = this._getGeminiResponseText(data);
      } else {
        aiResponseContent = data.choices?.[0]?.message?.content || "";
      }
      console.log("AI原始响应:", aiResponseContent);
      return aiResponseContent;
    },
    // 清理和解析JSON响应
    parseJSONResponse(aiResponseContent) {
      const cleanedResponse = aiResponseContent
        .replace(/```json\s*/i, "")
        .replace(/```\s*$/, "")
        .trim();
      if (!cleanedResponse) {
        throw new Error("AI返回了空的响应内容");
      }

      // 先尝试直接解析
      try {
        return JSON.parse(cleanedResponse);
      } catch (parseError) {
        console.warn("⚠️ [JSON解析] 直接解析失败，尝试使用修复工具...");
        console.error("原始错误:", parseError.message);
        console.error(
          "尝试解析的内容:",
          cleanedResponse.substring(0, 500) + "..."
        );

        // 使用JSON修复工具尝试修复
        const repairedJSON = StringBuilders.repairJSON(cleanedResponse);

        if (repairedJSON) {
          try {
            const parsedData = JSON.parse(repairedJSON);
            console.log("✅ [JSON解析] 使用修复工具成功解析");
            return parsedData;
          } catch (repairError) {
            console.error(
              "❌ [JSON解析] 修复后仍然无法解析:",
              repairError.message
            );
            throw new Error(`AI返回的数据无法修复: ${repairError.message}`);
          }
        } else {
          console.error("❌ [JSON解析] JSON修复工具无法修复");
          throw new Error(
            `AI返回的数据不是有效的JSON格式: ${parseError.message}`
          );
        }
      }
    },
    // 后处理：身份筛选和头像修正
    async postProcessData(data, userProfileInfo = null) {
      // 身份冒用筛选（如果未提供用户信息，函数会自动从数据库读取）
      data = await StringBuilders.filterUserImpersonation(
        data,
        userProfileInfo?.handle,
        userProfileInfo?.name
      );

      // 头像修正（总是从数据库读取最新头像）
      await StringBuilders.enforceAvatarRules(data);

      return data;
    },
  }; // 数据处理工具 - 简化重复的数据处理逻辑
  const DataUtils = {
    // 格式化数字显示
    formatNumber(num) {
      if (num === undefined || num === null) return "0";
      if (num < 1000) return num.toString();
      if (num < 1000000)
        return (num / 1000).toFixed(1).replace(/\.0$/, "") + "K";
      if (num < 1000000000)
        return (num / 1000000).toFixed(1).replace(/\.0$/, "") + "M";
      return (num / 1000000000).toFixed(1).replace(/\.0$/, "") + "B";
    },
    // 格式化时间显示
    formatTime(dateString) {
      const date = new Date(dateString);
      const now = new Date();
      const diffInSeconds = Math.floor((now - date) / 1000);
      if (diffInSeconds < 60) return "刚刚";
      if (diffInSeconds < 3600)
        return Math.floor(diffInSeconds / 60) + "分钟前";
      if (diffInSeconds < 86400)
        return Math.floor(diffInSeconds / 3600) + "小时前";
      if (diffInSeconds < 2592000)
        return Math.floor(diffInSeconds / 86400) + "天前";
      return date.toLocaleDateString("zh-CN", {
        year: "numeric",
        month: "short",
        day: "numeric",
      });
    },
    // 生成唯一ID
    generateId(prefix = "id") {
      return `${prefix}_${Date.now()}_${Math.random()
        .toString(36)
        .substr(2, 9)}`;
    },
    // 深拷贝对象
    deepClone(obj) {
      if (obj === null || typeof obj !== "object") return obj;
      if (obj instanceof Date) return new Date(obj.getTime());
      if (obj instanceof Array) return obj.map((item) => this.deepClone(item));
      if (typeof obj === "object") {
        const clonedObj = {};
        for (const key in obj) {
          if (obj.hasOwnProperty(key)) {
            clonedObj[key] = this.deepClone(obj[key]);
          }
        }
        return clonedObj;
      }
    },
    // 数组去重
    uniqueArray(arr, key = null) {
      if (key) {
        const seen = new Set();
        return arr.filter((item) => {
          const keyValue = item[key];
          if (seen.has(keyValue)) {
            return false;
          }
          seen.add(keyValue);
          return true;
        });
      }
      return [...new Set(arr)];
    },
    // 安全获取嵌套对象属性
    safeGet(obj, path, defaultValue = null) {
      const keys = path.split(".");
      let result = obj;
      for (const key of keys) {
        if (
          result === null ||
          result === undefined ||
          !result.hasOwnProperty(key)
        ) {
          return defaultValue;
        }
        result = result[key];
      }
      return result;
    },
    // 数据排序
    sortBy(arr, key, ascending = true) {
      return arr.sort((a, b) => {
        const aVal = this.safeGet(a, key);
        const bVal = this.safeGet(b, key);
        if (aVal < bVal) return ascending ? -1 : 1;
        if (aVal > bVal) return ascending ? 1 : -1;
        return 0;
      });
    },
    // 分页数据
    paginate(arr, page = 1, limit = 10) {
      const offset = (page - 1) * limit;
      return {
        data: arr.slice(offset, offset + limit),
        pagination: {
          page,
          limit,
          total: arr.length,
          totalPages: Math.ceil(arr.length / limit),
          hasNext: offset + limit < arr.length,
          hasPrev: page > 1,
        },
      };
    },
  }; // 性能优化工具 - 提升代码执行效率
  const PerformanceUtils = {
    // 缓存机制
    cache: new Map(),
    // 设置缓存
    setCache(key, value, ttl = 300000) {
      // 默认5分钟过期
      this.cache.set(key, {
        value,
        expiry: Date.now() + ttl,
      });
    },
    // 获取缓存
    getCache(key) {
      const item = this.cache.get(key);
      if (!item) return null;
      if (Date.now() > item.expiry) {
        this.cache.delete(key);
        return null;
      }
      return item.value;
    },
    // 清理过期缓存
    cleanExpiredCache() {
      const now = Date.now();
      for (const [key, item] of this.cache.entries()) {
        if (now > item.expiry) {
          this.cache.delete(key);
        }
      }
    },
    // 批量DOM操作
    batchDOMUpdate(updates) {
      const fragment = document.createDocumentFragment();
      updates.forEach((update) => {
        if (typeof update === "function") {
          update(fragment);
        }
      });
      return fragment;
    },
    // 延迟执行
    defer(callback, delay = 0) {
      return setTimeout(callback, delay);
    },
    // 请求空闲时间执行
    idle(callback) {
      if (window.requestIdleCallback) {
        return window.requestIdleCallback(callback);
      } else {
        return setTimeout(callback, 1);
      }
    },
    // 监控性能
    measurePerformance(name, fn) {
      return async (...args) => {
        const start = performance.now();
        try {
          const result = await fn(...args);
          const end = performance.now();
          console.log(`Performance [${name}]: ${(end - start).toFixed(2)}ms`);
          return result;
        } catch (error) {
          const end = performance.now();
          console.error(
            `Performance [${name}] Error: ${(end - start).toFixed(2)}ms`,
            error
          );
          throw error;
        }
      };
    },
  }; // 定期清理缓存
  setInterval(() => PerformanceUtils.cleanExpiredCache(), 60000); // 每分钟清理一次
  // === 核心业务逻辑函数 ===
  // 页面切换函数
  // 切换X社交页面的函数 - 优化后
  function switchXPage(pageType) {
    // 🔒 社交功能权限验证：通知和私信页面需要验证
    if (pageType === "notifications" || pageType === "messages") {
      if (
        typeof window.xSocialAuth !== "undefined" &&
        !window.xSocialAuth.hasAccess()
      ) {
        console.log(`🔒 访问 ${pageType} 页面需要社交功能权限`);
        window.xSocialAuth.requestAccess();
        return; // 阻止页面切换
      }

      // 🔍 实时验证 Token 是否仍然有效（防止密钥被删除或拉黑）
      if (
        typeof window.xSocialAuth !== "undefined" &&
        window.xSocialAuth.validateToken
      ) {
        window.xSocialAuth.validateToken().catch((error) => {
          console.error("社交功能 Token 验证失败:", error);
          // Token 验证失败会自动清除本地 token 并显示提示
          // 刷新页面以重新检查权限
          setTimeout(() => {
            window.location.reload();
          }, 1500);
        });
      }
    }

    // 如果切换到主页、消息、通知、设置等主要页面，清除搜索结果标记
    const mainPages = [
      "home",
      "notifications",
      "messages",
      "settings",
      "profile",
    ];
    if (mainPages.includes(pageType) && isInSearchResults) {
      console.log("📖 [导航] 切换到其他页面，清除搜索结果标记");
      isInSearchResults = false;
      currentSearchQuery = "";
    }
    // 清除对应页面的提醒点
    if (pageType === "home") {
      hideNavNotificationDot("home");
    } else if (pageType === "notifications") {
      hideNavNotificationDot("notifications");
    } else if (pageType === "messages") {
      hideNavNotificationDot("messages");
    }
    // 隐藏所有页面，显示选中页面
    DOMUtils.hide(".x-page");
    const targetPage = document.getElementById("x-" + pageType + "-page");
    if (targetPage) targetPage.style.display = "flex"; // 获取顶部栏和底部导航栏
    const topBar = document.querySelector(".x-top-bar");
    const bottomNav = document.querySelector(".x-bottom-nav");
    const refreshBtn = document.querySelector(".refresh-trends-btn"); // 如果是提问箱页面或直播页面，隐藏顶部栏和底部导航栏
    if (pageType === "askbox" || pageType === "live") {
      if (topBar) topBar.style.display = "none";
      if (bottomNav) bottomNav.style.display = "none";
      if (refreshBtn) refreshBtn.style.display = "none";
    } else {
      // 其他页面显示顶部栏和底部导航栏
      if (topBar) topBar.style.display = "flex";
      if (bottomNav) bottomNav.style.display = "flex"; // 只在搜索页面显示刷新按钮
      if (refreshBtn) {
        refreshBtn.style.display = pageType === "search" ? "flex" : "none";
      }
    }
    // 重置导航样式
    DOMUtils.removeClass(".x-nav-item", "active");
    DOMUtils.setStyle(".x-nav-item svg", "fill", "#fff");
    DOMUtils.hide(".nav-highlight"); // 页面索引映射
    const pageIndexMap = {
      home: 0,
      search: 1,
      notifications: 2,
      messages: 3,
      settings: -1,
      profile: -1,
      askbox: -1,
      live: -1,
    };
    const targetIndex = pageIndexMap[pageType];
    if (pageType === "profile") {
      setTimeout(() => {
        loadUserProfileToUI(); // 刷新用户资料显示
        loadUserProfileTweets(); // 加载用户推文
      }, 100);
    } else if (pageType === "askbox") {
      // 加载提问箱数据
      setTimeout(() => {
        loadAskboxData();
      }, 100);
    } else if (pageType === "live") {
      // 加载直播页面数据
      setTimeout(async () => {
        await initLivePage();
      }, 100);
    } else if (pageType === "search") {
      // 加载搜索页面数据
      setTimeout(() => {
        initSearchPage();
      }, 100);
    } else if (pageType === "notifications") {
      // 加载通知数据
      setTimeout(async () => {
        await loadNotifications();
      }, 100);
    } else if (pageType === "messages") {
      // 加载私信列表
      setTimeout(async () => {
        await loadMessagesList();
      }, 100);
    }
    // 切换到设置页面时，重新加载X设置（按账号加载）
    if (pageType === "settings") {
      setTimeout(async () => {
        await initializeXSettings();
        await loadLanguagePreference(); // 加载语言偏好
        await loadAccentColorPreference(); // 加载主题色偏好
        console.log("✅ 已加载当前账号的X设置");
      }, 100);
    }
    // 高亮当前导航项
    const navItems = document.querySelectorAll(".x-nav-item");
    if (navItems[targetIndex] && targetIndex >= 0) {
      navItems[targetIndex].classList.add("active");
      navItems[targetIndex].querySelector("svg").style.fill = "var(--x-accent)";
      navItems[targetIndex].querySelector(".nav-highlight").style.display =
        "block";
    }
  }
  // 添加主页标签切换功能
  function switchHomeTab(tabName) {
    // 重置所有标签和内容
    DOMUtils.removeClass(".x-tab", "active");
    DOMUtils.setStyle(".x-tab", "color", "#71767b");
    DOMUtils.hide(".tab-indicator");
    DOMUtils.hide(".tab-content"); // 激活选中的标签
    const tabs = document.querySelectorAll(".x-tab");
    const tabIndex = tabName === "for-you" ? 0 : 1;
    const contentId =
      tabName === "for-you" ? "for-you-content" : "following-content";
    if (tabs[tabIndex]) {
      tabs[tabIndex].classList.add("active");
      tabs[tabIndex].style.color = "#fff";
      tabs[tabIndex].querySelector(".tab-indicator").style.display = "block";
    }
    const content = document.getElementById(contentId);
    if (content) content.style.display = "flex";
  }
  // ============================================
  // 搜索页面功能
  // ============================================
  // 热搜数据
  let currentSearchTab = "recommended";
  let trendingData = {
    recommended: [
      {
        id: "t1",
        category: "娱乐 · 热门话题",
        title: "流行电影讨论",
        count: 125600,
      },
      {
        id: "t2",
        category: "体育 · 实时",
        title: "篮球比赛精彩瞬间",
        count: 89200,
      },
      {
        id: "t3",
        category: "科技 · 趋势",
        title: "AI技术新突破",
        count: 256700,
      },
      {
        id: "t4",
        category: "音乐 · 流行",
        title: "新专辑发布",
        count: 67800,
      },
      {
        id: "t5",
        category: "游戏 · 热门",
        title: "年度游戏评选",
        count: 145300,
      },
    ],
    trending: [
      {
        id: "t6",
        category: "全球 · 趋势",
        title: "国际新闻热点",
        count: 892300,
      },
      {
        id: "t7",
        category: "商业 · 财经",
        title: "股市最新动态",
        count: 234500,
      },
      {
        id: "t8",
        category: "社会 · 讨论",
        title: "社会话题关注",
        count: 456700,
      },
      {
        id: "t9",
        category: "文化 · 热议",
        title: "传统文化传承",
        count: 178900,
      },
      {
        id: "t10",
        category: "健康 · 生活",
        title: "养生健康小贴士",
        count: 123400,
      },
    ],
  }; // 自定义分类数据
  let customCategories = []; // 搜索相关数据
  let currentSearchQuery = "";
  let currentSearchResultTab = "top";
  let isInSearchResults = false; // 标记是否在搜索结果视图
  let searchResultsData = {
    top: [],
    latest: [],
    users: [],
  }; // 切换搜索标签
  function switchSearchTab(tabName) {
    currentSearchTab = tabName; // 更新标签样式
    const tabs = document.querySelectorAll(".search-tab");
    tabs.forEach((tab) => {
      tab.classList.remove("active");
    });
    const activeTab = Array.from(tabs).find(
      (tab) => tab.onclick && tab.onclick.toString().includes(tabName)
    );
    if (activeTab) {
      activeTab.classList.add("active");
    }
    // 渲染对应的热搜列表
    renderTrendingList();
  }
  // 渲染热搜列表
  function renderTrendingList() {
    const container = document.getElementById("trending-list");
    if (!container) return;
    const trends = trendingData[currentSearchTab] || [];
    if (trends.length === 0) {
      container.innerHTML = `
 <div style="display: flex; justify-content: center; align-items: center; padding: 40px 20px; color: #71767b;">
 暂无热搜内容
 </div>
 `;
      return;
    }
    container.innerHTML = trends
      .map(
        (trend) => `
 <div class="trending-item" onclick="handleTrendingClick('${trend.id}')">
 <div class="trending-header">
 <div class="trending-category">${trend.category}</div>
 <div class="trending-more" onclick="event.stopPropagation(); handleTrendingMore('${
   trend.id
 }')">
 <svg viewBox="0 0 24 24" aria-hidden="true">
 <g><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
 </svg>
 </div>
 </div>
 <div class="trending-title">${trend.title}</div>
 <div class="trending-count">${formatNumber(trend.count)} 条帖子</div>
 </div>
`
      )
      .join("");
  }
  // 刷新热搜（第五个情景：热搜生成器）
  async function refreshTrends() {
    const refreshBtn = document.querySelector(".refresh-trends-btn");
    if (!refreshBtn) return; // 添加旋转动画
    refreshBtn.classList.add("spinning");
    try {
      // 🔧 使用统一的API配置加载工具
      const { apiConfig, xSettings, xDb } =
        await APIUtils.loadConfigAndSettings();
      const { userPrompt, worldSetting, boundCharacters } = xSettings; // 3. 构建用户X个人资料信息
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(
        window.userProfileData
      ); // 4. 判断用户是否为大曝光身份（明星/网红等公众人物）
      const publicIdentity = userXProfileInfo.publicIdentity || "";
      const bio = userXProfileInfo.bio || "";
      const isPublicFigure =
        /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
          publicIdentity + " " + bio
        );
      console.log("🎭 用户公众身份检测:", {
        isPublicFigure,
        publicIdentity,
        bio,
      }); // Token计数器
      let tokenCount = 0; // 5. 构建基础系统提示词（提示词 + 世界观）
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage(
        "热搜生成器",
        "基础系统提示词",
        systemPrompt,
        tokenCount
      ); // 5.5. 获取适用的世界书内容
      const worldBooksContent = await StringBuilders.getApplicableWorldBooks(
        "trending",
        {
          boundCharacters,
        }
      );
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage(
          "热搜生成器",
          "世界书内容",
          worldBooksContent,
          tokenCount
        );
      }

      // 5.7. 🌍 读取世界运转大事件（如果启用） - 热搜必须反映大事件
      const worldEventsPrompt = await getWorldEventsPrompt("热搜生成器", {
        usageRate: 0.6, // 60%的热搜应该围绕大事件（热搜就是反映当前热点）
        usageDescription: `**热搜场景的大事件使用（重要！）**：
🔥 **核心原则**：热搜榜应该真实反映当前世界的热点事件，至少60%的热搜应该与大事件直接相关

1. **直接热搜**：大事件本身就是热搜话题
   - 事件标题直接上榜："XXX事件引发全网讨论"
   - 事件关键词："XXX"、"XXX最新进展"
   - 相关人物/机构："XXX回应XXX事件"

2. **衍生话题**：从大事件延伸出的讨论话题
   - 网友反应："网友热议XXX"
   - 专家评论："专家解读XXX"
   - 类似事件："XXX与XXX事件对比"

3. **次级热搜**：受大事件影响的相关内容
   - 如果是灾难事件，可能有"捐款榜"、"救援进展"等
   - 如果是娱乐八卦，可能有"吃瓜群众"、"资深扒手"等
   - 如果是政策事件，可能有"影响分析"、"专家访谈"等

4. **黑色幽默热搜**：保持讽刺风格
   - 热搜标题要有黑色幽默感
   - 可以讽刺、夸张、反转

5. **分布要求**：
   - "为你推荐"：3-4条大事件相关（60-80%）
   - "当前趋势"：3-4条大事件相关（60-80%）
   - 其余可以是常规热搜（娱乐、体育、日常等）`,
      });

      if (worldEventsPrompt) {
        systemPrompt += worldEventsPrompt;
        tokenCount = TokenUtils.logTokenUsage(
          "热搜生成器",
          "世界运转大事件",
          worldEventsPrompt,
          tokenCount
        );
      }

      // 6. 获取启用的自定义分类
      const enabledCustomCategories = customCategories.filter(
        (cat) => cat.enabled && cat.name
      ); // 7. 添加热搜生成任务说明
      systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务说明 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的热搜生成器。请生成当前的热门话题列表。
【生成要求】：
- 为"为你推荐"和"当前趋势"各生成5条热搜
${
  enabledCustomCategories.length > 0
    ? `- 同时为以下自定义分类各生成5条热搜：${enabledCustomCategories
        .map((c) => `"${c.name}"`)
        .join("、")}`
    : ""
}
- 热搜话题要多样化，涵盖不同领域和分类
- 热搜数量（帖子数）要符合真实社交平台规模（1万到100万之间）
- 话题标题要简洁有力，符合社交媒体特点
${
  isPublicFigure
    ? "- 用户或绑定角色是公众人物，可以适当生成1-2条相关热搜（占比约20%）"
    : "- 用户和角色不是公众人物，生成通用热门话题即可，不要涉及用户或角色"
}
【热搜分类示例】：
- 娱乐 · 热门话题：电影、音乐、综艺、明星动态
- 体育 · 实时：比赛、运动员、体育赛事
- 科技 · 趋势：新技术、产品发布、科技新闻
- 社会 · 讨论：时事、民生、社会话题
- 游戏 · 热门：游戏更新、电竞、游戏新闻
- 文化 · 热议：艺术、文学、传统文化
- 音乐 · 流行：新歌、演唱会、音乐人动态
- 美食 · 推荐：美食探店、烹饪技巧
- 旅游 · 探索：旅行目的地、旅游攻略
- 时尚 · 潮流：穿搭、时装周、潮流单品
- 健康 · 生活：养生、健身、生活方式
- 全球 · 趋势：国际新闻、全球热点
- 商业 · 财经：经济动态、商业新闻
- 教育 · 学习：学习方法、教育资讯
${
  enabledCustomCategories.length > 0
    ? `
【自定义分类详细说明】：${enabledCustomCategories
        .map(
          (cat) => `
- ${cat.name}：${cat.description || "生成该分类下的热门话题"}`
        )
        .join("")}
`
    : ""
}
`; // 8. 如果是公众人物，添加用户和角色信息
      if (isPublicFigure) {
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 公众人物信息（可用于生成相关热搜）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【用户公开信息】：
- 用户名：${userXProfileInfo.name}
- 用户句柄：${userXProfileInfo.handle}
- 公众身份：${userXProfileInfo.publicIdentity}
${userXProfileInfo.bio ? `- 个人简介：${userXProfileInfo.bio}` : ""}
${
  userXProfileInfo.verificationType !== "none"
    ? `- 认证状态：${StringBuilders.getUserVerificationTypeDescription(
        userXProfileInfo
      )}`
    : ""
}
${
  userXProfileInfo.verificationType === "couple" &&
  userXProfileInfo.coupleCharacterName
    ? `- 情侣关系：与${userXProfileInfo.coupleCharacterName}为公开情侣`
    : ""
}
`; // 9. 读取绑定的公众人物（角色 + NPC）
        // 🎯 优化：添加NPC支持
        const publicFigureProfiles = []; // 9.1. 检查绑定角色
        if (boundCharacters.length > 0) {
          const allXProfiles = await xDb.xCharacterProfiles.toArray();
          for (const charId of boundCharacters) {
            const xProfile = allXProfiles.find((p) => p.characterId === charId);
            if (xProfile && xProfile.publicIdentity) {
              // 只添加有公众身份的角色
              const isCharPublicFigure =
                /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
                  xProfile.publicIdentity
                );
              if (isCharPublicFigure) {
                publicFigureProfiles.push({
                  type: "character",
                  name: xProfile.xName,
                  handle: xProfile.xHandle,
                  publicIdentity: xProfile.publicIdentity,
                  bio: xProfile.xBio || "",
                });
              }
            }
          }
        }
        // 9.2. 检查绑定的NPC
        const npcDataId = "xNPCs_global";
        const npcData = await xDb.xNPCs.get(npcDataId);
        const allNPCs = npcData?.npcs || [];
        const currentAccount = currentAccountId || "main";
        const boundNPCs = allNPCs.filter(
          (npc) => npc.boundUsers && npc.boundUsers.includes(currentAccount)
        );
        for (const npc of boundNPCs) {
          // 检查NPC是否有公众属性（人设或主页内容中提到明星、网红等）
          const npcTexts = [npc.personality || "", npc.homepage || ""].join(
            " "
          );
          const isNpcPublicFigure =
            /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
              npcTexts
            );
          if (isNpcPublicFigure) {
            publicFigureProfiles.push({
              type: "npc",
              name: npc.name,
              handle: npc.handle,
              publicIdentity: "公众人物",
              bio: npc.personality || "",
            });
          }
        }
        if (publicFigureProfiles.length > 0) {
          systemPrompt += `
【绑定公众人物信息】：
`;
          for (const profile of publicFigureProfiles) {
            systemPrompt += `
【${profile.name}】（${profile.type === "character" ? "角色" : "NPC"}）
- X姓名：${profile.name}
- X句柄：${profile.handle}
- 公众身份：${profile.publicIdentity}
${profile.bio ? `- 简介/人设：${profile.bio}` : ""}
`; // 读取近期推文
            try {
              const cleanHandle = profile.handle.replace("@", "");
              const accountProfile = await xDb.xAccountProfiles.get(
                cleanHandle
              );
              const recentTweets = accountProfile?.tweets?.slice(0, 5) || [];
              if (recentTweets.length > 0) {
                systemPrompt += `
${profile.name} 的近期推文（${recentTweets.length}条）：
`;
                recentTweets.forEach((tweet, index) => {
                  systemPrompt += `
${index + 1}. "${tweet.content}"
- 时间：${tweet.time || "最近"}
- 互动：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发
${
  tweet.media && tweet.media.length > 0
    ? ` - 媒体：${tweet.media[0].description.substring(0, 50) + "..."}\n`
    : ""
}`;
                });
              }
            } catch (error) {
              console.warn(
                `热搜生成器：读取 ${profile.name} 的推文失败:`,
                error
              );
            }
            systemPrompt += `\n`;
          }
        }
        // 10. 添加用户近期推文（如果用户是公众人物）
        // 读取用户的最近5条推文
        try {
          const userTweetsId = `userTweets_${currentAccountId || "main"}`;
          const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
          const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || [];
          if (recentUserTweets.length > 0) {
            systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📰 用户近期推文（公众人物）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
${userXProfileInfo.name} 的近期推文（${recentUserTweets.length}条）：
`;
            recentUserTweets.forEach((tweet, index) => {
              systemPrompt += `
${index + 1}. "${tweet.content}"
- 时间：${tweet.time || "最近"}
- 互动：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发，${
                tweet.stats?.comments || 0
              }评论
${
  tweet.image
    ? ` - 媒体：${
        tweet.image.type === "description"
          ? tweet.image.content.substring(0, 50) + "..."
          : "包含图片"
      }\n`
    : ""
}`;
            });
            systemPrompt += `
【使用说明】：
- 可以基于用户和角色的近期推文内容生成相关的热搜话题
- 热搜可以反映他们最近的活动、作品、或引起的讨论
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          }
        } catch (error) {
          console.warn("热搜生成器：读取用户推文失败:", error);
        }
        systemPrompt += `
【公众人物热搜规则】：
- 可以生成与用户或角色相关的热搜话题（1-2条，占比约20%）
- 话题应该基于公众身份信息和近期推文内容，符合其领域和形象
- 可以围绕他们的近期动态、作品、或引起的热议生成热搜
- 不要泄露私密人设、聊天记忆等非公开信息
- 热搜内容要真实可信，像真正的社交平台热搜
- 其余80%的热搜应该是与用户/角色无关的通用热门话题
`; // 统计公众人物信息和推文的 token 使用
        const publicFigureSection = systemPrompt.substring(
          systemPrompt.indexOf("📋 公众人物信息")
        );
        tokenCount = TokenUtils.logTokenUsage(
          "热搜生成器",
          "公众人物信息与近期推文",
          publicFigureSection,
          tokenCount
        );
      }
      // 11. 添加格式要求
      let jsonFormat = `{
"recommended": [
{
 "category": "分类 · 标签",
 "title": "热搜话题标题",
 "count": 数字（帖子数量，1万-100万之间）
}
],
"trending": [
{
 "category": "分类 · 标签",
 "title": "热搜话题标题",
 "count": 数字（帖子数量，1万-100万之间）
}
]`; // 如果有自定义分类，添加到JSON格式中
      if (enabledCustomCategories.length > 0) {
        enabledCustomCategories.forEach((cat) => {
          jsonFormat += `,
"${cat.id}": [
{
 "category": "分类 · 标签",
 "title": "热搜话题标题",
 "count": 数字（帖子数量，1万-100万之间）
}
]`;
        });
      }
      jsonFormat += `
}`;
      systemPrompt += `
【返回格式】：严格JSON格式，不要添加任何其他文字说明
${jsonFormat}
**注意事项**：
1. category格式：分类 · 标签（例如："娱乐 · 热门话题"）
2. title要简洁有力，不超过20个字
3. count必须是纯数字，不带引号，范围在10000-1000000之间
4. 每个数组包含5个热搜项
5. 话题要多样化，不要集中在某一领域
6. 确保返回纯JSON，不要有markdown代码块标记
${
  enabledCustomCategories.length > 0
    ? `7. 自定义分类的热搜要紧密围绕分类主题和描述，确保内容相关性`
    : ""
}
【最终检查】：确认话题真实可信，分类准确，数量合理，${
        worldSetting.trim() ? "严格遵守世界观设定，" : ""
      }格式正确。
`;
      const requirementsSection = systemPrompt.substring(
        systemPrompt.indexOf("🎯 核心任务说明 🎯")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "热搜生成器",
        "任务说明与格式要求",
        requirementsSection,
        tokenCount
      );
      const messages = [
        { role: "user", content: "请生成最新的X平台热搜话题列表" },
      ]; // 最终统计
      TokenUtils.logFinalPrompt(
        "热搜生成器",
        systemPrompt,
        messages[0].content
      ); // 🔧 使用统一的API请求工具
      const aiResponseContent = await APIUtils.sendAIRequest({
        apiConfig,
        systemPrompt,
        messages,
        temperature: 0.9,
      }); // 🔧 使用统一的JSON解析工具
      const newTrendsData = APIUtils.parseJSONResponse(aiResponseContent);
      // 14. 验证数据格式
      if (!newTrendsData.recommended || !newTrendsData.trending) {
        throw new Error("AI返回的数据格式不正确，缺少必要字段");
      }
      if (
        !Array.isArray(newTrendsData.recommended) ||
        !Array.isArray(newTrendsData.trending)
      ) {
        throw new Error("热搜数据格式错误：recommended和trending必须是数组");
      }
      // 验证自定义分类数据
      if (enabledCustomCategories.length > 0) {
        for (const category of enabledCustomCategories) {
          if (!newTrendsData[category.id]) {
            console.warn(`⚠️ AI未返回自定义分类"${category.name}"的数据`);
          } else if (!Array.isArray(newTrendsData[category.id])) {
            console.warn(`⚠️ 自定义分类"${category.name}"的数据格式错误`);
          }
        }
      }
      // 15. 为热搜添加唯一ID
      const timestamp = Date.now();
      newTrendsData.recommended = newTrendsData.recommended.map(
        (trend, index) => ({
          ...trend,
          id: `rec_${timestamp}_${index}`,
        })
      );
      newTrendsData.trending = newTrendsData.trending.map((trend, index) => ({
        ...trend,
        id: `trend_${timestamp}_${index}`,
      })); // 为自定义分类添加唯一ID
      enabledCustomCategories.forEach((category) => {
        if (
          newTrendsData[category.id] &&
          Array.isArray(newTrendsData[category.id])
        ) {
          newTrendsData[category.id] = newTrendsData[category.id].map(
            (trend, index) => ({
              ...trend,
              id: `${category.id}_${timestamp}_${index}`,
            })
          );
        }
      }); // 16. 更新全局热搜数据
      trendingData.recommended = newTrendsData.recommended;
      trendingData.trending = newTrendsData.trending; // 更新自定义分类数据
      enabledCustomCategories.forEach((category) => {
        if (newTrendsData[category.id]) {
          trendingData[category.id] = newTrendsData[category.id];
        }
      }); // 17. 保存到数据库
      try {
        const saveData = {
          id: "trends",
          recommended: newTrendsData.recommended,
          trending: newTrendsData.trending,
          lastUpdated: new Date().toISOString(),
        }; // 添加自定义分类数据
        enabledCustomCategories.forEach((category) => {
          if (newTrendsData[category.id]) {
            saveData[category.id] = newTrendsData[category.id];
          }
        });
        await xDb.xTweetsData.put(saveData);
        console.log("✅ 热搜数据已保存到数据库", {
          默认分类: 2,
          自定义分类: enabledCustomCategories.length,
        });
      } catch (saveError) {
        console.error("⚠️ 保存热搜数据失败:", saveError); // 不影响主流程，继续执行
      }
      // 18. 重新渲染热搜列表
      renderTrendingList();
      showXToast("热搜已刷新", "success");
    } catch (error) {
      console.error("❌ 刷新热搜失败:", error);
      showXToast(`刷新失败: ${error.message}`, "error");
    } finally {
      // 移除旋转动画
      if (refreshBtn) {
        refreshBtn.classList.remove("spinning");
      }
    }
  }
  // 处理热搜点击
  function handleTrendingClick(trendId) {
    console.log("点击热搜:", trendId); // 查找热搜数据
    let trendItem = null;
    for (const category in trendingData) {
      const found = trendingData[category].find((t) => t.id === trendId);
      if (found) {
        trendItem = found;
        break;
      }
    }
    if (!trendItem) {
      console.error("未找到热搜数据:", trendId);
      return;
    }
    // 将热搜标题填入搜索框
    const searchInput = document.getElementById("search-input");
    if (searchInput) {
      searchInput.value = trendItem.title;
      toggleSearchButton(); // 显示搜索按钮
    }
    // 自动执行搜索
    performSearch();
  }
  // 处理热搜更多选项
  function handleTrendingMore(trendId) {
    console.log("热搜更多选项:", trendId);
    showXToast("更多选项功能待开发", "info");
  }
  // 显示/隐藏搜索按钮
  function toggleSearchButton() {
    const input = document.getElementById("search-input");
    const button = document.getElementById("search-submit-btn");
    if (input && button) {
      if (input.value.trim()) {
        button.style.display = "flex";
      } else {
        button.style.display = "none";
      }
    }
  }
  // 切换搜索结果标签
  function switchSearchResultTab(tabName) {
    currentSearchResultTab = tabName; // 更新标签样式
    const tabs = document.querySelectorAll("#search-results-view .search-tab");
    tabs.forEach((tab, index) => {
      const tabNames = ["top", "latest", "users"];
      if (tabNames[index] === tabName) {
        tab.classList.add("active");
      } else {
        tab.classList.remove("active");
      }
    }); // 渲染对应的搜索结果
    renderSearchResults();
  }
  // 渲染搜索结果
  function renderSearchResults() {
    const container = document.getElementById("search-results-content");
    if (!container) return;
    const results = searchResultsData[currentSearchResultTab] || [];
    if (results.length === 0) {
      container.innerHTML = `
 <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 60px 20px; color: #71767b; ">
 <svg viewBox="0 0 24 24" style="width: 80px; height: 80px; fill: #71767b; margin-bottom: 20px;">
 <g><path d="M10.25 3.75c-3.59 0-6.5 2.91-6.5 6.5s2.91 6.5 6.5 6.5c1.795 0 3.419-.726 4.596-1.904 1.178-1.177 1.904-2.801 1.904-4.596 0-3.59-2.91-6.5-6.5-6.5zm-8.5 6.5c0-4.694 3.806-8.5 8.5-8.5s8.5 3.806 8.5 8.5c0 1.986-.682 3.815-1.824 5.262l4.781 4.781-1.414 1.414-4.781-4.781c-1.447 1.142-3.276 1.824-5.262 1.824-4.694 0-8.5-3.806-8.5-8.5z"></path></g>
 </svg>
 <div style="font-size: 20px; font-weight: 600; margin-bottom: 8px;">没有找到结果</div>
 <div style="font-size: 14px;">尝试搜索其他内容</div>
 </div>
 `;
      return;
    }
    // 如果是用户标签，显示用户卡片
    if (currentSearchResultTab === "users") {
      container.innerHTML = results
        .map(
          (user) => `
 <div style="padding: 16px; border-bottom: 1px solid #2f3336; display: flex; align-items: center; gap: 12px; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <img
 src="${user.avatar}"
 alt="${user.name}"
 onclick="event.stopPropagation(); openAccountProfile('${user.name.replace(
   /'/g,
   "\\'"
 )}', '${user.handle.startsWith("@") ? user.handle : "@" + user.handle}', '${
            user.avatar
          }', {
 source: 'search',
 searchQuery: '${currentSearchQuery.replace(/'/g, "\\'")}',
 userBio: '${(user.bio || "").replace(/'/g, "\\'")}',
 verified: ${user.verified || false}
 })"
 style="width: 48px; height: 48px; border-radius: 50%; flex-shrink: 0; cursor: pointer; transition: opacity 0.2s; "
 onmouseover="this.style.opacity='0.8'"
 onmouseout="this.style.opacity='1'">
 <div style="flex: 1; min-width: 0;">
 <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px;">
 <span style="color: #fff; font-weight: 700; font-size: 15px;">${
   user.name
 }</span>
 ${
   user.verified
     ? `<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);">
 <g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.26 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.45 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g>
 </svg>`
     : ""
 }
 </div>
 <div style="color: #71767b; font-size: 15px; margin-bottom: 4px;">@${
   user.handle
 }</div>
 ${
   user.bio
     ? `<div style="color: #e7e9ea; font-size: 14px;">${user.bio}</div>`
     : ""
 }
 </div>
 </div>
 `
        )
        .join("");
    } else {
      // 渲染推文列表（热门/最新）
      container.innerHTML = "";
      results.forEach((tweet) => {
        const tweetElement = createTweetElement(tweet);
        container.appendChild(tweetElement); // 修改评论按钮的点击行为，使其显示详情页而不是评论列表
        const commentAction = tweetElement.querySelector(
          ".tweet-action.comment"
        );
        if (commentAction) {
          // 移除原有的 onclick 属性
          commentAction.removeAttribute("onclick"); // 添加新的点击事件
          commentAction.addEventListener("click", async (e) => {
            e.stopPropagation();
            console.log("📖 [搜索结果] 点击评论按钮，显示详情:", tweet.id);
            await showSearchTweetDetail(tweet.id);
          });
        }
      });
    }
  }
  // 显示搜索结果推文详情
  window.showSearchTweetDetail = async function (tweetId) {
    console.log("📖 [搜索结果] 显示推文详情:", tweetId); // 从搜索结果中查找推文
    const allSearchTweets = [
      ...(searchResultsData.top || []),
      ...(searchResultsData.latest || []),
    ];
    const tweet = allSearchTweets.find((t) => t.id === tweetId);
    if (!tweet) {
      showXToast("未找到该推文", "error");
      return;
    }
    // 确保推文已标记为搜索结果
    if (!tweet._source) {
      tweet._source = "search";
    }
    // 使用现有的showTweetDetail函数显示详情
    await showTweetDetail(tweet);
  }; // 执行搜索（第六个情景：搜索生成器）
  async function performSearch() {
    const input = document.getElementById("search-input");
    const query = input?.value?.trim();
    if (!query) {
      showXToast("请输入搜索内容", "info");
      return;
    }
    currentSearchQuery = query;
    isInSearchResults = true; // 标记进入搜索结果视图
    // 显示搜索结果视图，隐藏热搜视图
    document.getElementById("trending-view").style.display = "none";
    document.getElementById("search-results-view").style.display = "flex"; // 显示返回按钮，隐藏刷新按钮
    const backBtn = document.getElementById("search-back-btn");
    if (backBtn) backBtn.style.display = "flex";
    const refreshBtn = document.querySelector(".refresh-trends-btn");
    if (refreshBtn) refreshBtn.style.display = "none"; // 显示加载状态
    const container = document.getElementById("search-results-content");
    container.innerHTML = `
 <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 60px 20px; color: #71767b; ">
 <div style="width: 40px; height: 40px; border: 3px solid var(--x-accent); border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; "></div>
 <div style="margin-top: 20px; font-size: 15px;">正在搜索"${query}"...</div>
 </div>
`;
    try {
      // 🔧 使用统一的API配置加载工具
      const { apiConfig, xSettings, xDb } =
        await APIUtils.loadConfigAndSettings();
      const { userPrompt, worldSetting, boundCharacters } = xSettings; // 3. 构建用户X个人资料信息
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(
        window.userProfileData
      ); // 4. 读取绑定角色的X资料
      const allXProfiles = await xDb.xCharacterProfiles.toArray();
      const characterXProfiles = [];
      for (const charId of boundCharacters) {
        const xProfile = allXProfiles.find((p) => p.characterId === charId);
        if (xProfile) {
          characterXProfiles.push(xProfile);
        }
      }
      // 5. 检查用户是否为公众人物（高曝光率身份）
      const userPublicIdentity = userXProfileInfo.publicIdentity || "";
      const userBio = userXProfileInfo.bio || "";
      const isUserPublicFigure =
        /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
          userPublicIdentity + " " + userBio
        ); // Token计数器
      let tokenCount = 0; // 7. 构建基础系统提示词
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage(
        "搜索生成器",
        "基础系统提示词",
        systemPrompt,
        tokenCount
      ); // 7.5. 获取适用的世界书内容
      const worldBooksContent = await StringBuilders.getApplicableWorldBooks(
        "search",
        {
          boundCharacters,
        }
      );
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage(
          "搜索生成器",
          "世界书内容",
          worldBooksContent,
          tokenCount
        );
      }
      // 7.6. 从世界书中提取可能提到的角色ID，并将其添加到允许列表
      const worldBookCharacterIds = new Set();
      if (worldBooksContent) {
        // 遍历所有绑定的角色，检查世界书中是否提到他们
        for (const charId of boundCharacters) {
          const xProfile = allXProfiles.find((p) => p.characterId === charId);
          if (xProfile) {
            const charName = xProfile.xName || "";
            const charHandle = xProfile.xHandle || ""; // 如果世界书内容中提到了角色名或句柄，将其加入列表
            if (
              (charName && worldBooksContent.includes(charName)) ||
              (charHandle && worldBooksContent.includes(charHandle))
            ) {
              worldBookCharacterIds.add(charId);
              console.log(`🔍 世界书中提到角色: ${charName} (${charHandle})`);
            }
          }
        }
      }
      // 6. 检查所有可能出现在搜索中的身份（角色/NPC/关系NPC）
      // 🎯 优化：使用统一资料获取系统
      const allowedProfiles = [];
      const queryLower = query.toLowerCase(); // 6.1. 检查绑定角色
      for (const xProfile of characterXProfiles) {
        let allowInSearch = false; // 检查角色是否为公众人物
        const charPublicIdentity = xProfile.publicIdentity || "";
        const isCharPublicFigure =
          /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
            charPublicIdentity
          ); // 判断是否允许在搜索结果中出现
        if (isCharPublicFigure) {
          // 公众人物：检查搜索关键词是否与角色相关
          const charName = xProfile.xName || "";
          const charHandle = xProfile.xHandle || "";
          const charBio = xProfile.xBio || "";
          if (
            charName.toLowerCase().includes(queryLower) ||
            queryLower.includes(charName.toLowerCase()) ||
            charHandle.toLowerCase().includes(queryLower) ||
            queryLower.includes(charHandle.toLowerCase()) ||
            charPublicIdentity.toLowerCase().includes(queryLower) ||
            queryLower.includes(charPublicIdentity.toLowerCase()) ||
            (charBio &&
              (charBio.toLowerCase().includes(queryLower) ||
                queryLower.includes(charBio.toLowerCase())))
          ) {
            allowInSearch = true;
          }
        }
        // 检查真名搜索：只有公开真名的角色才能通过真名搜索到
        if (xProfile.showRealName && xProfile.realName) {
          const realNameLower = xProfile.realName.toLowerCase();
          if (
            realNameLower.includes(queryLower) ||
            queryLower.includes(realNameLower)
          ) {
            allowInSearch = true;
          }
        }
        if (allowInSearch) {
          allowedProfiles.push({
            type: "character",
            characterId: xProfile.characterId,
            xProfile: xProfile,
            name: xProfile.xName,
            handle: xProfile.xHandle,
            avatar: xProfile.xAvatar,
            verified: xProfile.xVerified || false,
            publicIdentity: charPublicIdentity,
            bio: xProfile.xBio || "",
            reason: "公众人物或真名搜索",
          });
        }
      }
      // 6.2. 检查绑定的NPC
      const npcDataId = "xNPCs_global";
      const npcData = await xDb.xNPCs.get(npcDataId);
      const allNPCs = npcData?.npcs || [];
      const currentAccount = currentAccountId || "main";
      const boundNPCs = allNPCs.filter(
        (npc) => npc.boundUsers && npc.boundUsers.includes(currentAccount)
      );
      for (const npc of boundNPCs) {
        // NPC默认可以被搜索到（因为它们通常是公开账户）
        const npcName = npc.name || "";
        const npcHandle = npc.handle || "";
        const npcPersonality = npc.personality || "";
        const npcHomepage = npc.homepage || ""; // 检查搜索关键词是否与NPC相关
        if (
          npcName.toLowerCase().includes(queryLower) ||
          queryLower.includes(npcName.toLowerCase()) ||
          npcHandle.toLowerCase().includes(queryLower) ||
          queryLower.includes(npcHandle.toLowerCase()) ||
          npcPersonality.toLowerCase().includes(queryLower) ||
          npcHomepage.toLowerCase().includes(queryLower)
        ) {
          allowedProfiles.push({
            type: "npc",
            npc: npc,
            name: npcName,
            handle: npcHandle,
            avatar: npc.avatar,
            verified: false,
            publicIdentity: "",
            bio: "",
            reason: "NPC账户匹配",
          });
        }
      }
      // 6.3. 检查关系NPC
      for (const xProfile of allXProfiles) {
        if (xProfile.relationships && xProfile.relationships.length > 0) {
          for (const relationship of xProfile.relationships) {
            const relNpcName = relationship.npcName || "";
            const relNpcHandle = relationship.npcHandle || "";
            const relType = relationship.relationshipType || "";
            const relDesc = relationship.description || ""; // 检查搜索关键词是否与关系NPC相关
            if (
              relNpcName.toLowerCase().includes(queryLower) ||
              queryLower.includes(relNpcName.toLowerCase()) ||
              relNpcHandle.toLowerCase().includes(queryLower) ||
              queryLower.includes(relNpcHandle.toLowerCase()) ||
              relType.toLowerCase().includes(queryLower) ||
              relDesc.toLowerCase().includes(queryLower)
            ) {
              allowedProfiles.push({
                type: "relationshipNpc",
                relationship: relationship,
                ownerXProfile: xProfile,
                name: relNpcName,
                handle: relNpcHandle,
                avatar:
                  "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
                verified: false,
                publicIdentity: "",
                bio: "",
                reason: "关系NPC匹配",
              });
            }
          }
        }
      }
      console.log("🔍 搜索匹配检查:", {
        query,
        角色: allowedProfiles.filter((p) => p.type === "character").length,
        NPC: allowedProfiles.filter((p) => p.type === "npc").length,
        关系NPC: allowedProfiles.filter((p) => p.type === "relationshipNpc")
          .length,
        总计: allowedProfiles.length,
      }); // 7.7. 将世界书中提到的角色也加入允许列表（如果尚未加入）
      for (const charId of worldBookCharacterIds) {
        // 检查是否已在允许列表中
        if (
          !allowedProfiles.find(
            (p) => p.type === "character" && p.characterId === charId
          )
        ) {
          const xProfile = allXProfiles.find((p) => p.characterId === charId);
          if (xProfile) {
            allowedProfiles.push({
              type: "character",
              characterId: xProfile.characterId,
              xProfile: xProfile,
              name: xProfile.xName,
              handle: xProfile.xHandle,
              avatar: xProfile.xAvatar,
              verified: xProfile.xVerified || false,
              publicIdentity: xProfile.publicIdentity || "",
              bio: xProfile.xBio || "",
              reason: "世界书提及",
            });
          }
        }
      }
      console.log("🔍 搜索隐私检查（优化后）:", {
        query,
        isUserPublicFigure,
        totalCharacters: boundCharacters.length,
        totalNPCs: boundNPCs.length,
        worldBookMentioned: worldBookCharacterIds.size,
        allowedTotal: allowedProfiles.length,
        allowedList: allowedProfiles.map((p) => `${p.name} (${p.reason})`),
      });

      // 7.7. 🌍 读取世界运转大事件（如果启用） - 搜索可能涉及大事件
      const worldEventsPrompt = await getWorldEventsPrompt("搜索生成器", {
        usageRate: 0.3, // 30%的搜索结果可能涉及大事件（如果关键词相关）
        usageDescription: `**搜索场景的大事件使用**：
1. **关键词匹配**：如果搜索关键词与某个大事件相关（标题、分类、详情中包含关键词），应该优先在搜索结果中展示
2. **相关推文**：如果大事件与搜索关键词相关，热门推文和最新推文应该包含讨论该事件的内容
3. **相关用户**：如果大事件涉及某些人物/机构，用户列表可能包含相关账户
4. **自然关联**：即使关键词不完全匹配，如果搜索主题与大事件相关，也可以适度融入
5. **使用率说明**：只有当关键词与大事件相关时才融入，不相关则忽略`,
      });

      if (worldEventsPrompt) {
        systemPrompt += worldEventsPrompt;
        tokenCount = TokenUtils.logTokenUsage(
          "搜索生成器",
          "世界运转大事件",
          worldEventsPrompt,
          tokenCount
        );
      }

      // 8. 添加搜索任务说明
      systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务说明 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的搜索结果生成器。用户搜索了关键词："${query}"
这是全局搜索，需要生成符合搜索关键词的X平台内容。
请生成与搜索关键词相关的结果：
- 热门：3-8条与关键词高度相关的热门推文
- 最新：3-5条与关键词相关的最新推文
- 用户：2-6个与关键词相关的X用户账号
【重要隐私规则】：
${
  allowedProfiles.length === 0 && !isUserPublicFigure
    ? `- **禁止出现绑定身份**：用户和所有绑定身份都不符合搜索条件
- 生成的所有内容必须是虚构的陌生用户，不能使用任何绑定角色/NPC的信息
- 这是全局搜索，应该展示与关键词相关的公众内容，而非私人关系`
    : ""
}
${
  isUserPublicFigure && queryLower.includes(userXProfileInfo.name.toLowerCase())
    ? `- **用户是公众人物且搜索了用户相关关键词**：可以生成少量与用户相关的内容（1-2条）`
    : ""
}
${
  allowedProfiles.length > 0
    ? `- **允许出现以下身份**（仅限这些）：${allowedProfiles
        .map((p) => `${p.name}[${p.reason}]`)
        .join("、")}
- 原因说明：
* "公众人物或真名搜索"：该角色是公众人物且搜索关键词与他们相关，或搜索了他们公开的真名
* "世界书提及"：该角色在世界书中被提及，可以根据世界书的上下文在搜索结果中出现
* "NPC账户匹配"：该NPC的名称、句柄或人设与搜索关键词匹配
* "关系NPC匹配"：该关系NPC的名称、句柄或关系描述与搜索关键词匹配
- 其他未列出的身份严禁出现`
    : `- **禁止出现任何绑定身份**：没有身份符合出现条件（非公众人物、搜索关键词不相关、且未在世界书中提及）`
}
【生成要求】：
- 所有内容必须与搜索关键词"${query}"高度相关
- 热门推文应该有较高的互动数据（点赞、转发、评论）
- 最新推文时间较近（几分钟到几小时前）
- 推文内容要多样化，从不同角度体现搜索关键词
- 每条推文2-5条评论即可
- 用户账号要有相关性（用户名、简介、或身份与关键词相关）
- 除已绑定角色外，其他用户头像统一：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
- 这是全局搜索，应展示多样化的陌生用户内容，而非私人社交圈
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
      const taskSection = systemPrompt.substring(
        systemPrompt.indexOf("🎯 核心任务说明 🎯")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "搜索生成器",
        "搜索任务说明",
        taskSection,
        tokenCount
      ); // 9. 如果有允许出现的身份，添加资料 + 近期推文
      // 🎯 优化：支持角色/NPC/关系NPC
      if (allowedProfiles.length > 0) {
        const profileSectionStart = systemPrompt.length;
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 允许出现的身份信息
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
以下是符合搜索条件、可以在结果中出现的身份：
`;
        for (const profile of allowedProfiles) {
          systemPrompt += `
【${profile.name}】（${
            profile.type === "character"
              ? "角色"
              : profile.type === "npc"
              ? "NPC"
              : "关系NPC"
          }）
- X姓名：${profile.name}
- X句柄：${profile.handle}
- X头像：${profile.avatar}
- 认证状态：${profile.verified ? "已认证" : "未认证"}
${profile.publicIdentity ? `- 公众身份：${profile.publicIdentity}` : ""}
${profile.bio ? `- X简介：${profile.bio}` : ""}
- 出现原因：${profile.reason}
`; // 根据类型添加特定信息
          if (profile.type === "character" && profile.xProfile) {
            if (profile.xProfile.showRealName && profile.xProfile.realName) {
              systemPrompt += `- 真实姓名：${profile.xProfile.realName}（已公开）\n`;
            }
          } else if (profile.type === "npc" && profile.npc) {
            if (profile.npc.personality) {
              systemPrompt += `- 人设：${profile.npc.personality}\n`;
            }
            if (profile.npc.postingHabits) {
              systemPrompt += `- 发帖习惯：${profile.npc.postingHabits}\n`;
            }
          } else if (
            profile.type === "relationshipNpc" &&
            profile.relationship
          ) {
            systemPrompt += `- 关系类型：与 ${profile.ownerXProfile.xName} (${profile.ownerXProfile.xHandle}) 的 ${profile.relationship.relationshipType}\n`;
            if (profile.relationship.description) {
              systemPrompt += `- 关系描述：${profile.relationship.description}\n`;
            }
          }
          // 读取近期推文（所有类型都尝试读取）
          try {
            const cleanHandle = profile.handle.replace("@", "");
            const accountProfile = await xDb.xAccountProfiles.get(cleanHandle);
            const recentTweets = accountProfile?.tweets?.slice(0, 5) || [];
            if (recentTweets.length > 0) {
              systemPrompt += `
${profile.name} 的近期推文（${recentTweets.length}条）：
`;
              recentTweets.forEach((tweet, index) => {
                systemPrompt += `
${index + 1}. "${tweet.content}"
- 时间：${tweet.time || "最近"}
- 互动：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发
${
  tweet.media && tweet.media.length > 0
    ? ` - 媒体：${tweet.media[0].description.substring(0, 50) + "..."}\n`
    : ""
}`;
              });
            }
          } catch (error) {
            console.warn(`搜索生成器：读取 ${profile.name} 的推文失败:`, error);
          }
          systemPrompt += `\n`;
        }
        systemPrompt += `
【使用规则】：
- 只能使用上述列出的身份信息
- 必须严格使用其X姓名、句柄、头像、认证状态
- 如果他们与搜索关键词相关，可以作为推文发布者或出现在用户列表中
- 可以基于他们的近期推文内容生成相关的搜索结果
- 标注为"世界书提及"的角色，说明他们在世界书中被提及
- 标注为"公众人物或真名搜索"的角色，说明他们是公众人物且与搜索关键词相关
- 标注为"NPC账户匹配"的NPC，说明其信息与搜索关键词匹配
- 标注为"关系NPC匹配"的关系NPC，说明其关系信息与搜索关键词匹配
- 其他未列出的身份严禁出现
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        const profileSection = systemPrompt.substring(profileSectionStart);
        tokenCount = TokenUtils.logTokenUsage(
          "搜索生成器",
          "允许身份信息与推文",
          profileSection,
          tokenCount
        );
      }
      // 10. 用户资料 + 近期推文（如果用户是公众人物且被搜索）
      const userConstraintsStart = systemPrompt.length;
      systemPrompt +=
        StringBuilders.buildUniversalConstraints(userXProfileInfo); // 如果用户是公众人物且搜索关键词与用户相关，添加用户近期推文
      if (
        isUserPublicFigure &&
        queryLower.includes(userXProfileInfo.name.toLowerCase())
      ) {
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📰 用户近期推文（公众人物）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`; // 读取用户的最近5条推文
        try {
          const userTweetsId = `userTweets_${currentAccountId || "main"}`;
          const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
          const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || [];
          if (recentUserTweets.length > 0) {
            systemPrompt += `${userXProfileInfo.name} 的近期推文（${recentUserTweets.length}条）：
`;
            recentUserTweets.forEach((tweet, index) => {
              systemPrompt += `
${index + 1}. "${tweet.content}"
- 时间：${tweet.time || "最近"}
- 互动：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发，${
                tweet.stats?.comments || 0
              }评论
${
  tweet.image
    ? ` - 媒体：${
        tweet.image.type === "description"
          ? tweet.image.content.substring(0, 50) + "..."
          : "包含图片"
      }\n`
    : ""
}`;
            });
            systemPrompt += `
【使用说明】：
- 可以基于用户的近期推文生成相关的搜索结果
- 用户是公众人物，可以在搜索结果中适度出现（1-2条推文）
- 但仍然禁止在评论区假扮用户身份
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          } else {
            systemPrompt += `暂无近期推文数据
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          }
        } catch (error) {
          console.warn("搜索生成器：读取用户推文失败:", error);
          systemPrompt += `暂无近期推文数据
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        }
      }
      const userConstraints = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage(
        "搜索生成器",
        "用户资料约束与推文",
        userConstraints,
        tokenCount
      ); // 11. 添加格式要求
      systemPrompt += `
【JSON返回格式】：
\`\`\`json
{
"top": [热门推文数组(3-5条)],
"latest": [最新推文数组(3-5条)],
"users": [用户数组(2-4个)]
}
\`\`\`
推文对象结构：
- user: {name, handle, avatar, verified}
- content: 推文文本（必须与"${query}"相关）
- time: 时间描述
- stats: {comments, retweets, likes, views} (纯数字)
- media: [{type:"description", description:"描述，至少20字", sensitive:false}] (可选，30-50%推文包含)
- comments: [评论数组(2-5条，必须生成)]
评论对象结构：
- id: 评论唯一ID（可留空，系统自动生成）
- user: {name, handle, avatar, verified}
- content: 评论文本
- time: 时间描述
- image: {type: "description", content: "图片文字描述"} (可选，10-20%的评论带图)
- replies: [楼中楼回复数组] (可选，0-2条)
楼中楼回复对象结构：
- id: 回复唯一ID（可留空，系统自动生成）
- user: {name, handle, avatar, verified}
- content: 回复文本
- time: 时间描述
- image: {type: "description", content: "图片文字描述"} (可选)
- replyTo: "@被回复者句柄" (必填)
用户对象结构：
- name: 用户姓名
- handle: 用户句柄（不带@）
- avatar: 头像URL
- verified: 布尔值
- bio: 个人简介（体现与"${query}"的关联）
关键规则：
1. 所有内容必须围绕搜索关键词"${query}"展开
2. 热门推文stats高（1万-50万），最新推文stats低（100-5千）
3. 最新推文时间近（刚刚、几分钟前、1小时前等）
4. verified字段必须是布尔值(true/false)
5. stats中所有数字必须是纯数字
6. 每条推文必须包含2-5条评论，10-20%的评论可带图
7. 评论可以包含楼中楼回复（replies数组），形成对话链${
        worldSetting.trim() ? "\n8. 严格遵守世界观设定" : ""
      }
【🔒 隐私保护规则】：
🚨 搜索结果中的评论者（非绑定角色/关系NPC的路人）只能基于X平台公开信息：
✅ 可以使用：X姓名、X句柄、X简介、公开身份
❌ 禁止提及：真实姓名、真实职业、私人关系、未公开的身份信息
❌ 禁止使用：只有亲密关系才知道的称呼（如"老师"、"同学"等，除非是公开身份）
⚠️ 只有已绑定的关系NPC才能在评论中提及私密信息（因为他们是角色的私人关系）
`;
      const formatSection = systemPrompt.substring(
        systemPrompt.lastIndexOf("【JSON返回格式】")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "搜索生成器",
        "JSON格式要求",
        formatSection,
        tokenCount
      );
      const messages = [
        { role: "user", content: `请生成关键词"${query}"的搜索结果` },
      ]; // 最终统计
      TokenUtils.logFinalPrompt(
        "搜索生成器",
        systemPrompt,
        messages[0].content
      ); // 🔧 使用统一的API请求工具
      const aiResponseContent = await APIUtils.sendAIRequest({
        apiConfig,
        systemPrompt,
        messages,
        temperature: 0.8,
      }); // 🔧 使用统一的JSON解析和后处理工具
      let searchResults = APIUtils.parseJSONResponse(aiResponseContent);
      searchResults = await APIUtils.postProcessData(
        searchResults,
        userXProfileInfo
      ); // 14. 验证数据格式
      if (!searchResults.top || !searchResults.latest || !searchResults.users) {
        throw new Error("AI返回的数据格式不正确，缺少必要字段");
      }
      // 15. 为推文添加唯一ID和来源标记
      const timestamp = Date.now();
      searchResults.top = searchResults.top.map((tweet, index) => ({
        ...tweet,
        id: `search_top_${timestamp}_${index}`,
        _source: "search", // 标记为搜索结果
        comments:
          tweet.comments?.map((comment, cIndex) => {
            const commentWithId = {
              ...comment,
              id: `search_top_${timestamp}_${index}_c${cIndex}`,
            }; // 为楼中楼回复添加ID
            if (comment.replies && comment.replies.length > 0) {
              commentWithId.replies = comment.replies.map((reply, rIndex) => ({
                ...reply,
                id: `search_top_${timestamp}_${index}_c${cIndex}_r${rIndex}`,
              }));
            }
            return commentWithId;
          }) || [],
      }));
      searchResults.latest = searchResults.latest.map((tweet, index) => ({
        ...tweet,
        id: `search_latest_${timestamp}_${index}`,
        _source: "search", // 标记为搜索结果
        comments:
          tweet.comments?.map((comment, cIndex) => {
            const commentWithId = {
              ...comment,
              id: `search_latest_${timestamp}_${index}_c${cIndex}`,
            }; // 为楼中楼回复添加ID
            if (comment.replies && comment.replies.length > 0) {
              commentWithId.replies = comment.replies.map((reply, rIndex) => ({
                ...reply,
                id: `search_latest_${timestamp}_${index}_c${rIndex}`,
              }));
            }
            return commentWithId;
          }) || [],
      })); // 16. 更新搜索结果数据
      searchResultsData.top = searchResults.top;
      searchResultsData.latest = searchResults.latest;
      searchResultsData.users = searchResults.users; // 17. 保存到数据库
      try {
        await xDb.xTweetsData.put({
          id: `search_${query}`,
          query: query,
          results: searchResults,
          timestamp: new Date().toISOString(),
        });
        console.log("✅ 搜索结果已保存到数据库");
      } catch (saveError) {
        console.error("⚠️ 保存搜索结果失败:", saveError);
      }
      // 18. 渲染搜索结果
      renderSearchResults();
      showXToast(
        `找到 ${
          searchResults.top.length + searchResults.latest.length
        } 条相关推文`,
        "success"
      );
    } catch (error) {
      console.error("❌ 搜索失败:", error);
      showXToast(`搜索失败: ${error.message}`, "error"); // 显示错误状态
      const container = document.getElementById("search-results-content");
      container.innerHTML = `
 <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 60px 20px; color: #f4212e; ">
 <svg viewBox="0 0 24 24" style="width: 80px; height: 80px; fill: #f4212e; margin-bottom: 20px;">
 <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path></g>
 </svg>
 <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">搜索出错</div>
 <div style="font-size: 14px; color: #71767b;">${error.message}</div>
 </div>
 `;
    }
  }
  // 返回热搜视图
  function backToTrending() {
    isInSearchResults = false; // 清除搜索结果标记
    document.getElementById("search-results-view").style.display = "none";
    document.getElementById("trending-view").style.display = "flex"; // 隐藏返回按钮，显示刷新按钮
    const backBtn = document.getElementById("search-back-btn");
    if (backBtn) backBtn.style.display = "none";
    const refreshBtn = document.querySelector(".refresh-trends-btn");
    if (refreshBtn) refreshBtn.style.display = "flex"; // 清空搜索框
    const input = document.getElementById("search-input");
    if (input) {
      input.value = "";
      toggleSearchButton();
    }
    currentSearchQuery = "";
  }
  // 打开自定义分类管理模态框
  async function openAddCategoryModal() {
    const modal = document.getElementById("category-manager-modal");
    if (modal) {
      modal.style.display = "flex"; // 加载自定义分类数据
      await loadCustomCategories(); // 渲染分类列表
      renderCustomCategoriesList();
    }
  }
  // 关闭分类管理模态框
  function closeCategoryModal(event) {
    if (event && event.target !== event.currentTarget) return;
    const modal = document.getElementById("category-manager-modal");
    if (modal) {
      modal.style.display = "none";
    }
  }
  // 加载自定义分类
  async function loadCustomCategories() {
    try {
      const xDb = getXDB();
      const accountId = currentAccountId || "main";
      const settingsId = `customCategories_${accountId}`;
      const savedData = await xDb.xTweetsData.get(settingsId);
      if (savedData && savedData.categories) {
        customCategories = savedData.categories;
        console.log("✅ 已加载自定义分类:", customCategories.length, "个");
      } else {
        customCategories = [];
      }
    } catch (error) {
      console.error("⚠️ 加载自定义分类失败:", error);
      customCategories = [];
    }
  }
  // 保存自定义分类
  async function saveCustomCategories() {
    try {
      const xDb = getXDB();
      const accountId = currentAccountId || "main";
      const settingsId = `customCategories_${accountId}`;
      await xDb.xTweetsData.put({
        id: settingsId,
        categories: customCategories,
        lastUpdated: new Date().toISOString(),
      });
      console.log("✅ 自定义分类已保存");
      showXToast("分类设置已保存", "success"); // 更新标签栏显示
      updateSearchTabs(); // 关闭模态框
      closeCategoryModal();
    } catch (error) {
      console.error("❌ 保存自定义分类失败:", error);
      showXToast("保存失败: " + error.message, "error");
    }
  }
  // 渲染自定义分类列表
  function renderCustomCategoriesList() {
    const container = document.getElementById("custom-categories-list");
    if (!container) return;
    if (customCategories.length === 0) {
      container.innerHTML = `
 <div style="text-align: center; padding: 40px 20px; color: #71767b; font-size: 14px; ">
 还没有自定义分类，点击"添加分类"按钮创建
 </div>
 `;
      return;
    }
    container.innerHTML = customCategories
      .map(
        (category, index) => `
 <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 16px; ">
 <div style="display: flex; align-items: flex-start; gap: 12px;">

 <label style="display: flex; align-items: center; cursor: pointer; margin-top: 4px; ">
 <input
 type="checkbox"
 ${category.enabled ? "checked" : ""}
 onchange="toggleCategory(${index})"
 style="width: 18px; height: 18px; accent-color: var(--x-accent); cursor: pointer; ">
 </label>

 <div style="flex: 1; min-width: 0;">

 <div style="margin-bottom: 12px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 4px; ">分类名称 *</label>
 <input
 type="text"
 value="${category.name || ""}"
 placeholder="例如：动漫"
 onchange="updateCategoryName(${index}, this.value)"
 style="width: 100%; background-color:#000; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 8px 12px; font-size: 15px; outline: none; "
 onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='#333'">
 </div>

 <div style="margin-bottom: 12px;">
 <label style="display: block; color: #8b98a5; font-size: 13px; margin-bottom: 4px; ">分类内容/类型（可选）</label>
 <textarea
 placeholder="例如：动画、漫画、声优、番剧相关内容"
 onchange="updateCategoryDescription(${index}, this.value)"
 style="width: 100%; min-height: 60px; background-color:#000; border: 1px solid #333; border-radius: 4px; color: #fff; padding: 8px 12px; font-size: 14px; resize: vertical; outline: none; font-family: inherit; "
 onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='#333'">${category.description || ""}</textarea>
 </div>

 <div style="display: flex; align-items: center; justify-content: space-between; color:${
   category.enabled ? "var(--x-accent)" : "#71767b"
 }; font-size: 12px; ">
 <span>${category.enabled ? "✅ 已启用" : "❌ 已禁用"}</span>
 <button
 onclick="deleteCategory(${index})"
 style="background: transparent; color: #f4212e; border: 1px solid #f4212e; border-radius: 16px; padding: 4px 12px; font-size: 12px; cursor: pointer; transition: all 0.2s; "
 onmouseover="this.style.backgroundColor='rgba(244,33,46,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 删除
 </button>
 </div>
 </div>
 </div>
 </div>
`
      )
      .join("");
  }
  // 添加新分类
  function addNewCategory() {
    customCategories.push({
      id: `custom_${Date.now()}`,
      name: "",
      description: "",
      enabled: true,
    });
    renderCustomCategoriesList();
  }
  // 删除分类
  function deleteCategory(index) {
    if (confirm("确定要删除这个分类吗？")) {
      customCategories.splice(index, 1);
      renderCustomCategoriesList();
    }
  }
  // 切换分类启用状态
  function toggleCategory(index) {
    if (customCategories[index]) {
      customCategories[index].enabled = !customCategories[index].enabled;
      renderCustomCategoriesList();
    }
  }
  // 更新分类名称
  function updateCategoryName(index, name) {
    if (customCategories[index]) {
      customCategories[index].name = name.trim();
    }
  }
  // 更新分类描述
  function updateCategoryDescription(index, description) {
    if (customCategories[index]) {
      customCategories[index].description = description.trim();
    }
  }
  // 更新搜索标签栏
  function updateSearchTabs() {
    const tabsContainer = document.querySelector(".search-tabs");
    if (!tabsContainer) return; // 清空现有标签（保留+号按钮）
    const addBtn = tabsContainer.querySelector(".add-category-btn");
    tabsContainer.innerHTML = ""; // 添加默认标签
    const recommendedTab = document.createElement("div");
    recommendedTab.className =
      "search-tab" + (currentSearchTab === "recommended" ? " active" : "");
    recommendedTab.textContent = "为你推荐";
    recommendedTab.onclick = () => switchSearchTab("recommended");
    tabsContainer.appendChild(recommendedTab);
    const trendingTab = document.createElement("div");
    trendingTab.className =
      "search-tab" + (currentSearchTab === "trending" ? " active" : "");
    trendingTab.textContent = "当前趋势";
    trendingTab.onclick = () => switchSearchTab("trending");
    tabsContainer.appendChild(trendingTab); // 添加启用的自定义分类标签
    customCategories
      .filter((cat) => cat.enabled && cat.name)
      .forEach((category) => {
        const customTab = document.createElement("div");
        customTab.className =
          "search-tab" + (currentSearchTab === category.id ? " active" : "");
        customTab.textContent = category.name;
        customTab.onclick = () => switchSearchTab(category.id);
        tabsContainer.appendChild(customTab);
      }); // 重新添加+号按钮
    if (addBtn) {
      tabsContainer.appendChild(addBtn);
    }
  }
  // 初始化搜索页面
  async function initSearchPage() {
    // 加载自定义分类
    await loadCustomCategories(); // 更新标签栏
    updateSearchTabs(); // 检查是否需要恢复搜索结果视图
    if (isInSearchResults && currentSearchQuery) {
      // 保持搜索结果视图
      document.getElementById("trending-view").style.display = "none";
      document.getElementById("search-results-view").style.display = "flex"; // 显示返回按钮，隐藏刷新按钮
      const backBtn = document.getElementById("search-back-btn");
      if (backBtn) backBtn.style.display = "flex";
      const refreshBtn = document.querySelector(".refresh-trends-btn");
      if (refreshBtn) refreshBtn.style.display = "none";
    } else {
      // 默认显示热搜视图，隐藏搜索结果视图
      document.getElementById("trending-view").style.display = "flex";
      document.getElementById("search-results-view").style.display = "none"; // 显示刷新按钮，隐藏返回按钮
      const refreshBtn = document.querySelector(".refresh-trends-btn");
      if (refreshBtn) refreshBtn.style.display = "flex";
      const backBtn = document.getElementById("search-back-btn");
      if (backBtn) backBtn.style.display = "none";
    }
    // 尝试从数据库加载热搜数据
    try {
      const xDb = getXDB();
      const savedTrends = await xDb.xTweetsData.get("trends");
      if (savedTrends) {
        // 加载默认分类数据
        if (savedTrends.recommended && savedTrends.trending) {
          trendingData.recommended = savedTrends.recommended;
          trendingData.trending = savedTrends.trending;
        }
        // 加载自定义分类数据
        customCategories.forEach((category) => {
          if (savedTrends[category.id]) {
            trendingData[category.id] = savedTrends[category.id];
          }
        });
        console.log("✅ 已从数据库加载热搜数据");
      }
    } catch (error) {
      console.log("⚠️ 加载热搜数据失败，使用默认数据:", error);
    }
    // 渲染热搜列表
    renderTrendingList();
  }
  // ▼▼▼ ！！！三个情景综合如下！！！▼▼▼
  // "为你推荐"页面的测试推文数据（示范用）
  const forYouTweets = [
    {
      id: "1",
      user: {
        name: "热门推荐用户",
        handle: "@trending_user",
        avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
        verified: true,
      },
      content: "🔥 今日热门话题！大家都在讨论的新技术趋势 #AI #科技 #未来",
      time: "3小时",
      media: [],
      stats: {
        comments: 567,
        retweets: 1200,
        likes: 5600,
        views: 89000,
      },
      comments: [
        {
          id: "c1-1",
          user: {
            name: "科技达人",
            handle: "@tech_expert",
            avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
            verified: true,
          },
          content: "确实，AI技术发展太快了，每天都有新突破",
          time: "2小时",
          replies: [
            {
              id: "c1-1-1",
              user: {
                name: "学生小王",
                handle: "@student_wang",
                avatar:
                  "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
                verified: false,
              },
              content: "请问有什么推荐的学习资源吗？",
              time: "1小时",
              replyTo: "@tech_expert",
            },
          ],
        },
      ],
    },
  ]; // "正在关注"页面的测试推文数据（示范用）
  const followingTweets = [
    {
      id: "2",
      user: {
        name: "我的朋友",
        handle: "@my_friend",
        avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
        verified: false,
      },
      content: "今天天气真不错，和朋友们一起出去玩了！😊 #美好时光",
      time: "30分钟",
      media: [
        {
          type: "image",
          description: "阳光明媚的公园里，几个朋友在草地上野餐的温馨场景",
          sensitive: false,
        },
      ],
      stats: {
        comments: 8,
        retweets: 2,
        likes: 24,
        views: 156,
      },
      comments: [
        {
          id: "c2-1",
          user: {
            name: "好友A",
            handle: "@friend_a",
            avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
            verified: false,
          },
          content: "看起来很棒！下次叫上我 😊",
          time: "25分钟",
          replies: [],
        },
      ],
    },
    {
      id: "3",
      user: {
        name: "数码达人",
        handle: "@digital_expert",
        avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
        verified: true,
      },
      content:
        "完全同意这个观点！AI确实正在改变我们的生活方式，每个人都应该学会拥抱这种变化 🤖✨",
      time: "45分钟",
      media: [],
      quotedTweet: {
        type: "tweet",
        user: {
          name: "科技前沿",
          handle: "@tech_frontier",
          avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
          verified: true,
        },
        content:
          "AI技术的快速发展正在重塑各行各业，从自动驾驶到智能助手，我们正生活在一个科技革命的时代 #AI #未来科技",
        time: "2小时",
      },
      stats: {
        comments: 15,
        retweets: 32,
        likes: 89,
        views: 1250,
      },
      comments: [
        {
          id: "c3-1",
          user: {
            name: "科技爱好者",
            handle: "@tech_lover",
            avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
            verified: false,
          },
          content: "是的，特别是在工作效率提升方面，AI工具帮助很大",
          time: "40分钟",
          replies: [],
        },
      ],
    },
  ]; // 格式化数字显示
  function formatNumber(num) {
    if (num >= 1000000) {
      return (num / 1000000).toFixed(1) + "万";
    } else if (num >= 10000) {
      return (num / 10000).toFixed(1) + "万";
    } else if (num >= 1000) {
      return (num / 1000).toFixed(1) + "K";
    }
    return num.toString();
  }
  // 处理推文内容，为话题标签和提及添加高亮
  function processContent(content, options = {}) {
    if (!content) return "";

    const isOwn = options.isOwn || false;
    const highlightColor = isOwn
      ? "rgba(255, 255, 255, 0.9)"
      : "var(--x-accent)";

    // 🔧 修复：先转义HTML特殊字符（防止XSS）
    // 注意：单引号在普通文本中不需要转义，只转义真正危险的字符
    content = content
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");

    // 🔧 修复：保留换行 - 将 \n 转换为 <br>
    content = content.replace(/\n/g, "<br>");

    // 🔧 修复：保留多个空格 - 将连续空格转换为 &nbsp;
    // 但保留单个空格为普通空格，只转换多余的空格
    content = content.replace(/ {2,}/g, (match) => {
      // 第一个空格用普通空格，其余用 &nbsp;
      return " " + "&nbsp;".repeat(match.length - 1);
    });

    // 处理话题标签 (#hashtag) - 注意：此时内容已转义，所以匹配转义后的字符
    content = content.replace(
      /#([^\s#@<]+)/g,
      `<span class="hashtag" style="color: ${highlightColor}; font-weight: 600;">#$1</span>`
    );

    // 处理提及 (@mention)
    content = content.replace(
      /@([^\s#@<]+)/g,
      `<span class="mention" style="color: ${highlightColor}; font-weight: 600;">@$1</span>`
    );

    return content;
  }
  // 清理评论内容中的重复回复文本
  function cleanReplyContent(content, replyTo) {
    if (!content) return ""; // 如果有replyTo，移除评论内容开头的"回复@xxx:"格式
    if (replyTo) {
      // 移除开头的"回复@用户名:"或"回复 @用户名:"
      content = content.replace(/^回复\s*@[^\s:：]+[：:]\s*/, ""); // 移除开头直接的"@用户名"格式（如果跟replyTo重复）
      const replyHandle = replyTo.replace("@", "");
      content = content.replace(
        new RegExp(`^@${replyHandle}\\s*[：:]?\\s*`, "i"),
        ""
      ); // 移除内容中任何与replyTo重复的@提及
      content = content.replace(
        new RegExp(`@${replyHandle}(?=\\s|$|[^\\w])`, "gi"),
        ""
      );
    }
    return content;
  }
  // 创建推文元素
  function createTweetElement(tweet) {
    const tweetEl = document.createElement("div");
    tweetEl.className = "tweet-item";
    tweetEl.dataset.tweetId = tweet.id;
    tweetEl.innerHTML = `
 <img class="tweet-avatar" src="${tweet.user.avatar}" alt="${tweet.user.name}">
 <div class="tweet-main">
 <div class="tweet-user-info">
 <span class="tweet-user-name">${tweet.user.name}</span>
 ${
   tweet.user.verified
     ? '<svg class="tweet-verified" viewBox="0 0 24 24"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'
     : ""
 }
 <span class="tweet-user-handle">${tweet.user.handle}</span>
 <span class="tweet-time">·${tweet.time}</span>
 <div class="tweet-more">
 <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
 <g><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
 </svg>
 </div>
 </div>
 ${
   tweet.content
     ? `<div class="tweet-content">${processContent(tweet.content)}</div>`
     : ""
 }
 ${
   tweet.quotedTweet
     ? `
 <div class="quoted-tweet" onclick="handleQuotedTweetClick('${
   tweet.quotedTweet.user.handle
 }')">
 <div class="quote-indicator">
 <svg viewBox="0 0 24 24">
 <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g>
 </svg>
 ${tweet.quotedTweet.type === "comment" ? "引用评论" : "引用推文"}
 </div>
 <div class="quoted-user-info">
 <img class="quoted-user-avatar" src="${tweet.quotedTweet.user.avatar}" alt="${
         tweet.quotedTweet.user.name
       }">
 <span class="quoted-user-name">${tweet.quotedTweet.user.name}</span>
 ${
   tweet.quotedTweet.user.verified
     ? '<svg class="tweet-verified" style="width: 14px; height: 14px;" viewBox="0 0 24 24"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'
     : ""
 }
 <span class="quoted-user-handle">${tweet.quotedTweet.user.handle}</span>
 <span class="quoted-user-time">·${tweet.quotedTweet.time}</span>
 </div>
 <div class="quoted-content">${processContent(tweet.quotedTweet.content)}</div>
 ${
   tweet.quotedTweet.image
     ? `
 <div class="quoted-media" style="margin-top: 8px;">
 ${
   tweet.quotedTweet.image.type === "description"
     ? `
 <div style="background-color: rgba(255,255,255,0.05); border: 1px solid #333; border-radius: 8px; padding: 8px;">
 <div style="color: #fff; font-size: 12px; line-height: 1.4;">${tweet.quotedTweet.image.content}</div>
 </div>
 `
     : ""
 }
 ${
   tweet.quotedTweet.image.type === "upload"
     ? `
 <div style="border-radius: 8px; overflow: hidden;">
 <img src="${tweet.quotedTweet.image.content}" style="width: 100%; max-height: 100px; object-fit: cover; display: block;" alt="引用图片">
 </div>
 `
     : ""
 }
 </div>
 `
     : ""
 }
 </div>
 `
     : ""
 }
 ${
   tweet.media && tweet.media.length > 0
     ? `
 <div class="tweet-media">
 <div style="width: 100%; max-height: 200px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 16px; color:var(--x-text-primary); position: relative; overflow: hidden;" id="media-${
   tweet.id
 }">
 ${
   tweet.media[0].sensitive
     ? `
 <div class="sensitive-overlay" onclick="showSensitiveContent('${tweet.id}')">
 <div class="sensitive-text">敏感内容</div>
 <div class="sensitive-description">此推文可能包含敏感内容</div>
 </div>
 `
     : ""
 }
 <div class="tweet-media-scrollable" style="width: 100%; max-height: 200px; padding: 16px; overflow-y: auto; box-sizing: border-box; ${
   tweet.media[0].sensitive ? "filter: blur(20px);" : ""
 }" id="content-${tweet.id}">
 <div style="font-size: 14px; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${
   tweet.media[0].description
 }</div>
 </div>
 </div>
 </div>
 `
     : ""
 }
 <div class="tweet-actions">
 <div class="tweet-action comment" onclick="showTweetComments('${tweet.id}')">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
 <g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g>
 </svg>
 <span>${formatNumber(tweet.stats.comments)}</span>
 </div>
 <div class="tweet-action retweet" onclick="handleQuoteRetweetFromData('tweet', '${
   tweet.id
 }')">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
 <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g>
 </svg>
 <span>${DataUtils.formatNumber(tweet.stats.retweets)}</span>
 </div>
 <div class="tweet-action like" onclick="toggleLike('${
   tweet.id
 }', this)" data-liked="false" data-likes="${tweet.stats.likes}">
 <svg class="action-icon like-icon" viewBox="0 0 24 24" fill="currentColor">
 <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>
 </svg>
 <span class="like-count">${DataUtils.formatNumber(tweet.stats.likes)}</span>
 </div>
 <div class="tweet-action view">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
 <g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10H6v10H4zm9.248 0v-7h2v7h-2z"></path></g>
 </svg>
 <span>${DataUtils.formatNumber(tweet.stats.views)}</span>
 </div>
 <div class="tweet-action bookmark" onclick="toggleBookmark('${
   tweet.id
 }', this)" data-bookmarked="false">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
 <g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g>
 </svg>
 </div>
 <div class="tweet-action share">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
 <g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.29 3.3-1.42-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g>
 </svg>
       </div>
      </div>
      </div>
      `;

    // 🚀 性能优化：不在创建时立即查询状态，而是标记需要懒加载
    // 当推文进入视口时再通过IntersectionObserver加载状态
    tweetEl.dataset.needsStatusCheck = "true";

    return tweetEl;
  }
  // 处理引用推文点击
  function handleQuotedTweetClick(userHandle) {
    showXToast(`点击了引用的 ${userHandle} 的内容`, "info");
  }
  // ============================================
  // 书签/亮点功能
  // ============================================
  // 切换书签状态
  window.toggleBookmark = async function (tweetId, buttonElement) {
    try {
      const isBookmarked =
        buttonElement.getAttribute("data-bookmarked") === "true";
      if (isBookmarked) {
        // 取消收藏
        await removeBookmark(tweetId);
        buttonElement.setAttribute("data-bookmarked", "false"); // 更新图标为未收藏状态
        const svg = buttonElement.querySelector("svg");
        if (svg) {
          svg.innerHTML =
            '<g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g>';
        }
        showXToast("已取消收藏", "info");
        console.log(`📌 [书签] 已取消收藏推文: ${tweetId}`);
      } else {
        // 添加收藏
        await saveBookmark(tweetId);
        buttonElement.setAttribute("data-bookmarked", "true"); // 更新图标为已收藏状态（实心）
        const svg = buttonElement.querySelector("svg");
        if (svg) {
          svg.innerHTML =
            '<g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5z"></path></g>';
        }
        showXToast("已添加到书签", "success");
        console.log(`📌 [书签] 已收藏推文: ${tweetId}`);
      }
      // 如果当前在用户主页的亮点标签，刷新内容
      const highlightsContent = document.getElementById(
        "profile-highlights-content"
      );
      if (highlightsContent && highlightsContent.style.display === "block") {
        await loadHighlights();
      }
    } catch (error) {
      console.error("❌ [书签] 切换书签状态失败:", error);
      showXToast("操作失败", "error");
    }
  }; // 保存书签到数据库（按账户隔离）
  async function saveBookmark(tweetId) {
    try {
      const accountId = currentAccountId || "main";
      const xDb = getXDB(); // 查找推文数据 - 多种来源
      let tweetData = null; // 1. 从内存中的首页推文查找
      const allTweets = [
        ...(window.xTweetsData?.forYouTweets || []),
        ...(window.xTweetsData?.followingTweets || []),
      ];
      tweetData = allTweets.find((t) => t.id === tweetId); // 2. 如果没找到，从数据库中的首页推文查找
      if (!tweetData) {
        const tweetsData = await xDb.xTweetsData.get("tweets");
        if (tweetsData) {
          tweetData =
            tweetsData.forYouTweets?.find((t) => t.id === tweetId) ||
            tweetsData.followingTweets?.find((t) => t.id === tweetId);
        }
      }
      // 3. 如果是用户发的推文，从用户推文数据查找
      if (!tweetData && tweetId.startsWith("user_")) {
        const userTweetsId = `userTweets_${accountId}`;
        const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
        if (userTweetsData && userTweetsData.tweets) {
          tweetData = userTweetsData.tweets.find((t) => t.id === tweetId);
        }
      }
      // 4. 从账户主页推文中查找
      if (!tweetData && currentViewingAccount && currentViewingAccount.tweets) {
        tweetData = currentViewingAccount.tweets.find((t) => t.id === tweetId);
      }
      // 5. 从DOM中提取推文数据作为最后的备选方案
      if (!tweetData) {
        const tweetElement = document.querySelector(
          `[data-tweet-id="${tweetId}"]`
        );
        if (tweetElement) {
          console.log("📝 [书签] 从DOM中提取推文数据"); // 从DOM元素中提取基本信息
          tweetData = extractTweetDataFromDOM(tweetElement);
        }
      }
      if (!tweetData) {
        console.warn("⚠️ [书签] 未找到推文数据:", tweetId);
        showXToast("无法收藏该推文", "error");
        return;
      }
      const bookmarkId = `bookmark_${accountId}_${tweetId}`; // 保存书签数据（多账户隔离）
      await xDb.xBookmarks.put({
        id: bookmarkId,
        accountId: accountId,
        tweetId: tweetId,
        tweetData: tweetData,
        bookmarkedAt: Date.now(),
      });
      console.log(`✅ [书签] 账户 ${accountId} 已保存书签: ${tweetId}`);
    } catch (error) {
      console.error("❌ [书签] 保存书签失败:", error);
      throw error;
    }
  }
  // 从DOM元素中提取推文数据（备用方案）
  function extractTweetDataFromDOM(tweetElement) {
    try {
      // 提取用户信息
      const avatar = tweetElement.querySelector(".tweet-avatar")?.src || "";
      const userName =
        tweetElement.querySelector(".tweet-user-name")?.textContent || "";
      const userHandle =
        tweetElement.querySelector(".tweet-user-handle")?.textContent || "";
      const verified = !!tweetElement.querySelector(".tweet-verified"); // 提取推文内容
      const content =
        tweetElement.querySelector(".tweet-content")?.textContent || "";
      const time =
        tweetElement
          .querySelector(".tweet-time")
          ?.textContent?.replace("·", "")
          .trim() || ""; // 提取统计数据
      const commentCount =
        tweetElement.querySelector(".tweet-action.comment span")?.textContent ||
        "0";
      const retweetCount =
        tweetElement.querySelector(".tweet-action.retweet span")?.textContent ||
        "0";
      const likeCount =
        tweetElement.querySelector(".like-count")?.textContent || "0";
      const viewCount =
        tweetElement.querySelector(".tweet-action.view span")?.textContent ||
        "0";
      return {
        id: tweetElement.dataset.tweetId,
        user: {
          name: userName,
          handle: userHandle,
          avatar: avatar,
          verified: verified,
        },
        content: content,
        time: time,
        stats: {
          comments: parseStatNumber(commentCount),
          retweets: parseStatNumber(retweetCount),
          likes: parseStatNumber(likeCount),
          views: parseStatNumber(viewCount),
        },
        comments: [], // DOM中无法获取完整评论数据
      };
    } catch (error) {
      console.error("❌ [书签] 从DOM提取推文数据失败:", error);
      return null;
    }
  }
  // 解析统计数字（支持K、M等单位）
  function parseStatNumber(str) {
    if (!str) return 0;
    str = str.trim().toUpperCase();
    if (str.endsWith("K")) {
      return Math.round(parseFloat(str) * 1000);
    } else if (str.endsWith("M")) {
      return Math.round(parseFloat(str) * 1000000);
    }
    return parseInt(str) || 0;
  }
  // 从数据库移除书签（按账户隔离）
  async function removeBookmark(tweetId) {
    try {
      const accountId = currentAccountId || "main";
      const xDb = getXDB();
      const bookmarkId = `bookmark_${accountId}_${tweetId}`;
      await xDb.xBookmarks.delete(bookmarkId);
      console.log(`✅ [书签] 账户 ${accountId} 已删除书签: ${tweetId}`);
    } catch (error) {
      console.error("❌ [书签] 删除书签失败:", error);
      throw error;
    }
  }
  // 加载当前账户的所有书签（多账户隔离）
  async function loadBookmarks() {
    try {
      const accountId = currentAccountId || "main";
      const xDb = getXDB(); // 只加载当前账户的书签
      const bookmarks = await xDb.xBookmarks
        .where("accountId")
        .equals(accountId)
        .sortBy("bookmarkedAt"); // 倒序排列（最新的在前）
      bookmarks.reverse();
      console.log(
        `📚 [书签] 账户 ${accountId} 已加载 ${bookmarks.length} 个书签`
      );
      return bookmarks;
    } catch (error) {
      console.error("❌ [书签] 加载书签失败:", error);
      return [];
    }
  }
  // 检查推文是否已被当前账户收藏
  async function isBookmarked(tweetId) {
    try {
      const accountId = currentAccountId || "main";
      const xDb = getXDB();
      const bookmarkId = `bookmark_${accountId}_${tweetId}`;
      const bookmark = await xDb.xBookmarks.get(bookmarkId);
      return !!bookmark;
    } catch (error) {
      console.error("❌ [书签] 检查收藏状态失败:", error);
      return false;
    }
  }
  // 加载并显示亮点内容
  window.loadHighlights = async function () {
    try {
      console.log("🌟 [亮点] 开始加载亮点内容");
      const highlightsContent = document.getElementById(
        "profile-highlights-content"
      );
      if (!highlightsContent) {
        console.warn("⚠️ [亮点] 未找到亮点容器");
        return;
      }
      // 加载当前账户的所有书签
      const bookmarks = await loadBookmarks();
      if (bookmarks.length === 0) {
        // 显示空状态（使用国际化文本）
        const config = languageConfig[currentLanguage] || languageConfig.zh;
        highlightsContent.innerHTML = `
 <div style="padding: 60px 32px; text-align: center;">
 <div style="color:var(--x-text-secondary); font-size: 31px; font-weight: 800; margin-bottom: 8px;">${config.profileNoHighlights}</div>
 <div style="color:var(--x-text-secondary); font-size: 15px;">${config.profileNoHighlightsDesc}</div>
 </div>
 `;
        return;
      }
      // 清空容器
      highlightsContent.innerHTML = ""; // 渲染每个收藏的推文
      bookmarks.forEach((bookmark) => {
        if (bookmark.tweetData) {
          const tweetElement = createTweetElement(bookmark.tweetData);
          highlightsContent.appendChild(tweetElement); // 更新书签按钮状态为已收藏
          const bookmarkBtn = tweetElement.querySelector(".bookmark");
          if (bookmarkBtn) {
            bookmarkBtn.setAttribute("data-bookmarked", "true");
            const svg = bookmarkBtn.querySelector("svg");
            if (svg) {
              svg.innerHTML =
                '<g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5z"></path></g>';
            }
          }
        }
      });
      console.log(`✅ [亮点] 已显示 ${bookmarks.length} 个收藏的推文`);
    } catch (error) {
      console.error("❌ [亮点] 加载亮点内容失败:", error);
      showXToast("加载失败", "error");
    }
  }; // ============================================
  // 💖 喜欢功能
  // ============================================
  // 切换喜欢状态
  window.toggleLike = async function (tweetId, buttonElement) {
    try {
      const isLiked = buttonElement.getAttribute("data-liked") === "true";
      const likeCountSpan = buttonElement.querySelector(".like-count");
      let currentLikes =
        parseInt(buttonElement.getAttribute("data-likes")) || 0;
      if (isLiked) {
        // 取消喜欢
        await removeLike(tweetId);
        buttonElement.setAttribute("data-liked", "false");
        currentLikes = Math.max(0, currentLikes - 1);
        buttonElement.setAttribute("data-likes", currentLikes); // 更新UI
        if (likeCountSpan) {
          likeCountSpan.textContent = DataUtils.formatNumber(currentLikes);
        }
        // 更新图标为未喜欢状态（空心）
        const svg = buttonElement.querySelector("svg");
        if (svg) {
          svg.innerHTML =
            '<g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>';
        }
        console.log(`💔 [喜欢] 已取消喜欢推文: ${tweetId}`);
      } else {
        // 添加喜欢
        await saveLike(tweetId);
        buttonElement.setAttribute("data-liked", "true");
        currentLikes += 1;
        buttonElement.setAttribute("data-likes", currentLikes); // 更新UI
        if (likeCountSpan) {
          likeCountSpan.textContent = DataUtils.formatNumber(currentLikes);
        }
        // 更新图标为已喜欢状态（实心）
        const svg = buttonElement.querySelector("svg");
        if (svg) {
          svg.innerHTML =
            '<g><path d="M20.884 13.19c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>';
        }
        console.log(`💖 [喜欢] 已喜欢推文: ${tweetId}`); // 🎯 检查是否需要触发AI主动发消息
        await checkAutoMessageTrigger();
      }
      // 如果当前在用户主页的喜欢标签，刷新内容
      const likesContent = document.getElementById("profile-likes-content");
      if (likesContent && likesContent.style.display === "block") {
        await loadLikes();
      }
    } catch (error) {
      console.error("❌ [喜欢] 切换喜欢状态失败:", error);
      showXToast("操作失败", "error");
    }
  }; // 保存喜欢到数据库（按账户隔离）
  async function saveLike(tweetId) {
    try {
      const accountId = currentAccountId || "main";
      const xDb = getXDB(); // 查找推文数据 - 多种来源
      let tweetData = null; // 1. 从内存中的首页推文查找
      const allTweets = [...forYouTweets, ...followingTweets];
      tweetData = allTweets.find((t) => t.id === tweetId); // 2. 如果没找到，从数据库中的首页推文查找
      if (!tweetData) {
        const tweetsData = await xDb.xTweetsData.get("tweets");
        if (tweetsData) {
          tweetData =
            tweetsData.forYouTweets?.find((t) => t.id === tweetId) ||
            tweetsData.followingTweets?.find((t) => t.id === tweetId);
        }
      }
      // 3. 如果是用户发的推文，从用户推文数据查找
      if (!tweetData && tweetId.startsWith("user_")) {
        const userTweetsId = `userTweets_${accountId}`;
        const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
        if (userTweetsData && userTweetsData.tweets) {
          tweetData = userTweetsData.tweets.find((t) => t.id === tweetId);
        }
      }
      // 4. 从账户主页推文中查找
      if (!tweetData && currentViewingAccount && currentViewingAccount.tweets) {
        tweetData = currentViewingAccount.tweets.find((t) => t.id === tweetId);
      }
      // 5. 从DOM中提取推文数据作为最后的备选方案
      if (!tweetData) {
        const tweetElement = document.querySelector(
          `[data-tweet-id="${tweetId}"]`
        );
        if (tweetElement) {
          console.log("📝 [喜欢] 从DOM中提取推文数据");
          tweetData = extractTweetDataFromDOM(tweetElement);
        }
      }
      if (!tweetData) {
        console.warn("⚠️ [喜欢] 未找到推文数据:", tweetId);
        showXToast("无法喜欢该推文", "error");
        return;
      }
      const likeId = `like_${accountId}_${tweetId}`; // 保存喜欢数据（多账户隔离）
      await xDb.xLikes.put({
        id: likeId,
        accountId: accountId,
        tweetId: tweetId,
        tweetData: tweetData,
        likedAt: Date.now(),
      });
      console.log(`✅ [喜欢] 账户 ${accountId} 已保存喜欢: ${tweetId}`);
    } catch (error) {
      console.error("❌ [喜欢] 保存喜欢失败:", error);
      throw error;
    }
  }
  // 从数据库移除喜欢（按账户隔离）
  async function removeLike(tweetId) {
    try {
      const accountId = currentAccountId || "main";
      const xDb = getXDB();
      const likeId = `like_${accountId}_${tweetId}`;
      await xDb.xLikes.delete(likeId);
      console.log(`✅ [喜欢] 账户 ${accountId} 已删除喜欢: ${tweetId}`);
    } catch (error) {
      console.error("❌ [喜欢] 删除喜欢失败:", error);
      throw error;
    }
  }
  // 加载当前账户的所有喜欢（多账户隔离）
  async function loadLikesData() {
    try {
      const accountId = currentAccountId || "main";
      const xDb = getXDB(); // 只加载当前账户的喜欢
      const likes = await xDb.xLikes
        .where("accountId")
        .equals(accountId)
        .sortBy("likedAt"); // 倒序排列（最新的在前）
      likes.reverse();
      console.log(`💖 [喜欢] 账户 ${accountId} 已加载 ${likes.length} 个喜欢`);
      return likes;
    } catch (error) {
      console.error("❌ [喜欢] 加载喜欢失败:", error);
      return [];
    }
  }
  // 检查推文是否已被当前账户喜欢
  async function isLiked(tweetId) {
    try {
      const accountId = currentAccountId || "main";
      const xDb = getXDB();
      const likeId = `like_${accountId}_${tweetId}`;
      const like = await xDb.xLikes.get(likeId);
      return !!like;
    } catch (error) {
      console.error("❌ [喜欢] 检查喜欢状态失败:", error);
      return false;
    }
  }
  // 加载并显示喜欢内容
  window.loadLikes = async function () {
    try {
      console.log("💖 [喜欢] 开始加载喜欢内容");
      const likesContent = document.getElementById("profile-likes-content");
      if (!likesContent) {
        console.warn("⚠️ [喜欢] 未找到喜欢容器");
        return;
      }
      // 加载当前账户的所有喜欢
      const likes = await loadLikesData();
      if (likes.length === 0) {
        // 显示空状态（使用国际化文本）
        const config = languageConfig[currentLanguage] || languageConfig.zh;
        likesContent.innerHTML = `
 <div style="padding: 60px 32px; text-align: center;">
 <div style="color:var(--x-text-secondary); font-size: 31px; font-weight: 800; margin-bottom: 8px;">${config.profileNoLikes}</div>
 <div style="color:var(--x-text-secondary); font-size: 15px;">${config.profileNoLikesDesc}</div>
 </div>
 `;
        return;
      }
      // 清空容器
      likesContent.innerHTML = ""; // 渲染每个喜欢的推文
      likes.forEach((like) => {
        if (like.tweetData) {
          const tweetElement = createTweetElement(like.tweetData);
          likesContent.appendChild(tweetElement); // 更新喜欢按钮状态为已喜欢
          const likeBtn = tweetElement.querySelector(".tweet-action.like");
          if (likeBtn) {
            likeBtn.setAttribute("data-liked", "true");
            const svg = likeBtn.querySelector("svg");
            if (svg) {
              svg.innerHTML =
                '<g><path d="M20.884 13.19c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>';
            }
          }
        }
      });
      console.log(`✅ [喜欢] 已显示 ${likes.length} 个喜欢的推文`);
    } catch (error) {
      console.error("❌ [喜欢] 加载喜欢内容失败:", error);
      showXToast("加载失败", "error");
    }
  }; // 🎯 检查是否需要触发AI主动发消息（每点赞5条触发一次）
  let lastLikeTriggerTime = 0; // 上次触发时间戳
  const LIKE_TRIGGER_COOLDOWN = 5 * 60 * 1000; // 5分钟冷却时间

  async function checkAutoMessageTrigger() {
    try {
      const accountId = currentAccountId || "main";
      const xDb = getXDB(); // 获取当前账户的喜欢总数
      const likesCount = await xDb.xLikes
        .where("accountId")
        .equals(accountId)
        .count();
      console.log(`📊 [喜欢触发] 当前喜欢总数: ${likesCount}`); // 每5条喜欢触发一次
      if (likesCount > 0 && likesCount % 5 === 0) {
        // 检查冷却时间
        const now = Date.now();
        const timeSinceLastTrigger = now - lastLikeTriggerTime;
        if (timeSinceLastTrigger < LIKE_TRIGGER_COOLDOWN) {
          const remainingSeconds = Math.ceil(
            (LIKE_TRIGGER_COOLDOWN - timeSinceLastTrigger) / 1000
          );
          console.log(`⏳ [喜欢触发] 冷却中，还需等待 ${remainingSeconds} 秒`);
          return;
        }
        console.log("🎯 [喜欢触发] 达到触发条件，准备随机选择一条喜欢的推文");
        lastLikeTriggerTime = now; // 更新触发时间
        // 获取最近5条喜欢的推文
        const recentLikes = await xDb.xLikes
          .where("accountId")
          .equals(accountId)
          .sortBy("likedAt");
        const last5Likes = recentLikes.slice(-5);
        if (last5Likes.length > 0) {
          // 随机选择其中一条
          const randomLike =
            last5Likes[Math.floor(Math.random() * last5Likes.length)];
          const tweetData = randomLike.tweetData;
          console.log(`🎲 [喜欢触发] 随机选中推文:`, tweetData); // 查找对应的角色或账户私信
          const tweetAuthorHandle = tweetData.user.handle.replace("@", ""); // 触发AI主动发消息
          await triggerAutoMessageFromLikedTweet(tweetAuthorHandle, tweetData);
        }
      }
    } catch (error) {
      console.error("❌ [喜欢触发] 检查触发条件失败:", error);
    }
  }
  // 🤖 从喜欢的推文触发AI主动发消息
  async function triggerAutoMessageFromLikedTweet(authorHandle, tweetData) {
    try {
      console.log(`🤖 [喜欢触发AI] 开始处理推文作者: ${authorHandle}`);
      const xDb = getXDB();
      const accountId = currentAccountId || "main"; // 1. 检查是否是角色
      const allXProfiles = await xDb.xCharacterProfiles.toArray();
      const characterProfile = allXProfiles.find(
        (p) =>
          p.xHandle &&
          p.xHandle.replace("@", "").toLowerCase() ===
            authorHandle.toLowerCase()
      );
      if (characterProfile) {
        console.log(`✅ [喜欢触发AI] 找到角色: ${characterProfile.xName}`); // 构造消息数据（模拟私信结构）
        const messageData = {
          id: characterProfile.characterId
            ? `msg_${characterProfile.characterId}`
            : "msg_001",
          user: {
            name: characterProfile.xName,
            handle: characterProfile.xHandle,
            avatar: characterProfile.xAvatar,
            verified: characterProfile.xVerified || false,
          },
          preview: `看到你喜欢了我的推文`,
          time: "刚刚",
        }; // 触发私信详情生成（续写模式 + 自动发消息模式）
        const result = await generateMessageConversation(messageData, true, {
          isAutoMessage: true,
          timeSinceLastMessage: 0,
          likedTweetContext: tweetData, // 传递喜欢的推文信息
        });
        if (result && result.length > 0) {
          // 保存AI生成的消息到对话记录
          const conversationId = `messageConversation_${
            currentAccountId || "main"
          }_${messageData.id}`;
          let savedConversation = await xDb.xAccountProfiles.get(
            conversationId
          );
          if (!savedConversation) {
            savedConversation = {
              handle: conversationId,
              name: "messageConversation",
              data: { messages: [] },
              messageId: messageData.id,
              accountId: currentAccountId || "main",
              updatedAt: new Date().toISOString(),
            };
          }
          // 添加新消息
          savedConversation.data.messages.push(...result);
          savedConversation.updatedAt = new Date().toISOString();
          await xDb.xAccountProfiles.put(savedConversation); // 显示手机样式通知
          const isEnglish = currentLanguage === "en";
          showPhoneNotification({
            title: "X",
            message: isEnglish
              ? `${characterProfile.xName} noticed you liked their tweet and sent you a message!`
              : `${characterProfile.xName} 看到你喜欢了TA的推文，发来了私信！`,
            avatar: characterProfile.xAvatar,
            leftIcon: "x",
          });
          console.log(
            `✅ [喜欢触发AI] 已触发${characterProfile.xName}的主动私信`
          );
        }
      } else {
        console.log(`ℹ️ [喜欢触发AI] ${authorHandle} 不是绑定角色，跳过触发`);
      }
    } catch (error) {
      console.error("❌ [喜欢触发AI] 触发失败:", error);
    }
  }
  // 渲染推文到容器
  function renderTweets(tweets, containerId) {
    const container = document.querySelector(
      `#${containerId} .tweets-container`
    );
    container.innerHTML = "";

    // 🚀 分批渲染优化：避免大量推文同步渲染导致白屏
    const BATCH_SIZE = 10; // 每批渲染10条
    let currentIndex = 0;

    function renderBatch() {
      const endIndex = Math.min(currentIndex + BATCH_SIZE, tweets.length);
      const fragment = document.createDocumentFragment(); // 使用DocumentFragment减少重排

      for (let i = currentIndex; i < endIndex; i++) {
        const tweet = tweets[i];
        const tweetElement = createTweetElement(tweet); // 🎬 新推文添加滑入动画
        if (tweet.isNew) {
          tweetElement.style.opacity = "0";
          tweetElement.style.transform = "translateY(-20px)";
          tweetElement.style.transition =
            "opacity 0.4s ease, transform 0.4s ease"; // 延迟添加动画，创造层叠效果
          setTimeout(() => {
            tweetElement.style.opacity = "1";
            tweetElement.style.transform = "translateY(0)"; // 动画完成后移除isNew标记
            tweet.isNew = false;
          }, i * 50); // 每个推文延迟50ms
        }
        fragment.appendChild(tweetElement);
        attachTweetEventHandlers(tweetElement, tweet, containerId); // 提取事件绑定到独立函数
      }

      container.appendChild(fragment);
      currentIndex = endIndex;

      // 如果还有未渲染的推文，继续下一批
      if (currentIndex < tweets.length) {
        requestAnimationFrame(renderBatch);
      }
    }

    // 立即渲染第一批（优先显示内容）
    renderBatch();

    // 🚀 批量懒加载推文状态（书签/喜欢）
    // 等所有推文渲染完成后，再开始加载状态
    setTimeout(() => {
      lazyLoadTweetStatuses(container);
    }, 100);
  }

  // 🚀 懒加载推文状态（书签/喜欢） - 使用IntersectionObserver优化性能
  function lazyLoadTweetStatuses(container) {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(async (entry) => {
          if (entry.isIntersecting) {
            const tweetEl = entry.target;
            if (tweetEl.dataset.needsStatusCheck === "true") {
              tweetEl.dataset.needsStatusCheck = "false";
              const tweetId = tweetEl.dataset.tweetId;

              // 并行查询书签和喜欢状态
              const [bookmarked, liked] = await Promise.all([
                isBookmarked(tweetId),
                isLiked(tweetId),
              ]);

              // 更新书签UI
              const bookmarkBtn = tweetEl.querySelector(".bookmark");
              if (bookmarkBtn && bookmarked) {
                bookmarkBtn.setAttribute("data-bookmarked", "true");
                const svg = bookmarkBtn.querySelector("svg");
                if (svg) {
                  svg.innerHTML =
                    '<g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5z"></path></g>';
                }
              }

              // 更新喜欢UI
              const likeBtn = tweetEl.querySelector(".tweet-action.like");
              if (likeBtn && liked) {
                likeBtn.setAttribute("data-liked", "true");
                const svg = likeBtn.querySelector("svg");
                if (svg) {
                  svg.innerHTML =
                    '<g><path d="M20.884 13.19c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>';
                }
              }

              observer.unobserve(tweetEl);
            }
          }
        });
      },
      {
        root: container,
        rootMargin: "100px", // 提前100px加载
        threshold: 0.01,
      }
    );

    // 观察所有需要加载状态的推文
    container
      .querySelectorAll('.tweet-item[data-needs-status-check="true"]')
      .forEach((tweetEl) => {
        observer.observe(tweetEl);
      });
  }

  // 🔧 提取推文事件绑定逻辑，避免在renderTweets中重复代码
  function attachTweetEventHandlers(tweetElement, tweet, containerId) {
    // 为推文作者头像添加点击事件
    const avatar = tweetElement.querySelector(".tweet-avatar");
    if (avatar) {
      avatar.style.cursor = "pointer";
      avatar.addEventListener("click", (e) => {
        e.stopPropagation();
        openAccountProfile(
          tweet.user.name,
          tweet.user.handle,
          tweet.user.avatar,
          {
            source: "feed",
            tweetContent: tweet.content,
            tweetMedia: tweet.media,
            tweetStats: tweet.stats,
            tweetTime: tweet.time,
          }
        );
      });
    }
    // 为引用推文中的头像添加点击事件
    const quotedAvatar = tweetElement.querySelector(".quoted-user-avatar");
    if (quotedAvatar && tweet.quotedTweet) {
      quotedAvatar.style.cursor = "pointer";
      quotedAvatar.addEventListener("click", (e) => {
        e.stopPropagation();
        openAccountProfile(
          tweet.quotedTweet.user.name,
          tweet.quotedTweet.user.handle,
          tweet.quotedTweet.user.avatar,
          {
            source: "feed",
            tweetContent: tweet.quotedTweet.content,
            tweetTime: tweet.quotedTweet.time,
          }
        );
      });
    }
    // 📱 长按多选删除功能
    let longPressTimer = null;
    let touchStarted = false; // 移动端长按
    tweetElement.addEventListener("touchstart", (e) => {
      if (isFeedMultiSelectMode) {
        // 已经在多选模式，直接点击选择
        return;
      }
      touchStarted = true;
      longPressTimer = setTimeout(() => {
        if (touchStarted) {
          e.preventDefault();
          enterFeedMultiSelectMode(containerId);
          selectFeedTweet(tweet.id, tweetElement);
        }
      }, 500);
    });
    tweetElement.addEventListener("touchmove", () => {
      touchStarted = false;
      if (longPressTimer) clearTimeout(longPressTimer);
    });
    tweetElement.addEventListener("touchend", () => {
      touchStarted = false;
      if (longPressTimer) clearTimeout(longPressTimer);
    }); // 桌面端长按
    tweetElement.addEventListener("mousedown", (e) => {
      if (isFeedMultiSelectMode) {
        // 已经在多选模式，直接点击选择
        return;
      }
      if (e.button !== 0) return;
      longPressTimer = setTimeout(() => {
        enterFeedMultiSelectMode(containerId);
        selectFeedTweet(tweet.id, tweetElement);
      }, 500);
    });
    tweetElement.addEventListener("mouseup", () => {
      if (longPressTimer) clearTimeout(longPressTimer);
    });
    tweetElement.addEventListener("mouseleave", () => {
      if (longPressTimer) clearTimeout(longPressTimer);
    }); // 多选模式下点击选择
    tweetElement.addEventListener("click", (e) => {
      if (isFeedMultiSelectMode) {
        e.preventDefault();
        e.stopPropagation();
        selectFeedTweet(tweet.id, tweetElement);
      }
    });
  }
  // ============================================
  // 📱 首页推文多选删除功能
  // ============================================
  let isFeedMultiSelectMode = false;
  let selectedFeedTweetIds = new Set();
  let currentFeedContainer = null; // 进入多选模式
  function enterFeedMultiSelectMode(containerId) {
    if (isFeedMultiSelectMode) return;
    isFeedMultiSelectMode = true;
    currentFeedContainer = containerId;
    selectedFeedTweetIds.clear(); // 显示多选工具栏
    showFeedMultiSelectToolbar(); // 给所有推文添加视觉提示
    const container = document.querySelector(
      `#${containerId} .tweets-container`
    );
    if (container) {
      const tweetElements = container.querySelectorAll(".tweet-item");
      tweetElements.forEach((el) => {
        el.style.transition =
          "transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease";
        el.style.cursor = "pointer";
      });
    }
    console.log("📱 [首页多选] 已进入多选模式");
  }
  // 选择推文
  function selectFeedTweet(tweetId, tweetElement) {
    if (!isFeedMultiSelectMode) return;
    if (selectedFeedTweetIds.has(tweetId)) {
      // 取消选择
      selectedFeedTweetIds.delete(tweetId);
      tweetElement.style.transform = "";
      tweetElement.style.boxShadow = "";
      tweetElement.style.backgroundColor = "";
    } else {
      // 选中
      selectedFeedTweetIds.add(tweetId);
      tweetElement.style.transform = "scale(0.98)";
      tweetElement.style.boxShadow = "0 0 0 3px var(--x-accent)";
      tweetElement.style.backgroundColor =
        "color-mix(in srgb, var(--x-accent) 10%, transparent)";
    }
    updateFeedMultiSelectToolbar();
  }
  // 显示多选工具栏
  function showFeedMultiSelectToolbar() {
    const oldToolbar = document.getElementById("feed-multi-select-toolbar");
    if (oldToolbar) oldToolbar.remove();
    const toolbar = document.createElement("div");
    toolbar.id = "feed-multi-select-toolbar";
    toolbar.style.cssText = `
 position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%); background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 24px; padding: 12px 20px; display: flex; align-items: center; gap: 16px; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); animation: feedSlideUp 0.3s ease;
`;
    toolbar.innerHTML = `
 <span id="feed-selected-count" style="color:var(--x-text-primary); font-size: 14px; font-weight: 600;">已选择 0 条</span>
 <button onclick="selectAllFeedTweets()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 16px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
 全选
 </button>
 <button onclick="deleteFeedSelectedTweets()" style="background-color: #f4212e; color: #fff; border: none; border-radius: 16px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#d91b2a'" onmouseout="this.style.backgroundColor='#f4212e'">
 删除
 </button>
 <button onclick="exitFeedMultiSelectMode()" style="background-color: transparent; color:var(--x-text-primary); border: 1px solid var(--x-border-color); border-radius: 16px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'">
 取消
 </button>
`;
    document.body.appendChild(toolbar); // 添加动画CSS
    if (!document.getElementById("feed-multiselect-animation-style")) {
      const style = document.createElement("style");
      style.id = "feed-multiselect-animation-style";
      style.textContent = `
 @keyframes feedSlideUp {
 from {
 transform: translateX(-50%) translateY(20px); opacity: 0; }
 to {
 transform: translateX(-50%) translateY(0); opacity: 1; }
 }
 @keyframes feedSlideDown {
 from {
 transform: translateX(-50%) translateY(0); opacity: 1; }
 to {
 transform: translateX(-50%) translateY(20px); opacity: 0; }
 }
 `;
      document.head.appendChild(style);
    }
  }
  // 更新工具栏
  function updateFeedMultiSelectToolbar() {
    const countElement = document.getElementById("feed-selected-count");
    if (countElement) {
      countElement.textContent = `已选择 ${selectedFeedTweetIds.size} 条`;
    }
  }
  // 全选
  window.selectAllFeedTweets = function () {
    if (!isFeedMultiSelectMode || !currentFeedContainer) return;
    const container = document.querySelector(
      `#${currentFeedContainer} .tweets-container`
    );
    if (!container) return;
    const isForYou = currentFeedContainer === "for-you-content";
    const tweets = isForYou ? forYouTweets : followingTweets; // 全选所有推文
    const tweetElements = container.querySelectorAll(".tweet-item");
    tweets.forEach((tweet, index) => {
      selectedFeedTweetIds.add(tweet.id);
      const tweetElement = tweetElements[index];
      if (tweetElement) {
        tweetElement.style.transform = "scale(0.98)";
        tweetElement.style.boxShadow = "0 0 0 3px var(--x-accent)";
        tweetElement.style.backgroundColor =
          "color-mix(in srgb, var(--x-accent) 10%, transparent)";
      }
    });
    updateFeedMultiSelectToolbar();
  }; // 退出多选模式
  window.exitFeedMultiSelectMode = function () {
    if (!isFeedMultiSelectMode) return;
    isFeedMultiSelectMode = false;
    selectedFeedTweetIds.clear();
    currentFeedContainer = null; // 隐藏工具栏
    const toolbar = document.getElementById("feed-multi-select-toolbar");
    if (toolbar) {
      toolbar.style.animation = "feedSlideDown 0.3s ease";
      setTimeout(() => toolbar.remove(), 300);
    }
    // 移除所有选择样式
    document.querySelectorAll(".tweet-item").forEach((el) => {
      el.style.transform = "";
      el.style.boxShadow = "";
      el.style.backgroundColor = "";
      el.style.cursor = "";
    });
    console.log("📱 [首页多选] 已退出多选模式");
  }; // 删除选中的推文
  window.deleteFeedSelectedTweets = async function () {
    if (selectedFeedTweetIds.size === 0) {
      showXToast("请先选择要删除的推文", "info");
      return;
    }
    if (!confirm(`确定要删除 ${selectedFeedTweetIds.size} 条推文吗？`)) {
      return;
    }
    try {
      const isForYou = currentFeedContainer === "for-you-content";
      const tweetsArray = isForYou ? forYouTweets : followingTweets; // 过滤掉选中的推文
      const remainingTweets = tweetsArray.filter(
        (tweet) => !selectedFeedTweetIds.has(tweet.id)
      );
      if (isForYou) {
        forYouTweets.length = 0;
        forYouTweets.push(...remainingTweets);
      } else {
        followingTweets.length = 0;
        followingTweets.push(...remainingTweets);
      }
      // 更新数据库
      const xDb = getXDB();
      await xDb.xTweetsData.put({
        id: "tweets",
        forYouTweets: forYouTweets,
        followingTweets: followingTweets,
        lastUpdated: new Date().toISOString(),
      }); // 重新渲染
      renderTweets(
        isForYou ? forYouTweets : followingTweets,
        currentFeedContainer
      );
      showXToast(`已删除 ${selectedFeedTweetIds.size} 条推文`, "success"); // 退出多选模式
      exitFeedMultiSelectMode();
    } catch (error) {
      console.error("删除推文失败:", error);
      showXToast("删除失败", "error");
    }
  }; // 初始化推文数据
  async function initializeTweets() {
    try {
      // 尝试从数据库加载保存的推文数据
      const db = getXDB();
      const savedData = await db.xTweetsData.get("tweets");
      if (savedData && savedData.forYouTweets && savedData.followingTweets) {
        // 使用保存的数据
        forYouTweets.length = 0;
        followingTweets.length = 0;
        forYouTweets.push(...savedData.forYouTweets);
        followingTweets.push(...savedData.followingTweets);
        console.log(
          "已加载保存的推文数据，最后更新时间:",
          savedData.lastUpdated
        );
      }
    } catch (error) {
      console.error("加载推文数据失败，使用默认数据:", error);
    }
    // 渲染推文
    renderTweets(forYouTweets, "for-you-content");
    renderTweets(followingTweets, "following-content");
  }
  // ============================================
  // ⏰ 动态时间更新功能
  // ============================================
  // 计算相对时间
  function getRelativeTime(createdAt) {
    const now = Date.now();
    const diff = now - createdAt;
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    if (seconds < 60) return "刚刚";
    if (minutes < 60) return `${minutes}分钟前`;
    if (hours < 24) return `${hours}小时前`;
    if (days < 7) return `${days}天前`; // 超过7天显示具体日期
    const date = new Date(createdAt);
    const month = date.getMonth() + 1;
    const day = date.getDate();
    return `${month}月${day}日`;
  }
  // 更新所有推文的时间显示
  function updateAllTweetTimes() {
    // 更新为你推荐页面
    forYouTweets.forEach((tweet) => {
      if (tweet.createdAt) {
        tweet.time = getRelativeTime(tweet.createdAt);
      }
    }); // 更新正在关注页面
    followingTweets.forEach((tweet) => {
      if (tweet.createdAt) {
        tweet.time = getRelativeTime(tweet.createdAt);
      }
    }); // 🔧 更新DOM中所有带有data-timestamp的时间显示（适用于所有页面）
    document
      .querySelectorAll(".tweet-time[data-timestamp]")
      .forEach((timeEl) => {
        const timestamp = parseInt(timeEl.dataset.timestamp);
        if (timestamp && !isNaN(timestamp)) {
          timeEl.textContent = getRelativeTime(timestamp);
        }
      }); // 🔧 兼容旧的推文时间更新逻辑
    document.querySelectorAll(".tweet-time").forEach((timeEl) => {
      const tweetEl = timeEl.closest(".tweet-item");
      if (tweetEl && tweetEl.dataset.tweetId && !timeEl.dataset.timestamp) {
        const tweetId = tweetEl.dataset.tweetId;
        const tweet = [...forYouTweets, ...followingTweets].find(
          (t) => t.id === tweetId
        );
        if (tweet && tweet.createdAt) {
          timeEl.textContent = getRelativeTime(tweet.createdAt);
        }
      }
    });
  }
  // 启动动态时间更新定时器（每30秒更新一次）
  setInterval(updateAllTweetTimes, 30000); // 显示敏感内容
  function showSensitiveContent(tweetId) {
    const overlay = document.querySelector(
      `#media-${tweetId} .sensitive-overlay`
    );
    const content = document.getElementById(`content-${tweetId}`);
    if (overlay) {
      overlay.style.display = "none";
    }
    if (content) {
      content.style.filter = "none";
    }
  }
  // 点赞功能已移至书签功能下方的window.toggleLike（完整版本，包含数据库保存和AI触发）
  // 生成随机点赞数
  function generateRandomLikes() {
    return Math.floor(Math.random() * 50) + 1;
  }
  // 动态计算评论时间显示
  function formatCommentTime(commentTimestamp) {
    // 验证时间戳有效性
    if (!commentTimestamp || isNaN(commentTimestamp) || commentTimestamp <= 0) {
      console.warn("⚠️ [时间显示] 无效的时间戳:", commentTimestamp);
      return "刚刚";
    }
    const now = Date.now();
    const diff = now - commentTimestamp;
    const minutes = Math.floor(diff / (1000 * 60));
    const hours = Math.floor(diff / (1000 * 60 * 60));
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    if (minutes < 1) return "刚刚";
    if (minutes < 60) return `${minutes}分钟前`;
    if (hours < 24) return `${hours}小时前`;
    if (days < 7) return `${days}天前`; // 超过7天显示具体日期
    const date = new Date(commentTimestamp); // 二次验证日期对象有效性
    if (isNaN(date.getTime())) {
      console.warn("⚠️ [时间显示] 无效的日期对象，时间戳:", commentTimestamp);
      return "刚刚";
    }
    const month = date.getMonth() + 1;
    const day = date.getDate();
    return `${month}月${day}日`;
  }
  // 创建评论元素
  function createCommentElement(comment, isReply = false) {
    const commentEl = document.createElement("div");
    commentEl.className = isReply ? "comment-item reply-item" : "comment-item";
    commentEl.dataset.commentId = comment.id;
    const randomLikes = generateRandomLikes();
    const randomComments = Math.floor(Math.random() * 10) + 1;
    const randomRetweets = Math.floor(Math.random() * 5) + 1;
    const randomViews = Math.floor(Math.random() * 1000) + 50;
    commentEl.innerHTML = `
 <img class="tweet-avatar" src="${comment.user.avatar}" alt="${
      comment.user.name
    }"
 onclick="openAccountProfile('${comment.user.name.replace(/'/g, "\\'")}', '${
      comment.user.handle
    }', '${
      comment.user.avatar
    }', {source: 'tweetDetail', commentContent: '${comment.content
      .replace(/'/g, "\\'")
      .substring(0, 100)}'});event.stopPropagation();"
 style="cursor: pointer; transition: opacity 0.2s;"
 onmouseover="this.style.opacity='0.8'"
 onmouseout="this.style.opacity='1'">
 <div class="comment-main">
 <div class="comment-user-info">
 <span class="tweet-user-name" onclick="openAccountProfile('${comment.user.name.replace(
   /'/g,
   "\\'"
 )}', '${comment.user.handle}', '${
      comment.user.avatar
    }', {source: 'tweetDetail', commentContent: '${comment.content
      .replace(/'/g, "\\'")
      .substring(
        0,
        100
      )}'});event.stopPropagation();" style="cursor: pointer;">${
      comment.user.name
    }</span>
 ${
   comment.user.verified
     ? '<svg class="tweet-verified" viewBox="0 0 24 24"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'
     : ""
 }
 <span class="tweet-user-handle">${
   comment.user.handle.startsWith("@")
     ? comment.user.handle
     : "@" + comment.user.handle
 }</span>
 <span class="tweet-time">·${
   comment.timestamp
     ? formatCommentTime(comment.timestamp)
     : comment.time || "刚刚"
 }</span>
 <div style="margin-left: auto; cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color: 0.2s; display: flex; align-items: center;" onmouseover="this.style.backgroundColor='color-mix(in srgb, var(--x-accent) , 0.1)'" onmouseout="this.style.backgroundColor='transparent'" onclick="${
   comment.user.handle === userProfileData.handle
     ? `deleteUserComment('${comment.id}')`
     : `event.stopPropagation(); showXToast('更多选项开发中', 'info')`
 }">
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #71767b;">
 <g><circle cx="12" cy="5" r="2"></circle><circle cx="12" cy="12" r="2"></circle><circle cx="12" cy="19" r="2"></circle></g>
 </svg>
 </div>
 </div>
 <div class="comment-content">
 ${comment.replyTo ? `<span class="reply-to">${comment.replyTo}</span>` : ""}
 ${processContent(cleanReplyContent(comment.content, comment.replyTo))}
 ${
   comment.image
     ? comment.image.type === "description"
       ? `<div style="margin-top: 8px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 8px; box-sizing: border-box;">
 <div style="color:var(--x-text-primary); font-size: 13px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${comment.image.content}</div>
 </div>`
       : `<div style="margin-top: 8px; border-radius: 12px; overflow: hidden; max-width: 300px;">
 <img src="${comment.image.content}" style="width: 100%; max-height: 280px; object-fit: cover; display: block;" alt="评论图片">
 </div>`
     : ""
 }
 ${
   comment.sticker
     ? `<div style="margin-top: 8px; max-width: 120px;">
 <img src="${comment.sticker.url}" alt="${comment.sticker.description}" style="width: 100%; height: auto; display: block; border-radius: 8px; cursor: pointer;"
      onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'padding: 12px; color:var(--x-text-secondary); text-align: center;\\'>表情包加载失败</div>';"
      title="${comment.sticker.description}">
 </div>`
     : ""
 }
 </div>
 <div class="comment-actions" style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px; gap: 2px; max-width: 100%; overflow-x: hidden;">
 <div class="comment-action reply-action" onclick="showReplyInput('${
   comment.id
 }', '${
      comment.user.handle
    }')" style="display: flex; align-items: center; gap: 2px; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 1 auto; min-width: 0;">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;">
 <g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g>
 </svg>
 <span style="font-size: 12px; white-space: nowrap;">${randomComments}</span>
 </div>
 <div class="comment-action" onclick="handleQuoteRetweetFromData('comment', '${
   comment.id
 }')" style="display: flex; align-items: center; gap: 2px; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 1 auto; min-width: 0;">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;">
 <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g>
 </svg>
 <span style="font-size: 12px; white-space: nowrap;">${randomRetweets}</span>
 </div>
 <div class="comment-action like" onclick="toggleCommentLike('${
   comment.id
 }', this)" data-liked="false" data-likes="${randomLikes}" style="display: flex; align-items: center; gap: 2px; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 1 auto; min-width: 0;">
 <svg class="action-icon like-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;">
 <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>
 </svg>
 <span class="like-count" style="font-size: 12px; white-space: nowrap;">${randomLikes}</span>
 </div>
 <div class="comment-action" style="display: flex; align-items: center; gap: 2px; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 1 auto; min-width: 0;">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;">
 <g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10H6v10H4zm9.248 0v-7h2v7h-2z"></path></g>
 </svg>
 <span style="font-size: 12px; white-space: nowrap;">${formatNumber(
   randomViews
 )}</span>
 </div>
 <div class="comment-action bookmark" style="display: flex; align-items: center; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 0 auto; min-width: 16px;">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;">
 <g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g>
 </svg>
 </div>
 <div class="comment-action share comment-share-btn" data-comment-id="${
   comment.id
 }" style="display: flex; align-items: center; cursor: pointer; color: #71767b; transition: color 0.2s; flex: 0 0 auto; min-width: 16px;">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; flex-shrink: 0;">
 <g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.29 3.3-1.42-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g>
 </svg>
 </div>
 </div>

 <div id="reply-input-${
   comment.id
 }" class="reply-input-container" style="display: none; margin-top: 12px; padding-left: 48px;">
 <div style="display: flex; align-items: flex-start; gap: 12px;">
 <img src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg" alt="Your avatar" style="width: 32px; height: 32px; border-radius: 50%; flex-shrink: 0;" class="reply-user-avatar">
 <div style="flex: 1;">
 <textarea placeholder="发布你的回复" style="width: 100%; min-height: 20px; max-height: 80px; background: transparent; border: none; color: #fff; font-size: 15px; resize: none; outline: none; font-family: inherit; line-height: 1.3; border-bottom: 1px solid #333; padding-bottom: 8px;" oninput="autoResizeReply(this, '${
   comment.id
 }')" onkeydown="handleReplyInput(event, '${comment.id}', '${
      comment.user.handle
    }')"></textarea>
 <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
 <div style="display: flex; gap: 12px;">
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent); cursor: pointer;">
 <g><path d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v9.086l3-3 3 3 5-5 3 3V5.5c0-.276-.224-.5-.5-.5h-13zM19 15.414l-3-3-5 5-3-3-3 3V18.5c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-3.086zM9.75 7C8.784 7 8 7.784 8 8.75s.784 1.75 1.75 1.75 1.75-.784 1.75-1.75S10.716 7 9.75 7z"></path></g>
 </svg>
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent); cursor: pointer;">
 <g><path d="M8 9.5C8 8.119 8.672 7 9.5 7S11 8.119 11 9.5 10.328 12 9.5 12 8 10.881 8 9.5zm6.5 2.5c.828 0 1.5-1.119 1.5-2.5S15.328 7 14.5 7 13 8.119 13 9.5s.672 2.5 1.5 2.5zM12 16c-2.224 0-3.021-2.227-3.051-2.316l-1.897.633c.05.15 1.271 3.684 4.949 3.684s4.898-3.533 4.949-3.684l-1.896-.638c-.033.095-.83 2.322-3.053 2.322zm10.25-4.001c0 5.652-4.598 10.25-10.25 10.25S1.75 17.652 1.75 12 6.348 1.75 12 1.75 22.25 6.348 22.25 12zm-2 0c0-4.549-3.701-8.25-8.25-8.25S3.75 7.451 3.75 12s3.701 8.25 8.25 8.25 8.25-3.701 8.25-8.25z"></path></g>
 </svg>
 </div>
 <div style="display: flex; gap: 8px;">
 <button onclick="cancelReply('${
   comment.id
 }')" style="background: transparent; color: #71767b; border: 1px solid #333; border-radius: 16px; padding: 4px 12px; font-size: 13px; cursor: pointer;">取消</button>
 <button id="reply-btn-${comment.id}" onclick="submitReply('${comment.id}', '${
      comment.user.handle
    }')" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 16px; padding: 4px 12px; font-size: 13px; cursor: pointer; opacity: 0.5;" disabled>回复</button>
 </div>
 </div>
 </div>
 </div>
 </div>
 </div>
 `; // 添加分享按钮点击事件
    const shareBtn = commentEl.querySelector(".comment-share-btn");
    if (shareBtn) {
      shareBtn.onclick = () => {
        // 尝试从 sessionStorage 获取当前推文数据
        let parentTweet = null;
        const currentTweetDataStr = sessionStorage.getItem("currentTweetData");
        if (currentTweetDataStr) {
          try {
            parentTweet = JSON.parse(currentTweetDataStr);
          } catch (e) {
            console.error("解析推文数据失败:", e);
          }
        }
        showShareContentModal(
          {
            user: comment.user,
            content: comment.content,
            time:
              comment.time ||
              (comment.timestamp
                ? formatCommentTime(comment.timestamp)
                : "刚刚"),
            image: comment.image,
            // 包含所属推文的数据
            parentTweet: parentTweet,
          },
          "comment"
        );
      };
    }
    return commentEl;
  }
  // 删除用户评论功能
  async function deleteUserComment(commentId) {
    if (!confirm("确定要删除这条评论吗？")) {
      return;
    }
    const commentElement = document.querySelector(
      `[data-comment-id="${commentId}"]`
    );
    if (commentElement) {
      // 添加淡出动画
      commentElement.style.transition =
        "opacity 0.3s ease, transform 0.3s ease";
      commentElement.style.opacity = "0";
      commentElement.style.transform = "translateX(-20px)"; // 动画完成后移除元素
      setTimeout(() => {
        commentElement.remove();
        showXToast("评论已删除", "success");
      }, 300); // 递归删除评论的辅助函数
      const removeCommentById = (comments, targetId) => {
        return comments.filter((comment) => {
          if (comment.id === targetId) {
            return false; // 删除匹配的评论
          }
          if (comment.replies && comment.replies.length > 0) {
            comment.replies = removeCommentById(comment.replies, targetId);
          }
          return true;
        });
      }; // 同时从推文数据中移除这条评论
      try {
        // 更新sessionStorage中的数据
        const currentTweetData = sessionStorage.getItem("currentTweetData");
        if (currentTweetData) {
          const tweetData = JSON.parse(currentTweetData);
          if (tweetData.comments) {
            tweetData.comments = removeCommentById(
              tweetData.comments,
              commentId
            );
            sessionStorage.setItem(
              "currentTweetData",
              JSON.stringify(tweetData)
            ); // 更新统计数据
            const commentsCount = document.querySelector(
              ".tweet-stats .comment-count"
            );
            if (commentsCount) {
              const currentCount = parseInt(commentsCount.textContent) || 0;
              if (currentCount > 0) {
                commentsCount.textContent = currentCount - 1;
              }
            }
            // 同时更新数据库中的数据
            const db = getXDB();
            const tweetsData = await db.xTweetsData.get("tweets");
            if (tweetsData) {
              // 在forYouTweets中查找并更新
              if (tweetsData.forYouTweets) {
                const tweetIndex = tweetsData.forYouTweets.findIndex(
                  (t) => t.id === tweetData.id
                );
                if (tweetIndex !== -1) {
                  tweetsData.forYouTweets[tweetIndex].comments =
                    removeCommentById(
                      tweetsData.forYouTweets[tweetIndex].comments || [],
                      commentId
                    ); // 更新全局变量
                  forYouTweets[tweetIndex] =
                    tweetsData.forYouTweets[tweetIndex];
                }
              }
              // 在followingTweets中查找并更新
              if (tweetsData.followingTweets) {
                const tweetIndex = tweetsData.followingTweets.findIndex(
                  (t) => t.id === tweetData.id
                );
                if (tweetIndex !== -1) {
                  tweetsData.followingTweets[tweetIndex].comments =
                    removeCommentById(
                      tweetsData.followingTweets[tweetIndex].comments || [],
                      commentId
                    ); // 更新全局变量
                  followingTweets[tweetIndex] =
                    tweetsData.followingTweets[tweetIndex];
                }
              }
              // 保存更新后的数据
              await db.xTweetsData.put(tweetsData);
            }
            // 如果是用户自己的推文，也更新用户推文数据
            if (tweetData.id.startsWith("user_")) {
              // 🔧 多账户隔离：使用账户ID
              const userTweetsId = `userTweets_${currentAccountId || "main"}`;
              const userTweets = await db.xUserTweets.get(userTweetsId);
              if (userTweets && userTweets.tweets) {
                const userTweetIndex = userTweets.tweets.findIndex(
                  (t) => t.id === tweetData.id
                );
                if (userTweetIndex !== -1) {
                  userTweets.tweets[userTweetIndex].comments =
                    removeCommentById(
                      userTweets.tweets[userTweetIndex].comments || [],
                      commentId
                    );
                  await db.xUserTweets.put(userTweets);
                }
              }
            }
            console.log("评论已从数据库中删除:", commentId);
          }
        } else if (currentTweetId) {
          // 如果是主页评论页面，更新主页数据
          const allTweets = [...forYouTweets, ...followingTweets];
          const tweet = allTweets.find((t) => t.id === currentTweetId);
          if (tweet && tweet.comments) {
            tweet.comments = removeCommentById(tweet.comments, commentId);
            tweet.stats.comments = Math.max(0, (tweet.stats.comments || 0) - 1); // 更新全局数组引用
            const tweetIndex = forYouTweets.findIndex((t) => t.id === tweet.id);
            if (tweetIndex !== -1) {
              forYouTweets[tweetIndex] = tweet;
            } else {
              const followingIndex = followingTweets.findIndex(
                (t) => t.id === tweet.id
              );
              if (followingIndex !== -1) {
                followingTweets[followingIndex] = tweet;
              }
            }
            // 保存到数据库
            const db = getXDB();
            await db.xTweetsData.put({
              id: "tweets",
              forYouTweets: forYouTweets,
              followingTweets: followingTweets,
              lastUpdated: new Date().toISOString(),
            });
            console.log("主页评论已从数据库中删除:", commentId);
          }
        }
      } catch (error) {
        console.error("删除评论数据失败:", error);
        showXToast("删除评论失败，请重试", "error");
      }
    }
  }
  // 评论点赞功能
  function toggleCommentLike(commentId, element) {
    const isLiked = element.dataset.liked === "true";
    const currentLikes = parseInt(element.dataset.likes);
    const likeIcon = element.querySelector(".like-icon");
    const likeCount = element.querySelector(".like-count");
    if (isLiked) {
      element.dataset.liked = "false";
      element.dataset.likes = (currentLikes - 1).toString();
      element.classList.remove("liked");
      likeCount.textContent = (currentLikes - 1).toString();
    } else {
      element.dataset.liked = "true";
      element.dataset.likes = (currentLikes + 1).toString();
      element.classList.add("liked");
      likeCount.textContent = (currentLikes + 1).toString();
      likeIcon.classList.add("like-animation");
      setTimeout(() => {
        likeIcon.classList.remove("like-animation");
      }, 600);
    }
  }
  // 渲染评论
  function renderComments(tweetId) {
    const container = document.querySelector(".comments-container");
    container.innerHTML = ""; // 找到对应的推文（包括主页推文、搜索结果推文、账户推文）
    let allTweets = [...forYouTweets, ...followingTweets]; // 添加搜索结果推文
    if (searchResultsData.top || searchResultsData.latest) {
      allTweets = [
        ...allTweets,
        ...(searchResultsData.top || []),
        ...(searchResultsData.latest || []),
      ];
    }
    // 添加账户推文
    if (currentViewingAccount && currentViewingAccount.tweets) {
      allTweets = [...allTweets, ...currentViewingAccount.tweets];
    }
    const tweet = allTweets.find((t) => t.id === tweetId);
    if (!tweet || !tweet.comments) return;
    tweet.comments.forEach((comment) => {
      // 创建评论组容器
      const commentGroup = document.createElement("div");
      commentGroup.style.cssText = "position: relative;"; // 添加主评论
      const commentElement = createCommentElement(comment); // 如果有回复，给主评论添加特殊类
      if (comment.replies && comment.replies.length > 0) {
        commentElement.classList.add("has-replies");
      }
      commentGroup.appendChild(commentElement); // 为主评论头像添加点击事件
      const commentAvatar = commentElement.querySelector(".tweet-avatar");
      if (commentAvatar) {
        commentAvatar.style.cursor = "pointer";
        commentAvatar.addEventListener("click", (e) => {
          e.stopPropagation();
          openAccountProfile(
            comment.user.name,
            comment.user.handle,
            comment.user.avatar,
            {
              source: "comment",
              commentContent: comment.content,
              commentImage: comment.image,
              commentTime: comment.time,
            }
          );
        });
      }
      // 渲染回复
      if (comment.replies && comment.replies.length > 0) {
        comment.replies.forEach((reply) => {
          const replyElement = createCommentElement(reply, true);
          commentGroup.appendChild(replyElement); // 为回复头像添加点击事件
          const replyAvatar = replyElement.querySelector(".tweet-avatar");
          if (replyAvatar) {
            replyAvatar.style.cursor = "pointer";
            replyAvatar.addEventListener("click", (e) => {
              e.stopPropagation();
              openAccountProfile(
                reply.user.name,
                reply.user.handle,
                reply.user.avatar,
                {
                  source: "comment",
                  commentContent: reply.content,
                  commentImage: reply.image,
                  commentTime: reply.time,
                  replyTo: reply.replyTo,
                }
              );
            });
          }
        });
      }
      container.appendChild(commentGroup);
    }); // 更新所有回复输入框头像
    const replyUserAvatars = document.querySelectorAll(".reply-user-avatar");
    replyUserAvatars.forEach((avatar) => {
      avatar.src = userProfileData.avatar;
    });
  }
  // 评论图片数据存储
  let commentImageData = null;
  let detailCommentImageData = null; // 触发主页评论图片上传
  function triggerCommentImageUpload() {
    document.getElementById("comment-image-input").click();
  }
  // 处理主页评论图片上传
  function handleCommentImageUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function (e) {
      commentImageData = e.target.result;
      const preview = document.getElementById("comment-image-preview");
      const img = document.getElementById("comment-image-preview-img");
      img.src = commentImageData;
      preview.style.display = "block";
      showXToast("图片已添加", "success");
    };
    reader.readAsDataURL(file);
  }
  // 移除主页评论图片
  function removeCommentImage() {
    commentImageData = null;
    const preview = document.getElementById("comment-image-preview");
    const img = document.getElementById("comment-image-preview-img");
    img.src = "";
    preview.style.display = "none";
    document.getElementById("comment-image-input").value = "";
  }
  // 触发详情页评论图片上传
  function triggerDetailCommentImageUpload() {
    document.getElementById("detail-comment-image-input").click();
  }

  // 触发详情页评论表情包选择
  function openCommentStickers() {
    if (window.setCommentStickerMode) {
      window.setCommentStickerMode(true);
    }

    if (window.resetSelectedCommentSticker) {
      window.resetSelectedCommentSticker();
    }

    if (window.openStickerPicker) {
      window.openStickerPicker();
    } else {
      showXToast("表情包功能暂不可用", "error");
    }
  }
  // 处理详情页评论图片上传
  function handleDetailCommentImageUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function (e) {
      detailCommentImageData = e.target.result;
      const preview = document.getElementById("detail-comment-image-preview");
      const img = document.getElementById("detail-comment-image-preview-img");
      img.src = detailCommentImageData;
      preview.style.display = "block";
      showXToast("图片已添加", "success");
    };
    reader.readAsDataURL(file);
  }
  // 移除详情页评论图片
  function removeDetailCommentImage() {
    detailCommentImageData = null;
    const preview = document.getElementById("detail-comment-image-preview");
    const img = document.getElementById("detail-comment-image-preview-img");
    img.src = "";
    preview.style.display = "none";
    document.getElementById("detail-comment-image-input").value = "";
  }
  // 处理评论输入
  function handleCommentInput(event) {
    const textarea = event.target;
    const replyBtn = document.getElementById("reply-btn"); // 更新按钮状态
    if (textarea.value.trim().length > 0) {
      replyBtn.style.opacity = "1";
      replyBtn.disabled = false;
    } else {
      replyBtn.style.opacity = "0.5";
      replyBtn.disabled = true;
    }
    // 回车发送评论（Shift+回车换行）
    if (event.key === "Enter" && !event.shiftKey) {
      event.preventDefault();
      if (textarea.value.trim().length > 0) {
        submitComment();
      }
    }
  }
  // 自动调整textarea高度
  function autoResize(textarea) {
    textarea.style.height = "20px";
    textarea.style.height = Math.min(textarea.scrollHeight, 120) + "px"; // 更新按钮状态
    const replyBtn = document.getElementById("reply-btn");
    if (textarea.value.trim().length > 0) {
      replyBtn.style.opacity = "1";
      replyBtn.disabled = false;
    } else {
      replyBtn.style.opacity = "0.5";
      replyBtn.disabled = true;
    }
  }
  // 当前正在查看的推文ID
  let currentTweetId = null; // 提交评论
  async function submitComment() {
    const textarea = document.getElementById("comment-input");
    const content = textarea.value.trim();
    if (content.length === 0 || !currentTweetId) return; // 获取当前推文数据 - 需要同时检查账户推文
    let tweet = null;
    let isAccountTweet = false; // 先从主页推文中查找
    const allTweets = [...forYouTweets, ...followingTweets];
    tweet = allTweets.find((t) => t.id === currentTweetId); // 如果没找到，检查是否为账户推文
    if (!tweet && currentViewingAccount && currentViewingAccount.tweets) {
      tweet = currentViewingAccount.tweets.find((t) => t.id === currentTweetId);
      isAccountTweet = !!tweet;
    }
    if (!tweet) {
      showXToast("无法找到对应的推文", "error");
      return;
    }
    // 检查是否为仅自己可见的帖子（主页推文一般不会有private标记，但为了统一）
    if (tweet.privacy === "private") {
      showXToast("私有帖子不支持回复功能", "error");
      return;
    }
    // 创建新评论对象（使用window.userProfileData确保获取最新账号数据）
    const newComment = {
      id: "new-" + Date.now(),
      user: {
        name: window.userProfileData.name,
        handle: window.userProfileData.handle,
        avatar: window.userProfileData.avatar,
        verified: window.userProfileData.verified,
      },
      content: content,
      timestamp: Date.now(), // 使用时间戳而不是固定文本
      replies: [],
    }; // 如果有图片，添加图片数据
    if (commentImageData) {
      newComment.image = {
        type: "upload",
        content: commentImageData,
      };
    }
    // 添加到对应推文的评论列表
    if (tweet) {
      // 确保评论列表存在
      if (!tweet.comments) {
        tweet.comments = [];
      }
      tweet.comments.push(newComment);
      tweet.stats.comments += 1; // 强制更新全局数组引用，确保数据同步
      const tweetIndex = forYouTweets.findIndex((t) => t.id === tweet.id);
      if (tweetIndex !== -1) {
        forYouTweets[tweetIndex] = tweet;
      } else {
        const followingIndex = followingTweets.findIndex(
          (t) => t.id === tweet.id
        );
        if (followingIndex !== -1) {
          followingTweets[followingIndex] = tweet;
        }
      }
      // 保存更新后的推文数据
      try {
        const db = getXDB();
        if (isAccountTweet) {
          // 保存到账户主页数据
          const accountHandle =
            tweet._accountHandle ||
            (currentViewingAccount.accountInfo || currentViewingAccount).handle;
          const cleanHandle = accountHandle.replace("@", ""); // 更新currentViewingAccount中的推文
          const tweetIndex = currentViewingAccount.tweets.findIndex(
            (t) => t.id === tweet.id
          );
          if (tweetIndex !== -1) {
            currentViewingAccount.tweets[tweetIndex] = tweet;
          }
          // 保存到数据库
          await db.xAccountProfiles.put({
            handle: cleanHandle,
            name: (currentViewingAccount.accountInfo || currentViewingAccount)
              .name,
            accountInfo:
              currentViewingAccount.accountInfo || currentViewingAccount,
            tweets: currentViewingAccount.tweets,
            accountReplies: currentViewingAccount.accountReplies || [],
            updatedAt: new Date().toISOString(),
          });
          console.log(
            "✅ 用户评论已保存到账户推文，评论ID:",
            newComment.id,
            "账户:",
            cleanHandle
          );
        } else {
          // 保存到主页推文数据
          await db.xTweetsData.put({
            id: "tweets",
            forYouTweets: forYouTweets,
            followingTweets: followingTweets,
            lastUpdated: new Date().toISOString(),
          });
          console.log("用户评论已保存到数据库，评论ID:", newComment.id);
        }
      } catch (saveError) {
        console.error("保存评论数据失败:", saveError);
      }
    }
    // 重新渲染评论
    renderComments(currentTweetId); // 清空输入框并重置高度
    textarea.value = "";
    textarea.style.height = "20px"; // 清除图片
    if (commentImageData) {
      removeCommentImage();
    }
    // 重置按钮状态
    const replyBtn = document.getElementById("reply-btn");
    replyBtn.style.opacity = "0.5";
    replyBtn.disabled = true; // 滚动到底部显示新评论
    const commentsContainer = document.querySelector(".comments-container");
    setTimeout(() => {
      commentsContainer.scrollTop = commentsContainer.scrollHeight;
    }, 100);
    showXToast("你的评论等待回复中", "info"); // 触发AI回复 - 判断是否为用户自己的帖子（主页推文中用户自己的帖子需要特别处理）
    const isOwnPost =
      tweet.user &&
      (tweet.user.handle === userProfileData.handle ||
        tweet.id.startsWith("user_")); // 延迟触发AI回复，确保用户评论已经完全渲染和保存
    setTimeout(async () => {
      await generateUnifiedAIResponse(tweet, newComment, {
        isOwnPost,
        commentType: "main_comment",
        pageType: "main",
        parentComment: null,
      });
    }, 100);
  }
  // 显示回复输入框
  function showReplyInput(commentId, userHandle) {
    // 隐藏所有其他回复输入框
    document.querySelectorAll(".reply-input-container").forEach((container) => {
      container.style.display = "none";
    }); // 显示当前评论的回复输入框
    const replyContainer = document.getElementById(`reply-input-${commentId}`);
    if (replyContainer) {
      replyContainer.style.display = "block";
      const textarea = replyContainer.querySelector("textarea");
      textarea.focus();
    }
  }
  // 取消回复
  function cancelReply(commentId) {
    const replyContainer = document.getElementById(`reply-input-${commentId}`);
    if (replyContainer) {
      replyContainer.style.display = "none";
      const textarea = replyContainer.querySelector("textarea");
      textarea.value = "";
      textarea.style.height = "20px"; // 重置按钮状态
      const replyBtn = document.getElementById(`reply-btn-${commentId}`);
      replyBtn.style.opacity = "0.5";
      replyBtn.disabled = true;
    }
  }
  // 处理回复输入
  function handleReplyInput(event, commentId, userHandle) {
    const textarea = event.target;
    const replyBtn = document.getElementById(`reply-btn-${commentId}`); // 更新按钮状态
    if (textarea.value.trim().length > 0) {
      replyBtn.style.opacity = "1";
      replyBtn.disabled = false;
    } else {
      replyBtn.style.opacity = "0.5";
      replyBtn.disabled = true;
    }
    // 回车发送回复
    if (event.key === "Enter" && !event.shiftKey) {
      event.preventDefault();
      if (textarea.value.trim().length > 0) {
        submitReply(commentId, userHandle);
      }
    }
  }
  // 自动调整回复textarea高度
  function autoResizeReply(textarea, commentId) {
    textarea.style.height = "20px";
    textarea.style.height = Math.min(textarea.scrollHeight, 80) + "px"; // 更新按钮状态
    const replyBtn = document.getElementById(`reply-btn-${commentId}`);
    if (textarea.value.trim().length > 0) {
      replyBtn.style.opacity = "1";
      replyBtn.disabled = false;
    } else {
      replyBtn.style.opacity = "0.5";
      replyBtn.disabled = true;
    }
  }
  // 提交回复
  async function submitReply(commentId, replyToHandle) {
    const replyContainer = document.getElementById(`reply-input-${commentId}`);
    const textarea = replyContainer.querySelector("textarea");
    const content = textarea.value.trim();
    if (content.length === 0) return; // 获取当前推文数据 - 先尝试从sessionStorage（详情页），再从主页数据
    let tweetData = null;
    const currentTweetDataFromSession =
      sessionStorage.getItem("currentTweetData");
    if (currentTweetDataFromSession) {
      // 详情页面的情况
      try {
        tweetData = JSON.parse(currentTweetDataFromSession);
      } catch (e) {
        console.error("解析sessionStorage推文数据失败:", e);
      }
    }
    if (!tweetData && currentTweetId) {
      // 主页推文的情况
      const allTweets = [...forYouTweets, ...followingTweets];
      tweetData = allTweets.find((t) => t.id === currentTweetId);
    }
    if (!tweetData) {
      showXToast("无法获取推文信息", "error");
      return;
    }
    // 检查是否为仅自己可见的帖子
    if (tweetData.privacy === "private") {
      showXToast("私有帖子不支持回复功能", "error");
      return;
    }
    // 找到被回复的评论 - 支持楼中楼回复并处理为平级显示
    let parentComment = null;
    let mainCommentId = commentId; // 用于查找主评论ID（对于楼中楼回复）
    const isDetailPage = !!currentTweetDataFromSession;
    const commentsContainer = isDetailPage
      ? document.getElementById("detail-comments-container")
      : document.querySelector(".comments-container");
    const allComments = commentsContainer.querySelectorAll(".comment-item"); // 首先找到被回复的评论
    let targetCommentEl = null;
    allComments.forEach((commentEl) => {
      if (commentEl.dataset.commentId === commentId) {
        targetCommentEl = commentEl;
      }
    });
    if (targetCommentEl) {
      // 从DOM中提取评论信息构建parentComment
      const userName =
        targetCommentEl.querySelector(".tweet-user-name").textContent;
      const userHandle =
        targetCommentEl.querySelector(".tweet-user-handle").textContent;
      const commentContent = targetCommentEl
        .querySelector(".comment-content")
        .textContent.trim();
      parentComment = {
        id: commentId,
        user: { name: userName, handle: userHandle },
        content: commentContent,
      }; // 如果被回复的是楼中楼，需要找到对应的主评论ID（用于数据存储）
      if (targetCommentEl.classList.contains("reply-item")) {
        // 向上查找同一个评论组中的主评论
        let currentEl = targetCommentEl.previousElementSibling;
        while (currentEl && currentEl.classList.contains("reply-item")) {
          currentEl = currentEl.previousElementSibling;
        }
        if (
          currentEl &&
          currentEl.classList.contains("comment-item") &&
          !currentEl.classList.contains("reply-item")
        ) {
          mainCommentId = currentEl.dataset.commentId;
        } else {
          // 如果向上没找到，可能是第一个回复，向上查找父容器中的主评论
          let parentContainer = targetCommentEl.parentNode;
          let firstComment = parentContainer.querySelector(
            ".comment-item:not(.reply-item)"
          );
          if (firstComment) {
            mainCommentId = firstComment.dataset.commentId;
          }
        }
      }
    }
    // 创建新回复对象（使用window.userProfileData确保获取最新账号数据）
    const newReply = {
      id: "reply-" + Date.now(),
      user: {
        name: window.userProfileData.name,
        handle: window.userProfileData.handle,
        avatar: window.userProfileData.avatar,
        verified: window.userProfileData.verified,
      },
      content: content,
      timestamp: Date.now(), // 使用时间戳而不是固定文本
      replyTo: replyToHandle,
      replies: [],
    };
    console.log("💬 [楼中楼回复] 创建新回复:", {
      id: newReply.id,
      content: newReply.content.substring(0, 50) + "...",
      replyTo: replyToHandle,
      mainCommentId,
      isDetailPage,
    });
    if (isDetailPage) {
      // 详情页面：渲染到页面并同时保存到数据库 - 修复楼中楼插入位置
      const commentElement = createCommentElement(newReply, true);
      if (targetCommentEl) {
        let insertAfter = null;
        if (targetCommentEl.classList.contains("reply-item")) {
          // 如果回复的是楼中楼，找到这个评论组的最后一个评论
          let nextSibling = targetCommentEl.nextElementSibling;
          insertAfter = targetCommentEl; // 找到当前评论组的最后一条评论
          while (nextSibling && nextSibling.classList.contains("reply-item")) {
            insertAfter = nextSibling;
            nextSibling = nextSibling.nextElementSibling;
          }
        } else {
          // 如果回复的是主评论，找到这个评论组的最后一条评论（包括所有楼中楼）
          let nextSibling = targetCommentEl.nextElementSibling;
          insertAfter = targetCommentEl;
          while (nextSibling && nextSibling.classList.contains("reply-item")) {
            insertAfter = nextSibling;
            nextSibling = nextSibling.nextElementSibling;
          }
        }
        // 插入到正确位置
        if (insertAfter.nextSibling) {
          insertAfter.parentNode.insertBefore(
            commentElement,
            insertAfter.nextSibling
          );
        } else {
          insertAfter.parentNode.appendChild(commentElement);
        }
      }
      // 同时保存到sessionStorage中的推文数据
      try {
        console.log("💬 [楼中楼回复] 开始保存到数据库");
        let updatedTweetData = JSON.parse(
          sessionStorage.getItem("currentTweetData")
        );
        if (updatedTweetData) {
          console.log("💬 [楼中楼回复] 推文ID:", updatedTweetData.id);
          console.log("💬 [楼中楼回复] 主评论ID:", mainCommentId);
          console.log(
            "💬 [楼中楼回复] 当前评论总数:",
            updatedTweetData.comments?.length || 0
          );
          const mainComment = updatedTweetData.comments.find(
            (c) => c.id === mainCommentId
          );
          if (mainComment) {
            console.log(
              "💬 [楼中楼回复] 找到主评论，当前回复数:",
              mainComment.replies?.length || 0
            );
            if (!mainComment.replies) mainComment.replies = [];
            mainComment.replies.push(newReply);
            console.log(
              "💬 [楼中楼回复] 新回复已添加，新回复总数:",
              mainComment.replies.length
            ); // 更新sessionStorage
            sessionStorage.setItem(
              "currentTweetData",
              JSON.stringify(updatedTweetData)
            );
            console.log("✅ [楼中楼回复] sessionStorage 已更新"); // 同时保存到数据库
            const db = getXDB();
            const isUserTweet = updatedTweetData.id.startsWith("user_");
            const isAccountTweet = updatedTweetData._source === "account";
            console.log("💬 [楼中楼回复] 是否为用户推文:", isUserTweet);
            console.log("💬 [楼中楼回复] 是否为账户推文:", isAccountTweet);
            if (isAccountTweet) {
              // 账户推文，保存到 xAccountProfiles
              console.log("💬 [楼中楼回复] 保存到账户推文数据库");
              const accountHandle =
                updatedTweetData._accountHandle ||
                (currentViewingAccount.accountInfo || currentViewingAccount)
                  .handle;
              const cleanHandle = accountHandle.replace("@", "");
              if (currentViewingAccount && currentViewingAccount.tweets) {
                const tweetIndex = currentViewingAccount.tweets.findIndex(
                  (t) => t.id === updatedTweetData.id
                );
                if (tweetIndex !== -1) {
                  currentViewingAccount.tweets[tweetIndex] = updatedTweetData;
                  await db.xAccountProfiles.put({
                    handle: cleanHandle,
                    name: (
                      currentViewingAccount.accountInfo || currentViewingAccount
                    ).name,
                    accountInfo:
                      currentViewingAccount.accountInfo ||
                      currentViewingAccount,
                    tweets: currentViewingAccount.tweets,
                    accountReplies: currentViewingAccount.accountReplies || [],
                    updatedAt: new Date().toISOString(),
                  });
                  console.log(
                    "✅ [楼中楼回复] 账户推文已更新，账户:",
                    cleanHandle
                  );
                } else {
                  console.warn("⚠️ [楼中楼回复] 未找到目标账户推文");
                }
              }
            } else if (isUserTweet) {
              // 用户自己的推文，保存到 xUserTweets
              console.log("💬 [楼中楼回复] 保存到用户推文数据库");
              const accountTweetsId = `userTweets_${
                currentAccountId || "main"
              }`;
              const userTweets = await db.xUserTweets.get(accountTweetsId);
              if (userTweets && userTweets.tweets) {
                console.log(
                  "💬 [楼中楼回复] 找到用户推文数据，推文总数:",
                  userTweets.tweets.length
                );
                const userTweetIndex = userTweets.tweets.findIndex(
                  (t) => t.id === updatedTweetData.id
                );
                if (userTweetIndex !== -1) {
                  console.log(
                    "💬 [楼中楼回复] 找到目标推文，索引:",
                    userTweetIndex
                  );
                  userTweets.tweets[userTweetIndex] = updatedTweetData;
                  await db.xUserTweets.put(userTweets);
                  console.log(
                    "✅ [楼中楼回复] 用户推文已更新到账户:",
                    accountTweetsId
                  );
                } else {
                  console.warn("⚠️ [楼中楼回复] 未找到目标用户推文");
                }
              } else {
                console.warn("⚠️ [楼中楼回复] 未找到用户推文数据");
              }
            } else {
              // 主页推文，保存到 xTweetsData
              console.log("💬 [楼中楼回复] 保存到主页推文数据库");
              const tweetsData = await db.xTweetsData.get("tweets");
              if (tweetsData) {
                let updated = false;
                if (tweetsData.forYouTweets) {
                  const tweetIndex = tweetsData.forYouTweets.findIndex(
                    (t) => t.id === updatedTweetData.id
                  );
                  if (tweetIndex !== -1) {
                    tweetsData.forYouTweets[tweetIndex] = updatedTweetData;
                    updated = true;
                    console.log("💬 [楼中楼回复] 已更新 forYouTweets");
                  }
                }
                if (!updated && tweetsData.followingTweets) {
                  const tweetIndex = tweetsData.followingTweets.findIndex(
                    (t) => t.id === updatedTweetData.id
                  );
                  if (tweetIndex !== -1) {
                    tweetsData.followingTweets[tweetIndex] = updatedTweetData;
                    updated = true;
                    console.log("💬 [楼中楼回复] 已更新 followingTweets");
                  }
                }
                if (updated) {
                  await db.xTweetsData.put(tweetsData);
                  console.log("✅ [楼中楼回复] 主页推文已保存到数据库");
                } else {
                  console.warn("⚠️ [楼中楼回复] 未在主页数据中找到目标推文");
                }
              }
            }
          } else {
            console.warn(
              "⚠️ [楼中楼回复] 未找到主评论，mainCommentId:",
              mainCommentId
            );
          }
        } else {
          console.warn("⚠️ [楼中楼回复] sessionStorage 中无推文数据");
        }
      } catch (saveError) {
        console.error("❌ [楼中楼回复] 保存失败:", saveError);
      }
    } else {
      // 主页推文：添加到数据并重新渲染 - 支持楼中楼平级回复
      const mainComment = tweetData.comments.find(
        (c) => c.id === mainCommentId
      );
      if (mainComment) {
        if (!mainComment.replies) mainComment.replies = [];
        mainComment.replies.push(newReply); // 强制更新全局数组引用，确保数据同步
        const tweetIndex = forYouTweets.findIndex((t) => t.id === tweetData.id);
        if (tweetIndex !== -1) {
          forYouTweets[tweetIndex] = tweetData;
        } else {
          const followingIndex = followingTweets.findIndex(
            (t) => t.id === tweetData.id
          );
          if (followingIndex !== -1) {
            followingTweets[followingIndex] = tweetData;
          }
        }
        // 保存更新后的推文数据
        try {
          const db = getXDB();
          await db.xTweetsData.put({
            id: "tweets",
            forYouTweets: forYouTweets,
            followingTweets: followingTweets,
            lastUpdated: new Date().toISOString(),
          });
          console.log("用户回复已保存到数据库，回复ID:", newReply.id);
        } catch (saveError) {
          console.error("保存回复数据失败:", saveError);
        }
        // 重新渲染评论
        renderComments(currentTweetId);
      }
    }
    // 隐藏回复输入框
    cancelReply(commentId);
    showXToast("你的评论等待回复中", "info"); // 触发AI回复 - 判断是否为用户自己的帖子
    const isOwnPost =
      tweetData.user &&
      (tweetData.user.handle === userProfileData.handle ||
        tweetData.id.startsWith("user_")); // 延迟触发AI回复，确保用户回复已经完全渲染和保存
    setTimeout(async () => {
      await generateUnifiedAIResponse(tweetData, newReply, {
        isOwnPost,
        commentType: "reply_comment",
        pageType: isDetailPage ? "detail" : "main",
        parentComment,
        mainCommentId, // 传递主评论ID用于楼中楼回复处理
      });
    }, 100);
  }
  // 修改显示推文评论页面函数，保存当前推文ID
  async function showTweetComments(tweetId) {
    console.log("📖 [首页推文] 点击评论按钮，推文ID:", tweetId); // 从forYouTweets或followingTweets中找到对应的推文
    let tweet = forYouTweets.find((t) => t.id === tweetId);
    if (!tweet) {
      tweet = followingTweets.find((t) => t.id === tweetId);
    }
    if (!tweet) {
      console.error("❌ [首页推文] 未找到推文:", tweetId);
      showXToast("未找到该推文", "error");
      return;
    }
    // 使用统一的推文详情页面显示
    await showTweetDetail(tweet);
  }
  // X风格提示框（PSP风格设计）
  function showXToast(message, type = "success") {
    // 移除现有的提示框
    const existingToast = document.querySelector(".x-toast");
    if (existingToast) {
      existingToast.remove();
    }

    // 🎨 主题检测
    const xSocialScreen = document.getElementById("x-social-screen");
    const isLightTheme = xSocialScreen?.classList.contains("x-theme-light");

    // 🎨 根据类型和主题设置颜色
    let bgColor, borderColor, textColor, shadowColor, icon;

    if (type === "success") {
      icon = "✓";
      if (isLightTheme) {
        bgColor = "linear-gradient(135deg, rgba(29, 155, 240, 0.15) 0%, rgba(29, 155, 240, 0.08) 100%)";
        borderColor = "rgba(29, 155, 240, 0.4)";
        textColor = "#1d9bf0";
        shadowColor = "rgba(29, 155, 240, 0.3)";
      } else {
        bgColor = "linear-gradient(135deg, rgba(29, 155, 240, 0.25) 0%, rgba(29, 155, 240, 0.15) 100%)";
        borderColor = "rgba(29, 155, 240, 0.6)";
        textColor = "#60c5ff";
        shadowColor = "rgba(29, 155, 240, 0.4)";
      }
    } else if (type === "error") {
      icon = "✕";
      if (isLightTheme) {
        bgColor = "linear-gradient(135deg, rgba(244, 33, 46, 0.15) 0%, rgba(244, 33, 46, 0.08) 100%)";
        borderColor = "rgba(244, 33, 46, 0.4)";
        textColor = "#f4212e";
        shadowColor = "rgba(244, 33, 46, 0.3)";
      } else {
        bgColor = "linear-gradient(135deg, rgba(244, 33, 46, 0.25) 0%, rgba(244, 33, 46, 0.15) 100%)";
        borderColor = "rgba(244, 33, 46, 0.6)";
        textColor = "#ff6b75";
        shadowColor = "rgba(244, 33, 46, 0.4)";
      }
    } else {
      // info 类型
      icon = "ℹ";
      if (isLightTheme) {
        bgColor = "linear-gradient(135deg, rgba(83, 100, 113, 0.15) 0%, rgba(83, 100, 113, 0.08) 100%)";
        borderColor = "rgba(83, 100, 113, 0.4)";
        textColor = "#536471";
        shadowColor = "rgba(83, 100, 113, 0.3)";
      } else {
        bgColor = "linear-gradient(135deg, rgba(113, 118, 123, 0.25) 0%, rgba(113, 118, 123, 0.15) 100%)";
        borderColor = "rgba(113, 118, 123, 0.6)";
        textColor = "#8b98a5";
        shadowColor = "rgba(113, 118, 123, 0.4)";
      }
    }

    // 📦 创建Toast容器
    const toast = document.createElement("div");
    toast.className = "x-toast";
    toast.innerHTML = `
      <div class="x-toast-icon">${icon}</div>
      <div class="x-toast-message">${message}</div>
      <div class="x-toast-scanline"></div>
    `;

    // 🎨 PSP风格样式
    toast.style.cssText = `
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 20px;
      background: ${bgColor};
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 2px solid ${borderColor};
      color: ${textColor};
      font-size: 15px;
      font-weight: 600;
      z-index: 100000;
      box-shadow:
        0 4px 16px ${shadowColor},
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      clip-path: polygon(
        0 8px, 8px 0, calc(100% - 8px) 0, 100% 8px,
        100% calc(100% - 8px), calc(100% - 8px) 100%,
        8px 100%, 0 calc(100% - 8px)
      );
      animation: xToastSlideIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      pointer-events: none;
      user-select: none;
    `;

    // 🎨 图标样式
    const iconEl = toast.querySelector(".x-toast-icon");
    iconEl.style.cssText = `
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      font-size: 16px;
      font-weight: bold;
      flex-shrink: 0;
    `;

    // 🎨 消息样式
    const messageEl = toast.querySelector(".x-toast-message");
    messageEl.style.cssText = `
      flex: 1;
      line-height: 1.4;
    `;

    // 🎨 扫描线效果
    const scanlineEl = toast.querySelector(".x-toast-scanline");
    scanlineEl.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: repeating-linear-gradient(
        0deg,
        rgba(255, 255, 255, 0.03) 0px,
        rgba(255, 255, 255, 0.03) 1px,
        transparent 1px,
        transparent 2px
      );
      pointer-events: none;
      z-index: 1;
    `;

    // 🎬 添加动画样式
    const style = document.createElement("style");
    style.textContent = `
      @keyframes xToastSlideIn {
        0% {
          opacity: 0;
          transform: translateX(-50%) translateY(-30px) scale(0.9);
        }
        100% {
          opacity: 1;
          transform: translateX(-50%) translateY(0) scale(1);
        }
      }
      @keyframes xToastSlideOut {
        0% {
          opacity: 1;
          transform: translateX(-50%) translateY(0) scale(1);
        }
        100% {
          opacity: 0;
          transform: translateX(-50%) translateY(-30px) scale(0.9);
        }
      }
    `;
    document.head.appendChild(style);
    document.body.appendChild(toast);

    // ⏰ 3秒后滑出并移除
    setTimeout(() => {
      toast.style.animation = "xToastSlideOut 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards";
      setTimeout(() => {
        if (toast.parentNode) {
          toast.remove();
        }
        if (style.parentNode) {
          style.remove();
        }
      }, 300);
    }, 2700);
  }
  // ▼▼▼ 【主要！！！】第一个情景：推文生成器▼▼▼
  async function refreshXTweets() {
    const refreshBtn = document.querySelector(".x-refresh-btn"); // 添加旋转动画
    refreshBtn.style.animation = "spin 1s linear infinite";
    const spinStyle = document.createElement("style");
    spinStyle.textContent = `
 @keyframes spin {
 from {transform: rotate(0deg); }
 to {transform: rotate(360deg); }
 }
 `;
    document.head.appendChild(spinStyle);
    try {
      // CSV解析函数
      function parseCSVToTweets(csvText) {
        const lines = csvText
          .split("\n")
          .map((line) => line.trim())
          .filter((line) => line);
        const tweetsData = {
          forYouTweets: [],
          followingTweets: [],
        };
        let currentSection = "";
        let tweetIndex = 0;
        for (const line of lines) {
          if (line.includes("=== 为你推荐 ===")) {
            currentSection = "forYou";
            tweetIndex = 0;
            continue;
          } else if (line.includes("=== 正在关注 ===")) {
            currentSection = "following";
            tweetIndex = 0;
            continue;
          }
          // 跳过表头
          if (
            line.includes("用户名,用户句柄,用户头像,是否认证") ||
            line.includes("评论1用户名,评论1句柄")
          ) {
            continue;
          }
          // 解析推文数据行
          if (currentSection && line.includes(",")) {
            const values = line.split(",").map((v) => v.trim());
            if (values.length >= 12) {
              // 至少包含基本推文信息（包括头像字段）
              const tweet = {
                id: `${currentSection}_${tweetIndex}`,
                user: {
                  name: values[0] || "匿名用户",
                  handle: values[1] || "@anonymous",
                  avatar:
                    values[2] ||
                    "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
                  verified: values[3] === "是",
                },
                content: values[4] || "",
                time: values[5] || "刚刚",
                media: values[6]
                  ? [
                      {
                        type: "image",
                        description: values[6],
                        sensitive: values[7] === "是",
                      },
                    ]
                  : [],
                stats: {
                  comments: parseInt(values[8]) || 0,
                  retweets: parseInt(values[9]) || 0,
                  likes: parseInt(values[10]) || 0,
                  views: parseInt(values[11]) || 0,
                },
                comments: [],
              }; // 解析引用推文数据（如果存在）
              // 检查引用字段：索引12-18是引用相关字段（引用类型、引用用户名、引用句柄、引用头像、引用认证、引用内容、引用时间）
              if (
                values.length >= 19 &&
                values[12] &&
                values[13] &&
                values[17]
              ) {
                tweet.quotedTweet = {
                  type: values[12] || "tweet", // 'tweet' 或 'comment'
                  user: {
                    name: values[13] || "引用用户",
                    handle: values[14] || "@quoted",
                    avatar:
                      values[15] ||
                      "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
                    verified: values[16] === "是",
                  },
                  content: values[17] || "",
                  time: values[18] || "刚刚",
                };
              }
              // 统一处理评论解析：所有推文的评论都从索引19开始
              // 无论是否有引用推文，评论字段的位置都是固定的
              const comments = [];
              const commentStartIndex = 19; // 12个基本字段 + 7个引用字段 = 19
              // 从索引19开始，每7个字段为一个评论：用户名、句柄、头像、认证、内容、时间、回复对象
              let commentIndex = 1;
              let startIndex = commentStartIndex;
              while (startIndex + 6 < values.length) {
                const commentName = values[startIndex];
                const commentHandle = values[startIndex + 1];
                const commentAvatar = values[startIndex + 2];
                const commentVerified = values[startIndex + 3];
                const commentContent = values[startIndex + 4];
                const commentTime = values[startIndex + 5];
                const commentReplyTo = values[startIndex + 6]; // 检查评论是否有效（至少需要用户名、句柄、内容）
                if (commentName && commentHandle && commentContent) {
                  const newComment = {
                    id: `${tweet.id}_c${commentIndex}`,
                    user: {
                      name: commentName,
                      handle: commentHandle,
                      avatar:
                        commentAvatar ||
                        "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
                      verified: commentVerified === "是",
                    },
                    content: commentContent,
                    time: commentTime || "刚刚",
                    replyTo: commentReplyTo || "",
                    replies: [],
                  }; // 如果这个评论是回复其他评论，找到被回复的评论并添加为回复
                  if (commentReplyTo) {
                    const targetComment = comments.find(
                      (c) => c.user.handle === commentReplyTo
                    );
                    if (targetComment) {
                      targetComment.replies.push(newComment);
                    } else {
                      // 如果找不到被回复的评论，作为独立评论添加
                      comments.push(newComment);
                    }
                  } else {
                    // 独立评论
                    comments.push(newComment);
                  }
                  commentIndex++;
                } else {
                  // 如果遇到空的评论字段，停止解析
                  break;
                }
                // 移动到下一个评论的起始位置
                startIndex += 7;
              }
              tweet.comments = comments;
              if (currentSection === "forYou") {
                tweetsData.forYouTweets.push(tweet);
              } else if (currentSection === "following") {
                tweetsData.followingTweets.push(tweet);
              }
              tweetIndex++;
            }
          }
        }
        return tweetsData;
      }
      // 🔧 使用统一的API配置加载工具
      const { db, xDb, apiConfig, xSettings } =
        await APIUtils.loadConfigAndSettings();
      const { userPrompt, worldSetting, boundCharacters } = xSettings;
      // 🔧 使用统一的NPC加载工具
      const boundNPCs = await APIUtils.loadBoundNPCs();
      // 使用工具函数构建用户X个人资料信息（使用window.userProfileData确保获取最新数据）
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(
        window.userProfileData
      ); // 调试：输出用户身份识别设置
      console.log("🎭 绑定角色数量:", boundCharacters.length);
      if (boundCharacters.length > 0) {
        console.log("🎭 绑定角色列表:", boundCharacters);
      }
      console.log(
        "👤 已知身份角色数:",
        window.userProfileData.knownIdentityCharacters?.length || 0
      );
      if (window.userProfileData.knownIdentityCharacters?.length > 0) {
        console.log(
          "👤 已知身份角色列表:",
          window.userProfileData.knownIdentityCharacters
        );
      }
      // 检测用户是否为高曝光身份（明星/网红等公众人物）
      const userPublicIdentity = userXProfileInfo.publicIdentity || "";
      const userBio = userXProfileInfo.bio || "";
      const isUserHighExposure =
        /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
          userPublicIdentity + " " + userBio
        ); // 检测角色是否为高曝光身份
      const highExposureCharacters = [];
      if (boundCharacters.length > 0) {
        const allXProfiles = await xDb.xCharacterProfiles.toArray();
        for (const charId of boundCharacters) {
          const xProfile = allXProfiles.find((p) => p.characterId === charId);
          if (xProfile && xProfile.publicIdentity) {
            const isCharHighExposure =
              /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
                xProfile.publicIdentity
              );
            if (isCharHighExposure) {
              highExposureCharacters.push({
                characterId: charId,
                xProfile: xProfile,
              });
            }
          }
        }
      }
      console.log("🌟 高曝光身份检测:", {
        isUserHighExposure,
        highExposureCharactersCount: highExposureCharacters.length,
        highExposureCharactersList: highExposureCharacters.map(
          (c) => c.xProfile.xName
        ),
      }); // 如果有高曝光身份，读取近期推文
      let recentTweetsContext = "";
      if (isUserHighExposure || highExposureCharacters.length > 0) {
        const userTweetsId = `userTweets_${currentAccountId || "main"}`;
        const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
        const recentUserTweets = userTweetsData?.tweets?.slice(0, 3) || [];
        if (recentUserTweets.length > 0 || highExposureCharacters.length > 0) {
          recentTweetsContext = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━🌟 高曝光身份 - 近期推文上下文
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
以下是高曝光身份的公众人物近期发布的推文，其他用户可能会讨论这些内容：
`; // 添加用户近期推文
          if (isUserHighExposure && recentUserTweets.length > 0) {
            recentTweetsContext += `
【${userXProfileInfo.name} 的近期推文】（${userXProfileInfo.publicIdentity}）
`;
            recentUserTweets.forEach((tweet, index) => {
              recentTweetsContext += `
${index + 1}. "${tweet.content}"`;
              // 添加位置信息
              if (tweet.location) {
                recentTweetsContext += `
- 位置：${tweet.location}`;
              }
              // 添加图片信息
              if (tweet.image) {
                if (tweet.image.type === "description") {
                  recentTweetsContext += `
- 图片描述：${tweet.image.content}`;
                } else if (tweet.image.type === "upload") {
                  recentTweetsContext += `
- 附带真实上传图片`;
                } else if (
                  tweet.image.type === "uploads" &&
                  tweet.image.images
                ) {
                  recentTweetsContext += `
- 附带${tweet.image.images.length}张真实上传图片`;
                }
              }
              // 添加链接信息
              if (tweet.link) {
                recentTweetsContext += `
- 附带链接：${tweet.link.title || tweet.link.url || "链接"}`;
                if (tweet.link.description) {
                  recentTweetsContext += `（${tweet.link.description}）`;
                }
              }
              // 添加引用推文信息
              if (tweet.quotedTweet) {
                const quoted = tweet.quotedTweet;
                const quotedType = quoted.type === "tweet" ? "推文" : "评论";
                recentTweetsContext += `
- 引用转发了 ${quoted.user.name} 的${quotedType}："${quoted.content}"`;
                if (quoted.image) {
                  if (quoted.image.type === "description") {
                    recentTweetsContext += `（含图片：${quoted.image.content}）`;
                  } else {
                    recentTweetsContext += `（含图片）`;
                  }
                }
              }
              // 添加粉丝群引用信息
              if (tweet.quotedFanGroup) {
                const fanGroup = tweet.quotedFanGroup;
                recentTweetsContext += `
- 转发了粉丝群：${fanGroup.name}（${fanGroup.memberCount || 0}位成员，门槛：${
                  fanGroup.threshold || "无"
                }）`;
              }
              recentTweetsContext += `
- 发布时间：${tweet.time || "最近"}
- 互动数据：${tweet.stats?.likes || 0}喜欢，${
                tweet.stats?.retweets || 0
              }转发，${tweet.stats?.comments || 0}评论
`;
            });
          }
          // 添加高曝光角色的近期推文（如果有）
          for (const { xProfile } of highExposureCharacters) {
            recentTweetsContext += `
【${xProfile.xName} 的信息】（${xProfile.publicIdentity}）
- 可能会发布与其身份相关的推文
- 可能会被其他用户讨论或提及
`;
          }
          recentTweetsContext += `
【高曝光身份推文生成规则】：
- 约20-30%的新推文可以包含对上述推文的讨论、转发、或评论
- 讨论应该是其他普通用户或粉丝的视角，而非本人
- 可以是支持、批评、分析、或单纯的转发评论
- 不要在每条推文中都提及，保持自然和多样性
- 其余70-80%的推文应该是与高曝光身份无关的通用热门内容
- 如果生成讨论推文，要体现公众人物的影响力（较高的互动数据）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          console.log(
            "📰 已加载高曝光身份近期推文上下文，用户推文数:",
            recentUserTweets.length
          );
        }
      }
      // Token计数器
      let tokenCount = 0; // 0. 时间感知（北京时间）
      const now = new Date();
      const timeInfo = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⏰ 时间感知
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
当前北京时间：${now.toLocaleString("zh-CN", {
        timeZone: "Asia/Shanghai",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        weekday: "long",
      })}
【时间相关提示】：
- 生成的推文时间应该合理（例如：刚刚、1分钟前、5分钟前、1小时前、今天 xx:xx等）
- 不要生成未来时间
- 根据当前时间判断是早晨、中午、下午、晚上、深夜，内容应该符合时段特征
- 周末/工作日的内容风格可以有所不同
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`; // 1. 提示词 + 世界书
      let systemPrompt =
        timeInfo +
        StringBuilders.buildBaseSystemPrompt({
          userPrompt,
          worldSetting,
        });
      tokenCount = TokenUtils.logTokenUsage(
        "推文生成器",
        "时间感知+基础系统提示词",
        systemPrompt,
        tokenCount
      ); // 1.5. 获取适用的世界书内容
      const worldBooksContent = await StringBuilders.getApplicableWorldBooks(
        "feed",
        {
          boundCharacters,
        }
      );
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage(
          "推文生成器",
          "世界书内容",
          worldBooksContent,
          tokenCount
        );
      }

      // 1.7. 🌍 读取世界运转大事件（如果启用）
      const worldEventsDataId = `worldEvents_${currentAccountId || "main"}`;
      const worldEventsRecord = await xDb.xWorldEvents.get(worldEventsDataId);
      if (
        worldEventsRecord &&
        worldEventsRecord.enabled &&
        worldEventsRecord.events &&
        worldEventsRecord.events.length > 0
      ) {
        const worldEventsPrompt = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🌍 世界运转状态（推文生成必读）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【当前世界设定】：
📍 所在地点：${worldEventsRecord.location}
🌤️ 天气状况：${worldEventsRecord.weather?.condition || "--"} ${
          worldEventsRecord.weather?.temp || "--"
        }
💡 穿衣建议：${worldEventsRecord.weather?.tip || "--"}

【近期大事件】（${worldEventsRecord.events.length}个热门事件）：
${worldEventsRecord.events
  .map(
    (event, index) => `
${index + 1}. [${event.category}] ${event.title}
   详情：${event.detail}
   影响：${event.impact}
`
  )
  .join("")}

【大事件融入规则】：
🎯 核心原则：约10-40%的推文应该围绕这些大事件展开，让世界显得鲜活
1. **直接讨论**：路人/角色直接评论某个事件，发表看法
2. **间接影响**：事件影响了日常生活（如天气影响穿着、政策影响工作等）
3. **转发声明**：如果某个事件涉及明星/公众人物，可能有当事人声明或粉丝转发
4. **话题延伸**：从大事件延伸出相关话题讨论
5. **黑色幽默**：保持讽刺、夸张的黑色幽默风格，与事件本身的风格一致
6. **自然融入**：不要强行在每条推文中提及，保持多样性

【注意】：
- 其余60-90%的推文可以是与事件无关的日常内容
- 事件讨论要符合用户/角色的身份和视角
- 路人评论只能基于事件的公开信息，不能知道内幕细节
- 角色如果与事件相关（如明星角色遇到娱乐事件），可以有更深入的互动
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        systemPrompt += worldEventsPrompt;
        tokenCount = TokenUtils.logTokenUsage(
          "推文生成器",
          "世界运转大事件",
          worldEventsPrompt,
          tokenCount
        );
        console.log(
          `🌍 [推文生成器] 已注入 ${worldEventsRecord.events.length} 个世界大事件`
        );
      } else {
        console.log("ℹ️ [推文生成器] 世界大事件未启用或无数据，生成常规推文");
      }

      // 2. 角色定义（推文生成专用）
      systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务说明 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的内容生成器。请生成两组推文数据：
- "为你推荐"页面（热门有趣内容）
- "正在关注"页面（个人生活日常）
**你只负责生成其他用户的推文，绝不生成用户本人的推文！**

🚨 **重要：你必须只返回有效的JSON格式数据，任何语法错误都会导致系统崩溃！** 🚨
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【生成要求】：
- 每组生成5-10条推文，内容多样化
- 热门推文5-12条评论，普通推文1-5条，支持多层级楼中楼回复
- **绑定角色可以作为推文发布者**：根据角色设定和兴趣发布独立推文
- **绑定NPC可以作为推文发布者**：根据NPC人设和发帖习惯发布推文
- NPC关系互动：有绑定关系的NPC在角色推文下自然留言，体现关系特点
- 除了绑定角色外，其他用户头像统一：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
- 引用推文功能：约20-30%的推文可以使用引用功能，适合表达观点、评论热点、转发有趣内容
【情侣关系与粉丝群体规则】：
${
  userXProfileInfo.verificationType === "couple" &&
  userXProfileInfo.coupleCharacterName
    ? `- **情侣关系自然化**：用户与${userXProfileInfo.coupleCharacterName}是公开情侣，但这是私人关系
- 情侣角色可以偶尔出现在推文/评论中，但频率要低（建议10-20%概率），保持自然
- 情侣互动应该围绕推文主题，不要每次都强调情侣身份
- 粉丝群体判断：
* 如果用户或情侣角色有明星/网红/公众人物等身份 → 可以生成少量CP粉丝评论（最多1-2条）
* 如果都是普通人身份 → 禁止生成"磕CP""嗑糖"等粉丝向评论，普通情侣不会有粉丝群体`
    : "- **普通情侣关系**：如果生成情侣内容，确保只在适合的场景下出现，且不应有粉丝群体"
}`;
      const coreTaskSection = systemPrompt.substring(
        tokenCount > 0
          ? systemPrompt.lastIndexOf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
          : 0
      );
      tokenCount = TokenUtils.logTokenUsage(
        "推文生成器",
        "核心任务说明",
        coreTaskSection,
        tokenCount
      ); // 3. 角色资料（推文发布场景）
      const charactersInfo = await StringBuilders.buildCompleteCharacterInfo(
        boundCharacters,
        userXProfileInfo,
        "tweet"
      );
      if (charactersInfo) {
        systemPrompt += charactersInfo;
        tokenCount = TokenUtils.logTokenUsage(
          "推文生成器",
          "角色资料信息",
          charactersInfo,
          tokenCount
        );
      }
      // 3.3. 角色关系网络（新增）
      const relationshipsInfo =
        await StringBuilders.buildCharacterRelationships(
          boundCharacters,
          currentAccountId || "main"
        );
      if (relationshipsInfo) {
        systemPrompt += relationshipsInfo;
        tokenCount = TokenUtils.logTokenUsage(
          "推文生成器",
          "角色关系网络",
          relationshipsInfo,
          tokenCount
        );
        console.log("💞 已加载角色关系网络信息");
      }
      // 3.5. NPC资料（绑定NPC信息）
      if (boundNPCs.length > 0) {
        const npcSectionStart = systemPrompt.length;
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 绑定NPC资料
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
以下是与当前用户绑定的NPC，他们可以在推文生成中作为独立用户出现：
`;
        for (const npc of boundNPCs) {
          systemPrompt += `
【NPC基本信息】
- X姓名：${npc.name}
- X句柄：${npc.handle}
- X头像：${npc.avatar}
- 认证状态：false（NPC默认无认证）
【NPC人设】
${npc.personality || "暂无人设描述"}
【发帖习惯】
${npc.postingHabits || "暂无发帖习惯描述"}
【主页内容】
${npc.homepage || "暂无主页内容设置"}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        }
        systemPrompt += `
【NPC使用规则】：
1. NPC可以作为推文发布者，生成符合其人设和发帖习惯的推文
2. NPC可以在评论区出现，根据其人设进行互动
3. NPC的内容应该围绕其人设和主页内容展开
4. NPC与角色/用户的互动应该自然，不要过于频繁
5. 严格使用NPC的X姓名(${boundNPCs
          .map((n) => n.name)
          .join("、")})、句柄(${boundNPCs
          .map((n) => n.handle)
          .join("、")})和头像
6. NPC认证状态固定为 false
`;
        const npcSection = systemPrompt.substring(npcSectionStart);
        tokenCount = TokenUtils.logTokenUsage(
          "推文生成器",
          "NPC资料信息",
          npcSection,
          tokenCount
        );
      }
      // 3.7. 高曝光身份近期推文上下文（如果有）
      if (recentTweetsContext) {
        systemPrompt += recentTweetsContext;
        tokenCount = TokenUtils.logTokenUsage(
          "推文生成器",
          "高曝光身份推文上下文",
          recentTweetsContext,
          tokenCount
        );
      }
      // 4. 用户资料
      const userConstraintsStart = systemPrompt.length;
      systemPrompt +=
        StringBuilders.buildUniversalConstraints(userXProfileInfo);
      const userConstraints = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage(
        "推文生成器",
        "用户资料约束",
        userConstraints,
        tokenCount
      );
      systemPrompt += `
【JSON返回格式】：
\`\`\`json
{"forYouTweets": [推文数组], "followingTweets": [推文数组]}
\`\`\`
推文对象结构：
- user: {name, handle, avatar, verified}
- content: 推文文本
- time: 时间描述
- stats: {comments, retweets, likes, views} (纯数字)
- sticker: {url: "表情包链接", description: "表情包描述"} (可选，约10-15%评论使用)
- media: [{type:"description", description:"文字描述，至少30字"}] (可选)
- quotedTweet: {type, user, content, time} (可选，约20-30%推文使用)
- comments: [评论数组] (3-8条热门推文，1-4条普通推文)
评论对象结构：
- user: {name, handle, avatar, verified}
- content: 评论文本
- time: 时间描述
- replies: [回复数组] (可选，支持多层级但不超过3层)
- replyTo: "@被回复者句柄" (楼中楼回复时必填)
关键规则：
1. verified字段必须是布尔值(true/false)
2. stats中所有数字必须是纯数字，不带引号
3. 可选字段不使用时完全省略，不要设为null
4. content直接写内容，不用引号包裹`;
      const formatSection = systemPrompt.substring(
        systemPrompt.lastIndexOf("【JSON返回格式】")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "推文生成器",
        "JSON格式要求",
        formatSection,
        tokenCount
      );
      const messages = [
        { role: "user", content: "请生成新的X社交平台推文数据" },
      ]; // 最终统计
      TokenUtils.logFinalPrompt(
        "推文生成器",
        systemPrompt,
        messages[0].content
      ); // 🔧 使用统一的API请求工具
      const aiResponseContent = await APIUtils.sendAIRequest({
        apiConfig,
        systemPrompt,
        messages,
        temperature: 0.8,
      }); // 🔧 使用统一的JSON解析工具
      let newTweetsData = APIUtils.parseJSONResponse(aiResponseContent); // 🔧 使用统一的后处理工具
      newTweetsData = await APIUtils.postProcessData(
        newTweetsData,
        userXProfileInfo
      ); // 验证数据格式
      if (!newTweetsData.forYouTweets || !newTweetsData.followingTweets) {
        throw new Error("AI返回的数据格式不正确，缺少必要字段");
      }
      // 为推文添加必要的ID和格式化
      const processTweets = (tweets) => {
        return tweets.map((tweet) => {
          // 确保stats字段存在
          if (!tweet.stats) {
            tweet.stats = {
              comments: tweet.comments?.length || 0,
              retweets: 0,
              likes: 0,
              views: 0,
            };
          }
          // 处理评论数据，添加ID
          if (tweet.comments) {
            tweet.comments = tweet.comments.map((comment) => {
              const processedComment = {
                ...comment,
                id: `c_${Date.now()}_${Math.random()
                  .toString(36)
                  .substr(2, 9)}`,
              }; // 处理回复数据
              if (comment.replies) {
                processedComment.replies = comment.replies.map((reply) => ({
                  ...reply,
                  id: `r_${Date.now()}_${Math.random()
                    .toString(36)
                    .substr(2, 9)}`,
                }));
              }
              return processedComment;
            });
          }
          return tweet;
        });
      };
      newTweetsData.forYouTweets = processTweets(newTweetsData.forYouTweets);
      newTweetsData.followingTweets = processTweets(
        newTweetsData.followingTweets
      ); // 为推文分配ID和时间戳
      const timestamp = Date.now();
      newTweetsData.forYouTweets.forEach((tweet, index) => {
        tweet.id = `fy_${timestamp}_${index}`;
        tweet.createdAt = timestamp; // 添加创建时间戳用于动态时间计算
      });
      newTweetsData.followingTweets.forEach((tweet, index) => {
        tweet.id = `fl_${timestamp}_${index}`;
        tweet.createdAt = timestamp; // 添加创建时间戳用于动态时间计算
      }); // 🔧 推进模式：在现有推文前面添加新推文，而不是覆盖
      forYouTweets.unshift(...newTweetsData.forYouTweets);
      followingTweets.unshift(...newTweetsData.followingTweets); // 限制推文总数，避免数据过多（保留最新的50条）
      if (forYouTweets.length > 50) {
        forYouTweets.splice(50);
      }
      if (followingTweets.length > 50) {
        followingTweets.splice(50);
      }
      // 保存推文数据到数据库
      try {
        await xDb.xTweetsData.put({
          id: "tweets",
          forYouTweets: newTweetsData.forYouTweets,
          followingTweets: newTweetsData.followingTweets,
          lastUpdated: new Date().toISOString(),
        });
      } catch (saveError) {
        console.error("保存推文数据失败:", saveError);
      }
      // 检查是否有人@用户
      const userHandle = userXProfileInfo.handle;
      let mentionFound = false; // 检查"为你推荐"中的推文和评论
      for (const tweet of newTweetsData.forYouTweets) {
        if (tweet.content && tweet.content.includes(userHandle)) {
          mentionFound = true;
          break;
        }
        if (tweet.comments) {
          for (const comment of tweet.comments) {
            if (comment.content && comment.content.includes(userHandle)) {
              mentionFound = true;
              break;
            }
            // 检查回复中的内容
            if (comment.replies) {
              for (const reply of comment.replies) {
                if (reply.content && reply.content.includes(userHandle)) {
                  mentionFound = true;
                  break;
                }
              }
            }
            if (mentionFound) break;
          }
        }
        if (mentionFound) break;
      }
      // 检查"正在关注"中的推文和评论
      if (!mentionFound) {
        for (const tweet of newTweetsData.followingTweets) {
          if (tweet.content && tweet.content.includes(userHandle)) {
            mentionFound = true;
            break;
          }
          if (tweet.comments) {
            for (const comment of tweet.comments) {
              if (comment.content && comment.content.includes(userHandle)) {
                mentionFound = true;
                break;
              }
              // 检查回复中的内容
              if (comment.replies) {
                for (const reply of comment.replies) {
                  if (reply.content && reply.content.includes(userHandle)) {
                    mentionFound = true;
                    break;
                  }
                }
              }
              if (mentionFound) break;
            }
          }
          if (mentionFound) break;
        }
      }
      // 标记新推文（用于动画效果）
      newTweetsData.forYouTweets.forEach((tweet) => {
        tweet.isNew = true;
      });
      newTweetsData.followingTweets.forEach((tweet) => {
        tweet.isNew = true;
      }); // 重新渲染页面
      renderTweets(forYouTweets, "for-you-content");
      renderTweets(followingTweets, "following-content"); // 显示相应的提醒消息
      const isEnglish = currentLanguage === "en";
      const userAvatar =
        window.userProfileData?.avatar ||
        "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg";
      if (mentionFound) {
        showPhoneNotification({
          title: "X",
          message: isEnglish
            ? "Your feed has been refreshed! Someone mentioned you 🔔"
            : "你的首页已刷新！有人提到你了哦 🔔",
          avatar: userAvatar,
          leftIcon: "x",
        });
      } else {
        showPhoneNotification({
          title: "X",
          message: isEnglish
            ? "Your feed has been refreshed!"
            : "你的首页已刷新！",
          avatar: userAvatar,
          leftIcon: "x",
        });
      }
    } catch (error) {
      console.error("刷新推文失败:", error);
      showXToast(`刷新失败: ${error.message}`, "error");
    } finally {
      // 停止旋转动画
      refreshBtn.style.animation = "";
      if (spinStyle.parentNode) {
        spinStyle.remove();
      }
    }
  }
  // ▲▲▲ 【主要！！！】第一个情景：推文生成器 ▲▲▲

  // ============================================
  // ▼▼▼ 【新增！！！】第十二个情景：世界运转大事件生成器 ▼▼▼
  // ============================================

  // 全局状态：世界大事件是否启用
  let worldEventsEnabled = false;

  // 开关切换：世界运转大事件
  window.toggleWorldEvents = async function () {
    worldEventsEnabled = !worldEventsEnabled;
    const toggle = document.getElementById("world-events-toggle");
    const circle = toggle.querySelector(".toggle-circle");
    const area = document.getElementById("world-events-area");
    const xDb = getXDB();
    const dataId = `worldEvents_${currentAccountId || "main"}`;

    if (worldEventsEnabled) {
      // 开启
      toggle.style.backgroundColor = "var(--x-accent)";
      circle.style.left = "22px";
      area.style.display = "block";

      // 检查是否已有数据
      const existingData = await xDb.xWorldEvents.get(dataId);

      if (
        !existingData ||
        !existingData.events ||
        existingData.events.length === 0
      ) {
        // 首次开启，生成大事件
        const isEnglish = currentLanguage === "en";
        showXToast(
          isEnglish ? "Generating world events..." : "正在生成世界大事件...",
          "info"
        );
        await generateWorldEvents();
      } else {
        // 已有数据，更新enabled状态并渲染
        existingData.enabled = true;
        await xDb.xWorldEvents.put(existingData);
        renderWorldEvents(existingData);
      }

      const isEnglish = currentLanguage === "en";
      showXToast(
        isEnglish ? "World Events enabled" : "世界运转大事件已开启",
        "success"
      );
    } else {
      // 关闭：更新数据库中的enabled状态
      const existingData = await xDb.xWorldEvents.get(dataId);
      if (existingData) {
        existingData.enabled = false;
        await xDb.xWorldEvents.put(existingData);
        console.log("🔴 [世界大事件] 已在数据库中标记为禁用");
      }

      toggle.style.backgroundColor = "#333";
      circle.style.left = "2px";
      area.style.display = "none";
      const isEnglish = currentLanguage === "en";
      showXToast(
        isEnglish ? "World Events disabled" : "世界运转大事件已关闭",
        "info"
      );
    }

    // 保存状态到设置表（双重保险）
    await saveWorldEventsState(worldEventsEnabled);
  };

  // 保存开关状态到数据库
  async function saveWorldEventsState(enabled) {
    try {
      const xDb = getXDB();
      const settingsId = `xSettings_${currentAccountId || "main"}`;
      let settings = await xDb.xSettings.get(settingsId);

      if (!settings) {
        settings = {
          id: settingsId,
          worldEventsEnabled: enabled,
          updatedAt: new Date().toISOString(),
        };
      } else {
        settings.worldEventsEnabled = enabled;
        settings.updatedAt = new Date().toISOString();
      }

      await xDb.xSettings.put(settings);
      console.log(`💾 [世界大事件] 状态已保存: ${enabled ? "开启" : "关闭"}`);
    } catch (error) {
      console.error("保存世界大事件状态失败:", error);
    }
  }

  // 恢复开关状态（在初始化时调用）
  async function restoreWorldEventsState() {
    try {
      const xDb = getXDB();
      const settingsId = `xSettings_${currentAccountId || "main"}`;
      const settings = await xDb.xSettings.get(settingsId);

      if (settings && settings.worldEventsEnabled) {
        console.log("🔄 [世界大事件] 检测到已保存的开启状态，正在恢复...");
        setTimeout(() => {
          const toggle = document.getElementById("world-events-toggle");
          if (toggle) {
            worldEventsEnabled = false; // 先设为false，让toggle函数切换
            window.toggleWorldEvents();
          }
        }, 1000);
      } else {
        console.log("ℹ️ [世界大事件] 未检测到开启状态，保持关闭");
      }
    } catch (error) {
      console.error("恢复世界大事件状态失败:", error);
    }
  }

  // ▼▼▼ 核心AI生成函数：第12个情景 ▼▼▼
  async function generateWorldEvents(isProgress = false) {
    try {
      console.log(
        `🌍 [世界大事件] 开始${isProgress ? "推进" : "生成"}大事件...`
      );

      const xDb = getXDB();
      const dataId = `worldEvents_${currentAccountId || "main"}`;

      // 读取现有数据（用于推进模式）
      let existingData = null;
      if (isProgress) {
        existingData = await xDb.xWorldEvents.get(dataId);
        if (!existingData) {
          const isEnglish = currentLanguage === "en";
          showXToast(
            isEnglish
              ? "No events found, please generate first"
              : "没有现有事件，请先生成",
            "error"
          );
          return;
        }
      }

      // 🔧 使用统一的API配置加载工具
      const { apiConfig, xSettings } = await APIUtils.loadConfigAndSettings();
      const { userPrompt, worldSetting } = xSettings;

      // Token计数器
      let tokenCount = 0;

      // 0. 时间感知（北京时间）
      const now = new Date();
      const timeInfo = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⏰ 时间感知
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
当前北京时间：${now.toLocaleString("zh-CN", {
        timeZone: "Asia/Shanghai",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        weekday: "long",
      })}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

      // 1. 基础系统提示词
      let systemPrompt =
        timeInfo +
        StringBuilders.buildBaseSystemPrompt({ userPrompt, worldSetting });
      tokenCount = TokenUtils.logTokenUsage(
        "世界大事件生成器",
        "时间感知+基础系统提示词",
        systemPrompt,
        tokenCount
      );

      // 1.5. 获取适用的世界书内容
      const worldBooksContent = await StringBuilders.getApplicableWorldBooks(
        "global",
        {}
      );
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage(
          "世界大事件生成器",
          "世界书内容",
          worldBooksContent,
          tokenCount
        );
      }

      // 2. 用户X资料（获取地点信息）
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(
        window.userProfileData
      );

      // 3. 构建生成/推进提示词
      if (isProgress) {
        // 推进模式：读取现有事件
        const timeSinceLastProgress =
          Date.now() -
          (existingData.lastProgressed || existingData.lastGenerated);
        const hoursPassed = Math.floor(
          timeSinceLastProgress / (1000 * 60 * 60)
        );
        const daysPassed = Math.floor(hoursPassed / 24);

        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务：世界推进模式
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是一个世界运转模拟器，负责推进已有的世界大事件。

【当前世界状态】：
📍 所在地点：${existingData.location}
🌤️ 天气状况：${existingData.weather?.condition || "--"} ${
          existingData.weather?.temp || "--"
        }

【现有大事件】（${existingData.events.length}个）：
${existingData.events
  .map(
    (e, i) => `
${i + 1}. [${e.category}] ${e.title}
   详情：${e.detail}
   影响：${e.impact}
`
  )
  .join("\n")}

【时间推进】：
距离上次更新已过去 ${hoursPassed} 小时（${daysPassed} 天）

【推进任务】：
1. **更新天气**：根据时间推移，合理更新天气状况（气温、天气、穿衣建议）
2. **推进现有事件**（30%）：选择1-2个现有事件，推进其发展（新进展、后续影响、反转等）
3. **生成新事件**（70%）：生成2-6个全新的大事件，符合世界观和时间线
4. **保持连贯性**：新旧事件可以有关联，形成因果链

【事件要求】：
- 总事件数控制在3-8个以内
- 必须符合现有世界观设定
- 黑色幽默风格，夸张但不荒诞
- 事件分类：抓马/政治/体育/娱乐/明星/新闻/流言/科技/社会等
- 每个事件包含：标题（10-30字）、分类、详细描述（50-150字）、影响（20-80字）

🚨 **重要：你必须只返回有效的JSON格式数据，任何语法错误都会导致系统崩溃！** 🚨

【JSON返回格式】：
\`\`\`json
{
  "location": "城市名",
  "weather": {
    "temp": "15-22°C",
    "condition": "多云转晴",
    "tip": "建议穿薄外套，早晚温差大"
  },
  "events": [
    {
      "title": "事件标题",
      "category": "娱乐",
      "detail": "事件详细描述，黑色幽默风格",
      "impact": "事件造成的影响和后果"
    }
  ]
}
\`\`\`
`;
      } else {
        // 生成模式：全新生成
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务：世界初始化
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是一个世界运转模拟器，负责为用户生成一个鲜活的、运转中的世界。

【任务】：
1. **确定地点**：${
          userXProfileInfo.publicIdentity
            ? `用户是${userXProfileInfo.publicIdentity}，`
            : ""
        }根据用户设定和世界观，确定一个合理的所在城市/地点
2. **生成天气**：当前时间的天气状况（气温范围、天气描述、穿衣建议）
3. **生成大事件**：3-8个近期发生的大事件（近三天，主要是今天）

【事件要求】：
- 必须符合世界观设定，不要脱离世界观臆造
- 黑色幽默风格：讽刺、荒诞、夸张，但保持逻辑自洽
- 事件分类多样化：政治丑闻、娱乐八卦、体育赛事、明星抓马、社会新闻、流言蜚语、科技突破、经济波动等
- 好坏参半：不全是正面或负面，有起有落才真实
- 每个事件包含：
  * 标题：10-30字，抓眼球
  * 分类：简短标签（如"娱乐"、"政治"、"体育"）
  * 详细：50-150字，黑色幽默叙述
  * 影响：20-80字，这事儿对世界/人们的影响

【风格示例】：
❌ 平淡："某市长宣布新政策"
✅ 黑色幽默："某市长凌晨三点发推宣布禁止凌晨三点发推，网友：你先自首吧"

🚨 **重要：你必须只返回有效的JSON格式数据，任何语法错误都会导致系统崩溃！** 🚨

【JSON返回格式】：
\`\`\`json
{
  "location": "城市名（如上海、纽约、虚构城市名等）",
  "weather": {
    "temp": "温度范围（如15-22°C）",
    "condition": "天气状况（如多云转晴、小雨、晴朗等）",
    "tip": "穿衣建议（如建议穿薄外套，早晚温差大）"
  },
  "events": [
    {
      "title": "事件标题",
      "category": "事件分类",
      "detail": "事件详细描述，黑色幽默风格",
      "impact": "事件造成的影响和后果"
    }
  ]
}
\`\`\`
`;
      }

      const scenarioSection = systemPrompt.substring(
        tokenCount > 0
          ? systemPrompt.lastIndexOf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
          : 0
      );
      tokenCount = TokenUtils.logTokenUsage(
        "世界大事件生成器",
        "核心任务说明",
        scenarioSection,
        tokenCount
      );

      const messages = [
        {
          role: "user",
          content: isProgress ? "请推进世界大事件" : "请生成世界大事件",
        },
      ];

      // 最终统计
      TokenUtils.logFinalPrompt(
        "世界大事件生成器",
        systemPrompt,
        messages[0].content
      );

      // 🔧 使用统一的API请求工具
      const aiResponseContent = await APIUtils.sendAIRequest({
        apiConfig,
        systemPrompt,
        messages,
        temperature: 0.9, // 提高创造性
      });

      // 🔧 使用统一的JSON解析工具
      let worldEventsData = APIUtils.parseJSONResponse(aiResponseContent);

      // 验证数据格式
      if (
        !worldEventsData.location ||
        !worldEventsData.weather ||
        !worldEventsData.events
      ) {
        throw new Error("AI返回的数据格式不正确，缺少必要字段");
      }

      // 为每个事件添加ID和时间戳
      worldEventsData.events = worldEventsData.events.map((event, index) => ({
        ...event,
        id: `evt_${Date.now()}_${index}`,
        timestamp: new Date().toISOString(),
      }));

      // 构建完整数据
      const finalData = {
        id: dataId,
        accountId: currentAccountId || "main",
        enabled: true,
        location: worldEventsData.location,
        weather: worldEventsData.weather,
        events: worldEventsData.events,
        lastGenerated: isProgress ? existingData.lastGenerated : Date.now(),
        lastProgressed: Date.now(),
        updatedAt: new Date().toISOString(),
      };

      // 保存到数据库
      await xDb.xWorldEvents.put(finalData);
      console.log(
        `✅ [世界大事件] ${isProgress ? "推进" : "生成"}完成，共${
          finalData.events.length
        }个事件`
      );

      // 渲染UI
      renderWorldEvents(finalData);

      const isEnglish = currentLanguage === "en";
      const successMsg = isProgress
        ? isEnglish
          ? "Events progressed"
          : "世界事件已推进"
        : isEnglish
        ? "Events generated"
        : "世界事件已生成";
      showXToast(successMsg, "success");
    } catch (error) {
      console.error("生成世界大事件失败:", error);
      const isEnglish = currentLanguage === "en";
      showXToast(
        isEnglish
          ? `Generation failed: ${error.message}`
          : `生成失败: ${error.message}`,
        "error"
      );
    }
  }

  // 渲染世界大事件UI
  function renderWorldEvents(data) {
    if (!data) return;

    // 更新地点
    const locationEl = document.getElementById("world-location");
    if (locationEl) locationEl.textContent = data.location || "--";

    // 更新天气
    const conditionEl = document.getElementById("weather-condition");
    const tempEl = document.getElementById("weather-temp");
    const tipEl = document.getElementById("weather-tip");
    if (conditionEl) conditionEl.textContent = data.weather?.condition || "--";
    if (tempEl) tempEl.textContent = data.weather?.temp || "--";
    if (tipEl) tipEl.textContent = data.weather?.tip || "--";

    // 更新时间
    const lastGenEl = document.getElementById("last-generated-time");
    const lastProgEl = document.getElementById("last-progressed-time");
    if (lastGenEl)
      lastGenEl.textContent = data.lastGenerated
        ? new Date(data.lastGenerated).toLocaleString("zh-CN")
        : "--";
    if (lastProgEl)
      lastProgEl.textContent = data.lastProgressed
        ? new Date(data.lastProgressed).toLocaleString("zh-CN")
        : "--";

    // 渲染事件列表
    const eventsListEl = document.getElementById("world-events-list");
    if (eventsListEl) {
      if (!data.events || data.events.length === 0) {
        const isEnglish = currentLanguage === "en";
        const noEventsText = isEnglish ? "No events yet" : "暂无事件";
        eventsListEl.innerHTML = `<p style="color: var(--x-text-secondary); text-align: center; padding: 20px;">${noEventsText}</p>`;
      } else {
        const isEnglish = currentLanguage === "en";
        const impactLabel = isEnglish ? "Impact" : "影响";

        eventsListEl.innerHTML = data.events
          .map(
            (event, index) => `
          <div style="background-color: var(--x-bg-primary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 12px; margin-bottom: 8px;">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
              <span style="background-color: var(--x-accent); color: #fff !important; font-size: 11px; font-weight: 600; padding: 2px 8px; border-radius: 4px;">${event.category}</span>
              <span style="color: var(--x-text-primary); font-size: 14px; font-weight: 600; flex: 1;">${event.title}</span>
            </div>
            <div style="color: var(--x-text-primary); font-size: 13px; line-height: 1.4; margin-bottom: 8px;">${event.detail}</div>
            <div style="color: var(--x-text-secondary); font-size: 12px; padding-top: 8px; border-top: 1px solid var(--x-border-color);">
              <strong style="color: var(--x-accent);">${impactLabel}:</strong> ${event.impact}
            </div>
          </div>
        `
          )
          .join("");
      }
    }

    // 检查推进按钮冷却时间
    updateProgressButtonState(data);
  }

  // 更新推进按钮状态（检查3小时冷却）
  function updateProgressButtonState(data) {
    const btn = document.getElementById("progress-world-events-btn");
    const tip = document.getElementById("progress-cooldown-tip");
    if (!btn || !data) return;

    const now = Date.now();
    const lastProgress = data.lastProgressed || data.lastGenerated;
    const timeSinceLastProgress = now - lastProgress;
    const threeHours = 3 * 60 * 60 * 1000;

    if (timeSinceLastProgress < threeHours) {
      // 冷却中
      btn.disabled = true;
      btn.style.opacity = "0.5";
      btn.style.cursor = "not-allowed";

      const remainingMs = threeHours - timeSinceLastProgress;
      const remainingHours = Math.floor(remainingMs / (60 * 60 * 1000));
      const remainingMins = Math.floor(
        (remainingMs % (60 * 60 * 1000)) / (60 * 1000)
      );

      if (tip) {
        tip.style.display = "block";
        const isEnglish = currentLanguage === "en";
        if (isEnglish) {
          tip.textContent = `Cooldown: ${remainingHours}h ${remainingMins}m remaining`;
        } else {
          tip.textContent = `推进功能冷却中，剩余 ${remainingHours}小时${remainingMins}分钟`;
        }
      }
    } else {
      // 可用
      btn.disabled = false;
      btn.style.opacity = "1";
      btn.style.cursor = "pointer";
      if (tip) tip.style.display = "none";
    }
  }

  // 更新按钮：重新生成所有事件
  window.refreshWorldEvents = async function () {
    if (!worldEventsEnabled) {
      const isEnglish = currentLanguage === "en";
      showXToast(
        isEnglish
          ? "Please enable World Events first"
          : "请先开启世界运转大事件",
        "error"
      );
      return;
    }

    const isEnglish = currentLanguage === "en";
    const confirmMsg = isEnglish
      ? "Regenerate all events? This will replace existing events."
      : "确定要重新生成所有大事件吗？这将替换现有的所有事件。";

    if (confirm(confirmMsg)) {
      await generateWorldEvents(false);
    }
  };

  // 推进按钮：推进现有事件
  window.progressWorldEvents = async function () {
    if (!worldEventsEnabled) {
      const isEnglish = currentLanguage === "en";
      showXToast(
        isEnglish
          ? "Please enable World Events first"
          : "请先开启世界运转大事件",
        "error"
      );
      return;
    }

    const xDb = getXDB();
    const dataId = `worldEvents_${currentAccountId || "main"}`;
    const data = await xDb.xWorldEvents.get(dataId);

    if (!data) {
      const isEnglish = currentLanguage === "en";
      showXToast(
        isEnglish
          ? "No events found, please generate first"
          : "没有现有事件，请先生成",
        "error"
      );
      return;
    }

    const now = Date.now();
    const lastProgress = data.lastProgressed || data.lastGenerated;
    const timeSinceLastProgress = now - lastProgress;
    const threeHours = 3 * 60 * 60 * 1000;

    if (timeSinceLastProgress < threeHours) {
      const remainingMs = threeHours - timeSinceLastProgress;
      const remainingHours = Math.floor(remainingMs / (60 * 60 * 1000));
      const remainingMins = Math.floor(
        (remainingMs % (60 * 60 * 1000)) / (60 * 1000)
      );

      const isEnglish = currentLanguage === "en";
      const cooldownMsg = isEnglish
        ? `Cooldown: ${remainingHours}h ${remainingMins}m remaining`
        : `推进功能冷却中，剩余 ${remainingHours}小时${remainingMins}分钟`;

      showXToast(cooldownMsg, "error");
      return;
    }

    await generateWorldEvents(true);
  };

  // ▲▲▲ 【新增！！！】第十二个情景：世界运转大事件生成器 ▲▲▲

  // ============================================
  // 🌍 世界大事件工具函数（供所有情景使用）
  // ============================================

  /**
   * 读取并格式化世界大事件数据
   * @param {string} scenarioName - 情景名称（用于日志和提示词调整）
   * @param {object} options - 配置选项
   * @param {number} options.usageRate - 使用率（如 0.3 表示30%内容围绕大事件）
   * @param {string} options.usageDescription - 使用说明（如何在该情景中使用大事件）
   * @param {boolean} options.isPublicFigure - 是否为公众人物（影响大事件使用方式）
   * @returns {Promise<string>} 格式化的提示词字符串，如果未启用则返回空字符串
   */
  async function getWorldEventsPrompt(scenarioName, options = {}) {
    const {
      usageRate = 0.3,
      usageDescription = "",
      isPublicFigure = false,
    } = options;

    try {
      const xDb = getXDB();
      const worldEventsDataId = `worldEvents_${currentAccountId || "main"}`;
      const worldEventsRecord = await xDb.xWorldEvents.get(worldEventsDataId);

      if (
        !worldEventsRecord ||
        !worldEventsRecord.enabled ||
        !worldEventsRecord.events ||
        worldEventsRecord.events.length === 0
      ) {
        console.log(`ℹ️ [${scenarioName}] 世界大事件未启用或无数据`);
        return "";
      }

      const usagePercentage = Math.round(usageRate * 100);
      const remainingPercentage = 100 - usagePercentage;

      const worldEventsPrompt = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🌍 世界运转状态（${scenarioName}必读）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【当前世界设定】：
📍 所在地点：${worldEventsRecord.location}
🌤️ 天气状况：${worldEventsRecord.weather?.condition || "--"} ${
        worldEventsRecord.weather?.temp || "--"
      }
💡 穿衣建议：${worldEventsRecord.weather?.tip || "--"}

【近期大事件】（${worldEventsRecord.events.length}个热门事件）：
${worldEventsRecord.events
  .map(
    (event, index) => `
${index + 1}. [${event.category}] ${event.title}
   详情：${event.detail}
   影响：${event.impact}
`
  )
  .join("")}

【大事件融入规则】：
🎯 核心原则：约${usagePercentage}%的内容应该围绕这些大事件展开，让世界显得鲜活
${
  usageDescription ||
  `1. **直接讨论**：直接评论某个事件，发表看法
2. **间接影响**：事件影响了日常生活（如天气影响穿着、政策影响工作等）
3. **转发声明**：如果某个事件涉及明星/公众人物，可能有当事人声明或粉丝转发
4. **话题延伸**：从大事件延伸出相关话题讨论
5. **黑色幽默**：保持讽刺、夸张的黑色幽默风格，与事件本身的风格一致
6. **自然融入**：不要强行在每条内容中提及，保持多样性`
}
${
  isPublicFigure
    ? `
⚠️ **公众人物特殊规则**：
- 高曝光用户可能被网友询问对大事件的看法
- 遇到灾难/慈善事件时，可能有人要求捐款或表态
- 遇到争议事件时，可能被要求"站队"表明立场
- 这些互动要真实展现网络生态（有支持、有质疑、有键盘侠）`
    : ""
}

【注意】：
- 其余${remainingPercentage}%的内容可以是与事件无关的日常内容
- 事件讨论要符合角色的身份和视角
- 路人评论只能基于事件的公开信息，不能知道内幕细节
- 黑色幽默风格要保持一致
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

      console.log(
        `🌍 [${scenarioName}] 已注入 ${worldEventsRecord.events.length} 个世界大事件（使用率${usagePercentage}%）`
      );

      return worldEventsPrompt;
    } catch (error) {
      console.error(`❌ [${scenarioName}] 读取世界大事件失败:`, error);
      return "";
    }
  }

  // ============================================
  // 底部导航栏提醒点管理
  // ============================================
  // 显示提醒点
  function showNavNotificationDot(page) {
    const dotId = `${page}-notification-dot`;
    const dot = document.getElementById(dotId);
    if (dot) {
      dot.style.display = "block";
      console.log(`✨ 显示${page}提醒点`);
    }
  }
  // 隐藏提醒点
  function hideNavNotificationDot(page) {
    const dotId = `${page}-notification-dot`;
    const dot = document.getElementById(dotId);
    if (dot) {
      dot.style.display = "none";
      console.log(`✅ 清除${page}提醒点`);
    }
  }
  // 将函数暴露到全局
  window.showNavNotificationDot = showNavNotificationDot;
  window.hideNavNotificationDot = hideNavNotificationDot; // ============================================
  // 智能刷新主页服务管理
  // ============================================
  let autoRefreshFeedTimer = null;
  let autoRefreshFeedEnabled = false;
  const REFRESH_INTERVAL = 10 * 60 * 1000; // 10分钟
  // 开关智能刷新主页服务
  window.toggleAutoRefreshFeed = async function () {
    autoRefreshFeedEnabled = !autoRefreshFeedEnabled;
    const toggle = document.getElementById("auto-refresh-feed-toggle");
    const circle = toggle.querySelector(".toggle-circle");
    const statusDiv = document.getElementById("auto-refresh-feed-status");
    if (autoRefreshFeedEnabled) {
      // 开启刷新
      toggle.style.backgroundColor = "var(--x-accent)";
      circle.style.left = "22px";
      statusDiv.style.display = "block"; // 启动定时器
      startAutoRefreshFeedTimer(); // 保存状态
      await saveAutoRefreshFeedState(true);
      const isEnglish = currentLanguage === "en";
      showXToast(
        isEnglish ? "Auto refresh enabled" : "智能刷新已开启",
        "success"
      );
    } else {
      // 关闭刷新
      toggle.style.backgroundColor = "#333";
      circle.style.left = "2px";
      statusDiv.style.display = "none"; // 停止定时器
      if (autoRefreshFeedTimer) {
        clearInterval(autoRefreshFeedTimer);
        autoRefreshFeedTimer = null;
      }
      // 保存状态
      await saveAutoRefreshFeedState(false);
      const isEnglish = currentLanguage === "en";
      showXToast(
        isEnglish ? "Auto refresh disabled" : "智能刷新已关闭",
        "info"
      );
    }
  }; // 启动定时器
  function startAutoRefreshFeedTimer() {
    if (autoRefreshFeedTimer) {
      clearInterval(autoRefreshFeedTimer);
    }
    autoRefreshFeedTimer = setInterval(async () => {
      await runAutoRefresh();
    }, REFRESH_INTERVAL);
    updateNextRefreshTime();
  }
  // 执行自动刷新
  async function runAutoRefresh() {
    try {
      console.log("⏰ [智能刷新] 开始自动刷新主页推文...");
      await refreshXTweets();
      updateNextRefreshTime(); // 显示主页提醒点（如果用户不在主页）
      const currentPage = document.querySelector(
        '.x-page[style*="display: flex"]'
      );
      const isOnHomePage = currentPage && currentPage.id === "x-home-page";
      if (!isOnHomePage) {
        showNavNotificationDot("home");
      }
      console.log("✅ [智能刷新] 刷新完成");
    } catch (error) {
      console.error("❌ [智能刷新] 自动刷新失败:", error);
    }
  }
  // 更新下次刷新时间显示
  function updateNextRefreshTime() {
    const nextTime = new Date(Date.now() + REFRESH_INTERVAL);
    const timeStr = `${nextTime
      .getHours()
      .toString()
      .padStart(2, "0")}:${nextTime.getMinutes().toString().padStart(2, "0")}`;
    const timeSpan = document.getElementById("next-refresh-time");
    if (timeSpan) {
      timeSpan.textContent = timeStr;
    }
  }
  // 保存刷新状态
  async function saveAutoRefreshFeedState(enabled) {
    try {
      const xDb = getXDB();
      const settingsId = `xSettings_${currentAccountId || "main"}`;
      let settings = await xDb.xSettings.get(settingsId);
      if (!settings) {
        settings = {
          id: settingsId,
          autoRefreshFeedEnabled: enabled,
          updatedAt: new Date().toISOString(),
        };
      } else {
        settings.autoRefreshFeedEnabled = enabled;
        settings.updatedAt = new Date().toISOString();
      }
      await xDb.xSettings.put(settings);
      console.log(`💾 [智能刷新] 状态已保存: ${enabled ? "开启" : "关闭"}`);
    } catch (error) {
      console.error("保存刷新状态失败:", error);
    }
  }
  // 恢复刷新状态（在初始化时调用）
  async function restoreAutoRefreshFeedState() {
    try {
      const xDb = getXDB();
      const settingsId = `xSettings_${currentAccountId || "main"}`;
      const settings = await xDb.xSettings.get(settingsId);
      if (settings && settings.autoRefreshFeedEnabled) {
        console.log("🔄 [智能刷新] 检测到已保存的开启状态，正在恢复..."); // 延迟1秒后启动，确保UI已加载
        setTimeout(() => {
          const toggle = document.getElementById("auto-refresh-feed-toggle");
          if (toggle) {
            autoRefreshFeedEnabled = false; // 先设为false，让toggle函数切换
            window.toggleAutoRefreshFeed();
          }
        }, 1000);
      } else {
        console.log("ℹ️ [智能刷新] 未检测到开启状态，保持关闭");
      }
    } catch (error) {
      console.error("恢复刷新状态失败:", error);
    }
  }
  // ▼▼▼ 【主要！！！】第七个情景：账户主页生成器 ▼▼▼
  // 当前查看的账户数据
  let currentViewingAccount = null; // 推进模式状态
  let isProgressMode = false;
  let progressLongPressTimer = null; // 计算两个字符串的相似度（0-1之间，1表示完全相同）- 账户主页生成器专用
  function calculateSimilarity(str1, str2) {
    if (str1 === str2) return 1;
    if (str1.length === 0 || str2.length === 0) return 0; // 使用最长公共子序列（LCS）算法的简化版本
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1; // 计算字符匹配度
    let matches = 0;
    const shorterChars = shorter.split("");
    const longerChars = longer.split("");
    shorterChars.forEach((char) => {
      const index = longerChars.indexOf(char);
      if (index !== -1) {
        matches++;
        longerChars.splice(index, 1); // 移除已匹配的字符，避免重复计数
      }
    }); // 相似度 = 匹配字符数 / 较长字符串长度
    const similarity = matches / longer.length; // 额外检测：如果较短字符串完全包含在较长字符串中，提高相似度
    if (longer.includes(shorter)) {
      return Math.max(similarity, shorter.length / longer.length);
    }
    return similarity;
  }
  // 打开账户主页
  window.openAccountProfile = async function (
    accountName,
    accountHandle,
    accountAvatar,
    sourceContext = {}
  ) {
    try {
      console.log(`🔍 正在打开账户主页: ${accountName} (${accountHandle})`);
      console.log("📍 来源信息:", sourceContext); // 先检查数据库中是否有已保存的账户主页数据
      const xDB = getXDB();
      const cleanHandle = accountHandle.replace("@", "");
      const savedProfile = await xDB.xAccountProfiles.get(cleanHandle);
      if (savedProfile) {
        console.log("✅ 找到已保存的账户主页数据"); // 🔄 检查是否是角色账户，如果是则同步最新的X资料信息
        const characterProfile = await xDB.xCharacterProfiles.toArray();
        const matchedCharacter = characterProfile.find(
          (cp) =>
            cp.xHandle === accountHandle || cp.xHandle === `@${cleanHandle}`
        );
        if (matchedCharacter) {
          console.log("🔄 [账户主页] 检测到角色账户，同步最新X资料"); // 判断认证类型
          let verificationType = "verified";
          if (
            window.userProfileData.verificationType === "couple" &&
            window.userProfileData.coupleCharacterId ===
              matchedCharacter.characterId
          ) {
            verificationType = "couple";
          }
          // 更新账户基本信息为最新的X资料
          savedProfile.accountInfo = {
            ...savedProfile.accountInfo,
            name: matchedCharacter.xName,
            handle: matchedCharacter.xHandle,
            avatar: matchedCharacter.xAvatar,
            verified: matchedCharacter.xVerified,
            verificationType: matchedCharacter.xVerified
              ? verificationType
              : "none",
            cover:
              matchedCharacter.xCover ||
              savedProfile.accountInfo.cover ||
              "https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg",
            bio: matchedCharacter.xBio || "",
            publicIdentity: matchedCharacter.publicIdentity || "",
            customTag1: matchedCharacter.customTag1 || null,
            customTag2: matchedCharacter.customTag2 || null,
            followingCount:
              matchedCharacter.followingCount ||
              savedProfile.accountInfo.followingCount ||
              "",
            followersCount:
              matchedCharacter.followersCount ||
              savedProfile.accountInfo.followersCount ||
              "",
          }; // 同步更新所有推文、评论、回复中的用户信息
          const updateUserInfo = (user) => {
            if (user && user.handle === matchedCharacter.xHandle) {
              user.name = matchedCharacter.xName;
              user.avatar = matchedCharacter.xAvatar;
              user.verified = matchedCharacter.xVerified;
              user.verificationType = matchedCharacter.xVerified
                ? verificationType
                : "none";
            }
          }; // 更新推文中的用户信息
          if (savedProfile.tweets) {
            savedProfile.tweets.forEach((tweet) => {
              updateUserInfo(tweet.user); // 更新推文评论中的用户信息
              if (tweet.comments) {
                tweet.comments.forEach((comment) => {
                  updateUserInfo(comment.user); // 更新楼中楼回复
                  if (comment.replies) {
                    comment.replies.forEach((reply) =>
                      updateUserInfo(reply.user)
                    );
                  }
                });
              }
            });
          }
          // 更新回复记录中的用户信息
          if (savedProfile.accountReplies) {
            savedProfile.accountReplies.forEach((reply) => {
              if (reply.accountReply) {
                updateUserInfo(reply.accountReply.user);
              }
            });
          }
          // 保存更新后的数据
          savedProfile.updatedAt = new Date().toISOString();
          await xDB.xAccountProfiles.put(savedProfile);
          console.log("✅ [账户主页] 已同步最新X资料信息");
        }
        // 🆕 重新读取X平台私信记忆（即使是已保存的数据，私信记忆也要实时读取）
        console.log("🔄 [账户主页] 重新读取X平台私信记忆");
        savedProfile.xMessageHistory =
          await StringBuilders._loadXMessageHistory(accountHandle);
        if (
          savedProfile.xMessageHistory &&
          savedProfile.xMessageHistory.length > 0
        ) {
          console.log(
            `✅ [账户主页] 重新读取到 ${savedProfile.xMessageHistory.length} 条私信记忆`
          );
        } else {
          console.log("ℹ️ [账户主页] 该账户暂无私信记忆");
        }
        console.log("📊 [账户主页] 加载数据统计:", {
          推文数: savedProfile.tweets?.length || 0,
          回复数: savedProfile.accountReplies?.length || 0,
          喜欢数: savedProfile.accountLikes?.length || 0,
          私信数: savedProfile.xMessageHistory?.length || 0,
        });

        // 💎 【关键修复】附加 sourceContext（包括 liveUserData）
        if (sourceContext && Object.keys(sourceContext).length > 0) {
          savedProfile.sourceContext = sourceContext;
          console.log(
            "💎 [账户主页] 附加来源上下文到已保存的数据",
            sourceContext
          );
        }

        currentViewingAccount = savedProfile;
        renderAccountProfile(savedProfile);
        return;
      }
      // 如果没有保存的数据，查询账户数据（传递现有资料）
      const accountData = await queryAccountData(
        accountName,
        accountHandle,
        accountAvatar,
        sourceContext.existingInfo
      );
      if (!accountData) {
        showXToast("无法加载账户信息", "error");
        return;
      }
      // 保存当前查看的账户（附加来源上下文）
      currentViewingAccount = { ...accountData, sourceContext }; // 如果有完整的主页数据，直接显示
      if (accountData.tweets && accountData.tweets.length > 0) {
        renderAccountProfile({ ...accountData, sourceContext });
        return;
      }
      // 否则，调用AI生成账户主页内容
      showXToast("正在生成账户主页...", "info");
      const profileData = await generateAccountProfileContent(accountData, {
        sourceContext,
      });
      if (profileData) {
        // 更新账户数据（保留sourceContext）
        currentViewingAccount = {
          ...accountData,
          ...profileData,
          sourceContext,
        };
        console.log("📊 [账户主页] 新生成数据统计:", {
          推文数: profileData.tweets?.length || 0,
          回复数: profileData.accountReplies?.length || 0,
          喜欢数: profileData.accountLikes?.length || 0,
        });
        renderAccountProfile(currentViewingAccount); // 保存到数据库
        await saveAccountProfile(currentViewingAccount);
        showXToast("账户主页已生成并保存", "success");
      }
    } catch (error) {
      console.error("打开账户主页失败:", error);
      showXToast(`加载失败: ${error.message}`, "error");
    }
  }; // 查询账户数据（判断是角色/NPC/未知账户）
  // 🎯 已优化：使用统一资料获取系统
  async function queryAccountData(
    accountName,
    accountHandle,
    accountAvatar,
    existingInfo = {}
  ) {
    console.log(`🔍 [账户查询] 查询账户: ${accountName} (${accountHandle})`);

    // 🆕 检查是否有来自私信名片的现有资料
    if (
      existingInfo.bio ||
      existingInfo.followersCount ||
      existingInfo.verified !== undefined
    ) {
      console.log("📋 [账户查询] 检测到私信名片的现有资料:", {
        bio: existingInfo.bio,
        followersCount: existingInfo.followersCount,
        verified: existingInfo.verified,
      });
    }

    // 使用统一资料获取系统
    const profile = await StringBuilders.getUnifiedProfile(accountHandle, {
      userProfileInfo: window.userProfileData, // 传递用户资料以检查身份识别
      includeRecentTweets: false, // 不需要推文，主页生成器会单独获取
      includeRelationships: true,
    });
    if (!profile) {
      // 未找到账户，返回未知账户
      console.log("⚠️ 未知账户，将根据基本信息生成:", accountName);
      const unknownAccountData = {
        accountType: "unknown",
        name: accountName,
        handle: accountHandle,
        avatar: accountAvatar,
        verified:
          existingInfo.verified !== undefined ? existingInfo.verified : false,
        cover: "https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg",
        bio: existingInfo.bio || "",
        publicIdentity: "",
        customTag1: null,
        customTag2: null,
        followingCount: "",
        followersCount: existingInfo.followersCount || "",
      };
      if (existingInfo.bio || existingInfo.followersCount) {
        console.log("✅ 使用来自私信的现有资料:", {
          bio: existingInfo.bio,
          followersCount: existingInfo.followersCount,
          verified: existingInfo.verified,
        });
      }
      return unknownAccountData;
    }
    // 根据账户类型返回对应的数据结构
    console.log(
      `✅ 识别为 ${profile.type} 账户:`,
      profile.name,
      `(${profile.handle})`
    ); // 🆕 统一提取X平台私信记忆（所有账户类型通用）
    let xMessageHistory = [];
    if (
      profile.type === "character" &&
      profile.characterData?.xMessageHistory
    ) {
      xMessageHistory = profile.characterData.xMessageHistory;
    } else if (
      profile.type === "account" &&
      profile.accountData?.xMessageHistory
    ) {
      xMessageHistory = profile.accountData.xMessageHistory;
    } else if (profile.type === "npc" && profile.npcData?.xMessageHistory) {
      xMessageHistory = profile.npcData.xMessageHistory;
    } else if (
      profile.type === "relationshipNpc" &&
      profile.relationshipData?.xMessageHistory
    ) {
      xMessageHistory = profile.relationshipData.xMessageHistory;
    } else if (
      profile.type === "stranger" &&
      profile.accountData?.xMessageHistory
    ) {
      xMessageHistory = profile.accountData.xMessageHistory;
    }
    if (xMessageHistory.length > 0) {
      console.log(
        `✅ [账户查询] 提取到 ${xMessageHistory.length} 条X平台私信记忆`
      );
    }
    if (profile.type === "character") {
      // 角色账户
      // 判断认证类型：检查该角色是否是用户的情侣认证对象
      let verificationType = "verified"; // 默认为普通认证
      if (
        window.userProfileData.verificationType === "couple" &&
        window.userProfileData.coupleCharacterId === profile.characterId
      ) {
        verificationType = "couple"; // 情侣认证
      }

      // 🆕 使用 existingInfo 覆盖部分字段（如果提供）
      const accountData = {
        accountType: "character",
        name: profile.name,
        handle: profile.handle,
        avatar: profile.avatar,
        verified:
          existingInfo.verified !== undefined
            ? existingInfo.verified
            : profile.verified,
        verificationType: profile.verified ? verificationType : "none",
        cover:
          profile.xProfile.xCover ||
          "https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg",
        bio: existingInfo.bio || profile.bio, // 🆕 优先使用 existingInfo
        publicIdentity: profile.publicIdentity,
        customTag1: profile.xProfile.customTag1 || null,
        customTag2: profile.xProfile.customTag2 || null,
        followingCount: profile.xProfile.followingCount || "",
        followersCount:
          existingInfo.followersCount || profile.xProfile.followersCount || "", // 🆕 优先使用 existingInfo
        personality: profile.characterData.aiPersona || "",
        characterData: profile.character,
        xProfileData: profile.xProfile,
        characterId: profile.characterId,
        xMessageHistory: xMessageHistory, // 🆕 统一字段
      };

      if (existingInfo.bio || existingInfo.followersCount) {
        console.log("✅ [角色账户] 已应用私信名片的现有资料");
      }

      return accountData;
    } else if (profile.type === "npc") {
      // NPC账户
      const accountData = {
        accountType: "npc",
        name: profile.npc.name,
        handle: profile.npc.handle,
        avatar: profile.npc.avatar,
        verified:
          existingInfo.verified !== undefined ? existingInfo.verified : false,
        cover: "https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg",
        bio: existingInfo.bio || "", // 🆕 优先使用 existingInfo
        publicIdentity: "",
        customTag1: null,
        customTag2: null,
        followingCount: "",
        followersCount: existingInfo.followersCount || "", // 🆕 优先使用 existingInfo
        personality: profile.npc.personality || "",
        postingHabits: profile.npc.postingHabits || "",
        homepage: profile.npc.homepage || "",
        npcData: profile.npc,
        xMessageHistory: xMessageHistory, // 🆕 统一字段
      };

      if (existingInfo.bio || existingInfo.followersCount) {
        console.log("✅ [NPC账户] 已应用私信名片的现有资料");
      }

      return accountData;
    } else if (profile.type === "relationshipNpc") {
      // 关系NPC账户
      const accountData = {
        accountType: "relationshipNpc",
        name: profile.relationship.npcName,
        handle: profile.relationship.npcHandle,
        avatar:
          accountAvatar ||
          "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
        verified:
          existingInfo.verified !== undefined ? existingInfo.verified : false,
        cover: "https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg",
        bio: existingInfo.bio || "", // 🆕 优先使用 existingInfo
        publicIdentity: "",
        customTag1: null,
        customTag2: null,
        followingCount: "",
        followersCount: existingInfo.followersCount || "", // 🆕 优先使用 existingInfo
        relationshipType: profile.relationship.relationshipType,
        relationshipDescription: profile.relationship.description || "",
        ownerCharacterId: profile.ownerCharacter.id,
        ownerCharacterName: profile.ownerCharacter.name,
        ownerXProfile: profile.ownerXProfile,
        relationshipData: profile.relationship,
        xMessageHistory: xMessageHistory, // 🆕 统一字段
      };

      if (existingInfo.bio || existingInfo.followersCount) {
        console.log("✅ [关系NPC账户] 已应用私信名片的现有资料");
      }

      return accountData;
    } else if (profile.type === "account") {
      // X账户（来自xAccountProfiles）
      const accountData = {
        accountType: "account",
        name: profile.accountInfo.name,
        handle: profile.accountInfo.handle,
        avatar: profile.accountInfo.avatar,
        verified:
          existingInfo.verified !== undefined
            ? existingInfo.verified
            : profile.accountInfo.verified || false,
        verificationType: profile.accountInfo.verificationType || "none",
        cover:
          profile.accountInfo.cover ||
          "https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg",
        bio: existingInfo.bio || profile.accountInfo.bio || "", // 🆕 优先使用 existingInfo
        publicIdentity: profile.accountInfo.publicIdentity || "",
        customTag1: profile.accountInfo.customTag1 || null,
        customTag2: profile.accountInfo.customTag2 || null,
        followingCount: profile.accountInfo.followingCount || "",
        followersCount:
          existingInfo.followersCount ||
          profile.accountInfo.followersCount ||
          "", // 🆕 优先使用 existingInfo
        accountInfo: profile.accountInfo,
        xMessageHistory: xMessageHistory, // 🆕 统一字段
      };

      if (existingInfo.bio || existingInfo.followersCount) {
        console.log("✅ [X账户] 已应用私信名片的现有资料");
      }

      return accountData;
    }
    // 兜底：返回未知账户
    return {
      accountType: "unknown",
      name: accountName,
      handle: accountHandle,
      avatar: accountAvatar,
      verified:
        existingInfo.verified !== undefined ? existingInfo.verified : false,
      cover: "https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg",
      bio: existingInfo.bio || "",
      publicIdentity: "",
      customTag1: null,
      customTag2: null,
      followingCount: "",
      followersCount: existingInfo.followersCount || "",
    };
  }
  // 调用AI生成账户主页内容
  async function generateAccountProfileContent(accountData, options = {}) {
    try {
      const {
        isProgressMode = false,
        existingTweets = [],
        existingReplies = [],
        sourceContext = {},
      } = options;
      // 🔧 使用统一的API配置加载工具
      const { apiConfig, xSettings, xDb } =
        await APIUtils.loadConfigAndSettings();
      const { userPrompt, worldSetting } = xSettings;
      // 构建用户X资料信息
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(
        window.userProfileData
      ); // Token计数器
      let tokenCount = 0; // ▼▼▼ 构建SystemPrompt ▼▼▼
      // 1. 提示词 + 世界书
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage(
        "账户主页生成器",
        "基础系统提示词",
        systemPrompt,
        tokenCount
      ); // 1.5. 获取适用的世界书内容（如果是角色账户，传入角色ID）
      const worldBooksOptions = { boundCharacters: [] };
      if (accountData.accountType === "character" && accountData.characterId) {
        worldBooksOptions.boundCharacters = [accountData.characterId];
      }
      const worldBooksContent = await StringBuilders.getApplicableWorldBooks(
        "profile",
        worldBooksOptions
      );
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage(
          "账户主页生成器",
          "世界书内容",
          worldBooksContent,
          tokenCount
        );
      }

      // 1.7. 🌍 读取世界运转大事件（如果启用）
      const isPublicFigure =
        /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
          (accountData.publicIdentity || "") + " " + (accountData.bio || "")
        );

      const worldEventsPrompt = await getWorldEventsPrompt("账户主页生成器", {
        usageRate: 0.3, // 30%的推文涉及大事件（账户主页展示多样性）
        isPublicFigure: isPublicFigure,
        usageDescription: `**账户主页场景的大事件使用**：
1. **推文内容**：约10%的推文可能围绕大事件展开
   - 发表对大事件的看法或评论
   - 分享与大事件相关的内容或心得
   - 如果是相关领域专家，可能深入分析
2. **回复互动**：账户可能回复其他人关于大事件的讨论
   - 在别人的推文下评论大事件
   - 回复关于大事件的提问
3. **喜欢内容**：账户可能喜欢与大事件相关的推文
   - 喜欢对大事件的精彩评论
   - 喜欢大事件相关的资讯或分析
4. **身份影响**：${
          isPublicFigure
            ? "公众人物的推文可能被要求对大事件表态"
            : "普通账户可能自然讨论大事件"
        }
5. **自然融入**：只有约10%的内容涉及大事件，其余90%展示账户的日常和个性`,
      });

      if (worldEventsPrompt) {
        systemPrompt += worldEventsPrompt;
        tokenCount = TokenUtils.logTokenUsage(
          "账户主页生成器",
          "世界运转大事件",
          worldEventsPrompt,
          tokenCount
        );
      }

      // 2. 核心任务说明
      if (isProgressMode) {
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务：推进账户主页内容 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你需要为X平台账户生成**新的**主页展示内容，包括：
- **新的**推文（3-4条，必须与已有内容完全不同）
- **新的**回复互动（2-3条，必须与已有回复完全不同）
⚠️⚠️⚠️ 【绝对禁止重复】⚠️⚠️⚠️
- 已有的推文和回复会在下方完整展示
- 新推文的内容、话题、观点必须与已有推文**完全不同**
- 新回复必须是全新的互动对象和内容
- 绝对不允许出现相同或高度相似的表达
**推进模式生成策略**：
- 账户基本信息已固定，不需要生成
- 新推文应展现不同的话题维度或新的生活动态
- 可以是时间流逝后的新话题、新想法、新事件
- 新推文的时间应该比已有推文更新
- 严格遵循账户已有的风格和人设，但内容必须全新
- **禁止生成置顶推文**：所有新推文的 pinned 字段必须设置为 false 或不设置
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
      } else {
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务：生成账户主页内容 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你需要为X平台账户生成主页展示内容，包括：
- 账户基本信息（若已提供则严格使用，不可修改）
- 最近发布的推文（3-5条）
- 推文下的评论互动
**生成原则**：
- 如果是已知角色账户，必须严格遵循其X资料设定
- 如果是NPC账户，必须严格遵循其人设和发帖习惯
- 如果是角色关系NPC账户，必须体现与所属角色的关系特点，遵循关系设定
- 如果是未知账户，根据昵称、句柄、简介进行合理推断
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
      }
      // 3. 目标账户信息
      systemPrompt += `
【目标账户信息】：
- X姓名：${accountData.name}
- X句柄：${accountData.handle}
- X头像：${accountData.avatar}
- 认证状态：${accountData.verified ? "是" : "否"}
${
  accountData.verified
    ? `- 认证类型：${
        accountData.verificationType === "couple"
          ? "情侣认证（心形图标）"
          : accountData.verificationType === "verified"
          ? "普通认证（蓝色勾标）"
          : "普通认证（蓝色勾标）"
      }`
    : ""
}
${accountData.bio ? `- X简介：${accountData.bio}` : ""}
${accountData.publicIdentity ? `- 公众身份：${accountData.publicIdentity}` : ""}
${accountData.personality ? `- 人设描述：${accountData.personality}` : ""}
${accountData.postingHabits ? `- 发帖习惯：${accountData.postingHabits}` : ""}
${accountData.cover ? `- 背景图：${accountData.cover}` : ""}
${
  accountData.customTag1
    ? `- 自定义标签1：${accountData.customTag1.icon} ${accountData.customTag1.text} (${accountData.customTag1.color})`
    : ""
}
${
  accountData.customTag2
    ? `- 自定义标签2：${accountData.customTag2.icon} ${accountData.customTag2.text} (${accountData.customTag2.color})`
    : ""
}
${accountData.followingCount ? `- 正在关注：${accountData.followingCount}` : ""}
${accountData.followersCount ? `- 关注者：${accountData.followersCount}` : ""}
`; // 3.5. 添加账户来源上下文（如果有）
      if (sourceContext && sourceContext.source) {
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【账户来源上下文】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        if (sourceContext.source === "feed") {
          systemPrompt += `来源：首页推文
该账户发布的内容：
"${sourceContext.tweetContent}"
${
  sourceContext.tweetMedia && sourceContext.tweetMedia.length > 0
    ? `媒体内容：${sourceContext.tweetMedia[0].description}\n`
    : ""
}- 发布时间：${sourceContext.tweetTime}
- 互动数据：${sourceContext.tweetStats?.comments || 0}评论，${
            sourceContext.tweetStats?.likes || 0
          }喜欢，${sourceContext.tweetStats?.retweets || 0}转发
**生成要求**：
- 基于该账户发布的内容，推断其兴趣、话题偏好和发帖风格
- 生成的主页推文应该与这条推文风格一致
- 可以生成主题相关但不重复的推文内容`;
        } else if (sourceContext.source === "comment") {
          systemPrompt += `来源：评论区
该账户发表的评论：
"${sourceContext.commentContent}"
${
  sourceContext.commentImage
    ? `评论图片：${
        sourceContext.commentImage.type === "description"
          ? sourceContext.commentImage.content
          : "包含图片"
      }\n`
    : ""
}- 发布时间：${sourceContext.commentTime}
${sourceContext.replyTo ? `- 回复对象：${sourceContext.replyTo}\n` : ""}
**生成要求**：
- 基于该账户发表的评论，推断其互动风格和表达习惯
- 生成的主页推文应该体现类似的表达方式和兴趣点
- 主页推文可以与评论主题相关，但要展现更完整的个人特色`;
        } else if (sourceContext.source === "search") {
          systemPrompt += `来源：搜索结果
搜索关键词："${sourceContext.searchQuery}"
该账户在搜索结果中的信息：
- 昵称：${accountData.name}
- 句柄：${accountData.handle}
${
  sourceContext.userBio ? `- 简介：${sourceContext.userBio}\n` : ""
}- 认证状态：${sourceContext.verified ? "已认证" : "未认证"}
**生成要求**：
- 基于搜索关键词和账户基本信息，推断账户特点和内容方向
- 生成的推文应该与搜索关键词"${sourceContext.searchQuery}"有一定相关性
- 确保账户特点与简介、昵称、句柄相符`;
        } else if (
          sourceContext.source === "dm" ||
          sourceContext.source === "dm_quote_profile"
        ) {
          const sourceName =
            sourceContext.source === "dm" ? "私信详情页" : "私信中的账户名片";
          systemPrompt += `来源：${sourceName}
该账户的已知信息：
- 昵称：${accountData.name}
- 句柄：${accountData.handle}
${accountData.bio ? `- 简介：${accountData.bio}\n` : ""}${
            accountData.followersCount
              ? `- 关注者：${accountData.followersCount}\n`
              : ""
          }- 认证状态：${accountData.verified ? "已认证" : "未认证"}
${
  sourceContext.messagePreview
    ? `- 私信预览："${sourceContext.messagePreview}"\n`
    : ""
}`;

          // 🆕 如果是从私信名片点击进入，尝试读取对话记录
          if (
            sourceContext.source === "dm_quote_profile" &&
            sourceContext.conversationContext
          ) {
            try {
              const { currentConversationHandle, messageId } =
                sourceContext.conversationContext;
              console.log(
                "📝 [名片生成] 尝试读取对话记录:",
                currentConversationHandle,
                "| messageId:",
                messageId
              );

              // 构建对话ID并尝试从数据库读取
              const conversationId = `messageConversation_${
                currentAccountId || "main"
              }_${messageId}`;
              console.log("📝 [名片生成] 查询对话ID:", conversationId);
              const savedConversation = await xDb.xAccountProfiles.get(
                conversationId
              );

              // 🔧 修正：数据保存在 savedConversation.data.messages 中
              if (
                savedConversation &&
                savedConversation.data &&
                savedConversation.data.messages &&
                savedConversation.data.messages.length > 0
              ) {
                console.log(
                  `✅ [名片生成] 找到对话记录，共 ${savedConversation.data.messages.length} 条消息`
                );

                systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【私信对话上下文】（该账户在私信中的对话记录）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

                // 提取最近30条消息作为上下文
                const recentMessages =
                  savedConversation.data.messages.slice(-30);
                let msgCount = 0;

                for (const msg of recentMessages) {
                  const sender = msg.isOwn ? "用户" : accountData.name;
                  let content = "";

                  if (msg.type === "text") {
                    content = msg.content;
                  } else if (msg.type === "image") {
                    content = msg.isOwn
                      ? "[用户发送了图片]"
                      : `[图片: ${msg.imageDescription || "图片"}]`;
                  } else if (msg.type === "voice") {
                    content = `[语音: ${msg.voiceText || "语音消息"}]`;
                  } else if (msg.type === "sticker") {
                    content = "[表情包]";
                  } else if (msg.type === "transfer") {
                    const amount = msg.amount ? `$${msg.amount}` : "";
                    const note = msg.note ? ` (${msg.note})` : "";
                    content = `[转账${amount}${note}]`;
                  } else if (msg.type === "link") {
                    content = `[分享链接: ${msg.title || "链接"}]`;
                  } else if (msg.type === "quoteTweet") {
                    content = `[转发推文: ${msg.tweet?.content || ""}]`;
                  } else if (msg.type === "quoteProfile") {
                    // 🆕 特别处理：如果是转发名片，显示详细信息
                    const profile = msg.profile || {};
                    content = `[分享主页: ${profile.name || ""}${
                      profile.bio ? ` - ${profile.bio}` : ""
                    }${
                      profile.followers ? ` (${profile.followers}关注者)` : ""
                    }]`;
                  } else {
                    content = `[${msg.type}消息]`;
                  }

                  if (content) {
                    const displayContent =
                      content.length > 150
                        ? `${content.substring(0, 150)}...`
                        : content;
                    systemPrompt += `${sender}: ${displayContent}\n`;
                    msgCount++;
                  }

                  if (msgCount >= 30) break;
                }

                systemPrompt += `
⚠️ 重要说明：
- 以上是该账户与用户在私信中的真实对话记录（共${msgCount}条）
- 生成账户主页时，必须基于这些对话内容来推断账户的性格、兴趣和特点
- 生成的推文内容、风格、话题应该与对话中展现的形象高度一致
- 如果对话中提到了具体的事件、话题或兴趣，推文应该体现这些内容
- 如果对话中有转发的账户名片，说明该账户与这些名片账户有关联
- 确保账户主页与私信中的形象完全匹配，不要出现矛盾
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

                const conversationSection = systemPrompt.substring(
                  systemPrompt.lastIndexOf("【私信对话上下文】")
                );
                tokenCount = TokenUtils.logTokenUsage(
                  "账户主页生成器",
                  "私信对话上下文",
                  conversationSection,
                  tokenCount
                );
              } else {
                console.log("ℹ️ [名片生成] 未找到对话记录或对话为空");
                if (savedConversation) {
                  console.log("📋 [名片生成] 对话数据结构:", {
                    hasData: !!savedConversation.data,
                    hasMessages: !!savedConversation.data?.messages,
                    messageCount: savedConversation.data?.messages?.length || 0,
                  });
                } else {
                  console.log("📋 [名片生成] 数据库中未找到该对话ID的记录");
                }
              }
            } catch (error) {
              console.error("❌ [名片生成] 读取对话记录失败:", error);
            }
          }

          systemPrompt += `
**生成要求**：
- ${
            accountData.bio
              ? "已有简介，必须严格使用，不可修改"
              : "需要生成符合该账户特点的简介"
          }
- ${
            accountData.followersCount
              ? `已有关注者数量(${accountData.followersCount})，必须使用，不可修改`
              : "需要生成合理的关注者数量（100-5000之间）"
          }
- 生成的推文内容要与已有信息（简介、私信内容等）保持一致
- ${
            sourceContext.source === "dm_quote_profile" &&
            sourceContext.conversationContext
              ? "特别注意：生成的账户主页必须与上述私信对话中展现的性格、兴趣、话题完全一致"
              : "确保账户形象真实可信，符合其在私信中展现的特点"
          }`;
        } else if (sourceContext.source === "live") {
          // 🎤 来自直播间
          const liveCtx = sourceContext.liveContext || {};
          systemPrompt += `来源：直播间
该账户正在进行直播：
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【直播信息】
- 直播主题：${liveCtx.liveTitle || "直播中"}
${
  liveCtx.liveSubtitle ? `- 副标题：${liveCtx.liveSubtitle}\n` : ""
}- 在线观众：${liveCtx.onlineViewers || 0}人
- 直播时长：${Math.floor((liveCtx.liveDuration || 0) / 60)}分钟
${
  liveCtx.liveTags && liveCtx.liveTags.length > 0
    ? `- 标签：${liveCtx.liveTags.join(", ")}\n`
    : ""
}${liveCtx.liveDescription ? `- 直播描述：${liveCtx.liveDescription}\n` : ""}${
            liveCtx.liveNotice ? `- 直播公告：${liveCtx.liveNotice}\n` : ""
          }
【主播发言记录】（最近${(liveCtx.streamerSpeeches || []).length}条）
`;
          if (liveCtx.streamerSpeeches && liveCtx.streamerSpeeches.length > 0) {
            liveCtx.streamerSpeeches.forEach((speech, index) => {
              systemPrompt += `${index + 1}. "${speech.content}"\n`;
            });
          } else {
            systemPrompt += `（暂无主播发言记录）\n`;
          }

          systemPrompt += `
【直播间弹幕】（最近${(liveCtx.danmakuMessages || []).length}条）
`;
          if (liveCtx.danmakuMessages && liveCtx.danmakuMessages.length > 0) {
            liveCtx.danmakuMessages.forEach((dm, index) => {
              systemPrompt += `${index + 1}. ${dm.userId}: "${dm.content}"\n`;
            });
          } else {
            systemPrompt += `（暂无弹幕记录）\n`;
          }

          systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
**生成要求**：
- 该账户正在直播中，需要在头像旁显示"直播中"光晕效果
- 基于直播间的主播发言、弹幕互动、直播主题，推断账户的内容风格和话题偏好
- 生成的主页推文应该与直播内容主题相关，体现主播的发言风格和兴趣点
- 可以生成一些与直播话题相关的推文（如预告直播、分享直播感想等）
- 推文内容要与主播在直播中展现的性格、语言风格保持一致
- 如果直播有特定标签，推文可以涉及这些话题领域
- 评论区可能有观众提及他们在直播间的互动或话题
- 保持账户形象与直播间主播形象高度一致`;
        }
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        const contextSection = systemPrompt.substring(
          systemPrompt.lastIndexOf("【账户来源上下文】")
        );
        tokenCount = TokenUtils.logTokenUsage(
          "账户主页生成器",
          "账户来源上下文",
          contextSection,
          tokenCount
        );
      }
      // 4. 账户类型特定要求
      if (accountData.accountType === "character") {
        systemPrompt += `
【角色账户特殊要求】：
- **严格遵守**：所有已提供的X资料信息必须完全一致，不得修改
- 推文内容要符合角色人设和性格特点
- 评论互动要体现角色的社交风格
- 如有NPC关系，可在推文/评论中自然体现`;
      } else if (accountData.accountType === "npc") {
        systemPrompt += `
【NPC账户特殊要求】：
- **严格遵守**：使用NPC的姓名、句柄、头像、人设
- 推文内容符合NPC的发帖习惯和主页内容设置
- 评论互动符合NPC的性格特点`;
      } else if (accountData.accountType === "relationshipNpc") {
        systemPrompt += `
【角色关系NPC账户特殊要求】：
- **严格遵守**：使用NPC的姓名（${accountData.name}）和句柄（${
          accountData.handle
        }）
- 该NPC与角色 ${accountData.ownerCharacterName} (${
          accountData.ownerXProfile.xName
        } - ${accountData.ownerXProfile.xHandle}) 的关系：${
          accountData.relationshipType
        }
${
  accountData.relationshipDescription
    ? `- 关系描述：${accountData.relationshipDescription}`
    : ""
}
- 推文内容应体现这种关系特点，可能会提及或艾特 ${
          accountData.ownerXProfile.xHandle
        }
- 生成的推文和互动要符合该NPC与角色的关系设定
- 评论区可能出现 ${accountData.ownerXProfile.xName} 的互动，要体现两者的关系
- 如未提供bio、关注者数等信息，由AI根据NPC特点和关系合理补充`;
      } else {
        systemPrompt += `
【未知账户生成要求】：
- 根据提供的昵称、句柄、简介推断账户特点
- 生成合理的推文内容和互动风格
- 保持账户身份的一致性`;
      }
      const accountInfoSection = systemPrompt.substring(
        systemPrompt.indexOf("【目标账户信息】")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "账户主页生成器",
        "账户信息与要求",
        accountInfoSection,
        tokenCount
      ); // 4.3. 如果是关系NPC账户，添加所属角色的详细资料
      if (
        accountData.accountType === "relationshipNpc" &&
        accountData.ownerCharacterId
      ) {
        const mainDB = getDB();
        const allChats = await mainDB.chats.toArray();
        const ownerCharacter = allChats.find(
          (c) => c.id === accountData.ownerCharacterId
        );
        const ownerXProfile = accountData.ownerXProfile;
        if (ownerCharacter && ownerXProfile) {
          let ownerInfo = `
【所属角色详细资料】（该NPC的关系对象）：
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
- 角色本名：${ownerCharacter.name}
- 角色人设：${ownerCharacter.settings.aiPersona || "无特定人设"}
- X平台身份（必须严格使用）：
* X用户名：${ownerXProfile.xName}
* X句柄：${ownerXProfile.xHandle}
* X头像：${ownerXProfile.xAvatar}
* 认证状态：${ownerXProfile.xVerified ? "是" : "否"}`;
          if (ownerXProfile.xBio)
            ownerInfo += `\n * X简介：${ownerXProfile.xBio}`;
          if (ownerXProfile.publicIdentity)
            ownerInfo += `\n * 公众身份：${ownerXProfile.publicIdentity}`;
          ownerInfo += `
- 该NPC（${accountData.name}）与角色（${ownerXProfile.xName}）的关系：${
            accountData.relationshipType
          }
${
  accountData.relationshipDescription
    ? `- 关系详情：${accountData.relationshipDescription}`
    : ""
}
【关系互动要求】：
- 推文内容应自然体现与 ${ownerXProfile.xName} (${ownerXProfile.xHandle}) 的关系
- ${ownerXProfile.xName} 可能在评论区出现，互动要符合双方关系设定
- 必须严格使用 ${ownerXProfile.xName} 的X平台身份信息
- 可以提及或艾特 ${ownerXProfile.xHandle}，但不要过度频繁
- 保持该NPC独立的个性，不要完全依附于角色
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          systemPrompt += ownerInfo;
          tokenCount = TokenUtils.logTokenUsage(
            "账户主页生成器",
            "关系NPC-所属角色资料",
            ownerInfo,
            tokenCount
          ); // 如果所属角色有NPC关系列表，也要加载
          if (
            ownerXProfile.relationships &&
            ownerXProfile.relationships.length > 0
          ) {
            let otherNpcsInfo = `
【所属角色的其他NPC关系】（可能在互动中出现）：
`;
            ownerXProfile.relationships.forEach((rel) => {
              // 跳过当前NPC自己
              if (rel.npcHandle !== accountData.handle) {
                otherNpcsInfo += `
- ${rel.npcName} (${rel.npcHandle}): ${rel.relationshipType}`;
                if (rel.description) otherNpcsInfo += ` - ${rel.description}`;
              }
            });
            otherNpcsInfo += `
注意：这些NPC也可能出现在评论区，要体现各自与 ${ownerXProfile.xName} 的关系特点。
`;
            systemPrompt += otherNpcsInfo;
            tokenCount = TokenUtils.logTokenUsage(
              "账户主页生成器",
              "关系NPC-其他NPC关系",
              otherNpcsInfo,
              tokenCount
            );
          }
          // 如果所属角色有角色关系网络，也要加载
          const ownerRelationshipsInfo =
            await StringBuilders.buildCharacterRelationships(
              [accountData.ownerCharacterId],
              currentAccountId || "main"
            );
          if (ownerRelationshipsInfo) {
            systemPrompt += `
【所属角色的角色关系网络】（可能在互动中出现）：
${ownerRelationshipsInfo}
`;
            tokenCount = TokenUtils.logTokenUsage(
              "账户主页生成器",
              "关系NPC-角色关系网络",
              ownerRelationshipsInfo,
              tokenCount
            );
          }
        }
      }
      // 4.4. 如果是角色账户，添加角色关系网络和关系角色的详细资料
      if (accountData.accountType === "character" && accountData.characterId) {
        const relationshipsInfo =
          await StringBuilders.buildCharacterRelationships(
            [accountData.characterId],
            currentAccountId || "main"
          );
        if (relationshipsInfo) {
          systemPrompt += relationshipsInfo;
          tokenCount = TokenUtils.logTokenUsage(
            "账户主页生成器",
            "角色关系网络",
            relationshipsInfo,
            tokenCount
          ); // 获取关系网络中涉及的其他角色的完整资料
          try {
            const mainDB = getDB();
            const currentAccount = currentAccountId || "main";
            const dataId = `xCharacterRelationships_${currentAccount}`;
            const relationshipRecord = await xDb.xCharacterRelationships.get(
              dataId
            );
            if (relationshipRecord && relationshipRecord.data) {
              const links = relationshipRecord.data.links || [];
              const relatedCharacterIds = new Set(); // 收集所有关系中的其他角色ID
              links.forEach((link) => {
                if (link.charA === accountData.characterId) {
                  relatedCharacterIds.add(link.charB);
                } else if (link.charB === accountData.characterId) {
                  relatedCharacterIds.add(link.charA);
                }
              });
              if (relatedCharacterIds.size > 0) {
                const allChats = await mainDB.chats.toArray();
                const allXProfiles = await xDb.xCharacterProfiles.toArray();
                let relatedCharsInfo = `
【关系角色详细资料】（可能出现在评论或互动中的角色）：
`;
                for (const charId of relatedCharacterIds) {
                  const charData = allChats.find((c) => c.id === charId);
                  const xProfile = allXProfiles.find(
                    (p) => p.characterId === charId
                  );
                  if (charData && xProfile) {
                    relatedCharsInfo += `
- 角色名：${charData.name}
人设：${charData.settings.aiPersona || "无特定人设"}
X平台身份（必须严格使用）：
- X用户名：${xProfile.xName}
- X句柄：${xProfile.xHandle}
- X头像：${xProfile.xAvatar}
- 认证状态：${xProfile.xVerified ? "是" : "否"}`;
                    if (xProfile.xBio)
                      relatedCharsInfo += `\n - X简介：${xProfile.xBio}`;
                    if (xProfile.publicIdentity)
                      relatedCharsInfo += `\n - 公众身份：${xProfile.publicIdentity}`;
                    relatedCharsInfo += `\n`;
                  }
                }
                relatedCharsInfo += `
【关系角色互动要求】：
- 关系角色可能在推文评论或回复中出现，体现彼此的关系
- 必须严格使用上述X平台身份信息（xName、xHandle、xAvatar等）
- 互动内容要符合角色人设和关系设定
- 保持各角色身份的一致性和准确性
`;
                systemPrompt += relatedCharsInfo;
                tokenCount = TokenUtils.logTokenUsage(
                  "账户主页生成器",
                  "关系角色详细资料",
                  relatedCharsInfo,
                  tokenCount
                );
              }
            }
          } catch (error) {
            console.error("获取关系角色详细资料失败:", error);
          }
        }
      }
      // 4.6. 如果是推进模式，添加现有内容作为上下文
      if (
        isProgressMode &&
        (existingTweets.length > 0 || existingReplies.length > 0)
      ) {
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【已有内容上下文】- 绝对禁止重复以下内容
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ 以下是该账户的所有已有推文和回复，生成新内容时必须**完全避开**这些话题和表达：
**已有推文（共${existingTweets.length}条）**：
`; // 显示所有已有推文，不再限制数量
        existingTweets.forEach((tweet, index) => {
          systemPrompt += `
${index + 1}. "${tweet.content}"
- 时间：${tweet.time}
- 互动：${tweet.stats.comments || 0}评论，${tweet.stats.likes || 0}喜欢
${
  tweet.media && tweet.media.length > 0
    ? ` - 媒体：${tweet.media[0].description}\n`
    : ""
}`;
        });
        if (existingReplies.length > 0) {
          systemPrompt += `
**已有回复（共${existingReplies.length}条）**：
`; // 显示所有已有回复
          existingReplies.forEach((reply, index) => {
            systemPrompt += `
${index + 1}. 回复了${reply.type === "tweet" ? "推文" : "评论"}: "${
              reply.accountReply.content
            }"
- 时间：${reply.accountReply.time}`;
          });
        }
        systemPrompt += `
🚫🚫🚫 【重复检测清单】🚫🚫🚫
- 上述${existingTweets.length}条推文的内容、话题、观点都已被使用
- 新推文必须是**全新的话题**或**不同角度的观点**
- 不要生成任何与上述内容相似度超过30%的推文
- 时间设置必须比最新推文（${existingTweets[0]?.time || "未知"}）更新
- 保持风格一致，但内容必须创新
**新内容生成方向建议**：
- 探索完全不同的生活话题或兴趣领域
- 展现不同时间段的新想法或新发现
- 基于人设生成全新角度的内容
- 避免重复已有推文的关键词和主题
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        const existingContentSection = systemPrompt.substring(
          systemPrompt.indexOf("【已有内容上下文】")
        );
        tokenCount = TokenUtils.logTokenUsage(
          "账户主页生成器",
          "已有内容上下文",
          existingContentSection,
          tokenCount
        );
      }
      // 5. 身份约束与禁令（统一结构，分情况处理）
      const userConstraintsStart = systemPrompt.length; // 5.1 首先明确当前正在生成的账户身份
      systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 当前生成账户
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
正在生成：${accountData.name} (${accountData.handle}) 的账户主页
账户类型：${
        accountData.accountType === "character"
          ? "角色账户"
          : accountData.accountType === "npc"
          ? "NPC账户"
          : accountData.accountType === "relationshipNpc"
          ? `角色关系NPC账户（与 ${accountData.ownerCharacterName} 的关系NPC）`
          : "未知账户"
      }
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`; // 5.2 根据账户类型和身份识别情况，提供相关身份信息
      if (accountData.accountType === "character" && accountData.characterId) {
        // 角色账户：检查是否知道用户身份
        const knowsUserIdentity =
          userXProfileInfo.knownIdentityCharacters.includes(
            accountData.characterId
          );
        if (knowsUserIdentity) {
          // 情况A：角色知道用户 → 提供用户X资料 + 角色专属用户人设 + 用户近期推文
          const knowsUserStart = systemPrompt.length;
          const verificationDesc =
            {
              verified: "蓝色勾标认证",
              couple: "情侣认证",
              married: "已婚认证",
              vip: "VIP认证",
            }[userXProfileInfo.verificationType] || "无认证";
          const hasUserPersona =
            accountData.xProfileData?.userPersona &&
            accountData.xProfileData.userPersona.trim();
          systemPrompt += `
【用户身份信息】该角色认识用户
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
用户X平台资料（仅供参考，严禁假扮）：
- 用户名：${userXProfileInfo.name}
- 用户句柄：${userXProfileInfo.handle}
- 认证状态：${verificationDesc}
${
  userXProfileInfo.publicIdentity
    ? `- 公众身份：${userXProfileInfo.publicIdentity}`
    : ""
}
${userXProfileInfo.bio ? `- 个人简介：${userXProfileInfo.bio}` : ""}
`; // 读取用户的最近5条推文
          try {
            const userTweetsId = `userTweets_${currentAccountId || "main"}`;
            const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
            const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || [];
            if (recentUserTweets.length > 0) {
              systemPrompt += `
用户近期推文（${recentUserTweets.length}条）：
`;
              recentUserTweets.forEach((tweet, index) => {
                systemPrompt += `
${index + 1}. "${tweet.content}"
- 时间：${tweet.time || "最近"}
- 互动：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发，${
                  tweet.stats?.comments || 0
                }评论
${
  tweet.image
    ? ` - 媒体：${
        tweet.image.type === "description"
          ? tweet.image.content.substring(0, 50) + "..."
          : "包含图片"
      }\n`
    : ""
}`;
              });
            }
          } catch (error) {
            console.warn("读取用户推文失败:", error);
          }
          systemPrompt += `
该角色了解的用户信息：
${
  hasUserPersona
    ? accountData.xProfileData.userPersona
    : "⚠️ 未设置用户人设 - 该角色只知道用户的基本X平台信息（上述资料），不了解用户的私人信息、性格特点或两者之间的具体关系。"
}
🚫 【关键约束】
${
  hasUserPersona
    ? `- 该角色可以在推文中提及或艾特用户 ${userXProfileInfo.handle}，也可以讨论用户的推文
- 但评论区不能出现用户 ${userXProfileInfo.name} (${userXProfileInfo.handle}) 的发言
- 所有评论必须是虚构的普通用户，不得使用用户的名称或句柄`
    : `- 该角色可以在推文中提及用户 ${userXProfileInfo.handle}（基于基本认识），也可以讨论用户的推文
- 但不要捏造或推断两者的具体关系（如情侣、伴侣、家人等）
- 评论区绝对禁止出现用户 ${userXProfileInfo.name} (${userXProfileInfo.handle}) 的发言
- 所有评论必须是虚构的普通用户，不得使用用户的名称或句柄
- ⚠️ 重要：未设置用户人设意味着不能假设两者有特殊关系`
}
- ${accountData.name} 和 ${userXProfileInfo.name} 是两个完全独立的不同个体
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          const knowsUserInfo = systemPrompt.substring(knowsUserStart);
          tokenCount = TokenUtils.logTokenUsage(
            "账户主页生成器",
            "角色认识用户-资料与推文",
            knowsUserInfo,
            tokenCount
          );
        } else {
          // 情况B：角色不知道用户 → 只提供用户X平台公开资料
          systemPrompt += `
【用户身份信息】该角色不认识用户
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
用户X平台公开资料（仅供参考，禁止假扮）：
- 用户名：${userXProfileInfo.name}
- 用户句柄：${userXProfileInfo.handle}
${
  userXProfileInfo.publicIdentity
    ? `- 公众身份：${userXProfileInfo.publicIdentity}`
    : ""
}
身份关系：
- ${accountData.name} 不知道用户的真实身份
- ${accountData.name} 和 ${userXProfileInfo.name} 是完全独立的不同个体
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        }
      } else {
        // 非角色账户（NPC/未知）：检测是否提及用户或角色的X昵称和句柄
        const accountTexts = [
          accountData.name || "", // 账户昵称
          accountData.handle || "", // 账户句柄
          accountData.bio || "", // 账户简介
          accountData.publicIdentity || "",
          accountData.personality || "",
          accountData.postingHabits || "",
          accountData.homepage || "",
        ].join(" "); // 检测是否提及用户的X昵称或句柄
        const mentionsUser =
          accountTexts.includes(userXProfileInfo.name) || // 用户X昵称
          accountTexts.includes(userXProfileInfo.handle) || // 用户句柄（含@）
          accountTexts.includes(userXProfileInfo.handle.replace("@", "")); // 用户句柄（不含@）
        // 检测是否提及角色的X昵称或句柄
        const mainDB = getDB();
        const allChats = await mainDB.chats.toArray();
        const allXProfiles = await xDb.xCharacterProfiles.toArray();
        const mentionedCharacters = [];
        for (const xProfile of allXProfiles) {
          // 只基于X平台的昵称和句柄进行匹配
          if (
            accountTexts.includes(xProfile.xName) || // 角色X昵称
            accountTexts.includes(xProfile.xHandle) || // 角色句柄（含@）
            accountTexts.includes(xProfile.xHandle.replace("@", "")) // 角色句柄（不含@）
          ) {
            const character = allChats.find(
              (c) => c.id === xProfile.characterId
            );
            if (character) {
              mentionedCharacters.push({ character, xProfile });
            }
          }
        }
        if (mentionsUser || mentionedCharacters.length > 0) {
          // 情况C：账户资料提及用户/角色 → 提供X平台公开资料 + 近期推文
          const mentionedInfoStart = systemPrompt.length;
          systemPrompt += `
【提及的身份信息】该账户资料提及以下身份
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          if (mentionsUser) {
            const verificationDesc =
              {
                verified: "蓝色勾标认证",
                couple: "情侣认证",
                married: "已婚认证",
                vip: "VIP认证",
              }[userXProfileInfo.verificationType] || "无认证";
            systemPrompt += `
用户X平台公开资料（仅供参考，禁止假扮）：
- 用户名：${userXProfileInfo.name}
- 用户句柄：${userXProfileInfo.handle}
- 认证状态：${verificationDesc}
${
  userXProfileInfo.publicIdentity
    ? `- 公众身份：${userXProfileInfo.publicIdentity}`
    : ""
}
${userXProfileInfo.bio ? `- 个人简介：${userXProfileInfo.bio}` : ""}
`; // 读取用户的最近5条推文
            try {
              const userTweetsId = `userTweets_${currentAccountId || "main"}`;
              const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
              const recentUserTweets =
                userTweetsData?.tweets?.slice(0, 5) || [];
              if (recentUserTweets.length > 0) {
                systemPrompt += `
用户近期推文（${recentUserTweets.length}条）：
`;
                recentUserTweets.forEach((tweet, index) => {
                  systemPrompt += `
${index + 1}. "${tweet.content}"
- 时间：${tweet.time || "最近"}
- 互动：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发，${
                    tweet.stats?.comments || 0
                  }评论
${
  tweet.image
    ? ` - 媒体：${
        tweet.image.type === "description"
          ? tweet.image.content.substring(0, 50) + "..."
          : "包含图片"
      }\n`
    : ""
}`;
                });
              }
            } catch (error) {
              console.warn("读取用户推文失败:", error);
            }
          }
          if (mentionedCharacters.length > 0) {
            systemPrompt += `
提及的角色X平台资料（仅供参考，禁止假扮）：
`;
            for (const { character, xProfile } of mentionedCharacters) {
              systemPrompt += `
- ${character.name} - X身份：${xProfile.xName} (${xProfile.xHandle})
${xProfile.publicIdentity ? `公众身份：${xProfile.publicIdentity}` : ""}
${xProfile.xBio ? `简介：${xProfile.xBio}` : ""}
`; // 读取角色的最近5条推文（从角色的账户主页数据中）
              try {
                const cleanCharHandle = xProfile.xHandle.replace("@", "");
                const charAccountProfile = await xDb.xAccountProfiles.get(
                  cleanCharHandle
                );
                const recentCharTweets =
                  charAccountProfile?.tweets?.slice(0, 5) || [];
                if (recentCharTweets.length > 0) {
                  systemPrompt += `
${xProfile.xName} 的近期推文（${recentCharTweets.length}条）：
`;
                  recentCharTweets.forEach((tweet, index) => {
                    systemPrompt += `
${index + 1}. "${tweet.content}"
- 时间：${tweet.time || "最近"}
- 互动：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发
${
  tweet.media && tweet.media.length > 0
    ? ` - 媒体：${tweet.media[0].description.substring(0, 50) + "..."}\n`
    : ""
}`;
                  });
                }
              } catch (error) {
                console.warn(`读取角色 ${xProfile.xName} 的推文失败:`, error);
              }
            }
          }
          systemPrompt += `
互动说明：
- ${accountData.name} 可以讨论或评论上述身份和他们的推文内容
- 可以基于上述推文内容生成相关的互动或回应
- 但 ${accountData.name} 不是上述任何身份，是独立的个体
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          const mentionedInfo = systemPrompt.substring(mentionedInfoStart);
          tokenCount = TokenUtils.logTokenUsage(
            "账户主页生成器",
            "提及身份信息与推文",
            mentionedInfo,
            tokenCount
          );
        } else {
          // 情况D：完全无关的陌生账户 → 只提供最基本的用户身份
          systemPrompt += `
【用户身份信息】无关联
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
用户基本标识（仅供参考，禁止假扮）：
- 用户名：${userXProfileInfo.name}
- 用户句柄：${userXProfileInfo.handle}
身份关系：
- ${accountData.name} 与用户无任何关联
- ${accountData.name} 和 ${userXProfileInfo.name} 是完全独立的不同个体
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        }
      }
      // 5.2.5 🆕 统一添加X平台私信记忆（所有账户类型通用）
      if (
        accountData.xMessageHistory &&
        accountData.xMessageHistory.length > 0
      ) {
        const xMessageSectionStart = systemPrompt.length;
        console.log(
          `📝 [账户主页生成器] 开始处理私信记忆，总数: ${accountData.xMessageHistory.length} 条`
        );
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【X平台私信记忆】（该账户与用户的私信对话记录）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        const recentXMessages = accountData.xMessageHistory.slice(-50);
        let xMemCount = 0;
        for (const msg of recentXMessages) {
          const sender = msg.isOwn ? "用户" : accountData.name;
          let content = "";
          if (msg.type === "text") {
            content = msg.content;
          } else if (msg.type === "image") {
            content = msg.isOwn
              ? "[用户发送了图片]"
              : `[图片: ${msg.imageDescription || "图片"}]`;
          } else if (msg.type === "voice") {
            content = `[语音: ${msg.voiceText || "语音消息"}]`;
          } else if (msg.type === "sticker") {
            content = "[表情包]";
          } else if (msg.type === "transfer") {
            const amount = msg.amount ? `$${msg.amount}` : "";
            const note = msg.note ? ` (${msg.note})` : "";
            content = `[转账${amount}${note}]`;
          } else if (msg.type === "link") {
            content = `[分享链接: ${msg.title || "链接"}]`;
          } else if (msg.type === "quoteTweet") {
            content = `[转发推文: ${msg.tweet?.content || ""}]`;
          } else if (msg.type === "quoteProfile") {
            content = `[分享主页: ${msg.profile?.name || ""}]`;
          } else {
            content = `[${msg.type}消息]`;
          }
          if (content) {
            const displayContent =
              content.length > 80 ? `${content.substring(0, 80)}...` : content;
            systemPrompt += `${sender}: ${displayContent}\n`;
            xMemCount++;
          }
          if (xMemCount >= 50) break;
        }
        systemPrompt += `
⚠️ 重要说明：
- 这些是在X平台私信功能中的真实对话记录
- 无论账户类型（角色/NPC/陌生人），这些对话都是客观存在的
- 生成账户主页时，可以基于这些互动记录展现关系和沟通风格
- 不要在公开推文中直接提及私密的私信内容
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        const xMessageSection = systemPrompt.substring(xMessageSectionStart);
        const xMessageTokens = TokenUtils.estimateTokens(xMessageSection);
        console.log(
          `📊 [私信] ${
            accountData.accountType === "character"
              ? "角色"
              : accountData.accountType === "npc"
              ? "NPC"
              : "账户"
          } ${accountData.name}: ${xMemCount}条, ~${xMessageTokens} tokens`
        );
        tokenCount = TokenUtils.logTokenUsage(
          "账户主页生成器",
          "X平台私信记忆",
          xMessageSection,
          tokenCount
        );
      } else {
        console.log(`ℹ️ [账户主页生成器] 该账户无私信记忆数据`);
      }
      // 5.3 统一的核心禁令（所有情况共用）
      systemPrompt += `
🚫🚫🚫 核心禁令（最高优先级）🚫🚫🚫
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【绝对禁止】假扮用户发布任何内容！
身份识别：
当前账户：${accountData.name} (${accountData.handle})
用户账户：${userXProfileInfo.name} (${userXProfileInfo.handle})
⚠️ 这是两个完全不同的独立个体！
生成规则：
✅ 可以生成：${accountData.name} (${accountData.handle}) 发布的推文/评论/回复
✅ 可以生成：虚构的普通X平台用户（自创用户名和句柄）
❌ 绝对禁止：以 ${userXProfileInfo.name} (${
        userXProfileInfo.handle
      }) 的身份发布任何内容
❌ 绝对禁止：在 user.name 或 user.handle 字段中使用用户的名称或句柄
⚠️ 重要提醒：
所有推文的 user 字段必须是 ${accountData.name} (${accountData.handle})
所有评论的 user 字段必须是虚构用户（不得是 ${userXProfileInfo.name} 或 ${
        userXProfileInfo.handle
      }）${
        accountData.accountType === "relationshipNpc"
          ? `
特殊说明：该NPC与 ${accountData.ownerXProfile.xName} (${accountData.ownerXProfile.xHandle}) 有关系，
评论区可以出现 ${accountData.ownerXProfile.xName} 的互动，但必须严格使用其X平台身份信息`
          : ""
      }
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
      const userConstraints = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage(
        "账户主页生成器",
        "身份约束与核心禁令",
        userConstraints,
        tokenCount
      ); // 6. JSON返回格式
      if (isProgressMode) {
        systemPrompt += `
【JSON返回格式】：
\`\`\`json
{"tweets": [推文数组], "accountReplies": [回复数组], "accountLikes": [喜欢数组]}
\`\`\`
**注意**：推进模式下不需要返回accountInfo，只需返回新的推文、回复和喜欢`;
      } else {
        systemPrompt += `
【JSON返回格式】：
\`\`\`json
{"accountInfo": {...}, "tweets": [推文数组], "accountReplies": [回复数组], "accountLikes": [喜欢数组]}
\`\`\`
accountInfo对象结构：
- name, handle, avatar, verified (已提供的必须完全一致)
- verificationType: ${
          accountData.verified
            ? `"${
                accountData.verificationType || "verified"
              }" (必须使用此值，不可修改)`
            : '"none" (不可修改)'
        }
- cover: 可补充
- bio: ${
          accountData.bio
            ? `"${accountData.bio}" (已提供，必须使用此值，不可修改)`
            : "可补充"
        }
- customTag1/2: {icon, text, color} (可选)
- followingCount: 可补充
- followersCount: ${
          accountData.followersCount
            ? `"${accountData.followersCount}" (已提供，必须使用此值，不可修改)`
            : "可补充"
        }`;
      }
      systemPrompt += `
tweets数组（3-5条）：
- user: {name, handle, avatar, verified, verificationType}
- content: 推文文本
- time: 时间描述
- stats: {comments, retweets, likes, views} (纯数字)
- media: [{type:"description", description:"图片描述，至少20字"}] (可选)
- comments: [评论数组] (1-5条，必须生成，10-20%的评论可带图)
- pinned: true/false (可选，第一条推文可置顶，显示"已置顶"标识)
评论对象结构（重要）：
- id: 评论唯一ID（可留空，系统自动生成）
- user: {name, handle, avatar, verified}
- content: 评论文本 (可与sticker同时存在)
- timeOffset: 相对推文发布的分钟数（负数，如-5表示推文发布后5分钟的评论）
- sticker: {url: "表情包链接", description: "表情包描述"} (可选，约10-15%评论使用)
- image: {type: "description", content: "图片文字描述"} (可选，10-20%的评论带图，用于展示图片视频等媒体)
- replies: [楼中楼回复数组] (可选，0-2条)
楼中楼回复对象结构：
- id: 回复唯一ID（可留空，系统自动生成）
- user: {name, handle, avatar, verified}
- content: 回复文本 (可与sticker同时存在)
- timeOffset: 相对推文发布的分钟数（负数，如-10表示推文发布后10分钟的回复）
- sticker: {url: "表情包链接", description: "表情包描述"} (可选，约10-15%回复使用)
- image: {type: "description", content: "图片文字描述"} (可选，少量回复可带图)
- replyTo: "@被回复者句柄" (必填)
accountReplies数组（2-4条，账户的回复记录）：
🚨 重要：每条回复都必须包含完整的三部分数据结构
结构说明：
- type: "tweet" | "comment" (回复推文或回复评论)
- originalTweet: 原始推文对象（🚨必填！无论type是什么）
{
user: {name, handle, avatar, verified},
content: "推文内容",
time: "时间描述",
stats: {comments: 数字, retweets: 数字, likes: 数字, views: 数字},
media: [{type:"description", description:"图片描述"}] //可选
}
- originalComment: 原始评论对象（⚠️仅当type="comment"时必填）
{
user: {name, handle, avatar, verified},
content: "评论内容",
time: "时间描述"
}
- accountReply: 账户的回复对象（🚨必填！）
{
user: {name, handle, avatar, verified}, //必须使用目标账户信息
content: "回复内容",
time: "时间描述",
stats: {comments: 数字, retweets: 数字, likes: 数字, views: 数字}
}
📋 示例1（回复推文）：
{
"type": "tweet",
"originalTweet": {完整推文对象},
"accountReply": {账户回复对象}
}
📋 示例2（回复评论）：
{
"type": "comment",
"originalTweet": {完整推文对象}, ← 必须提供！评论所属的推文
"originalComment": {完整评论对象}, ← 必须提供！被回复的评论
"accountReply": {账户回复对象}
}
accountLikes数组（3-5条，账户喜欢的推文）：
- user: {name, handle, avatar, verified, verificationType}
- content: 推文文本
- time: 时间描述
- stats: {comments, retweets, likes, views} (纯数字)
- media: [{type:"description", description:"图片描述"}] (可选，30-40%的推文可带媒体)
- comments: [评论数组] (1-3条即可，比主页推文评论少一些)
📋 喜欢推文示例：
{
"user": {
"name": "某用户",
"handle": "@someuser",
"avatar": "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
"verified": false
},
"content": "推文内容",
"time": "2小时",
"stats": {
"comments": 45,
"retweets": 128,
"likes": 892,
"views": 12400
},
"comments": [...]
}
⚠️ accountLikes特殊要求：
- 喜欢的推文来自其他用户，不是账户自己的推文
- 推文内容应该与账户的兴趣、身份、人设相关
- 如果是角色账户，喜欢的内容要符合角色性格
- 如果是关系NPC，可以喜欢所属角色的推文
- 推文的互动数据应该合理（likes数应该较高，因为值得被喜欢）
- 时间描述应该是相对时间（如"3小时"、"昨天"、"2天"等）
【表情包使用规则】：
- 表情包仅限使用世界书中提供的真实链接，严禁虚构或编造链接
- 表情包与文字内容可以同时存在，用于增强表达效果
- 使用频率控制在约10-15%的评论和回复中，保持自然
- sticker对象包含url和description两个必需字段

关键规则：
1. accountInfo已提供字段必须与输入完全一致，不得修改
2. 未提供字段由AI合理补充
3. verified必须是布尔值(true/false)
4. 如果该账户在角色X资料或NPC设置中标注为情侣关系，必须设置verificationType为"couple"
5. ${
        isProgressMode
          ? "**禁止生成置顶推文**：所有推文的 pinned 必须为 false 或不设置"
          : "建议将最重要或最新的一条推文设置为pinned: true（置顶）"
      }
6. stats所有数字必须是纯数字，不带引号
7. 每条推文必须包含1-5条评论，评论内容要与推文相关
8. 评论可以包含楼中楼回复（replies数组），形成对话链
9. 🚨 accountReplies必须生成2-4条，每条都必须包含完整数据：
- type="tweet": 必须有 originalTweet + accountReply
- type="comment": 必须有 originalTweet + originalComment + accountReply（三个都要！）
10. accountReplies中的accountReply.user必须使用目标账户的信息
11. 🚨 accountLikes必须生成3-5条，每条都是完整的推文对象：
- 必须包含user、content、time、stats字段
- user不能是目标账户本人（账户不能喜欢自己的推文）
- 推文内容要与账户兴趣相关，体现账户的品味和关注点
12. 除了角色和npc以外所有账号都使用统一头像：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
13. 默认背景图：https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg
14. 🚫 **禁止假扮用户**：绝对不可在user字段使用 ${userXProfileInfo.name} 或 ${
        userXProfileInfo.handle
      }，这是用户身份，不可假扮
15. ${
        accountData.accountType === "character"
          ? `🚫 **严禁自创角色关系**：除非明确提供的关系信息，不要让目标角色(${accountData.name})在推文/评论中声称与其他角色有特殊关系（如情侣、家人等）。所有评论者必须是虚构用户，不要使用其他已知角色的身份。`
          : accountData.accountType === "relationshipNpc"
          ? `✅ **关系NPC互动规则**：该NPC与 ${accountData.ownerXProfile.xName} (${accountData.ownerXProfile.xHandle}) 有 ${accountData.relationshipType} 关系。评论区可以出现 ${accountData.ownerXProfile.xName} 的互动，必须严格使用其X平台身份信息。其他评论者应为虚构用户。`
          : "评论者应为虚构的普通用户，保持身份的独立性"
      }
16. sticker字段只能使用世界书中存在的真实链接，禁止虚构`;
      const formatSection = systemPrompt.substring(
        systemPrompt.lastIndexOf("【JSON返回格式】")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "账户主页生成器",
        "JSON格式要求",
        formatSection,
        tokenCount
      ); // ▲▲▲ 构建SystemPrompt ▲▲▲
      const messages = [
        {
          role: "user",
          content: `请生成账户 ${accountData.name} (${accountData.handle}) 的主页内容`,
        },
      ]; // 最终统计
      TokenUtils.logFinalPrompt(
        "账户主页生成器",
        systemPrompt,
        messages[0].content
      );
      // 🔧 使用统一的API请求工具
      const aiResponseContent = await APIUtils.sendAIRequest({
        apiConfig,
        systemPrompt,
        messages,
        temperature: 0.7,
      });
      // 🔧 使用统一的JSON解析工具
      let profileData = APIUtils.parseJSONResponse(aiResponseContent);
      // 🔧 使用统一的后处理工具
      profileData = await APIUtils.postProcessData(
        profileData,
        userXProfileInfo
      ); // 验证数据格式
      if (isProgressMode) {
        // 推进模式下只需要推文数据
        if (!profileData.tweets) {
          throw new Error("AI返回的数据格式不正确：缺少推文数据");
        }
        // 推进模式：检测并过滤重复推文
        if (existingTweets && existingTweets.length > 0) {
          const newTweets = profileData.tweets || []; // 过滤重复推文
          const filteredTweets = newTweets.filter((newTweet) => {
            const newContent = newTweet.content.toLowerCase().trim(); // 检查是否与已有推文重复
            const isDuplicate = existingTweets.some((existingTweet) => {
              const existingContent = existingTweet.content
                .toLowerCase()
                .trim(); // 完全相同
              if (existingContent === newContent) return true; // 计算相似度（使用简单的字符匹配算法）
              const similarity = calculateSimilarity(
                existingContent,
                newContent
              ); // 相似度超过70%视为重复
              if (similarity > 0.7) {
                console.log(
                  `🚫 [账户主页推进] 检测到重复推文（相似度${(
                    similarity * 100
                  ).toFixed(1)}%）:`,
                  newContent.substring(0, 50)
                );
                return true;
              }
              return false;
            });
            return !isDuplicate;
          });
          const removedCount = newTweets.length - filteredTweets.length;
          if (removedCount > 0) {
            console.log(`🔍 [账户主页推进] 过滤了 ${removedCount} 条重复推文`);
            profileData.tweets = filteredTweets;
          }
          // 如果所有推文都被过滤了，提示错误
          if (filteredTweets.length === 0) {
            throw new Error("AI生成的所有推文都与已有内容重复，请重新生成");
          }
        }
        // 推进模式：检测并过滤重复回复
        if (
          existingReplies &&
          existingReplies.length > 0 &&
          profileData.accountReplies
        ) {
          const newReplies = profileData.accountReplies || [];
          const filteredReplies = newReplies.filter((newReply) => {
            const newContent =
              newReply.accountReply?.content?.toLowerCase().trim() || "";
            if (!newContent) return true;
            const isDuplicate = existingReplies.some((existingReply) => {
              const existingContent =
                existingReply.accountReply?.content?.toLowerCase().trim() || "";
              if (!existingContent) return false;
              if (existingContent === newContent) return true;
              const similarity = calculateSimilarity(
                existingContent,
                newContent
              );
              if (similarity > 0.7) {
                console.log(
                  `🚫 [账户主页推进] 检测到重复回复（相似度${(
                    similarity * 100
                  ).toFixed(1)}%）:`,
                  newContent.substring(0, 50)
                );
                return true;
              }
              return false;
            });
            return !isDuplicate;
          });
          const removedCount = newReplies.length - filteredReplies.length;
          if (removedCount > 0) {
            console.log(`🔍 [账户主页推进] 过滤了 ${removedCount} 条重复回复`);
            profileData.accountReplies = filteredReplies;
          }
        }
      } else {
        // 正常模式需要完整数据
        if (!profileData.accountInfo || !profileData.tweets) {
          throw new Error("AI返回的数据格式不正确");
        }
        // 强制使用正确的 verificationType，防止 AI 错误生成
        if (profileData.accountInfo) {
          const correctVerificationType =
            accountData.verificationType || "verified";
          profileData.accountInfo.verificationType = correctVerificationType;
          console.log(
            `🔒 [账户主页生成] 强制设置账户认证类型: ${correctVerificationType}`
          );
        }
      }
      // 强制修正所有推文和回复中的 verificationType
      const correctVerificationType =
        accountData.verificationType || "verified";
      const accountHandle = accountData.handle;
      let fixedCount = 0; // 修正推文中的认证类型
      if (profileData.tweets && profileData.tweets.length > 0) {
        profileData.tweets.forEach((tweet) => {
          if (tweet.user && tweet.user.handle === accountHandle) {
            if (tweet.user.verificationType !== correctVerificationType) {
              tweet.user.verificationType = correctVerificationType;
              fixedCount++;
            }
          }
          // 修正推文评论中的认证类型
          if (tweet.comments && tweet.comments.length > 0) {
            tweet.comments.forEach((comment) => {
              if (comment.user && comment.user.handle === accountHandle) {
                if (comment.user.verificationType !== correctVerificationType) {
                  comment.user.verificationType = correctVerificationType;
                  fixedCount++;
                }
              }
              // 修正楼中楼回复中的认证类型
              if (comment.replies && comment.replies.length > 0) {
                comment.replies.forEach((reply) => {
                  if (reply.user && reply.user.handle === accountHandle) {
                    if (
                      reply.user.verificationType !== correctVerificationType
                    ) {
                      reply.user.verificationType = correctVerificationType;
                      fixedCount++;
                    }
                  }
                });
              }
            });
          }
        });
      }
      // 修正回复记录中的认证类型
      if (profileData.accountReplies && profileData.accountReplies.length > 0) {
        profileData.accountReplies.forEach((replyRecord) => {
          if (
            replyRecord.accountReply &&
            replyRecord.accountReply.user &&
            replyRecord.accountReply.user.handle === accountHandle
          ) {
            if (
              replyRecord.accountReply.user.verificationType !==
              correctVerificationType
            ) {
              replyRecord.accountReply.user.verificationType =
                correctVerificationType;
              fixedCount++;
            }
          }
        });
      }
      if (fixedCount > 0) {
        console.log(`🔒 [账户主页生成] 共修正了 ${fixedCount} 处认证类型错误`);
      }
      // 为推文、评论、喜欢分配唯一ID和时间戳
      const timestamp = Date.now();
      profileData.tweets.forEach((tweet, tweetIndex) => {
        // 为推文分配ID（如果没有）
        if (!tweet.id) {
          tweet.id = `account_tweet_${timestamp}_${tweetIndex}`;
        }
        // 为推文添加timestamp（如果没有）
        if (!tweet.timestamp) {
          // 根据索引生成不同的时间戳（越前面的推文越新）
          const hoursAgo = tweetIndex * 2 + Math.floor(Math.random() * 2);
          tweet.timestamp = timestamp - hoursAgo * 60 * 60 * 1000;
        }
        // 确保stats字段存在
        if (!tweet.stats) {
          tweet.stats = {
            comments: tweet.comments?.length || 0,
            retweets: 0,
            likes: 0,
            views: 0,
          };
        }
        // 为评论分配ID和时间戳
        if (tweet.comments && tweet.comments.length > 0) {
          tweet.comments.forEach((comment, commentIndex) => {
            if (!comment.id) {
              comment.id = `account_comment_${timestamp}_${tweetIndex}_${commentIndex}`;
            }
            // 转换timeOffset为实际时间戳
            if (comment.timeOffset !== undefined) {
              comment.timestamp =
                tweet.timestamp + Math.abs(comment.timeOffset) * 60 * 1000;
              delete comment.timeOffset;
            } else if (!comment.timestamp) {
              // 如果没有timeOffset，随机生成一个时间戳
              comment.timestamp =
                tweet.timestamp + (5 + Math.random() * 30) * 60 * 1000;
            }
            // 为楼中楼回复分配ID和时间戳
            if (comment.replies && comment.replies.length > 0) {
              comment.replies.forEach((reply, replyIndex) => {
                if (!reply.id) {
                  reply.id = `account_reply_${timestamp}_${tweetIndex}_${commentIndex}_${replyIndex}`;
                }
                // 转换timeOffset为实际时间戳
                if (reply.timeOffset !== undefined) {
                  reply.timestamp =
                    tweet.timestamp + Math.abs(reply.timeOffset) * 60 * 1000;
                  delete reply.timeOffset;
                } else if (!reply.timestamp) {
                  // 回复时间应该比评论晚
                  reply.timestamp =
                    comment.timestamp + (1 + Math.random() * 10) * 60 * 1000;
                }
              });
            }
          });
        }
      }); // 为喜欢的推文分配ID和时间戳
      if (profileData.accountLikes && profileData.accountLikes.length > 0) {
        profileData.accountLikes.forEach((likedTweet, likeIndex) => {
          // 为喜欢的推文分配ID（如果没有）
          if (!likedTweet.id) {
            likedTweet.id = `account_liked_${timestamp}_${likeIndex}`;
          }
          // 为喜欢的推文添加timestamp（如果没有）
          if (!likedTweet.timestamp) {
            // 喜欢的推文时间戳应该比账户推文更早一些
            const daysAgo = likeIndex + 1 + Math.floor(Math.random() * 2);
            likedTweet.timestamp = timestamp - daysAgo * 24 * 60 * 60 * 1000;
          }
          // 确保stats字段存在
          if (!likedTweet.stats) {
            likedTweet.stats = {
              comments: likedTweet.comments?.length || 0,
              retweets: 0,
              likes: 0,
              views: 0,
            };
          }
          // 为喜欢推文的评论分配ID和时间戳
          if (likedTweet.comments && likedTweet.comments.length > 0) {
            likedTweet.comments.forEach((comment, commentIndex) => {
              if (!comment.id) {
                comment.id = `liked_comment_${timestamp}_${likeIndex}_${commentIndex}`;
              }
              // 转换timeOffset为实际时间戳
              if (comment.timeOffset !== undefined) {
                comment.timestamp =
                  likedTweet.timestamp +
                  Math.abs(comment.timeOffset) * 60 * 1000;
                delete comment.timeOffset;
              } else if (!comment.timestamp) {
                comment.timestamp =
                  likedTweet.timestamp + (5 + Math.random() * 30) * 60 * 1000;
              }
            });
          }
        });
      }
      // 显示手机样式通知
      const isEnglish = currentLanguage === "en";
      const userAvatar =
        window.userProfileData?.avatar ||
        "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg";
      showPhoneNotification({
        title: "X",
        message: isEnglish
          ? "Account profile has been generated!"
          : "账户主页已生成！",
        avatar: userAvatar,
        leftIcon: "x",
      });
      return profileData;
    } catch (error) {
      console.error("生成账户主页内容失败:", error);
      showXToast(`生成失败: ${error.message}`, "error");
      return null;
    }
  }
  // 渲染账户主页
  function renderAccountProfile(accountData) {
    console.log("渲染账户主页:", accountData); // 填充账户信息
    const accountInfo = accountData.accountInfo || accountData; // 设置导航栏标题和推文数
    document.getElementById("account-profile-nav-name").textContent =
      accountInfo.name || accountData.name;
    const tweetCount = (accountData.tweets && accountData.tweets.length) || 0;
    document.getElementById(
      "account-profile-nav-count"
    ).textContent = `${DataUtils.formatNumber(tweetCount)} ${getI18nText(
      "accountPostsCount"
    )}`; // 设置背景图
    const coverImage = document.getElementById("account-cover-image");
    coverImage.style.backgroundImage = `url('${
      accountInfo.cover ||
      accountData.cover ||
      "https://i.postimg.cc/tT8Rfsf1/mmexport1759603246385.jpg"
    }')`; // 设置头像
    const avatarImg = document.getElementById("account-avatar-image");
    avatarImg.src = accountInfo.avatar || accountData.avatar;

    // 🎤 如果是从直播间进入，记录直播状态（不添加视觉效果）
    if (
      accountData.sourceContext &&
      accountData.sourceContext.isLiveStreaming
    ) {
      console.log("🎤 [账户主页] 检测到正在直播");
      // 已移除直播光晕效果
    }

    // 设置名称
    document.getElementById("account-display-name").textContent =
      accountInfo.name || accountData.name; // 设置认证徽章（根据认证类型显示不同图标）
    const verifiedBadge = document.getElementById("account-verified-badge");
    const verificationType =
      accountInfo.verificationType ||
      accountData.verificationType ||
      "verified";
    if (accountInfo.verified || accountData.verified) {
      // 情侣认证使用心形图标
      if (verificationType === "couple") {
        verifiedBadge.innerHTML = `
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>
 </svg>
 `;
      } else {
        // 默认蓝色勾标
        verifiedBadge.innerHTML = `
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
 <g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g>
 </svg>
 `;
      }
      verifiedBadge.style.display = "inline-flex";
      verifiedBadge.style.alignItems = "center";
    } else {
      verifiedBadge.style.display = "none";
    }
    // 设置句柄（添加@前缀）
    const handle = accountInfo.handle || accountData.handle;
    document.getElementById("account-handle-text").textContent =
      handle.startsWith("@") ? handle : `@${handle}`; // 设置简介
    const bioElement = document.getElementById("account-bio-text");
    if (accountInfo.bio || accountData.bio) {
      bioElement.textContent = accountInfo.bio || accountData.bio;
      bioElement.style.display = "block";
    } else {
      bioElement.style.display = "none";
    }
    // 设置自定义标签
    const tagsContainer = document.getElementById("account-tags-container");
    tagsContainer.innerHTML = "";
    const customTag1 = accountInfo.customTag1 || accountData.customTag1;
    const customTag2 = accountInfo.customTag2 || accountData.customTag2;
    if (customTag1 && customTag1.text) {
      const tag1 = document.createElement("div");
      tag1.style.cssText = `display: flex; align-items: center; gap: 4px; color: ${
        customTag1.color || "#71767b"
      }; font-size: 15px;`;
      tag1.innerHTML = `<span>${customTag1.icon || ""}</span><span>${
        customTag1.text
      }</span>`;
      tagsContainer.appendChild(tag1);
    }
    if (customTag2 && customTag2.text) {
      const tag2 = document.createElement("div");
      tag2.style.cssText = `display: flex; align-items: center; gap: 4px; color: ${
        customTag2.color || "#71767b"
      }; font-size: 15px;`;
      tag2.innerHTML = `<span>${customTag2.icon || ""}</span><span>${
        customTag2.text
      }</span>`;
      tagsContainer.appendChild(tag2);
    }
    // 设置关注数据
    document.getElementById("account-following-count").textContent =
      accountInfo.followingCount || accountData.followingCount || "0";
    document.getElementById("account-followers-count").textContent =
      accountInfo.followersCount || accountData.followersCount || "0"; // 初始化关注按钮文本
    const followBtn = document.getElementById("account-follow-btn");
    if (followBtn && followBtn.textContent.includes("关注")) {
      followBtn.textContent = getI18nText("accountFollow");
    } else if (followBtn && followBtn.textContent.includes("Following")) {
      followBtn.textContent = getI18nText("accountFollow");
    }
    // 渲染推文
    const tweetsContainer = document.getElementById("account-tweets-container");
    tweetsContainer.innerHTML = "";
    if (accountData.tweets && accountData.tweets.length > 0) {
      accountData.tweets.forEach((tweet) => {
        const tweetElement = createAccountTweetElement(tweet, accountInfo);
        tweetsContainer.appendChild(tweetElement);
      });
    } else {
      tweetsContainer.innerHTML =
        '<div style="padding: 40px; text-align: center; color: #71767b;">该账户还没有发布推文</div>';
    }
    // 显示账户主页
    document
      .querySelectorAll(".x-page")
      .forEach((page) => (page.style.display = "none"));
    document.getElementById("account-profile-page").style.display = "flex";
    showXToast(
      `已加载 ${accountInfo.name || accountData.name} 的主页`,
      "success"
    );
  }
  // 创建账户回复元素
  function createAccountReplyElement(reply) {
    const replyEl = document.createElement("div");
    replyEl.style.cssText = "border-bottom: 1px solid #2f3336;";
    const accountInfo =
      currentViewingAccount.accountInfo || currentViewingAccount; // 数据完整性检查
    if (!reply || !reply.type) {
      console.warn("⚠️ [账户回复] 回复数据不完整:", reply);
      replyEl.innerHTML =
        '<div style="padding: 16px; color: #71767b;">回复数据不完整</div>';
      return replyEl;
    }
    // 构建账户认证图标HTML
    let accountVerifiedBadgeHtml = "";
    if (accountInfo.verified) {
      if (accountInfo.verificationType === "couple") {
        accountVerifiedBadgeHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-primary);"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>';
      } else {
        accountVerifiedBadgeHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>';
      }
    }
    if (reply.type === "tweet") {
      // 数据完整性检查
      if (
        !reply.originalTweet ||
        !reply.originalTweet.user ||
        !reply.accountReply
      ) {
        console.warn("⚠️ [账户回复] 推文回复数据不完整:", reply);
        replyEl.innerHTML =
          '<div style="padding: 16px; color: #71767b;">推文回复数据不完整</div>';
        return replyEl;
      }
      // 回复推文的样式
      const originalUser = reply.originalTweet.user;
      const accountReply = reply.accountReply; // 构建原推文作者认证图标
      let originalVerifiedHtml = "";
      if (originalUser.verified) {
        originalVerifiedHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>';
      }
      replyEl.innerHTML = `
 <div style="padding: 12px 16px;">

 <div style="display: flex; gap: 12px; margin-bottom: 8px;">
 <img src="${
   originalUser.avatar
 }" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
 <div style="flex: 1; min-width: 0;">
 <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px; flex-wrap: wrap;">
 <span style="color: #fff; font-weight: 800; font-size: 15px;">${
   originalUser.name
 }</span>
 ${originalVerifiedHtml}
 <span style="color: #71767b; font-size: 15px;">${
   originalUser.handle.startsWith("@")
     ? originalUser.handle
     : "@" + originalUser.handle
 }</span>
 <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span>
 <span class="tweet-time" data-timestamp="${
   reply.originalTweet.timestamp || Date.now()
 }" style="color: #71767b; font-size: 15px;">${
        reply.originalTweet.timestamp
          ? getRelativeTime(reply.originalTweet.timestamp)
          : reply.originalTweet.time || "刚刚"
      }</span>
 </div>
 <div style="color: #fff; font-size: 15px; line-height: 20px; word-wrap: break-word;">${processContent(
   reply.originalTweet.content
 )}</div>
${
  reply.originalTweet.media && reply.originalTweet.media.length > 0
    ? `
<div style="background-color:var(--x-bg-secondary); border-radius: 16px; padding: 12px; margin-top: 12px; border: 1px solid var(--x-border-color);">
<div style="color:var(--x-text-primary); font-size: 15px; line-height: 20px;">${processContent(
        reply.originalTweet.media[0].description
      )}</div>
</div>
`
    : ""
}
</div>
</div>

<div style="display: flex; gap: 12px;">

<div style="width: 40px; display: flex; justify-content: center; position: relative;">
<div style="width: 2px; height: 100%; background-color: #2f3336;"></div>
</div>
 <div style="flex: 1;"></div>
 </div>

 <div style="display: flex; gap: 12px; margin-top: 8px;">
 <img src="${
   accountInfo.avatar
 }" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
 <div style="flex: 1; min-width: 0;">
 <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px; flex-wrap: wrap;">
 <span style="color: #fff; font-weight: 800; font-size: 15px;">${
   accountInfo.name
 }</span>
 ${accountVerifiedBadgeHtml}
 <span style="color: #71767b; font-size: 15px;">${
   accountInfo.handle.startsWith("@")
     ? accountInfo.handle
     : "@" + accountInfo.handle
 }</span>
 <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span>
 <span class="tweet-time" data-timestamp="${
   accountReply.timestamp || Date.now()
 }" style="color: #71767b; font-size: 15px;">${
        accountReply.timestamp
          ? getRelativeTime(accountReply.timestamp)
          : accountReply.time || "刚刚"
      }</span>
 </div>
 <div style="color: #71767b; font-size: 15px; margin-bottom: 4px;">${getI18nText(
   "accountReplyTo"
 )} <span style="color: var(--x-accent);">${
        originalUser.handle.startsWith("@")
          ? originalUser.handle
          : "@" + originalUser.handle
      }</span></div>
 <div style="color: #fff; font-size: 15px; line-height: 20px; margin-bottom: 12px; word-wrap: break-word;">${processContent(
   accountReply.content
 )}</div>

 <div style="display: flex; justify-content: space-between; max-width: 425px;">
 <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g></svg>
 <span style="font-size: 13px;">${DataUtils.formatNumber(
   accountReply.stats.comments || 0
 )}</span>
 </div>
 <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='#00ba7c'" onmouseout="this.style.color='#71767b'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.79-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.79 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g></svg>
 <span style="font-size: 13px;">${DataUtils.formatNumber(
   accountReply.stats.retweets || 0
 )}</span>
 </div>
 <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='#f91880'" onmouseout="this.style.color='#71767b'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>
 <span style="font-size: 13px;">${DataUtils.formatNumber(
   accountReply.stats.likes || 0
 )}</span>
 </div>
 <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10h2L6 21H4zm9.248 0v-7h2v7h-2z"></path></g></svg>
 <span style="font-size: 13px;">${DataUtils.formatNumber(
   accountReply.stats.views || 0
 )}</span>
 </div>
 </div>
 </div>
 </div>
 </div>
 `;
    } else if (reply.type === "comment") {
      // 数据完整性检查
      if (
        !reply.originalTweet ||
        !reply.originalTweet.user ||
        !reply.originalComment ||
        !reply.originalComment.user ||
        !reply.accountReply
      ) {
        console.warn("⚠️ [账户回复] 评论回复数据不完整:", reply);
        replyEl.innerHTML =
          '<div style="padding: 16px; color: #71767b;">评论回复数据不完整</div>';
        return replyEl;
      }
      // 回复评论的样式（楼中楼）
      const originalTweetUser = reply.originalTweet.user;
      const originalCommentUser = reply.originalComment.user;
      const accountReply = reply.accountReply; // 构建认证图标
      let tweetVerifiedHtml = "";
      if (originalTweetUser.verified) {
        tweetVerifiedHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>';
      }
      let commentVerifiedHtml = "";
      if (originalCommentUser.verified) {
        commentVerifiedHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>';
      }
      replyEl.innerHTML = `
 <div style="padding: 12px 16px;">

 <div style="display: flex; gap: 12px; margin-bottom: 4px;">
 <img src="${
   originalTweetUser.avatar
 }" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
 <div style="flex: 1; min-width: 0;">
 <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px; flex-wrap: wrap;">
 <span style="color: #fff; font-weight: 800; font-size: 15px;">${
   originalTweetUser.name
 }</span>
 ${tweetVerifiedHtml}
 <span style="color: #71767b; font-size: 15px;">${
   originalTweetUser.handle.startsWith("@")
     ? originalTweetUser.handle
     : "@" + originalTweetUser.handle
 }</span>
 <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span>
 <span class="tweet-time" data-timestamp="${
   reply.originalTweet.timestamp || Date.now()
 }" style="color: #71767b; font-size: 15px;">${
        reply.originalTweet.timestamp
          ? getRelativeTime(reply.originalTweet.timestamp)
          : reply.originalTweet.time || "刚刚"
      }</span>
 </div>
 <div style="color: #fff; font-size: 15px; line-height: 20px; word-wrap: break-word;">${processContent(
   reply.originalTweet.content
 )}</div>
${
  reply.originalTweet.media && reply.originalTweet.media.length > 0
    ? `
<div style="background-color:var(--x-bg-secondary); border-radius: 16px; padding: 12px; margin-top: 12px; border: 1px solid var(--x-border-color);">
<div style="color:var(--x-text-primary); font-size: 15px; line-height: 20px;">${processContent(
        reply.originalTweet.media[0].description
      )}</div>
</div>
`
    : ""
}
</div>
</div>

<div style="display: flex; gap: 12px; margin-top: 8px;">
<div style="width: 40px; display: flex; justify-content: center;">
<div style="width: 2px; background-color: #2f3336; height: 100%;"></div>
</div>
 <div style="flex: 1; padding-top: 4px;">
 <div style="display: flex; gap: 12px;">
 <img src="${
   originalCommentUser.avatar
 }" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
 <div style="flex: 1; min-width: 0;">
 <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px; flex-wrap: wrap;">
 <span style="color: #fff; font-weight: 800; font-size: 15px;">${
   originalCommentUser.name
 }</span>
 ${commentVerifiedHtml}
 <span style="color: #71767b; font-size: 15px;">${
   originalCommentUser.handle.startsWith("@")
     ? originalCommentUser.handle
     : "@" + originalCommentUser.handle
 }</span>
 <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span>
 <span class="tweet-time" data-timestamp="${
   reply.originalComment.timestamp || Date.now()
 }" style="color: #71767b; font-size: 15px;">${
        reply.originalComment.timestamp
          ? getRelativeTime(reply.originalComment.timestamp)
          : reply.originalComment.time || "刚刚"
      }</span>
 </div>
 <div style="color: #fff; font-size: 15px; line-height: 20px; word-wrap: break-word;">${processContent(
   reply.originalComment.content
 )}</div>
 </div>
 </div>
 </div>
 </div>

 <div style="display: flex; gap: 12px; margin-top: 8px;">
 <div style="width: 40px; display: flex; justify-content: center;">
 <div style="width: 2px; background-color: #2f3336; height: 100%;"></div>
 </div>
 <div style="flex: 1; padding-top: 4px;">
 <div style="display: flex; gap: 12px;">
 <img src="${
   accountInfo.avatar
 }" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
 <div style="flex: 1; min-width: 0;">
 <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px; flex-wrap: wrap;">
 <span style="color: #fff; font-weight: 800; font-size: 15px;">${
   accountInfo.name
 }</span>
 ${accountVerifiedBadgeHtml}
 <span style="color: #71767b; font-size: 15px;">${
   accountInfo.handle.startsWith("@")
     ? accountInfo.handle
     : "@" + accountInfo.handle
 }</span>
 <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span>
 <span class="tweet-time" data-timestamp="${
   accountReply.timestamp || Date.now()
 }" style="color: #71767b; font-size: 15px;">${
        accountReply.timestamp
          ? getRelativeTime(accountReply.timestamp)
          : accountReply.time || "刚刚"
      }</span>
 </div>
 <div style="color: #71767b; font-size: 15px; margin-bottom: 4px;">${getI18nText(
   "accountReplyTo"
 )} <span style="color: var(--x-accent);">${
        originalCommentUser.handle.startsWith("@")
          ? originalCommentUser.handle
          : "@" + originalCommentUser.handle
      }</span></div>
 <div style="color: #fff; font-size: 15px; line-height: 20px; margin-bottom: 12px; word-wrap: break-word;">${processContent(
   accountReply.content
 )}</div>

 <div style="display: flex; justify-content: space-between; max-width: 425px;">
 <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g></svg>
 <span style="font-size: 13px;">${DataUtils.formatNumber(
   accountReply.stats.comments || 0
 )}</span>
 </div>
 <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='#00ba7c'" onmouseout="this.style.color='#71767b'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.79-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.79 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g></svg>
 <span style="font-size: 13px;">${DataUtils.formatNumber(
   accountReply.stats.retweets || 0
 )}</span>
 </div>
 <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='#f91880'" onmouseout="this.style.color='#71767b'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>
 <span style="font-size: 13px;">${DataUtils.formatNumber(
   accountReply.stats.likes || 0
 )}</span>
 </div>
 <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10h2L6 21H4zm9.248 0v-7h2v7h-2z"></path></g></svg>
 <span style="font-size: 13px;">${DataUtils.formatNumber(
   accountReply.stats.views || 0
 )}</span>
 </div>
 </div>
 </div>
 </div>
 </div>
 </div>
 </div>
 `;
    }
    return replyEl;
  }
  // 创建喜欢的推文元素（X风格，带"已喜欢"提示）
  function createLikedTweetElement(tweet, accountInfo) {
    const tweetEl = document.createElement("div");
    tweetEl.style.cssText = "border-bottom: 1px solid var(--x-border-color);";
    const user = tweet.user; // 构建认证图标HTML
    let verifiedBadgeHtml = "";
    if (user.verified) {
      if (user.verificationType === "couple") {
        verifiedBadgeHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-primary);"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>';
      } else {
        verifiedBadgeHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>';
      }
    }
    tweetEl.innerHTML = `

 <div style="padding: 12px 16px 0; display: flex; align-items: center; gap: 12px;">
 <div style="width: 40px; display: flex; justify-content: flex-end;">
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-text-secondary);">
 <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>
 </svg>
 </div>
 <span style="color:var(--x-text-secondary); font-size: 13px; font-weight: 700;">${
   accountInfo.name
 } ${getI18nText("accountLiked")}</span>
 </div>

 <div style="padding: 12px 16px; display: flex; gap: 12px; position: relative;">
 <img src="${user.avatar}" alt="${
      user.name
    }" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
 <div style="flex: 1; min-width: 0;">
 <div style="display: flex; align-items: center; gap: 2px; margin-bottom: 2px; flex-wrap: wrap;">
 <span style="color:var(--x-text-primary); font-weight: 800; font-size: 15px;">${
   user.name
 }</span>
 ${verifiedBadgeHtml}
 <span style="color:var(--x-text-secondary); font-size: 15px; margin-left: 4px;">${
   user.handle.startsWith("@") ? user.handle : "@" + user.handle
 }</span>
 <span style="color:var(--x-text-secondary); font-size: 15px; margin: 0 4px;">·</span>
 <span class="tweet-time" data-timestamp="${
   tweet.timestamp || Date.now()
 }" style="color:var(--x-text-secondary); font-size: 15px;">${
      tweet.timestamp ? getRelativeTime(tweet.timestamp) : tweet.time || "刚刚"
    }</span>
 </div>
 <div style="color:var(--x-text-primary); font-size: 15px; line-height: 20px; margin-bottom: 12px; word-wrap: break-word;">${processContent(
   tweet.content
 )}</div>
${
  tweet.media && tweet.media.length > 0
    ? `
<div style="background-color:var(--x-bg-secondary); border-radius: 16px; padding: 12px; margin-bottom: 12px; border: 1px solid var(--x-border-color);">
<div style="color:var(--x-text-primary); font-size: 15px; line-height: 20px;">${processContent(
        tweet.media[0].description
      )}</div>
</div>
`
    : ""
}
<div style="display: flex; justify-content: space-between; max-width: 425px; margin-top: 12px;">
<div onclick="showLikedTweetDetail('${
      tweet.id || Date.now()
    }')" style="display: flex; align-items: center; gap: 4px; color:var(--x-text-secondary); cursor: pointer; padding: 0;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='var(--x-text-secondary)'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g></svg>
 <span style="font-size: 13px;">${DataUtils.formatNumber(
   tweet.stats.comments || 0
 )}</span>
 </div>
 <div style="display: flex; align-items: center; gap: 4px; color:var(--x-text-secondary); cursor: pointer; padding: 0;" onmouseover="this.style.color='#00ba7c'" onmouseout="this.style.color='var(--x-text-secondary)'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.79-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.79 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g></svg>
 <span style="font-size: 13px;">${DataUtils.formatNumber(
   tweet.stats.retweets || 0
 )}</span>
 </div>
 <div style="display: flex; align-items: center; gap: 4px; color: #f91880; cursor: pointer; padding: 0;" onmouseover="this.style.color='#f91880'" onmouseout="this.style.color='#f91880'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>
 <span style="font-size: 13px;">${DataUtils.formatNumber(
   tweet.stats.likes || 0
 )}</span>
 </div>
 <div style="display: flex; align-items: center; gap: 4px; color:var(--x-text-secondary); cursor: pointer; padding: 0;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='var(--x-text-secondary)'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10h2L6 21H4zm9.248 0v-7h2v7h-2z"></path></g></svg>
 <span style="font-size: 13px;">${DataUtils.formatNumber(
   tweet.stats.views || 0
 )}</span>
 </div>
 <div style="display: flex; align-items: center; gap: 8px; color:var(--x-text-secondary); cursor: pointer; padding: 0;">
 <div style="display: flex; align-items: center;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='var(--x-text-secondary)'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g></svg>
 </div>
 <div style="display: flex; align-items: center;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='var(--x-text-secondary)'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.3 3.3-1.41-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g></svg>
 </div>
 </div>
 </div>
 </div>

 <div style="position: absolute; top: 12px; right: 16px; cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'" onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-secondary);">
 <g><path d="M3 12c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2zm9 2c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm7 0c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2z"></path></g>
 </svg>
 </div>
 </div>
`; // 将推文数据临时存储，方便后续点击查看详情
    tweetEl.dataset.tweetData = JSON.stringify(tweet);
    return tweetEl;
  }
  // 创建账户推文元素（按图片样式设计）
  function createAccountTweetElement(tweet, accountInfo) {
    const tweetEl = document.createElement("div");
    tweetEl.style.cssText = "border-bottom: 1px solid var(--x-border-color);";
    const user = tweet.user || accountInfo;
    const isPinned = tweet.pinned || false; // 构建认证图标HTML
    let verifiedBadgeHtml = "";
    if (user.verified) {
      if (user.verificationType === "couple") {
        verifiedBadgeHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-primary);"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>';
      } else {
        verifiedBadgeHtml =
          '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>';
      }
    }
    tweetEl.innerHTML = `
 ${
   isPinned
     ? `
 <div style="padding: 12px 16px 0; display: flex; align-items: center; gap: 12px;">
 <div style="width: 40px; display: flex; justify-content: flex-end;">
 <svg viewBox="0 0 32 32" style="width: 16px; height: 16px; fill: #71767b;">
 <path d="M20.743 14.815l-0.933-12.065h5.191c0.414 0 0.75-0.336 0.75-0.75s-0.336-0.75-0.75-0.75v0h-18c-0.414 0-0.75 0.336-0.75 0.75s0.336 0.75 0.75 0.75v0h5.432l-1.275 12.103c-3.213 0.959-5.574 3.738-5.904 7.113l-0.003 0.034c0 0.414 0.336 0.75 0.75 0.75h9.25v7.25c0 0.414 0.336 0.75 0.75 0.75s0.75-0.336 0.75-0.75v0-7.25h9.25c0.414-0 0.75-0.336 0.75-0.75v0c0-3.017-2.35-5.787-6.007-7.185zM12.104 16.081c0.096-0.035 0.179-0.085 0.249-0.148l-0.001 0.001 0.005-0.003c0.126-0.117 0.211-0.275 0.233-0.453l0-0.004 0.011-0.022 1.337-12.701h4.367l0.979 12.681c0.033 0.35 0.303 0.627 0.647 0.67l0.004 0c2.542 0.682 4.512 2.623 5.222 5.096l0.013 0.052h-18.341c0.729-2.54 2.714-4.49 5.222-5.157l0.052-0.012z"></path>
 </svg>
 </div>
 <span style="color: #71767b; font-size: 13px; font-weight: 700;">${getI18nText(
   "accountPinned"
 )}</span>
 </div>
 `
     : ""
 }
 <div style="padding: 12px 16px; display: flex; gap: 12px; position: relative;">
 <img src="${user.avatar}" alt="${
      user.name
    }" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
 <div style="flex: 1; min-width: 0;">
 <div style="display: flex; align-items: center; gap: 2px; margin-bottom: 2px; flex-wrap: wrap;">
 <span style="color: #fff; font-weight: 800; font-size: 15px;">${
   user.name
 }</span>
 ${verifiedBadgeHtml}
 <span style="color: #71767b; font-size: 15px; margin-left: 4px;">${
   user.handle.startsWith("@") ? user.handle : "@" + user.handle
 }</span>
 <span style="color: #71767b; font-size: 15px; margin: 0 4px;">·</span>
 <span class="tweet-time" data-timestamp="${
   tweet.timestamp || Date.now()
 }" style="color: #71767b; font-size: 15px;">${
      tweet.timestamp ? getRelativeTime(tweet.timestamp) : tweet.time || "刚刚"
    }</span>
 </div>
 <div style="color: #fff; font-size: 15px; line-height: 20px; margin-bottom: 12px; word-wrap: break-word;">${processContent(
   tweet.content
 )}</div>
${
  tweet.media && tweet.media.length > 0
    ? `
<div style="background-color:var(--x-bg-secondary); border-radius: 16px; padding: 12px; margin-bottom: 12px; border: 1px solid var(--x-border-color);">
<div style="color:var(--x-text-primary); font-size: 15px; line-height: 20px;">${processContent(
        tweet.media[0].description
      )}</div>
</div>
`
    : ""
}
<div style="display: flex; justify-content: space-between; max-width: 425px; margin-top: 12px;">
<div onclick="showAccountTweetDetail('${
      tweet.id
    }')" style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer; padding: 0;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g></svg>
 <span style="font-size: 13px;">${DataUtils.formatNumber(
   tweet.stats.comments || 0
 )}</span>
 </div>
 <div onclick="handleQuoteRetweetFromAccountTweet('${
   tweet.id
 }')" style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer; padding: 0;" onmouseover="this.style.color='#00ba7c'" onmouseout="this.style.color='#71767b'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.79-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.79 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g></svg>
 <span style="font-size: 13px;">${DataUtils.formatNumber(
   tweet.stats.retweets || 0
 )}</span>
 </div>
 <div class="tweet-action like" onclick="toggleLike('${
   tweet.id
 }', this)" data-liked="false" data-likes="${
      tweet.stats.likes || 0
    }" style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer; padding: 0;" onmouseover="this.style.color='#f91880'" onmouseout="this.style.color='#71767b'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>
 <span class="like-count" style="font-size: 13px;">${DataUtils.formatNumber(
   tweet.stats.likes || 0
 )}</span>
 </div>
 <div style="display: flex; align-items: center; gap: 4px; color: #71767b; cursor: pointer; padding: 0;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10h2L6 21H4zm9.248 0v-7h2v7h-2z"></path></g></svg>
 <span style="font-size: 13px;">${DataUtils.formatNumber(
   tweet.stats.views || 0
 )}</span>
 </div>
 <div style="display: flex; align-items: center; gap: 8px; color: #71767b; cursor: pointer; padding: 0;">
 <div onclick="toggleBookmark('${
   tweet.id
 }', this)" data-bookmarked="false" style="display: flex; align-items: center;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g></svg>
 </div>
 <div style="display: flex; align-items: center;" onmouseover="this.style.color='var(--x-accent)'" onmouseout="this.style.color='#71767b'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;"><g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.3 3.3-1.41-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g></svg>
 </div>
 </div>
 </div>
 </div>

   <div onclick="deleteAccountTweet('${tweet.id}', '${(
      accountInfo.handle || user.handle
    ).replace(
      "@",
      ""
    )}', event)" style="position: absolute; top: 12px; right: 16px; cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'" onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #71767b;">
 <g><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
 </svg>
 </div>
 </div>
`;
    return tweetEl;
  }
  // 关闭账户主页
  window.closeAccountProfile = function () {
    // 重置推进模式
    if (isProgressMode) {
      isProgressMode = false;
      updateRefreshButtonUI();
    }
    document.getElementById("account-profile-page").style.display = "none"; // 检查是否需要返回搜索页
    if (isInSearchResults && currentSearchQuery) {
      console.log("📖 [返回] 从账户主页返回搜索结果页"); // 恢复搜索结果视图
      document.getElementById("trending-view").style.display = "none";
      document.getElementById("search-results-view").style.display = "flex"; // 显示返回按钮，隐藏刷新按钮
      const backBtn = document.getElementById("search-back-btn");
      if (backBtn) backBtn.style.display = "flex";
      const refreshBtn = document.querySelector(".refresh-trends-btn");
      if (refreshBtn) refreshBtn.style.display = "none"; // 显示搜索页
      document.getElementById("x-search-page").style.display = "flex";
    } else {
      // 默认返回主页
      document.getElementById("x-home-page").style.display = "flex";
    }
  }; // 显示账户推文详情
  window.showAccountTweetDetail = async function (tweetId) {
    if (!currentViewingAccount || !currentViewingAccount.tweets) {
      showXToast("无法找到推文数据", "error");
      return;
    }
    // 从当前账户数据中查找推文
    const tweet = currentViewingAccount.tweets.find((t) => t.id === tweetId);
    if (!tweet) {
      showXToast("未找到该推文", "error");
      return;
    }
    // 标记数据来源为账户推文（避免与用户推文混淆）
    tweet._source = "account";
    tweet._accountHandle = (
      currentViewingAccount.accountInfo || currentViewingAccount
    ).handle; // 使用现有的showTweetDetail函数显示详情
    await showTweetDetail(tweet);
  }; // 显示喜欢的推文详情
  window.showLikedTweetDetail = async function (tweetId) {
    if (!currentViewingAccount || !currentViewingAccount.accountLikes) {
      showXToast("无法找到喜欢数据", "error");
      return;
    }
    // 从喜欢列表中查找推文
    const tweet = currentViewingAccount.accountLikes.find(
      (t) => t.id === tweetId
    );
    if (!tweet) {
      showXToast("未找到该推文", "error");
      return;
    }
    // 标记数据来源为喜欢的推文
    tweet._source = "liked";
    tweet._accountHandle = (
      currentViewingAccount.accountInfo || currentViewingAccount
    ).handle; // 使用现有的showTweetDetail函数显示详情
    await showTweetDetail(tweet);
  }; // 切换关注状态
  window.toggleAccountFollow = function () {
    const followBtn = document.getElementById("account-follow-btn");
    const notifyBtn = document.getElementById("account-notify-btn");
    const followText = getI18nText("accountFollow");
    const followingText = getI18nText("accountFollowing"); // 获取当前主题的颜色
    const bgPrimary = getComputedStyle(
      document.getElementById("x-social-screen")
    )
      .getPropertyValue("--x-bg-primary")
      .trim();
    const textPrimary = getComputedStyle(
      document.getElementById("x-social-screen")
    )
      .getPropertyValue("--x-text-primary")
      .trim();
    const borderColor = getComputedStyle(
      document.getElementById("x-social-screen")
    )
      .getPropertyValue("--x-border-color")
      .trim();
    if (followBtn.textContent === followText) {
      // 关注账户
      followBtn.textContent = followingText;
      followBtn.style.backgroundColor = bgPrimary || "#000";
      followBtn.style.color = textPrimary || "#fff";
      followBtn.style.border = `1px solid ${borderColor || "#536471"}`;
      notifyBtn.style.display = "flex";
      showXToast("已关注该账户", "success");
    } else {
      // 取消关注
      followBtn.textContent = followText; // 未关注状态：反转颜色
      followBtn.style.backgroundColor = textPrimary || "#fff";
      followBtn.style.color = bgPrimary || "#000";
      followBtn.style.border = "none";
      notifyBtn.style.display = "none";
      showXToast("已取消关注", "info");
    }
  }; // 切换通知设置
  window.toggleAccountNotifications = function () {
    showXToast("通知设置已更新", "success");
  }; // 发送私信
  window.sendMessageToAccount = async function () {

    // 🔧 检查该账户是否对应某个已绑定角色
    try {
      const xDb = getXDB();
      const settingsId = `xSettings_${currentAccountId || "main"}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const boundCharacters = xSettings?.boundCharacters || [];

      // 遍历已绑定角色，查找匹配的账户句柄
      let matchedCharacterId = null;
      for (const characterId of boundCharacters) {
        const xProfile = await xDb.xCharacterProfiles.get(characterId);
        if (xProfile && xProfile.xHandle.replace("@", "") === cleanHandle) {
          matchedCharacterId = characterId;
          console.log("✅ [统一ID] 找到匹配的已绑定角色:", characterId);
          break;
        }
      }

      // 根据是否匹配到角色，使用不同的 ID 格式
      let accountId;
      if (matchedCharacterId) {
        // 已绑定角色：使用 msg_${characterId} 格式（与私信列表添加的格式统一）
        accountId = `msg_${matchedCharacterId}`;
        console.log("📝 [统一ID] 使用角色ID格式:", accountId);
      } else {
        // 未绑定角色：使用 msg_account_${cleanHandle} 格式
        accountId = `msg_account_${cleanHandle}`;
        console.log("📝 [统一ID] 使用账户ID格式:", accountId);
      }

      // 💎 检查是否从直播间进入，如果是，提取 liveUserData
      let liveUserData = null;
      if (
        currentViewingAccount &&
        currentViewingAccount.sourceContext &&
        currentViewingAccount.sourceContext.source === "live" &&
        currentViewingAccount.sourceContext.liveUserData
      ) {
        liveUserData = currentViewingAccount.sourceContext.liveUserData;
        console.log(
          "💎 [私信] 检测到从直播间进入，携带用户直播间数据",
          liveUserData
        );
      }

      // 构建私信数据（messageData格式）
      const messageData = {
        id: accountId,
        userName: accountInfo.name,
        userHandle: accountInfo.handle,
        userAvatar: accountInfo.avatar,
        user: {
          name: accountInfo.name,
          handle: accountInfo.handle,
          avatar: accountInfo.avatar,
          verified: accountInfo.verified || false,
        },
        lastMessage: "",
        timestamp: new Date().toISOString(),
        unread: false,
        _fromAccountProfile: true, // 🔧 标记来自账户主页
        _liveUserData: liveUserData, // 💎 添加直播间用户数据
      }; // 构建账户资料数据
      const profileData = {
        name: accountInfo.name,
        handle: accountInfo.handle,
        avatar: accountInfo.avatar,
        bio: accountInfo.bio || "",
        followersCount: accountInfo.followersCount || "0",
        verified: accountInfo.verified || false,
      }; // 标记当前消息
      currentMessageConversation = messageData;
      userMessageQueue = []; // 保持账户主页在后台（不隐藏，以便返回）
      // document.getElementById('account-profile-page').style.display = 'none'; // 显示私信详情页面
      document.getElementById("x-message-detail-page").style.display = "flex"; // 加载私信详情
      loadCharacterMessageDetail(messageData, profileData);
      console.log("✅ 已打开私信详情页（来自账户主页）");
    } catch (error) {
      console.error("❌ [统一ID] 查找角色失败:", error);
      // 💎 检查是否从直播间进入（错误处理分支）
      let liveUserData = null;
      if (
        currentViewingAccount &&
        currentViewingAccount.sourceContext &&
        currentViewingAccount.sourceContext.source === "live" &&
        currentViewingAccount.sourceContext.liveUserData
      ) {
        liveUserData = currentViewingAccount.sourceContext.liveUserData;
        console.log(
          "💎 [私信] 检测到从直播间进入，携带用户直播间数据",
          liveUserData
        );
      }

      // 出错时使用默认的账户ID格式
      const accountId = `msg_account_${cleanHandle}`;
      const messageData = {
        id: accountId,
        userName: accountInfo.name,
        userHandle: accountInfo.handle,
        userAvatar: accountInfo.avatar,
        user: {
          name: accountInfo.name,
          handle: accountInfo.handle,
          avatar: accountInfo.avatar,
          verified: accountInfo.verified || false,
        },
        lastMessage: "",
        timestamp: new Date().toISOString(),
        unread: false,
        _fromAccountProfile: true, // 🔧 标记来自账户主页
        _liveUserData: liveUserData, // 💎 添加直播间用户数据
      };
      const profileData = {
        name: accountInfo.name,
        handle: accountInfo.handle,
        avatar: accountInfo.avatar,
        bio: accountInfo.bio || "",
        followersCount: accountInfo.followersCount || "0",
        verified: accountInfo.verified || false,
      };
      currentMessageConversation = messageData;
      userMessageQueue = [];
      // document.getElementById('account-profile-page').style.display = 'none';
      document.getElementById("x-message-detail-page").style.display = "flex";
      loadCharacterMessageDetail(messageData, profileData);
      console.log("✅ 已打开私信详情页（使用默认ID，来自账户主页）");
    }
  }; // 切换账户标签
  window.switchAccountTab = function (tabName) {
    // 更新标签样式
    const tabs = document.querySelectorAll(".account-tab");
    tabs.forEach((tab) => {
      if (tab.onclick.toString().includes(tabName)) {
        tab.style.fontWeight = "700";
        tab.style.color = "#fff";
        tab.style.borderBottom = "4px solid var(--x-accent)";
      } else {
        tab.style.fontWeight = "500";
        tab.style.color = "#71767b";
        tab.style.borderBottom = "4px solid transparent";
      }
    });
    const tweetsContainer = document.getElementById("account-tweets-container");
    tweetsContainer.innerHTML = "";
    if (tabName === "posts") {
      // 渲染推文
      if (currentViewingAccount && currentViewingAccount.tweets) {
        const accountInfo =
          currentViewingAccount.accountInfo || currentViewingAccount;
        currentViewingAccount.tweets.forEach((tweet) => {
          const tweetElement = createAccountTweetElement(tweet, accountInfo);
          tweetsContainer.appendChild(tweetElement);
        });
      } else {
        tweetsContainer.innerHTML = `
 <div style="padding: 60px 32px; text-align: center;">
 <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;">${getI18nText(
   "accountNoPosts"
 )}</div>
 <div style="color: #71767b; font-size: 15px;">${getI18nText(
   "accountNoPostsDesc"
 )}</div>
 </div>
 `;
      }
    } else if (tabName === "replies") {
      // 渲染回复
      if (
        currentViewingAccount &&
        currentViewingAccount.accountReplies &&
        currentViewingAccount.accountReplies.length > 0
      ) {
        // 过滤掉无效的回复数据
        const validReplies = currentViewingAccount.accountReplies.filter(
          (reply) => {
            if (!reply) {
              console.warn("⚠️ [账户标签] 跳过无效回复: null/undefined");
              return false;
            }
            if (!reply.type) {
              console.warn("⚠️ [账户标签] 跳过无效回复: 缺少 type 字段", reply);
              return false;
            }
            return true;
          }
        );
        if (validReplies.length > 0) {
          validReplies.forEach((reply) => {
            const replyElement = createAccountReplyElement(reply);
            tweetsContainer.appendChild(replyElement);
          });
        } else {
          tweetsContainer.innerHTML = `
 <div style="padding: 60px 32px; text-align: center;">
 <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;">${getI18nText(
   "accountNoReplies"
 )}</div>
 <div style="color: #71767b; font-size: 15px;">${getI18nText(
   "accountNoRepliesDesc"
 )}</div>
 </div>
 `;
        }
      } else {
        tweetsContainer.innerHTML = `
 <div style="padding: 60px 32px; text-align: center;">
 <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;">${getI18nText(
   "accountNoReplies"
 )}</div>
 <div style="color: #71767b; font-size: 15px;">${getI18nText(
   "accountNoRepliesDesc"
 )}</div>
 </div>
 `;
      }
    } else if (tabName === "likes") {
      // 渲染喜欢列表
      console.log("🔍 [喜欢列表] 开始渲染喜欢列表");
      console.log(
        "🔍 [喜欢列表] currentViewingAccount:",
        currentViewingAccount
      );
      console.log(
        "🔍 [喜欢列表] accountLikes数量:",
        currentViewingAccount?.accountLikes?.length || 0
      );
      if (
        currentViewingAccount &&
        currentViewingAccount.accountLikes &&
        currentViewingAccount.accountLikes.length > 0
      ) {
        console.log("✅ [喜欢列表] 找到喜欢数据，开始渲染");
        const accountInfo =
          currentViewingAccount.accountInfo || currentViewingAccount;
        currentViewingAccount.accountLikes.forEach((likedTweet, index) => {
          console.log(
            `📋 [喜欢列表] 渲染第 ${index + 1} 条喜欢:`,
            likedTweet.content?.substring(0, 30)
          );
          const tweetElement = createLikedTweetElement(likedTweet, accountInfo);
          tweetsContainer.appendChild(tweetElement);
        });
        console.log(
          `✅ [喜欢列表] 共渲染了 ${currentViewingAccount.accountLikes.length} 条喜欢`
        );
      } else {
        console.warn("⚠️ [喜欢列表] 无喜欢数据，显示空状态");
        tweetsContainer.innerHTML = `
 <div style="padding: 60px 32px; text-align: center;">
 <div style="color:var(--x-text-secondary); font-size: 31px; font-weight: 800; margin-bottom: 8px;">${getI18nText(
   "accountNoLikes"
 )}</div>
 <div style="color:var(--x-text-secondary); font-size: 15px;">${getI18nText(
   "accountNoLikesDesc"
 )}</div>
 </div>
 `;
      }
    }
  }; // 保存账户主页数据到数据库
  async function saveAccountProfile(accountData) {
    try {
      const xDB = getXDB();
      const cleanHandle = accountData.accountInfo.handle.replace("@", ""); // 准备保存的数据
      const profileToSave = {
        handle: cleanHandle,
        name: accountData.accountInfo.name,
        accountInfo: accountData.accountInfo,
        tweets: accountData.tweets || [],
        accountReplies: accountData.accountReplies || [],
        accountLikes: accountData.accountLikes || [], // 添加喜欢数据
        updatedAt: new Date().toISOString(),
      };

      // 🆕 保存直播间数据（如果存在）
      if (accountData.liveRoomData) {
        profileToSave.liveRoomData = accountData.liveRoomData;
        console.log(
          `🎤 [保存账户] 保存直播间数据: "${
            accountData.liveRoomData.title || "无标题"
          }"`
        );
      }

      await xDB.xAccountProfiles.put(profileToSave);
      console.log(
        "✅ 账户主页数据已保存:",
        cleanHandle,
        "- 推文数:",
        profileToSave.tweets.length,
        "- 回复数:",
        profileToSave.accountReplies.length,
        "- 喜欢数:",
        profileToSave.accountLikes.length
      );
    } catch (error) {
      console.error("保存账户主页数据失败:", error);
    }
  }
  // 🗑️ 删除账户主页推文
  window.deleteAccountTweet = async function (tweetId, accountHandle, event) {
    // 阻止事件冒泡（防止触发推文详情页）
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }

    const confirmDelete = confirm("确定要删除这条推文吗？删除后无法恢复。");
    if (!confirmDelete) return;

    try {
      const xDB = getXDB();
      const cleanHandle = accountHandle.replace("@", "");

      // 从数据库中获取账户主页数据
      const accountProfile = await xDB.xAccountProfiles.get(cleanHandle);

      if (!accountProfile || !accountProfile.tweets) {
        showXToast("未找到账户数据", "error");
        return;
      }

      // 过滤掉要删除的推文
      const originalLength = accountProfile.tweets.length;
      accountProfile.tweets = accountProfile.tweets.filter(
        (tweet) => tweet.id !== tweetId
      );

      // 检查是否真的删除了推文
      if (accountProfile.tweets.length === originalLength) {
        showXToast("未找到该推文", "error");
        return;
      }

      // 更新时间戳
      accountProfile.updatedAt = new Date().toISOString();

      // 保存到数据库
      await xDB.xAccountProfiles.put(accountProfile);

      console.log(
        `✅ 已删除账户推文: ${tweetId}，剩余推文数: ${accountProfile.tweets.length}`
      );
      showXToast("推文已删除", "success");

      // 如果当前正在查看该账户主页，刷新显示
      if (
        currentViewingAccount &&
        (currentViewingAccount.accountInfo?.handle === `@${cleanHandle}` ||
          currentViewingAccount.accountInfo?.handle === cleanHandle ||
          currentViewingAccount.handle === `@${cleanHandle}` ||
          currentViewingAccount.handle === cleanHandle)
      ) {
        console.log("🔄 刷新当前查看的账户主页");
        // 更新当前查看的账户数据
        currentViewingAccount.tweets = accountProfile.tweets;
        // 重新渲染账户主页
        renderAccountProfile(currentViewingAccount);
      }
    } catch (error) {
      console.error("❌ 删除账户推文失败:", error);
      showXToast("删除失败", "error");
    }
  };
  // 🆕 将推文添加到账户主页（用于智能检测生成的推文）
  async function addTweetToAccountProfile(userHandle, tweetData) {
    try {
      const xDB = getXDB();
      const cleanHandle = userHandle.replace("@", "");
      console.log(
        `📝 [账户主页同步] 开始将推文添加到 ${cleanHandle} 的账户主页`
      ); // 获取或创建账户主页数据
      let accountProfile = await xDB.xAccountProfiles.get(cleanHandle);
      if (!accountProfile) {
        // 如果账户主页不存在，创建新的
        console.log(`📝 [账户主页同步] 账户主页不存在，创建新的主页数据`);
        accountProfile = {
          handle: cleanHandle,
          name: tweetData.user.name,
          accountInfo: {
            name: tweetData.user.name,
            handle: userHandle,
            avatar: tweetData.user.avatar,
            verified: tweetData.user.verified || false,
            verificationType: tweetData.user.verificationType || "verified",
          },
          tweets: [],
          accountReplies: [],
          accountLikes: [],
          updatedAt: new Date().toISOString(),
        };
      }
      // 确保 tweets 数组存在
      if (!accountProfile.tweets) {
        accountProfile.tweets = [];
      }
      // 检查推文是否已存在（根据ID或时间戳）
      const isDuplicate = accountProfile.tweets.some(
        (tweet) =>
          tweet.id === tweetData.id || tweet.timestamp === tweetData.timestamp
      );
      if (isDuplicate) {
        console.log(`⏭️ [账户主页同步] 推文已存在，跳过添加`);
        return;
      }
      // 添加推文到数组
      // 🔧 确保置顶推文始终在第一位
      const pinnedTweet = accountProfile.tweets.find((t) => t.pinned);
      const unpinnedTweets = accountProfile.tweets.filter((t) => !t.pinned); // 将新推文添加到非置顶推文的开头
      unpinnedTweets.unshift(tweetData); // 按时间戳排序非置顶推文（最新的在前）
      unpinnedTweets.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0)); // 重新组合：置顶推文 → 其他推文
      if (pinnedTweet) {
        accountProfile.tweets = [pinnedTweet, ...unpinnedTweets];
      } else {
        accountProfile.tweets = unpinnedTweets;
      }
      // 更新时间
      accountProfile.updatedAt = new Date().toISOString(); // 保存到数据库
      await xDB.xAccountProfiles.put(accountProfile);
      console.log(
        `✅ [账户主页同步] 推文已添加到 ${cleanHandle} 的主页，当前推文总数: ${accountProfile.tweets.length}`
      ); // 如果当前正在查看该账户的主页，刷新显示
      if (
        currentViewingAccount &&
        (currentViewingAccount.accountInfo?.handle === userHandle ||
          currentViewingAccount.handle === userHandle)
      ) {
        console.log(`🔄 [账户主页同步] 检测到正在查看该账户主页，刷新显示`); // 更新当前查看的账户数据
        currentViewingAccount.tweets = accountProfile.tweets; // 重新渲染
        renderAccountProfile(currentViewingAccount);
      }
    } catch (error) {
      console.error("❌ [账户主页同步] 添加推文到账户主页失败:", error);
    }
  }
  // 切换推进模式
  window.toggleProgressMode = function () {
    isProgressMode = !isProgressMode;
    updateRefreshButtonUI();
    if (isProgressMode) {
      showXToast("已切换到推进模式 - 将生成新内容并追加", "success");
    } else {
      showXToast("已切换到重新生成模式 - 将覆盖现有内容", "info");
    }
  }; // 更新刷新按钮UI
  function updateRefreshButtonUI() {
    const refreshBtn = document.querySelector(
      '#account-profile-page [onclick="refreshAccountProfile()"]'
    );
    if (!refreshBtn) return; // 获取当前主题的文本颜色
    const textColor =
      getComputedStyle(document.getElementById("x-social-screen"))
        .getPropertyValue("--x-text-primary")
        .trim() || "#fff";
    if (isProgressMode) {
      // 推进模式 - 心电图图标
      refreshBtn.innerHTML = `
 <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="${textColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
 <path d="M3 12h4.5l1.5 -6l4 12l2 -9l1.5 3h4.5" />
 </svg>
 `;
      refreshBtn.setAttribute("title", "推进账户主页（生成新内容并追加）");
    } else {
      // 重新生成模式 - 刷新图标
      refreshBtn.innerHTML = `
 <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="${textColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
 <path d="M9 4.55a8 8 0 0 1 6 14.9m0 -4.45v5h5" />
 <path d="M5.63 7.16l0 .01" />
 <path d="M4.06 11l0 .01" />
 <path d="M4.63 15.1l0 .01" />
 <path d="M7.16 18.37l0 .01" />
 <path d="M11 19.94l0 .01" />
 </svg>
 `;
      refreshBtn.setAttribute("title", "重新生成账户主页");
    }
  }
  // 刷新按钮长按处理
  window.handleRefreshButtonMouseDown = function () {
    progressLongPressTimer = setTimeout(() => {
      toggleProgressMode();
    }, 800); // 长按800ms触发
  };
  window.handleRefreshButtonMouseUp = function () {
    if (progressLongPressTimer) {
      clearTimeout(progressLongPressTimer);
      progressLongPressTimer = null;
    }
  }; // 刷新账户主页（重新生成或推进）
  window.refreshAccountProfile = async function () {
    // 清除长按定时器
    if (progressLongPressTimer) {
      clearTimeout(progressLongPressTimer);
      progressLongPressTimer = null;
    }
    if (!currentViewingAccount) {
      showXToast("未找到当前账户信息", "error");
      return;
    }
    try {
      if (isProgressMode) {
        // 推进模式：生成新内容并追加
        showXToast("正在推进账户主页...", "info");
        await progressAccountProfile();
      } else {
        // 重新生成模式：覆盖现有内容
        showXToast("正在重新生成账户主页...", "info"); // 从当前账户数据中提取基本信息
        const accountInfo =
          currentViewingAccount.accountInfo || currentViewingAccount; // 查询账户数据（重新判断账户类型）
        const accountData = await queryAccountData(
          accountInfo.name,
          accountInfo.handle,
          accountInfo.avatar
        );
        if (!accountData) {
          showXToast("无法加载账户信息", "error");
          return;
        }
        // 调用AI重新生成账户主页内容
        const profileData = await generateAccountProfileContent(accountData);
        if (profileData) {
          // 更新账户数据
          currentViewingAccount = { ...accountData, ...profileData };
          console.log("📊 [账户主页] 重新生成数据统计:", {
            推文数: profileData.tweets?.length || 0,
            回复数: profileData.accountReplies?.length || 0,
            喜欢数: profileData.accountLikes?.length || 0,
          });
          renderAccountProfile(currentViewingAccount); // 保存到数据库（覆盖旧数据）
          await saveAccountProfile(currentViewingAccount);
          showXToast("账户主页已刷新", "success");
        }
      }
    } catch (error) {
      console.error("刷新账户主页失败:", error);
      showXToast(`刷新失败: ${error.message}`, "error");
    }
  }; // 推进账户主页（生成新内容并追加）
  async function progressAccountProfile() {
    try {
      const accountInfo =
        currentViewingAccount.accountInfo || currentViewingAccount; // 查询账户数据
      const accountData = await queryAccountData(
        accountInfo.name,
        accountInfo.handle,
        accountInfo.avatar
      );
      if (!accountData) {
        showXToast("无法加载账户信息", "error");
        return;
      }
      // 调用AI生成新的推文和回复（传入现有内容作为上下文）
      const newProfileData = await generateAccountProfileContent(accountData, {
        isProgressMode: true,
        existingTweets: currentViewingAccount.tweets || [],
        existingReplies: currentViewingAccount.accountReplies || [],
      });
      if (newProfileData) {
        // 确保新推文没有置顶标记
        if (newProfileData.tweets) {
          newProfileData.tweets.forEach((tweet) => {
            tweet.pinned = false;
          });
        }
        // 合并推文：置顶动态 → 新动态 → 旧动态
        const existingTweets = currentViewingAccount.tweets || [];
        const pinnedTweet = existingTweets.find((t) => t.pinned);
        const unpinnedOldTweets = existingTweets.filter((t) => !t.pinned);
        const newTweets = newProfileData.tweets || [];
        let updatedTweets;
        if (pinnedTweet) {
          // 如果有置顶：置顶 → 新推文 → 旧推文
          updatedTweets = [pinnedTweet, ...newTweets, ...unpinnedOldTweets];
        } else {
          // 如果没有置顶：新推文 → 旧推文
          updatedTweets = [...newTweets, ...unpinnedOldTweets];
        }
        // 合并回复：新回复 → 旧回复
        const updatedReplies = [
          ...(newProfileData.accountReplies || []),
          ...(currentViewingAccount.accountReplies || []),
        ]; // 合并喜欢：新喜欢 → 旧喜欢
        const updatedLikes = [
          ...(newProfileData.accountLikes || []),
          ...(currentViewingAccount.accountLikes || []),
        ];
        console.log("📊 [推进模式] 数据合并统计:", {
          新推文: newProfileData.tweets?.length || 0,
          旧推文: (currentViewingAccount.tweets || []).filter((t) => !t.pinned)
            .length,
          合并后推文: updatedTweets.length,
          新回复: newProfileData.accountReplies?.length || 0,
          旧回复: (currentViewingAccount.accountReplies || []).length,
          合并后回复: updatedReplies.length,
          新喜欢: newProfileData.accountLikes?.length || 0,
          旧喜欢: (currentViewingAccount.accountLikes || []).length,
          合并后喜欢: updatedLikes.length,
        }); // 更新账户数据
        currentViewingAccount = {
          ...currentViewingAccount,
          tweets: updatedTweets,
          accountReplies: updatedReplies,
          accountLikes: updatedLikes,
          // 保持 accountInfo 不变
          accountInfo: currentViewingAccount.accountInfo || accountInfo,
        };
        renderAccountProfile(currentViewingAccount); // 保存到数据库
        await saveAccountProfile(currentViewingAccount);
        showXToast(
          `已推进：新增 ${newProfileData.tweets?.length || 0} 条推文，${
            newProfileData.accountReplies?.length || 0
          } 条回复，${newProfileData.accountLikes?.length || 0} 条喜欢`,
          "success"
        );
      }
    } catch (error) {
      console.error("推进账户主页失败:", error);
      showXToast(`推进失败: ${error.message}`, "error");
    }
  }
  // ▲▲▲ 【主要！！！】第七个情景：账户主页生成器 ▲▲▲
  // ============================================
  // 语言切换功能
  // ============================================
  // 语言配置对象
  const languageConfig = {
    zh: {
      // 底部导航栏
      navHome: "主页",
      navSearch: "搜索",
      navNotifications: "通知",
      navMessages: "消息",
      // 主页
      homeTitle: "主页",
      homeForYou: "为你推荐",
      homeFollowing: "正在关注",
      homeCompose: "有什么新鲜事?",
      homeNoTweets: "暂无推文",
      homeNoTweetsDesc: "开始关注一些人，或刷新查看推荐内容",
      // 搜索页面
      searchTitle: "搜索",
      searchPlaceholder: "搜索",
      searchTrending: "热门话题",
      searchNoResults: "无搜索结果",
      searchRefresh: "刷新热搜",
      // 通知页面
      notificationsTitle: "通知",
      notificationsTabAll: "全部",
      notificationsTabMentions: "提及",
      notificationsEmpty: "暂无通知",
      notificationsEmptyDesc: "当有人点赞、评论或关注你时，你会在这里看到通知",
      notificationsRecommended: "推荐关注",
      notificationsLiked: "喜欢了你的帖子",
      notificationsFollowed: "关注了你",
      notificationsReplied: "回复了你",
      notificationsMentioned: "提及了你",
      notificationsRetweeted: "转推了你的帖子",
      // 私信页面
      messagesTitle: "私信",
      messagesEmpty: "暂无私信",
      messagesEmptyDesc: "发送私信与朋友保持联系",
      messageFollowers: "位关注者",
      messageInputPlaceholder: "开始写私信",
      // 用户资料页面
      profileTitle: "个人资料",
      profileEditProfile: "编辑个人资料",
      profileFollowing: "正在关注",
      profileFollowers: "关注者",
      profilePosts: "帖子",
      profilePostsCount: "帖子",
      profileLikes: "喜欢",
      profileHighlights: "亮点",
      profileArticles: "文章",
      profileMedia: "媒体",
      profileNoLikes: "还没有喜欢的推文",
      profileNoLikesDesc: "当你喜欢一条推文时，它会显示在这里。",
      profileNoHighlights: "还没有收藏",
      profileNoHighlightsDesc: "点击推文下方的书签按钮来收藏喜欢的内容",
      profileNoArticles: "还没有文章",
      profileNoArticlesDesc: "发布的文章会显示在这里。",
      profileNoMedia: "还没有媒体",
      profileNoMediaDesc: "包含照片和视频的推文会显示在这里。",
      profileAccountManager: "账号管理",
      // 推文详情页
      tweetDetailTitle: "帖子",
      tweetDetailReply: "回复",
      tweetDetailReplyPlaceholder: "发布你的回复",
      tweetDetailRerollTooltip: "重新生成回复",
      tweetDetailRetweets: "转推",
      tweetDetailLikes: "喜欢",
      tweetDetailBookmarks: "书签",
      tweetDetailViews: "查看",
      // 评论页面
      commentsTitle: "发帖",
      commentsReply: "回复",
      commentsReplyPlaceholder: "发布你的回复",
      // 账户主页
      accountPostsCount: "个帖子",
      accountFollow: "关注",
      accountFollowing: "正在关注",
      accountFollowingLabel: "正在关注",
      accountFollowersLabel: "关注者",
      accountFollowsYou: "关注你",
      accountPostsTab: "帖子",
      accountRepliesTab: "回复",
      accountLikesTab: "喜欢",
      accountPinned: "已置顶",
      accountNoPosts: "还没有帖子",
      accountNoPostsDesc: "该账户的帖子会显示在这里。",
      accountNoReplies: "还没有回复",
      accountNoRepliesDesc: "该账户的回复会显示在这里。",
      accountNoLikes: "还没有喜欢",
      accountNoLikesDesc: "该账户喜欢的内容会显示在这里。",
      accountReplyTo: "回复",
      accountLiked: "已喜欢",
      // 设置页面
      settingsTitle: "设置",
      settingsPrompt: "提示词",
      settingsPromptPlaceholder: "输入系统提示词...",
      settingsWorldView: "世界观设定",
      settingsWorldViewPlaceholder: "描述角色所在的世界观、背景设定...",
      settingsCharacterBinding: "绑定角色",
      settingsCharacterBindingDesc: "开启后，绑定的角色可以在X上发布推文",
      settingsSelectCharacter: "选择要绑定的角色",
      settingsRelationship: "角色关系册",
      settingsRelationshipDesc:
        "开启后，可以为已绑定的角色建立关系网络，设置角色之间的双向关系",
      settingsRelationshipGraph: "角色关系图",
      settingsEditGraph: "编辑关系图",
      settingsNPCBinding: "绑定NPC",
      settingsNPCBindingDesc:
        "开启后，可以创建和管理自定义NPC，设置其人设、发帖习惯和绑定用户",
      settingsNPCList: "NPC列表",
      settingsCreateNPC: "+ 创建NPC",
      settingsSave: "保存设置",
      settingsSavePreset: "保存为预设",
      settingsImport: "导入数据",
      settingsExport: "导出数据",
      settingsPresetManagement: "预设管理",
      settingsWorldBooks: "世界书管理",
      settingsWorldBooksDesc:
        "世界书可以为AI提供额外的知识库，支持绑定到不同场景和角色",
      settingsWorldBooksButton: "打开世界书管理面板",
      settingsWorldEvents: "世界运转大事件",
      settingsWorldEventsDesc:
        "开启后，AI将根据世界观生成地点、天气和近期大事件，让推文生成更真实连贯",
      settingsWorldEventsLocation: "所在地点",
      settingsWorldEventsWeather: "天气状况",
      settingsWorldEventsLastGenerated: "上次生成",
      settingsWorldEventsLastProgressed: "上次推进",
      settingsWorldEventsRecentEvents: "近期大事件",
      settingsWorldEventsNoEvents: "暂无事件",
      settingsWorldEventsRefresh: "更新事件",
      settingsWorldEventsProgress: "推进事件",
      settingsWorldEventsCooldownTip: "推进功能需要间隔3小时使用",
      settingsAutoTweetDetection: "智能发推检测",
      settingsAutoTweetDetectionDesc:
        "开启后，每隔5分钟自动检测已绑定角色的聊天记忆，生成New Tweet通知",
      settingsAutoTweetDetectionNote:
        '仅对设置了"角色身份识别"和"专属用户人设"的角色生效',
      settingsDetectionRunning: "检测服务运行中",
      settingsNextDetectionTime: "下次检测时间",
      settingsAutoRefreshFeed: "智能刷新主页",
      settingsAutoRefreshFeedDesc: "开启后，每隔10分钟自动刷新主页推文",
      settingsRefreshRunning: "刷新服务运行中",
      settingsNextRefreshTime: "下次刷新时间",
      // 关系图相关
      relationshipNoData: "暂无关系数据",
      relationshipNoDataHint: "点击上方按钮开始创建角色关系",
      relationshipCharacterCount: "角色数",
      relationshipLinkCount: "关系数",
      relationshipAddCharacter: "+ 添加角色",
      relationshipSave: "保存关系图",
      relationshipClose: "关闭",
      relationshipEmptyState: "暂无角色",
      relationshipEmptyStateHint: "点击上方按钮添加角色",
      // 直播页面
      liveTitle: "直播",
      liveAudioTab: "语音直播",
      liveVideoTab: "视频直播",
      liveOnlineCount: "人在线",
      liveJoinStream: "加入直播",
      liveNoAudioStreams: "暂无语音直播",
      liveNoVideoStreams: "暂无视频直播",
      liveWaitingContent: "等待精彩内容上线",
      // 直播间
      liveRoomInfo: "直播间信息",
      liveRoomDescription: "直播简介",
      liveRoomAnnouncement: "直播公告",
      liveRoomWelcome: "欢迎来到直播间！",
      liveRoomSendMessage: "说点什么...",
      danmakuSent: "弹幕已发送",
      you: "我",
      // Toast 提示
      toastThemeLight: "已切换到日间模式",
      toastThemeDark: "已切换到夜间模式",
      toastLanguageChinese: "已切换到中文",
      toastLanguageEnglish: "已切换到英文",
      // 通用按钮
      btnSave: "保存",
      btnCancel: "取消",
      btnEdit: "编辑",
      btnDelete: "删除",
      btnConfirm: "确认",
    },
    en: {
      // 底部导航栏
      navHome: "Home",
      navSearch: "Explore",
      navNotifications: "Notifications",
      navMessages: "Messages",
      // 主页
      homeTitle: "Home",
      homeForYou: "For you",
      homeFollowing: "Following",
      homeCompose: "What's happening?",
      homeNoTweets: "No posts yet",
      homeNoTweetsDesc: "Follow people or refresh to see recommended content",
      // 搜索页面
      searchTitle: "Explore",
      searchPlaceholder: "Search",
      searchTrending: "What's happening",
      searchNoResults: "No results found",
      searchRefresh: "Refresh trends",
      // 通知页面
      notificationsTitle: "Notifications",
      notificationsTabAll: "All",
      notificationsTabMentions: "Mentions",
      notificationsEmpty: "No notifications yet",
      notificationsEmptyDesc:
        "When someone likes, comments, or follows you, you'll see it here",
      notificationsRecommended: "Recommended",
      notificationsLiked: "liked your post",
      notificationsFollowed: "followed you",
      notificationsReplied: "replied to you",
      notificationsMentioned: "mentioned you",
      notificationsRetweeted: "retweeted your post",
      // 私信页面
      messagesTitle: "Messages",
      messagesEmpty: "No messages yet",
      messagesEmptyDesc: "Send a message to stay in touch with friends",
      messageFollowers: "followers",
      messageInputPlaceholder: "Start a message",
      // 用户资料页面
      profileTitle: "Profile",
      profileEditProfile: "Edit profile",
      profileFollowing: "Following",
      profileFollowers: "Followers",
      profilePosts: "Posts",
      profilePostsCount: "posts",
      profileLikes: "Likes",
      profileHighlights: "Highlights",
      profileArticles: "Articles",
      profileMedia: "Media",
      profileNoLikes: "No liked posts yet",
      profileNoLikesDesc: "When you like a post, it will show up here.",
      profileNoHighlights: "No bookmarks yet",
      profileNoHighlightsDesc:
        "Tap the bookmark button below posts to save your favorites",
      profileNoArticles: "No articles yet",
      profileNoArticlesDesc: "Published articles will show up here.",
      profileNoMedia: "No media yet",
      profileNoMediaDesc: "Posts with photos and videos will show up here.",
      profileAccountManager: "Account Manager",
      // 推文详情页
      tweetDetailTitle: "Post",
      tweetDetailReply: "Reply",
      tweetDetailReplyPlaceholder: "Post your reply",
      tweetDetailRerollTooltip: "Regenerate replies",
      tweetDetailRetweets: "Reposts",
      tweetDetailLikes: "Likes",
      tweetDetailBookmarks: "Bookmarks",
      tweetDetailViews: "Views",
      // 评论页面
      commentsTitle: "Post",
      commentsReply: "Reply",
      commentsReplyPlaceholder: "Post your reply",
      // 账户主页
      accountPostsCount: "posts",
      accountFollow: "Follow",
      accountFollowing: "Following",
      accountFollowingLabel: "Following",
      accountFollowersLabel: "Followers",
      accountFollowsYou: "Follows you",
      accountPostsTab: "Posts",
      accountRepliesTab: "Replies",
      accountLikesTab: "Likes",
      accountPinned: "Pinned",
      accountNoPosts: "No posts yet",
      accountNoPostsDesc: "Posts from this account will show up here.",
      accountNoReplies: "No replies yet",
      accountNoRepliesDesc: "Replies from this account will show up here.",
      accountNoLikes: "No likes yet",
      accountNoLikesDesc: "Liked posts will show up here.",
      accountReplyTo: "Replying to",
      accountLiked: "liked",
      // 设置页面
      settingsTitle: "Settings",
      settingsPrompt: "System Prompt",
      settingsPromptPlaceholder: "Enter system prompt...",
      settingsWorldView: "World Setting",
      settingsWorldViewPlaceholder:
        "Describe the world setting and background...",
      settingsCharacterBinding: "Character Binding",
      settingsCharacterBindingDesc:
        "When enabled, bound characters can post on X",
      settingsSelectCharacter: "Select Character to Bind",
      settingsRelationship: "Character Relations",
      settingsRelationshipDesc:
        "When enabled, create relationship networks for bound characters",
      settingsRelationshipGraph: "Relationship Graph",
      settingsEditGraph: "Edit Graph",
      settingsNPCBinding: "NPC Binding",
      settingsNPCBindingDesc: "When enabled, create and manage custom NPCs",
      settingsNPCList: "NPC List",
      settingsCreateNPC: "+ Create NPC",
      settingsSave: "Save Settings",
      settingsSavePreset: "Save as Preset",
      settingsImport: "Import Data",
      settingsExport: "Export Data",
      settingsPresetManagement: "Preset Management",
      settingsWorldBooks: "World Books",
      settingsWorldBooksDesc:
        "World books provide additional knowledge base for AI, can be bound to different scenes and characters",
      settingsWorldBooksButton: "Open World Books Panel",
      settingsWorldEvents: "World Events",
      settingsWorldEventsDesc:
        "When enabled, AI will generate location, weather and recent events based on world settings",
      settingsWorldEventsLocation: "Location",
      settingsWorldEventsWeather: "Weather",
      settingsWorldEventsLastGenerated: "Last Generated",
      settingsWorldEventsLastProgressed: "Last Progressed",
      settingsWorldEventsRecentEvents: "Recent Events",
      settingsWorldEventsNoEvents: "No events yet",
      settingsWorldEventsRefresh: "Refresh",
      settingsWorldEventsProgress: "Progress",
      settingsWorldEventsCooldownTip:
        "Progress function requires 3 hours cooldown",
      settingsAutoTweetDetection: "Auto Tweet Detection",
      settingsAutoTweetDetectionDesc:
        "When enabled, automatically detect chat history of bound characters every 5 minutes and generate New Tweet notifications",
      settingsAutoTweetDetectionNote:
        'Only effective for characters with "Identity Recognition" and "Exclusive User Persona" settings',
      settingsDetectionRunning: "Detection service running",
      settingsNextDetectionTime: "Next detection time",
      settingsAutoRefreshFeed: "Auto Refresh Feed",
      settingsAutoRefreshFeedDesc:
        "When enabled, automatically refresh feed every 10 minutes",
      settingsRefreshRunning: "Refresh service running",
      settingsNextRefreshTime: "Next refresh time",
      // 关系图相关
      relationshipNoData: "No relationship data",
      relationshipNoDataHint:
        "Click button above to create character relationships",
      relationshipCharacterCount: "Characters",
      relationshipLinkCount: "Relations",
      relationshipAddCharacter: "+ Add Character",
      relationshipSave: "Save Graph",
      relationshipClose: "Close",
      relationshipEmptyState: "No characters",
      relationshipEmptyStateHint: "Click button above to add characters",
      // 直播页面
      liveTitle: "Live",
      liveAudioTab: "Audio Live",
      liveVideoTab: "Video Live",
      liveOnlineCount: "viewers",
      liveJoinStream: "Join Live",
      liveNoAudioStreams: "No audio streams",
      liveNoVideoStreams: "No video streams",
      liveWaitingContent: "Waiting for exciting content",
      // Live Room
      liveRoomInfo: "Room Info",
      liveRoomDescription: "Description",
      liveRoomAnnouncement: "Announcement",
      liveRoomWelcome: "Welcome to the live room!",
      liveRoomSendMessage: "Say something...",
      danmakuSent: "Message sent",
      you: "You",
      // Toast 提示
      toastThemeLight: "Switched to Light Mode",
      toastThemeDark: "Switched to Dark Mode",
      toastLanguageChinese: "Switched to Chinese",
      toastLanguageEnglish: "Switched to English",
      // 通用按钮
      btnSave: "Save",
      btnCancel: "Cancel",
      btnEdit: "Edit",
      btnDelete: "Delete",
      btnConfirm: "Confirm",
    },
  }; // 当前语言
  let currentLanguage = "zh"; // 切换语言
  async function toggleXLanguage() {
    try {
      // 切换语言
      currentLanguage = currentLanguage === "zh" ? "en" : "zh"; // 应用语言
      applyLanguage(currentLanguage); // 保存语言偏好到数据库
      const xDb = getXDB();
      const settingsId = `xLanguage_${currentAccountId || "main"}`;
      await xDb.xSettings.put({
        id: settingsId,
        language: currentLanguage,
        updatedAt: new Date().toISOString(),
      });
      console.log(
        `🌐 语言已切换为: ${currentLanguage === "zh" ? "中文" : "English"}`
      );
      showXToast(
        currentLanguage === "zh"
          ? languageConfig.zh.toastLanguageChinese
          : languageConfig.en.toastLanguageEnglish,
        "success"
      );
    } catch (error) {
      console.error("语言切换失败:", error);
      showXToast("Language switch failed", "error");
    }
  }
  // 获取当前语言的翻译文本
  function getI18nText(key) {
    const config = languageConfig[currentLanguage] || languageConfig["zh"];
    return config[key] || key;
  }
  // 应用语言到界面
  function applyLanguage(lang) {
    const config = languageConfig[lang];
    if (!config) return;
    console.log(`🌐 正在应用语言: ${lang}`); // 更新语言按钮文本
    const languageText = document.getElementById("language-text");
    if (languageText) {
      languageText.textContent = lang === "zh" ? "中文" : "EN";
    }
    // 更新所有带 data-i18n 属性的元素
    document.querySelectorAll("[data-i18n]").forEach((el) => {
      const key = el.getAttribute("data-i18n");
      if (config[key]) {
        if (el.tagName === "INPUT" || el.tagName === "TEXTAREA") {
          el.placeholder = config[key];
        } else {
          // 对于其他元素，更新文本内容
          el.textContent = config[key];
        }
      }
    }); // 更新用户主页顶部的帖子计数（需要动态生成）
    const profileHeaderCount = document.getElementById(
      "x-profile-header-count"
    );
    if (profileHeaderCount && profileHeaderCount.textContent) {
      const count = profileHeaderCount.textContent.match(/\d+/);
      if (count) {
        profileHeaderCount.textContent = `${count[0]} ${config.profilePostsCount}`;
      }
    }
    // 更新推文详情页的动态内容
    updateTweetDetailLanguage(config); // 更新账户主页的动态内容
    updateAccountProfileLanguage(config); // 保存当前语言
    console.log(`✅ 语言已应用: ${lang === "zh" ? "中文" : "English"}`);
  }
  // 更新账户主页的语言
  function updateAccountProfileLanguage(config) {
    // 更新帖子计数
    const accountNavCount = document.getElementById(
      "account-profile-nav-count"
    );
    if (accountNavCount && accountNavCount.textContent) {
      const count = accountNavCount.textContent.match(/\d+/);
      if (count) {
        accountNavCount.textContent = `${count[0]} ${config.accountPostsCount}`;
      }
    }
    // 更新关注按钮文本
    const followBtn = document.getElementById("account-follow-btn");
    if (followBtn) {
      if (
        followBtn.textContent.includes("Following") ||
        followBtn.textContent.includes("正在关注")
      ) {
        followBtn.textContent = config.accountFollowing;
      } else if (
        followBtn.textContent.includes("Follow") ||
        followBtn.textContent.includes("关注")
      ) {
        followBtn.textContent = config.accountFollow;
      }
    }
  }
  // 更新推文详情页的语言
  function updateTweetDetailLanguage(config) {
    // 更新互动数据标签
    const statsDiv = document.getElementById("tweet-detail-stats");
    if (statsDiv) {
      const spans = statsDiv.querySelectorAll('span[style*="color: #71767b"]');
      if (spans.length >= 3) {
        spans[0].textContent = config.tweetDetailRetweets;
        spans[1].textContent = config.tweetDetailLikes;
        spans[2].textContent = config.tweetDetailBookmarks;
      }
    }
    // 更新查看次数标签
    const viewsLabel = document.getElementById("tweet-detail-views-label");
    if (viewsLabel) {
      viewsLabel.textContent = config.tweetDetailViews;
    }
  }
  // 加载保存的语言偏好
  async function loadLanguagePreference() {
    try {
      const xDb = getXDB();
      const settingsId = `xLanguage_${currentAccountId || "main"}`;
      const savedSettings = await xDb.xSettings.get(settingsId);
      if (savedSettings && savedSettings.language) {
        currentLanguage = savedSettings.language;
        applyLanguage(currentLanguage);
      }
    } catch (error) {
      console.error("加载语言偏好失败:", error);
    }
  }
  // ============================================
  // 主题切换功能
  // ============================================
  // 切换日间/夜间主题
  async function toggleXTheme() {
    try {
      const xSocialScreen = document.getElementById("x-social-screen");
      if (!xSocialScreen) return;
      const isLightMode = xSocialScreen.classList.contains("x-theme-light");
      const newTheme = isLightMode ? "dark" : "light"; // 切换主题类
      if (newTheme === "light") {
        xSocialScreen.classList.add("x-theme-light");
      } else {
        xSocialScreen.classList.remove("x-theme-light");
      }
      // 更新图标显示
      const darkIcon = document.getElementById("theme-icon-dark");
      const lightIcon = document.getElementById("theme-icon-light");
      if (newTheme === "light") {
        darkIcon.style.display = "none";
        lightIcon.style.display = "block";
      } else {
        darkIcon.style.display = "block";
        lightIcon.style.display = "none";
      }
      // 保存主题偏好到数据库
      const xDb = getXDB();
      const settingsId = `xTheme_${currentAccountId || "main"}`;
      await xDb.xSettings.put({
        id: settingsId,
        theme: newTheme,
        updatedAt: new Date().toISOString(),
      }); // 应用主题到所有动态元素
      applyThemeToElements(newTheme); // 重新渲染关系图画布（如果当前打开）
      const relationshipModal = document.getElementById('character-relationship-graph-modal');
      if (relationshipModal && relationshipModal.style.display !== 'none') {
        renderRelationshipGraph();
      }
      // 重新渲染关系预览画布（如果关系册已开启）
      const relationshipArea = document.getElementById('relationship-binding-area');
      if (relationshipArea && relationshipArea.style.display !== 'none') {
        setTimeout(() => {
          updateRelationshipPreview();
        }, 100);
      }
      console.log(`🎨 主题已切换为: ${newTheme === 'light' ? '日间模式' : '夜间模式'}`);
      const config = languageConfig[currentLanguage] || languageConfig.zh;
      showXToast(
        newTheme === "light" ? config.toastThemeLight : config.toastThemeDark,
        "success"
      );
    } catch (error) {
      console.error("主题切换失败:", error);
      showXToast("主题切换失败", "error");
    }
  }
  // 应用主题到动态元素
  function applyThemeToElements(theme) {
    const xSocialScreen = document.getElementById("x-social-screen");
    if (!xSocialScreen) return;
    const isLight = theme === "light"; // 更新所有需要动态更新的元素
    const elementsToUpdate = {
      // 背景色
      ".x-top-bar, .x-bottom-nav, .settings-header, .tweet-detail-header, .compose-header, .modal-header, .account-header":
        {
          backgroundColor: isLight ? "#fff" : "#000",
          borderBottomColor: isLight ? "#eff3f4" : "#2f3336",
        },
      // 文本色
      ".tweet-user-name, .tweet-content, .comment-content": {
        color: isLight ? "#0f1419" : "#fff",
      },
      // 次要文本色
      ".tweet-user-handle, .tweet-time, .comment-time": {
        color: isLight ? "#536471" : "#71767b",
      },
      // 边框色
      ".tweet-item, .comment-item, .settings-section": {
        borderBottomColor: isLight ? "#eff3f4" : "#2f3336",
      },
      // 输入框背景
      'textarea, input[type="text"]': {
        backgroundColor: isLight ? "#f7f9f9" : "#1a1a1a",
        borderColor: isLight ? "#eff3f4" : "#333",
        color: isLight ? "#0f1419" : "#fff",
      },
    }; // 应用样式（这些样式会在下次页面渲染时生效，当前页面的内联样式会覆盖）
    // 主要是为新生成的元素设置正确的主题
  }
  // 加载保存的主题偏好
  async function loadXThemePreference() {
    try {
      const xDb = getXDB();
      const settingsId = `xTheme_${currentAccountId || "main"}`;
      const themeSettings = await xDb.xSettings.get(settingsId);
      if (themeSettings && themeSettings.theme) {
        const xSocialScreen = document.getElementById("x-social-screen");
        if (!xSocialScreen) return;
        if (themeSettings.theme === "light") {
          xSocialScreen.classList.add("x-theme-light"); // 更新图标显示
          const darkIcon = document.getElementById("theme-icon-dark");
          const lightIcon = document.getElementById("theme-icon-light");
          if (darkIcon && lightIcon) {
            darkIcon.style.display = "none";
            lightIcon.style.display = "block";
          }
          applyThemeToElements("light");
        }
        console.log(
          `🎨 已加载主题偏好: ${
            themeSettings.theme === "light" ? "日间模式" : "夜间模式"
          }`
        );
      }
    } catch (error) {
      console.error("加载主题偏好失败:", error);
    }
  }
  // ============================================
  // 主题色自定义功能
  // ============================================
  // 预设主题色
  const presetAccentColors = [
    { name: "Twitter蓝", color: "#1d9bf0" },
    { name: "薰衣草紫", color: "#7856ff" },
    { name: "玫瑰粉", color: "#f91880" },
    { name: "翡翠绿", color: "#00ba7c" },
    { name: "橙色", color: "#ff7a00" },
    { name: "红色", color: "#f4212e" },
    { name: "黄色", color: "#ffd400" },
    { name: "青色", color: "#00d4ff" },
  ]; // 打开主题色选择器
  function openAccentColorPicker() {
    // 创建弹窗
    const modal = document.createElement("div");
    modal.id = "accent-color-picker-modal";
    modal.style.cssText = `
 position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; backdrop-filter: blur(4px);
`;
    const xSocialScreen = document.getElementById("x-social-screen");
    const currentAccent = getComputedStyle(xSocialScreen)
      .getPropertyValue("--x-accent")
      .trim();
    modal.innerHTML = `
 <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 400px; border: 1px solid var(--x-border-color); overflow: hidden; ">

 <div style="padding: 20px; border-bottom: 1px solid var(--x-border-color); display: flex; align-items: center; justify-content: space-between; ">
 <h3 style="margin: 0; color:var(--x-text-primary); font-size: 20px; font-weight: 700;">选择主题色</h3>
 <button onclick="closeAccentColorPicker()" style="background: transparent; border: none; color:var(--x-text-secondary); cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </button>
 </div>

 <div style="padding: 20px;">
 <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 12px;">预设颜色</div>
 <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 20px;">
 ${presetAccentColors
   .map(
     (preset) => `
 <div onclick="applyAccentColor('${
   preset.color
 }')" style="cursor: pointer; aspect-ratio: 1; border-radius: 8px; background-color: ${
       preset.color
     }; border: 3px solid ${
       preset.color === currentAccent ? "var(--x-text-primary)" : "transparent"
     }; transition: all 0.2s; position: relative; display: flex; align-items: center; justify-content: center; " onmouseover="this.style.transform='scale(1.05)'"
 onmouseout="this.style.transform='scale(1)'">
 ${
   preset.color === currentAccent
     ? '<svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #fff;"><path d="M9 16.17L5.53 12.7l-1.06 1.06L9 18.3l9.54-9.54-1.06-1.06L9 16.17z"/></svg>'
     : ""
 }
 </div>
 `
   )
   .join("")}
 </div>

 <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 12px;">自定义颜色</div>
 <div style="display: flex; gap: 12px; align-items: center;">
 <input type="color" id="custom-accent-color" value="${currentAccent}" style="width: 60px; height: 40px; border: 2px solid var(--x-border-color); border-radius: 8px; cursor: pointer; background: transparent; ">
 <button onclick="applyAccentColor(document.getElementById('custom-accent-color').value)" style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 10px 20px; font-size: 15px; font-weight: 700; cursor: pointer; transition: opacity 0.2s; " onmouseover="this.style.opacity='0.9'"
 onmouseout="this.style.opacity='1'">
 应用
 </button>
 </div>

 <button onclick="applyAccentColor('#1d9bf0')" style="width: 100%; margin-top: 16px; background: transparent; color:var(--x-text-secondary); border: 1px solid var(--x-border-color); border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 重置为默认色
 </button>
 </div>
 </div>
`;
    document.body.appendChild(modal); // 点击背景关闭
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        closeAccentColorPicker();
      }
    });
  }
  // 关闭主题色选择器
  function closeAccentColorPicker() {
    const modal = document.getElementById("accent-color-picker-modal");
    if (modal) {
      modal.remove();
    }
  }
  // 应用主题色
  async function applyAccentColor(color) {
    try {
      const xSocialScreen = document.getElementById("x-social-screen");
      if (!xSocialScreen) return; // 更新CSS变量
      xSocialScreen.style.setProperty("--x-accent", color); // 保存到数据库
      const xDb = getXDB();
      const settingsId = `xAccentColor_${currentAccountId || "main"}`;
      await xDb.xSettings.put({
        id: settingsId,
        accentColor: color,
        updatedAt: new Date().toISOString(),
      });
      showXToast("主题色已更新", "success");
      closeAccentColorPicker();
      console.log("✅ 主题色已应用:", color);
    } catch (error) {
      console.error("应用主题色失败:", error);
      showXToast("应用主题色失败", "error");
    }
  }
  // 加载保存的主题色
  async function loadAccentColorPreference() {
    try {
      const xDb = getXDB();
      const settingsId = `xAccentColor_${currentAccountId || "main"}`;
      const savedSettings = await xDb.xSettings.get(settingsId);
      if (savedSettings && savedSettings.accentColor) {
        const xSocialScreen = document.getElementById("x-social-screen");
        if (xSocialScreen) {
          xSocialScreen.style.setProperty(
            "--x-accent",
            savedSettings.accentColor
          );
          console.log("✅ 已加载主题色:", savedSettings.accentColor);
        }
      }
    } catch (error) {
      console.error("加载主题色偏好失败:", error);
    }
  }
  // ============================================
  // 账户提问箱功能
  // ============================================
  // 账户提问箱数据（临时存储）
  let accountAskboxData = {
    avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
    nickname: "⩌⌯⩌",
    prompt: "在这里输入你的匿名提问，或点击下方按钮生成随机提问...",
    background: "https://i.postimg.cc/tJvBC00j/mmexport1759642131681.jpg",
    answeredQuestions: [],
  }; // 🎯 用户当前输入的提问（临时存储，不保存到数据库）
  let currentUserQuestion = ""; // 账户提问箱多选删除相关变量
  let isAccountAskboxMultiSelectMode = false;
  let selectedAccountQuestions = new Set();
  let accountQuestionLongPressTimer = null; // 打开账户提问箱
  window.openAccountAskbox = async function () {
    if (!currentViewingAccount) {
      showXToast("未找到当前账户信息", "error");
      return;
    }
    try {
      // 加载该账户的提问箱数据
      await loadAccountAskboxData(); // 隐藏账户主页，显示提问箱页面
      document.getElementById("account-profile-page").style.display = "none";
      document.getElementById("account-askbox-page").style.display = "flex";
    } catch (error) {
      console.error("打开账户提问箱失败:", error);
      showXToast("打开提问箱失败: " + error.message, "error");
    }
  }; // 关闭账户提问箱
  window.closeAccountAskbox = function () {
    // 退出多选模式
    if (isAccountAskboxMultiSelectMode) {
      exitAccountAskboxMultiSelectMode();
    }
    document.getElementById("account-askbox-page").style.display = "none";
    document.getElementById("account-profile-page").style.display = "flex";
  }; // 从数据库加载账户提问箱数据
  async function loadAccountAskboxDataFromDB() {
    try {
      const xDb = getXDB();
      const accountInfo =
        currentViewingAccount.accountInfo || currentViewingAccount;
      const accountHandle = accountInfo.handle.replace("@", "");
      const askboxId = `account_askbox_${accountHandle}`;
      const savedData = await xDb.xAccountAskbox.get(askboxId);
      if (savedData) {
        // 从数据库加载
        Object.assign(accountAskboxData, savedData);
        console.log("✅ 账户提问箱数据已从数据库加载:", accountHandle);
      } else {
        // 使用默认数据并保存到数据库
        accountAskboxData = {
          avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
          nickname: "⩌⌯⩌",
          prompt: "在这里输入你的匿名提问，或点击下方按钮生成随机提问...",
          background: "https://i.postimg.cc/tJvBC00j/mmexport1759642131681.jpg",
          answeredQuestions: [],
          id: askboxId,
        };
        await xDb.xAccountAskbox.put(accountAskboxData);
        console.log("✅ 已创建默认账户提问箱数据:", accountHandle);
      }
    } catch (error) {
      console.error("❌ 加载账户提问箱数据失败:", error);
    }
  }
  // 保存账户提问箱数据到数据库
  async function saveAccountAskboxDataToDB() {
    try {
      const xDb = getXDB();
      const accountInfo =
        currentViewingAccount.accountInfo || currentViewingAccount;
      const accountHandle = accountInfo.handle.replace("@", "");
      const askboxId = `account_askbox_${accountHandle}`;
      accountAskboxData.id = askboxId;
      await xDb.xAccountAskbox.put(accountAskboxData);
      console.log("✅ 账户提问箱数据已保存到数据库:", accountHandle);
    } catch (error) {
      console.error("❌ 保存账户提问箱数据失败:", error);
    }
  }
  // 加载账户提问箱数据到UI
  async function loadAccountAskboxData() {
    // 从数据库加载
    await loadAccountAskboxDataFromDB(); // 🎯 清空用户提问（每次进入都重置）
    currentUserQuestion = ""; // 更新UI
    const avatarEl = document.getElementById("account-askbox-avatar");
    const nicknameEl = document.getElementById("account-askbox-nickname");
    const promptEl = document.getElementById("account-askbox-prompt");
    const backgroundEl = document.getElementById("account-askbox-background");
    if (avatarEl) avatarEl.src = accountAskboxData.avatar;
    if (nicknameEl) nicknameEl.textContent = accountAskboxData.nickname;
    // 🎯 每次进入都恢复默认文字
    if (promptEl)
      promptEl.textContent =
        "在这里输入你的匿名提问，或点击下方按钮生成随机提问...";
    if (backgroundEl)
      backgroundEl.style.backgroundImage = `url('${accountAskboxData.background}')`; // 渲染已回答的提问列表
    renderAccountAnsweredQuestions();
  }
  // 修改账户提问箱头像
  window.changeAccountAskboxAvatar = async function () {
    const newAvatar = prompt("请输入新的头像URL:", accountAskboxData.avatar);
    if (newAvatar && newAvatar.trim()) {
      accountAskboxData.avatar = newAvatar.trim();
      const avatarEl = document.getElementById("account-askbox-avatar");
      if (avatarEl) avatarEl.src = accountAskboxData.avatar; // 保存到数据库
      await saveAccountAskboxDataToDB();
      showXToast("头像已更新并保存", "success");
    }
  }; // 保存账户提问箱昵称（原处编辑）
  window.saveAccountAskboxNickname = async function () {
    const nicknameEl = document.getElementById("account-askbox-nickname");
    if (!nicknameEl) return;
    const newNickname = nicknameEl.textContent.trim();
    if (newNickname && newNickname !== accountAskboxData.nickname) {
      accountAskboxData.nickname = newNickname;
      await saveAccountAskboxDataToDB();
      console.log("✅ 昵称已自动保存:", newNickname);
    }
  }; // 保存账户提问卡片文字（用户提问输入）
  window.saveAccountAskboxPrompt = async function () {
    const promptEl = document.getElementById("account-askbox-prompt");
    if (!promptEl) return;
    const newText = promptEl.textContent.trim();
    const defaultPrompt =
      "在这里输入你的匿名提问，或点击下方按钮生成随机提问..."; // 🎯 如果不是默认文字，则视为用户输入的提问
    if (newText && newText !== defaultPrompt) {
      currentUserQuestion = newText;
      console.log("📝 [提问箱] 用户输入了提问:", currentUserQuestion);
    } else {
      currentUserQuestion = "";
      console.log("📝 [提问箱] 用户清空了提问");
    }
  }; // 打开账户提问箱设置
  window.openAccountAskboxSettings = function () {
    const newBackground = prompt(
      "请输入新的背景图URL:",
      accountAskboxData.background
    );
    if (newBackground && newBackground.trim()) {
      accountAskboxData.background = newBackground.trim();
      const backgroundEl = document.getElementById("account-askbox-background");
      if (backgroundEl)
        backgroundEl.style.backgroundImage = `url('${accountAskboxData.background}')`; // 保存到数据库
      saveAccountAskboxDataToDB();
      showXToast("背景图已更新并保存", "success");
    }
  }; // 获取新的提问（账户提问箱AI生成）
  window.getNewAccountQuestion = async function () {
    if (!currentViewingAccount) {
      showXToast("未找到当前账户信息", "error");
      return;
    }
    try {
      // 🔍 检查是否有用户提问
      const isUserQuestion =
        currentUserQuestion && currentUserQuestion.trim().length > 0;
      if (isUserQuestion) {
        console.log(
          "🎯 [提问箱] 检测到用户提问，准备生成回答:",
          currentUserQuestion
        );
        showXToast("正在生成回答...", "info");
      } else {
        console.log("🎲 [提问箱] 没有用户提问，生成随机问答");
        showXToast("正在生成新的提问...", "info");
      }
      // 从数据库读取API配置和X设置
      const db = getDB();
      const xDb = getXDB();
      const apiConfig = await db.apiConfig.get("main");
      if (
        !apiConfig ||
        !apiConfig.proxyUrl ||
        !apiConfig.apiKey ||
        !apiConfig.model
      ) {
        showXToast("请先配置API设置", "error");
        return;
      }
      const { proxyUrl, apiKey, model } = apiConfig; // 从X设置中读取配置（按账号读取）
      const settingsId = `xSettings_${currentAccountId || "main"}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const userPrompt = xSettings?.systemPrompt || "";
      const worldSetting = xSettings?.worldSetting || ""; // 获取账户信息
      const accountInfo =
        currentViewingAccount.accountInfo || currentViewingAccount;
      const accountHandle = accountInfo.handle.replace("@", ""); // 🎯 使用统一资料获取系统
      const accountProfile = await StringBuilders.getUnifiedProfile(
        accountInfo.handle
      );
      if (!accountProfile) {
        showXToast("无法获取账户资料", "error");
        return;
      }
      console.log("📋 [提问箱] 账户类型:", accountProfile.type); // 使用工具函数格式化账户资料
      let accountDetailInfo = StringBuilders.formatProfileForPrompt(
        accountProfile,
        {
          includeType: true,
          includeTweets: false, // 推文信息单独处理
          includeRelationships: true,
        }
      ); // 获取该账户已有的推文（最近5条）
      let accountTweetsInfo = "";
      if (
        currentViewingAccount.tweets &&
        currentViewingAccount.tweets.length > 0
      ) {
        accountTweetsInfo = `\n【该账户最近发布的推文】：\n`;
        currentViewingAccount.tweets.slice(0, 5).forEach((tweet, i) => {
          accountTweetsInfo += `${i + 1}. ${tweet.content}${
            tweet.time ? ` (${tweet.time})` : ""
          }`; // 添加图片信息
          if (tweet.image) {
            if (tweet.image.type === "description") {
              accountTweetsInfo += `\n [图片描述: ${tweet.image.content}]`;
            } else if (tweet.image.type === "upload") {
              accountTweetsInfo += `\n [包含上传的图片]`;
            }
          }
          // 添加媒体信息（如果使用media字段）
          if (tweet.media && tweet.media.length > 0) {
            tweet.media.forEach((m) => {
              if (m.type === "description" && m.description) {
                accountTweetsInfo += `\n [图片描述: ${m.description}]`;
              }
            });
          }
          accountTweetsInfo += "\n";
        });
      }
      // 获取用户的X资料（提问者的身份信息）
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(
        window.userProfileData
      ); // 获取情侣角色的X资料（如果有的话）
      let coupleCharacterInfo = "";
      if (
        accountProfile.relationships &&
        accountProfile.relationships.length > 0
      ) {
        const coupleRelation = accountProfile.relationships.find(
          (rel) => rel.relationshipType === "恋人"
        );
        if (coupleRelation) {
          coupleCharacterInfo = `\n【该账户的情侣关系】：\n与 ${coupleRelation.npcName}（${coupleRelation.npcHandle}）是恋人关系`;
          if (coupleRelation.description) {
            coupleCharacterInfo += `\n${coupleRelation.description}`;
          }
        }
      }
      // 收集已有的提问（如果要重新生成）
      let existingQuestionsContext = "";
      if (accountAskboxData.answeredQuestions.length > 0) {
        existingQuestionsContext = `\n【已有的提问列表（需要重新生成回答）】：\n`;
        accountAskboxData.answeredQuestions.forEach((q, i) => {
          existingQuestionsContext += `${i + 1}. ${q.question}\n`;
        });
      }
      // 构建系统提示词
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      }); // 🎯 根据是否有用户提问，构建不同的提示词
      let userQuestionContext = "";
      if (isUserQuestion) {
        userQuestionContext = `\n【🔴 用户匿名提问（必须回答）】：\n"${currentUserQuestion}"\n`;
      }
      systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务说明 - 账户提问箱生成 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你需要为该账户生成匿名提问，并以该账户的身份回答这些提问。
${accountDetailInfo}
${accountTweetsInfo}
${coupleCharacterInfo}
${userQuestionContext}
${existingQuestionsContext}
【生成要求】：
1. ${
        isUserQuestion
          ? `必须回答用户的匿名提问"${currentUserQuestion}"，同时额外生成2-5个随机问答`
          : existingQuestionsContext
          ? "如果有已有提问列表，请基于这些提问重新生成回答"
          : "生成3-10个适合该账户身份的匿名提问"
      }
2. ${
        isUserQuestion
          ? "用户提问是完全匿名的，不要在回答中假设提问者的身份"
          : "提问要自然、真实，符合匿名提问箱的风格"
      }
3. ${
        isUserQuestion
          ? ""
          : "提问内容要与账户的X平台公开信息相关（X姓名、简介、公开身份、最近推文）"
      }
4. ${
        accountProfile.type === "character" || accountProfile.type === "npc"
          ? "回答必须严格符合角色/NPC的人设和性格特点"
          : "回答要自然、真实"
      }
5. ${
        isUserQuestion
          ? "回答用户提问时要自然、真诚，体现账户的性格和口吻"
          : `提问可以是：
- 关于最近推文内容的追问或评论
- 关于生活经验、情感态度的询问
- 关于兴趣爱好、日常生活的好奇
- 轻松幽默或真诚的话题`
      }
6. ${isUserQuestion ? "" : "提问长度适中（10-50字）"}
7. 回答要体现该账户的性格和口吻，长度适中（20-100字）
8. ${isUserQuestion ? "" : "避免过于私密、冒犯或不适当的问题"}
${
  !isUserQuestion
    ? `【🔒 隐私保护规则 - 匿名提问限制】：
🚨 匿名提问者只能基于该账户的X平台公开信息：
✅ 可以基于：X姓名、X句柄、X简介、公开身份、公开的推文内容
❌ 禁止提及：真实姓名、真实职业、私密关系、未公开的身份信息
❌ 禁止使用：只有亲密关系才知道的称呼（如"老师"、"同学"等，除非是公开身份）
示例说明：
- ✅ 正确："姐姐你平时喜欢什么类型的音乐啊？"（基于公开称呼）
- ❌ 错误："张老师今天上课讲了什么内容？"（泄露了真实姓氏和职业）
- ❌ 错误："同学你这次考试考得怎么样？"（假装是同学关系）
⚠️ 回答也要注意：不要在回答中主动泄露私密信息，除非是角色本人想公开`
    : ""
}
【返回格式】：
返回JSON数组，每个对象包含question和answer字段：
\`\`\`json
[
{"question": "提问内容1", "answer": "该账户的回答1"},
{"question": "提问内容2", "answer": "该账户的回答2"},
{"question": "提问内容3", "answer": "该账户的回答3"}
]
\`\`\`
【重要】：
- 必须返回有效的JSON数组格式
- question是匿名提问的内容
- answer是该账户以自己的身份和人设回答的内容
- ${
        isUserQuestion
          ? `请务必包含用户提问"${currentUserQuestion}"的回答，并额外生成2-5组随机问答，将用户问答自然混入其中，不要特殊化`
          : existingQuestionsContext
          ? `请基于已有的${accountAskboxData.answeredQuestions.length}个提问重新生成回答`
          : "生成3-10组问答"
      }
现在，请生成JSON格式的问答内容：`;
      const messages = [
        {
          role: "user",
          content: isUserQuestion
            ? `请回答用户的匿名提问"${currentUserQuestion}"，同时生成2-5组随机问答，将用户问答自然混入其中，返回JSON数组格式`
            : existingQuestionsContext
            ? `请基于已有的${accountAskboxData.answeredQuestions.length}个提问，以该账户的身份重新生成回答，返回JSON数组格式`
            : "请生成3-10组问答，返回JSON数组格式",
        },
      ]; // 判断API类型并发送请求
      let isGemini = proxyUrl.includes("generativelanguage");
      let response;
      if (isGemini) {
        const GEMINI_API_URL =
          "https://generativelanguage.googleapis.com/v1beta/models";
        const geminiConfig = {
          url: `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(
            apiKey
          )}`,
          data: {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text:
                        systemPrompt +
                        "\n\n" +
                        messages.map((m) => m.content).join("\n"),
                    },
                  ],
                },
              ],
              generationConfig: {
                temperature: 0.9,
              },
            }),
          },
        };
        response = await fetch(geminiConfig.url, geminiConfig.data);
      } else {
        const openAiPayload = {
          model: model,
          messages: [{ role: "system", content: systemPrompt }, ...messages],
          temperature: 0.9,
          stream: false,
        };
        response = await fetch(`${proxyUrl}/v1/chat/completions`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify(openAiPayload),
        });
      }
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(
          `API错误: ${response.status} - ${
            errorData.error?.message || response.statusText
          }`
        );
      }
      const data = await response.json();
      let aiResponseContent;
      if (isGemini) {
        // Gemini格式
        if (
          data.candidates &&
          data.candidates[0] &&
          data.candidates[0].content &&
          data.candidates[0].content.parts
        ) {
          aiResponseContent = data.candidates[0].content.parts[0].text || "";
        }
      } else {
        // OpenAI格式
        aiResponseContent = data.choices?.[0]?.message?.content || "";
      }
      console.log("AI生成的问答:", aiResponseContent); // 解析JSON格式的回答
      let qaArray;
      try {
        // 提取JSON内容（可能被包裹在```json```中）
        let jsonText = aiResponseContent.trim();
        const jsonMatch = jsonText.match(
          /```(?:json)?\s*(\[\s*\{[\s\S]*?\}\s*\])\s*```/
        );
        if (jsonMatch) {
          jsonText = jsonMatch[1];
        } else if (jsonText.startsWith("[") && jsonText.endsWith("]")) {
          // 直接是JSON数组
          jsonText = jsonText;
        } else {
          throw new Error("未找到有效的JSON格式");
        }
        qaArray = JSON.parse(jsonText);
        if (!Array.isArray(qaArray) || qaArray.length === 0) {
          throw new Error("AI返回的不是有效的数组或数组为空");
        }
      } catch (parseError) {
        console.error("JSON解析失败:", parseError);
        throw new Error(`解析AI回答失败: ${parseError.message}`);
      }
      console.log(`✅ 解析到 ${qaArray.length} 组问答:`, qaArray); // 如果是重新生成，清空原有提问
      if (existingQuestionsContext) {
        accountAskboxData.answeredQuestions = [];
      }
      // 为每个问答创建对象并添加到数组
      const newQuestions = qaArray.map((qa, index) => ({
        id: `q_${Date.now()}_${index}_${Math.random()
          .toString(36)
          .substr(2, 9)}`,
        question: qa.question || "",
        answer: qa.answer || "",
        date: new Date().toISOString(),
      })); // 批量添加到最前面
      accountAskboxData.answeredQuestions.unshift(...newQuestions); // 保存到数据库
      await saveAccountAskboxDataToDB(); // 重新渲染提问列表
      renderAccountAnsweredQuestions(); // 🎯 如果是用户提问，清空提问并恢复默认文字
      if (isUserQuestion) {
        showXToast("已生成回答！", "success");
        currentUserQuestion = ""; // 清空提问
        const promptEl = document.getElementById("account-askbox-prompt");
        if (promptEl) {
          promptEl.textContent =
            "在这里输入你的匿名提问，或点击下方按钮生成随机提问...";
        }
        console.log(
          `✅ [提问箱] 用户提问已回答，问题已混入${newQuestions.length}组问答中`
        );
      } else {
        showXToast(
          `${
            existingQuestionsContext
              ? "已重新生成回答"
              : `生成了 ${newQuestions.length} 组问答`
          }`,
          "success"
        );
      }
      // 检查是否是已绑定角色的提问箱，如果是则随机触发角色主动发消息
      if (accountProfile.type === "character" && accountProfile.characterData) {
        // 🎲 随机概率触发（30%概率）
        const triggerProbability = 0.3;
        const shouldTrigger = Math.random() < triggerProbability;
        console.log("🔔 检测到角色提问箱");
        console.log(
          `🎲 触发概率: ${(triggerProbability * 100).toFixed(0)}%, 本次${
            shouldTrigger ? "触发" : "不触发"
          }`
        );
        if (!shouldTrigger) {
          console.log("⏭️ 本次未触发角色主动发消息");
          return; // 不触发，直接返回
        }
        console.log("✅ 准备触发角色主动发消息");
        console.log(
          "📋 角色数据:",
          accountProfile.characterData.originalName,
          accountProfile.characterData.id
        ); // 获取角色ID
        const characterId = accountProfile.characterData.id; // 构建提问箱内容摘要（最多3条最新问答）
        const askboxSummary = accountAskboxData.answeredQuestions
          .slice(0, 3)
          .map(
            (qa, index) => `${index + 1}. Q: ${qa.question}\n A: ${qa.answer}`
          )
          .join("\n\n"); // 延迟1秒后触发（让用户看到提问箱生成成功的提示）
        setTimeout(async () => {
          try {
            // 查找或创建与该角色的私信对话
            const messageId = `msg_${characterId}`; // 检查是否已存在该私信
            const messagesListId = `messagesList_${currentAccountId || "main"}`;
            const messagesListData = await xDb.xAccountProfiles.get(
              messagesListId
            );
            let existingMessage = null;
            if (messagesListData && messagesListData.data) {
              existingMessage = messagesListData.data.find(
                (msg) => msg.id === messageId
              );
            }
            // 如果没有该私信，创建一个
            if (!existingMessage) {
              const newMessage = {
                id: messageId,
                user: {
                  name: accountData.name,
                  handle: accountData.handle,
                  avatar: accountData.avatar,
                  verified: accountData.verified || false,
                },
                preview: "发现你在看我的提问箱...",
                time: "刚刚",
                unread: true,
                unreadCount: 1,
              };
              if (messagesListData && messagesListData.data) {
                messagesListData.data.unshift(newMessage);
                await xDb.xAccountProfiles.put(messagesListData);
              } else {
                await xDb.xAccountProfiles.put({
                  handle: messagesListId,
                  name: "messagesList",
                  data: [newMessage],
                  updatedAt: new Date().toISOString(),
                });
              }
              existingMessage = newMessage;
              sampleMessagesData.unshift(newMessage);
            }
            // 检查是否有现有对话记录
            // 🔧 多账户隔离：包含账户ID
            const conversationId = `messageConversation_${
              currentAccountId || "main"
            }_${messageId}`;
            const existingConversation = await xDb.xAccountProfiles.get(
              conversationId
            );
            const hasHistory =
              existingConversation &&
              existingConversation.data &&
              existingConversation.data.messages &&
              existingConversation.data.messages.length > 0;
            console.log("🎯 触发角色主动发消息（提问箱查看）");
            console.log(
              `📖 现有对话记录: ${
                hasHistory
                  ? existingConversation.data.messages.length + "条消息"
                  : "无（首次对话）"
              }`
            ); // 调用第九个情景生成器，使用特殊模式：askboxViewed
            const aiMessages = await generateMessageConversation(
              existingMessage,
              true, // 续写模式
              {
                isAskboxViewed: true, // 新增：提问箱查看模式
                askboxContent: askboxSummary, // 提问箱内容
                characterId: characterId,
              }
            );
            if (aiMessages && aiMessages.length > 0) {
              // 保存AI消息到数据库
              await saveAIMessagesToDB(aiMessages, existingMessage); // 更新私信列表（标记为未读）
              if (messagesListData && messagesListData.data) {
                const msgIndex = messagesListData.data.findIndex(
                  (msg) => msg.id === messageId
                );
                if (msgIndex !== -1) {
                  messagesListData.data[msgIndex].preview =
                    aiMessages[0].content ||
                    aiMessages[0].voiceText ||
                    "[消息]";
                  messagesListData.data[msgIndex].time =
                    aiMessages[0].time || "刚刚";
                  messagesListData.data[msgIndex].unread = true;
                  messagesListData.data[msgIndex].unreadCount =
                    (messagesListData.data[msgIndex].unreadCount || 0) +
                    aiMessages.length;
                  await xDb.xAccountProfiles.put(messagesListData);
                  sampleMessagesData = messagesListData.data;
                }
              }
              console.log(`✅ 角色已发送 ${aiMessages.length} 条私信`);
              showXToast(`${accountProfile.name} 给你发来了新消息`, "info");
            }
          } catch (error) {
            console.error("触发角色主动发消息失败:", error);
          }
        }, 1000);
      }
    } catch (error) {
      console.error("生成提问失败:", error);
      showXToast(`生成失败: ${error.message}`, "error");
    }
  }; // 渲染账户已回答的提问列表
  function renderAccountAnsweredQuestions() {
    const container = document.getElementById(
      "account-answered-questions-list"
    );
    const titleEl = document.getElementById("account-answered-questions-title");
    if (!container) return;
    if (accountAskboxData.answeredQuestions.length === 0) {
      // 隐藏标题
      if (titleEl) titleEl.style.display = "none";
      container.innerHTML = `
 <div style="text-align: center; color: rgba(255,255,255,0.6); font-size: 14px; padding: 40px 20px; ">
 暂无提问
 </div>
 `;
      return;
    }
    // 显示标题
    if (titleEl) titleEl.style.display = "block";
    container.innerHTML = accountAskboxData.answeredQuestions
      .map((q, index) => {
        const date = new Date(q.date);
        const dateStr = date.toLocaleDateString("zh-CN", {
          month: "short",
          day: "numeric",
        });
        const isSelected = selectedAccountQuestions.has(q.id);
        return `
 <div
 class="account-askbox-question-item"
 data-question-id="${q.id}"
 style="background-color: rgba(255,255,255,0.9); backdrop-filter: blur(10px); border-radius: 16px; overflow: hidden; margin-bottom: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); transition: all 0.2s; ${
   isSelected
     ? "border: 3px solid var(--x-accent); background-color: color-mix(in srgb, var(--x-accent) , 0.1);"
     : ""
 }
 ${
   isAccountAskboxMultiSelectMode
     ? "border-left: 3px solid var(--x-accent);"
     : ""
 }
 "
 onmouseover="if(!${isAccountAskboxMultiSelectMode}){this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0,0,0,0.2)';}"
 onmouseout="if(!${isAccountAskboxMultiSelectMode}){this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';}"
 onmousedown="startAccountQuestionLongPress('${q.id}')"
 onmouseup="endAccountQuestionLongPress()"
 onmouseleave="endAccountQuestionLongPress()"
 ontouchstart="handleAccountQuestionTouchStart(event, '${q.id}')"
 ontouchend="handleAccountQuestionTouchEnd(event, '${q.id}')"
 ontouchcancel="endAccountQuestionLongPress()"
 onclick="if(${isAccountAskboxMultiSelectMode}){toggleAccountQuestionSelection('${
          q.id
        }');event.stopPropagation();}"
 >

 <div style="background: linear-gradient(135deg, #3a3a3a 0%, #2a2a2a 100%); padding: 20px; color: #fff; ">
 <div style="font-size: 15px; line-height: 1.6; word-break: break-word;">
 ${q.question}
 </div>
 </div>

 <div style="background-color:#fff; padding: 20px; min-height: 60px; color: #333; ">
 <div id="account-answer-${q.id}"
 contenteditable="true"
 data-question-id="${q.id}"
 style="font-size: 14px; line-height: 1.6; word-break: break-word; outline: none; cursor: text; min-height: 20px; ${
   q.answer ? "" : "color: #999; text-align: center;"
 }
 "
 onblur="saveAccountQuestionAnswer('${q.id}')"
 onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();this.blur();}"
 onfocus="if(this.textContent==='点击此处回复...'){this.textContent='';this.style.color='#333';this.style.textAlign='left';}">${
   q.answer || "点击此处回复..."
 }</div>
 </div>

 <div style="background-color: #f5f5f5; padding: 8px 20px; color: #999; font-size: 12px; text-align: right; ">
 ${dateStr}
 </div>
 </div>
`;
      })
      .join("");
  }
  // 保存账户提问回复（原处编辑）
  window.saveAccountQuestionAnswer = async function (questionId) {
    const answerEl = document.getElementById(`account-answer-${questionId}`);
    if (!answerEl) return;
    const question = accountAskboxData.answeredQuestions.find(
      (q) => q.id === questionId
    );
    if (!question) return;
    let newAnswer = answerEl.textContent.trim(); // 如果是占位符文本，则清空
    if (newAnswer === "点击此处回复...") {
      newAnswer = "";
    }
    if (newAnswer !== question.answer) {
      question.answer = newAnswer;
      await saveAccountAskboxDataToDB();
      console.log("✅ 回复已自动保存:", questionId);
    }
  }; // ============================================
  // 账户提问箱多选删除功能
  // ============================================
  // 开始长按提问卡片
  window.startAccountQuestionLongPress = function (questionId) {
    if (isAccountAskboxMultiSelectMode) return;
    accountQuestionLongPressTimer = setTimeout(() => {
      enterAccountAskboxMultiSelectMode();
      toggleAccountQuestionSelection(questionId);
    }, 500);
  }; // 结束长按
  window.endAccountQuestionLongPress = function () {
    if (accountQuestionLongPressTimer) {
      clearTimeout(accountQuestionLongPressTimer);
      accountQuestionLongPressTimer = null;
    }
  }; // 处理触摸开始（移动端）
  window.handleAccountQuestionTouchStart = function (event, questionId) {
    // 如果已经在多选模式，不启动长按计时器
    if (isAccountAskboxMultiSelectMode) {
      return;
    }
    // 记录触摸开始时间和位置，用于判断是否是滑动
    window.accountQuestionTouchStartTime = Date.now();
    window.accountQuestionTouchStartY = event.touches[0].clientY; // 启动长按计时器
    accountQuestionLongPressTimer = setTimeout(() => {
      enterAccountAskboxMultiSelectMode();
      toggleAccountQuestionSelection(questionId);
    }, 500);
  }; // 处理触摸结束（移动端）
  window.handleAccountQuestionTouchEnd = function (event, questionId) {
    // 清除长按计时器
    if (accountQuestionLongPressTimer) {
      clearTimeout(accountQuestionLongPressTimer);
      accountQuestionLongPressTimer = null;
    }
    // 如果在多选模式下，触摸结束时切换选择状态
    if (isAccountAskboxMultiSelectMode) {
      // 检查是否是快速点击（不是滑动）
      const touchDuration =
        Date.now() - (window.accountQuestionTouchStartTime || 0);
      const touchMoveY = Math.abs(
        (event.changedTouches[0]?.clientY ||
          window.accountQuestionTouchStartY ||
          0) - (window.accountQuestionTouchStartY || 0)
      ); // 如果触摸时间短且移动距离小，认为是点击
      if (touchDuration < 500 && touchMoveY < 10) {
        event.preventDefault(); // 阻止默认行为和后续的click事件
        toggleAccountQuestionSelection(questionId);
      }
    }
  }; // 切换提问选择状态
  window.toggleAccountQuestionSelection = function (questionId) {
    if (!isAccountAskboxMultiSelectMode) {
      enterAccountAskboxMultiSelectMode();
    }
    const questionEl = document.querySelector(
      `.account-askbox-question-item[data-question-id="${questionId}"]`
    );
    if (!questionEl) return;
    if (selectedAccountQuestions.has(questionId)) {
      selectedAccountQuestions.delete(questionId);
      questionEl.style.border = "";
      questionEl.style.backgroundColor = "rgba(255,255,255,0.9)";
    } else {
      selectedAccountQuestions.add(questionId);
      questionEl.style.border = "3px solid var(--x-accent)";
      questionEl.style.backgroundColor =
        "color-mix(in srgb, var(--x-accent) , 0.1)";
    }
    updateAccountAskboxDeleteUI();
  }; // 进入账户提问箱多选模式
  function enterAccountAskboxMultiSelectMode() {
    isAccountAskboxMultiSelectMode = true;
    showAccountAskboxDeleteToolbar();
    document
      .querySelectorAll(".account-askbox-question-item")
      .forEach((item) => {
        item.style.borderLeft = "3px solid var(--x-accent)";
      });
    console.log("✅ 已进入账户提问箱多选模式");
  }
  // 退出账户提问箱多选模式
  window.exitAccountAskboxMultiSelectMode = function () {
    isAccountAskboxMultiSelectMode = false;
    selectedAccountQuestions.clear();
    hideAccountAskboxDeleteToolbar(); // 清除长按相关的计时器和临时变量
    if (accountQuestionLongPressTimer) {
      clearTimeout(accountQuestionLongPressTimer);
      accountQuestionLongPressTimer = null;
    }
    window.accountQuestionTouchStartTime = null;
    window.accountQuestionTouchStartY = null;
    document
      .querySelectorAll(".account-askbox-question-item")
      .forEach((item) => {
        item.style.border = "";
        item.style.borderLeft = "";
        item.style.backgroundColor = "rgba(255,255,255,0.9)";
      });
    console.log("✅ 已退出账户提问箱多选模式");
  }; // 显示账户提问箱删除工具栏
  function showAccountAskboxDeleteToolbar() {
    let toolbar = document.getElementById("account-askbox-delete-toolbar");
    if (!toolbar) {
      toolbar = document.createElement("div");
      toolbar.id = "account-askbox-delete-toolbar";
      toolbar.style.cssText = `
 position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); border-radius: 24px; padding: 12px 20px; display: flex; align-items: center; gap: 16px; z-index: 2000; box-shadow: 0 4px 20px rgba(0,0,0,0.5); `;
      toolbar.innerHTML = `
 <button onclick="selectAllAccountQuestions()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'">
 全选
 </button>
 <span id="account-askbox-selected-count" style="color: #fff; font-size: 14px; font-weight: 500;">已选择 0 个</span>
 <button onclick="deleteSelectedAccountQuestions()" style="background-color: #f91880; color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#d0155f'" onmouseout="this.style.backgroundColor='#f91880'">
 删除
 </button>
 <button onclick="exitAccountAskboxMultiSelectMode()" style="background-color: rgba(255,255,255,0.15); color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.25)'" onmouseout="this.style.backgroundColor='rgba(255,255,255,0.15)'">
 取消
 </button>
 `;
      document.body.appendChild(toolbar);
    }
    toolbar.style.display = "flex";
  }
  // 隐藏账户提问箱删除工具栏
  function hideAccountAskboxDeleteToolbar() {
    const toolbar = document.getElementById("account-askbox-delete-toolbar");
    if (toolbar) {
      toolbar.style.display = "none";
    }
  }
  // 更新账户提问箱删除UI
  function updateAccountAskboxDeleteUI() {
    const countEl = document.getElementById("account-askbox-selected-count");
    if (countEl) {
      countEl.textContent = `已选择 ${selectedAccountQuestions.size} 个`;
    }
  }
  // 全选账户提问
  window.selectAllAccountQuestions = function () {
    document
      .querySelectorAll(".account-askbox-question-item")
      .forEach((item) => {
        const questionId = item.dataset.questionId;
        if (!selectedAccountQuestions.has(questionId)) {
          selectedAccountQuestions.add(questionId);
          item.style.border = "3px solid var(--x-accent)";
          item.style.backgroundColor =
            "color-mix(in srgb, var(--x-accent) , 0.1)";
        }
      });
    updateAccountAskboxDeleteUI();
  }; // 删除选中的账户提问
  window.deleteSelectedAccountQuestions = async function () {
    if (selectedAccountQuestions.size === 0) {
      showXToast("请先选择要删除的提问", "warning");
      return;
    }
    const confirmDelete = confirm(
      `确定要删除选中的 ${selectedAccountQuestions.size} 个提问吗？删除后无法恢复。`
    );
    if (!confirmDelete) return;
    try {
      accountAskboxData.answeredQuestions =
        accountAskboxData.answeredQuestions.filter(
          (q) => !selectedAccountQuestions.has(q.id)
        );
      await saveAccountAskboxDataToDB();
      showXToast(`已删除 ${selectedAccountQuestions.size} 个提问`, "success");
      window.exitAccountAskboxMultiSelectMode();
      renderAccountAnsweredQuestions();
    } catch (error) {
      console.error("删除提问失败:", error);
      showXToast("删除失败: " + error.message, "error");
    }
  }; // X设置页面相关功能
  let xSettingsData = {
    systemPrompt: "",
    worldSetting: "",
    characterBinding: false,
    boundCharacters: [],
    worldBooks: [], // 世界书数组
  }; // 用户资料数据 - 初始化全局变量（实际数据将在loadUserProfile时从数据库加载）
  if (!window.userProfileData) {
    window.userProfileData = {
      name: "我",
      handle: "@me",
      avatar: "https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg",
      coverImage: "https://i.postimg.cc/qRzMB6nQ/default-cover.jpg",
      bio: "欢迎来到我的X主页！",
      verified: false,
      verificationType: "none",
      coupleCharacterId: "",
      coupleCharacterName: "",
      customTag1: "科技爱好者",
      customTag1Icon: "✨",
      customTag1Color: "#71767b",
      customTag2: "2024年加入",
      customTag2Icon: "📅",
      customTag2Color: "#71767b",
      following: "156",
      followers: "89",
      knownIdentityCharacters: [],
      publicIdentity: "",
      showRealName: false,
      realName: "",
    };
  }
  // 创建局部引用指向全局变量（确保所有地方都访问同一个对象）
  let userProfileData = window.userProfileData; // 获取用户认证类型描述
  function getUserVerificationTypeDescription(userProfile) {
    const verificationType = userProfile.verificationType || "none";
    const descriptions = {
      none: "无认证",
      verified: "已认证（蓝色勾标）",
      couple: "情侣认证（白色心形）",
      married: "已婚认证（白色圆环）",
      vip: "VIP认证（白色菱形）",
    };
    return descriptions[verificationType] || "无认证";
  }
  // 初始化X设置
  async function initializeXSettings() {
    try {
      const db = getXDB(); // 先加载全局世界书（所有账户共享）
      await loadGlobalWorldBooks(); // 按账号加载设置
      const settingsId = `xSettings_${currentAccountId || "main"}`;
      const savedSettings = await db.xSettings.get(settingsId);
      if (savedSettings) {
        // 🔧 保存全局世界书引用，避免被账户设置覆盖
        const globalWorldBooks = xSettingsData.worldBooks;
        xSettingsData = savedSettings; // 恢复全局世界书
        xSettingsData.worldBooks = globalWorldBooks;
      } else {
        // 如果当前账号没有设置，使用默认设置（worldBooks已经从全局加载）
        const globalWorldBooks = xSettingsData.worldBooks;
        xSettingsData = {
          systemPrompt: "",
          worldSetting: "",
          characterBinding: false,
          boundCharacters: [],
          npcBinding: false,
          worldBooks: globalWorldBooks,
        };
      }
      // 加载UI
      await loadXSettingsToUI(); // 加载预设列表
      loadXPresetsList();
      console.log("✅ X设置已加载 (账户:", currentAccountId || "main", ")");
      console.log(
        "📚 全局世界书:",
        xSettingsData.worldBooks?.length || 0,
        "个"
      ); // 🔧 注意：已移除智能检测和刷新的自动恢复功能（改为用户手动开启）
    } catch (error) {
      console.error("初始化X设置失败:", error);
    }
  }
  // 将设置数据加载到UI
  async function loadXSettingsToUI() {
    document.getElementById("x-system-prompt").value =
      xSettingsData.systemPrompt || "";
    document.getElementById("x-world-setting").value =
      xSettingsData.worldSetting || ""; // 确保 boundCharacters 数组存在
    if (!xSettingsData.boundCharacters) {
      xSettingsData.boundCharacters = [];
    }
    // 确保 worldBooks 数组存在
    if (!xSettingsData.worldBooks) {
      xSettingsData.worldBooks = [];
    }
    updateCharacterToggleUI(); // 如果开启了角色绑定，显示角色选择区域
    const bindingArea = document.getElementById("character-binding-area");
    if (xSettingsData.characterBinding) {
      bindingArea.style.display = "block";
      loadCharactersList();
    } else {
      bindingArea.style.display = "none";
    }
    // 更新角色关系册UI
    updateRelationshipToggleUI(); // 如果开启了角色关系册，显示关系册管理区域并更新预览
    const relationshipArea = document.getElementById(
      "relationship-binding-area"
    );
    if (xSettingsData.characterRelationship?.enabled) {
      relationshipArea.style.display = "block";
      await loadRelationshipData();
      setTimeout(() => {
        updateRelationshipPreview();
      }, 200);
    } else {
      relationshipArea.style.display = "none";
    }
    // 更新NPC绑定UI
    updateNPCToggleUI(); // 如果开启了NPC绑定，显示NPC管理区域
    const npcArea = document.getElementById("npc-binding-area");
    if (xSettingsData.npcBinding) {
      npcArea.style.display = "block";
      loadNPCsList();
    } else {
      npcArea.style.display = "none";
    }
  }
  // 切换角色绑定 (已被新版本替换，在新位置)
  // 保存全局世界书（所有账户共享）
  async function saveGlobalWorldBooks() {
    try {
      const db = getXDB();
      await db.xSettings.put({
        id: "globalWorldBooks",
        worldBooks: xSettingsData.worldBooks || [],
        lastUpdated: new Date().toISOString(),
      });
      console.log("✅ 全局世界书已保存");
    } catch (error) {
      console.error("保存全局世界书失败:", error);
      throw error;
    }
  }
  // 加载全局世界书（所有账户共享）
  async function loadGlobalWorldBooks() {
    try {
      const db = getXDB();
      const globalData = await db.xSettings.get("globalWorldBooks");
      if (
        globalData &&
        globalData.worldBooks &&
        globalData.worldBooks.length > 0
      ) {
        xSettingsData.worldBooks = globalData.worldBooks;
        console.log(
          "✅ 全局世界书已加载:",
          xSettingsData.worldBooks.length,
          "个"
        );
      } else {
        // 🔧 数据迁移：如果全局世界书为空，尝试从当前账户设置中迁移
        console.log("📦 [世界书迁移] 全局世界书为空，尝试从账户设置迁移...");
        const settingsId = `xSettings_${currentAccountId || "main"}`;
        const accountSettings = await db.xSettings.get(settingsId);
        if (
          accountSettings &&
          accountSettings.worldBooks &&
          accountSettings.worldBooks.length > 0
        ) {
          console.log(
            `📦 [世界书迁移] 发现账户设置中有 ${accountSettings.worldBooks.length} 个世界书，正在迁移到全局设置...`
          );
          xSettingsData.worldBooks = accountSettings.worldBooks; // 保存到全局设置
          await saveGlobalWorldBooks();
          console.log("✅ [世界书迁移] 迁移完成！");
        } else {
          xSettingsData.worldBooks = [];
          console.log("ℹ️ [世界书] 无世界书数据");
        }
      }
    } catch (error) {
      console.error("加载全局世界书失败:", error);
      xSettingsData.worldBooks = [];
    }
  }
  // 保存X设置（按账号存储）
  async function saveXSettings() {
    try {
      // 获取UI中的数据
      xSettingsData.systemPrompt =
        document.getElementById("x-system-prompt").value;
      xSettingsData.worldSetting =
        document.getElementById("x-world-setting").value;
      const db = getXDB();
      const settingsId = `xSettings_${currentAccountId || "main"}`; // 创建设置数据副本，移除worldBooks（因为它是全局的）
      const settingsToSave = { ...xSettingsData };
      delete settingsToSave.worldBooks;
      await db.xSettings.put({
        id: settingsId,
        ...settingsToSave,
        lastUpdated: new Date().toISOString(),
      });
      console.log("✅ X设置已保存 (账户:", currentAccountId || "main", ")");
      showXToast("设置已保存", "success");
    } catch (error) {
      console.error("保存设置失败:", error);
      showXToast("保存失败: " + error.message, "error");
    }
  }
  // ============================================
  // 世界书管理功能
  // ============================================
  // 打开世界书管理弹窗
  window.openWorldBooksManageModal = async function () {
    // 🔧 先加载全局世界书数据，确保显示最新内容
    await loadGlobalWorldBooks();
    const modal = document.createElement("div");
    modal.id = "world-books-manage-modal";
    modal.style.cssText = `
 position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); backdrop-filter: blur(4px); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 12px; box-sizing: border-box;
`;
    modal.innerHTML = `
 <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 100%; max-width: 700px; max-height: calc(100vh - 24px); display: flex; flex-direction: column; border: 1px solid var(--x-border-color); box-sizing: border-box; " onclick="event.stopPropagation()">

 <div style="display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid var(--x-border-color); flex-shrink: 0; ">
 <h2 style="color:var(--x-text-primary); font-size: 20px; font-weight: 700; margin: 0; ">世界书管理<span style="font-size: 14px; color:var(--x-text-secondary); font-weight: 400; margin-left: 8px;">(全局共享)</span></h2>
 <div style="display: flex; gap: 12px; align-items: center;">
 <button onclick="openCreateWorldBookModal()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
 + 添加世界书
 </button>
 <div onclick="closeWorldBooksManageModal()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>
 </div>
 </div>

 <div id="world-books-manage-list" style="flex: 1; overflow-y: auto; padding: 16px 20px; ">

 </div>
 </div>
`; // 添加到 X 社交屏幕容器中以继承主题变量
    const xScreen = document.getElementById("x-social-screen");
    if (xScreen) {
      xScreen.appendChild(modal);
    } else {
      document.body.appendChild(modal);
    }
    // 渲染世界书列表
    renderWorldBooksManageList(); // 点击背景关闭
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        closeWorldBooksManageModal();
      }
    });
  }; // 关闭世界书管理弹窗
  window.closeWorldBooksManageModal = function () {
    const modal = document.getElementById("world-books-manage-modal");
    if (modal) {
      modal.remove();
    }
  }; // 渲染世界书管理列表
  function renderWorldBooksManageList() {
    const container = document.getElementById("world-books-manage-list");
    if (!container) return;
    if (!xSettingsData.worldBooks || xSettingsData.worldBooks.length === 0) {
      container.innerHTML = `
 <div style="color:var(--x-text-secondary); font-size: 15px; text-align: center; padding: 60px 20px; background-color:var(--x-bg-secondary); border-radius: 16px; border: 2px dashed var(--x-border-color); ">
 <svg viewBox="0 0 24 24" style="width: 48px; height: 48px; fill: var(--x-text-secondary); margin-bottom: 16px;">
 <g><path d="M3 5.5C3 4.119 4.119 3 5.5 3h13C19.881 3 21 4.119 21 5.5v13c0 1.381-1.119 2.5-2.5 2.5h-13C4.119 21 3 19.881 3 18.5v-13zM5.5 5c-.276 0-.5.224-.5.5v13c0 .276.224.5.5.5h13c.276 0 .5-.224.5-.5v-13c0-.276-.224-.5-.5-.5h-13z"></path></g>
 </svg>
 <div style="font-weight: 600; margin-bottom: 8px; font-size: 16px;">暂无世界书</div>
 <div style="font-size: 13px;">点击右上角"添加世界书"按钮创建第一个世界书</div>
 </div>
 `;
      return;
    }
    const sceneLabels = {
      global: "全局",
      messages: "私信",
      search: "搜索",
      trending: "热搜",
      profile: "主页",
      feed: "首页",
      tweetDetail: "详情",
    };
    container.innerHTML = `
 <div style="display: flex; flex-direction: column; gap: 12px;">
 ${xSettingsData.worldBooks
   .map((wb, index) => {
     const sceneTags =
       wb.scenes?.map((s) => sceneLabels[s] || s).join(", ") || "未绑定场景";
     let bindInfo = [];
     if (wb.bindToAll) bindInfo.push("全局对话");
     if (wb.bindToCharacterOnly) bindInfo.push("仅角色对话");
     if (wb.boundCharacters && wb.boundCharacters.length > 0) {
       bindInfo.push(`${wb.boundCharacters.length}个指定角色`);
     }
     const bindText = bindInfo.length > 0 ? bindInfo.join(" + ") : "未绑定目标"; // 判断是否为闲置状态
     const isIdle =
       wb.isIdle ||
       (wb.targetType === "none" && (!wb.scenes || wb.scenes.length === 0));
     return `
 <div style="background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 16px; padding: 16px; transition: all 0.2s; " onmouseover="this.style.borderColor='var(--x-accent)'"
 onmouseout="this.style.borderColor='var(--x-border-color)'">
 <div style="display: flex; align-items: start; justify-content: space-between; margin-bottom: 12px;">
 <div style="flex: 1; min-width: 0;">
 <div style="color:var(--x-text-primary); font-size: 17px; font-weight: 700; margin-bottom: 8px; ">${
   wb.name
 }</div>
 <div style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px; ">
 ${
   isIdle
     ? `
 <span style="display: inline-flex; align-items: center; background-color: rgba(113, 118, 123, 0.2); color:var(--x-text-secondary); padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: 600; ">
 <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: var(--x-text-secondary); margin-right: 4px;">
 <g><path d="M8 7c0 2.21-1.79 4-4 4S0 9.21 0 7s1.79-4 4-4 4 1.79 4 4zm5-4c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm9 0c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"></path></g>
 </svg>
 闲置状态（暂未启用）
 </span>
 `
     : `
 <span style="display: inline-flex; align-items: center; background-color: #1d9bf0; color: #ffffff; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: 600; ">
 <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: #ffffff; margin-right: 4px;">
 <g><path d="M12 7c-1.93 0-3.5 1.57-3.5 3.5S10.07 14 12 14s3.5-1.57 3.5-3.5S13.93 7 12 7zm0 5c-.827 0-1.5-.673-1.5-1.5S11.173 9 12 9s1.5.673 1.5 1.5S12.827 12 12 12zm0-10c-4.687 0-8.5 3.813-8.5 8.5 0 5.967 7.621 11.116 7.945 11.332l.555.37.555-.37c.324-.216 7.945-5.365 7.945-11.332C20.5 5.813 16.687 2 12 2zm0 17.77c-1.665-1.241-6.5-5.196-6.5-9.27C5.5 6.916 8.416 4 12 4s6.5 2.916 6.5 6.5c0 4.073-4.835 8.028-6.5 9.27z"></path></g>
 </svg>
 ${sceneTags}
 </span>
 <span style="display: inline-flex; align-items: center; background-color: rgba(29, 155, 240, 0.15); color: #1d9bf0; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: 600; ">
 <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: #1d9bf0; margin-right: 4px;">
 <g><path d="M17.863 13.44c1.477 1.58 2.366 3.8 2.632 6.46l.11 1.1H3.395l.11-1.1c.266-2.66 1.155-4.88 2.632-6.46C7.627 11.85 9.648 11 12 11s4.373.85 5.863 2.44zM12 2C9.791 2 8 3.79 8 6s1.791 4 4 4 4-1.79 4-4-1.791-4-4-4z"></path></g>
 </svg>
 ${bindText}
 </span>
 `
 }
 </div>
 </div>
 <div style="display: flex; gap: 8px; flex-shrink: 0; margin-left: 12px;">
 <button onclick="editWorldBookInManage(${index})" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 18px; padding: 8px 16px; font-size: 13px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">编辑</button>
 <button onclick="deleteWorldBookInManage(${index})" style="background-color: #f4212e; color: #fff; border: none; border-radius: 18px; padding: 8px 16px; font-size: 13px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">删除</button>
 </div>
 </div>
 <div style="color:var(--x-text-secondary); font-size: 14px; line-height: 1.6; max-height: 80px; overflow: hidden; text-overflow: ellipsis; background-color:var(--x-bg-primary); padding: 12px; border-radius: 8px; ">${wb.content.substring(
   0,
   150
 )}${wb.content.length > 150 ? "..." : ""}</div>
 </div>
 `;
   })
   .join("")}
 </div>
`;
  }
  // 在管理面板中编辑世界书
  window.editWorldBookInManage = function (index) {
    const worldBook = xSettingsData.worldBooks[index];
    openWorldBookModal(worldBook, index);
  }; // 在管理面板中删除世界书
  window.deleteWorldBookInManage = async function (index) {
    if (!confirm("确定要删除这个世界书吗？")) return;
    xSettingsData.worldBooks.splice(index, 1);
    await saveGlobalWorldBooks();
    renderWorldBooksManageList();
    showXToast("世界书已删除", "success");
  }; // 打开创建世界书弹窗
  window.openCreateWorldBookModal = function () {
    openWorldBookModal();
  }; // 打开世界书编辑弹窗
  function openWorldBookModal(worldBook = null, editIndex = null) {
    const isEdit = worldBook !== null; // 创建弹窗
    const modal = document.createElement("div");
    modal.id = "world-book-modal";
    modal.style.cssText = `
 position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); backdrop-filter: blur(4px); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 12px; box-sizing: border-box;
`;
    modal.innerHTML = `
 <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 100%; max-width: 600px; max-height: calc(100vh - 24px); overflow-y: auto; border: 1px solid var(--x-border-color); box-sizing: border-box; " onclick="event.stopPropagation()">

 <div style="display: flex; align-items: center; justify-content: space-between; padding: 14px 16px; border-bottom: 1px solid var(--x-border-color); position: sticky; top: 0; background-color:var(--x-bg-primary); z-index: 1; ">
 <h2 style="color:var(--x-text-primary); font-size: 18px; font-weight: 700; margin: 0; ">${
   isEdit ? "编辑世界书" : "创建世界书"
 }</h2>
 <div onclick="closeWorldBookModal()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>
 </div>

 <div style="padding: 16px;">
 <form id="world-book-form" onsubmit="saveWorldBook(event)">

 <div style="margin-bottom: 16px;">
 <label style="display: block; color:var(--x-text-primary); font-size: 14px; font-weight: 600; margin-bottom: 6px; ">世界书名称 *</label>
 <input type="text" id="wb-name" required
 value="${worldBook?.name || ""}"
 placeholder="例如：表情包库、角色关系设定..."
 style="width: 100%; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; color:var(--x-text-primary); padding: 10px 12px; font-size: 14px; outline: none; box-sizing: border-box; "
 onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='var(--x-border-color)'">
 </div>

 <div style="margin-bottom: 16px;">
 <label style="display: block; color:var(--x-text-primary); font-size: 14px; font-weight: 600; margin-bottom: 6px; ">世界书内容 *</label>
 <textarea id="wb-content" required rows="6"
 placeholder="输入世界书内容，例如：&#10;表情包链接：&#10;- 开心：https://example.com/happy.gif&#10;- 生气：https://example.com/angry.gif&#10;&#10;或其他设定内容..."
 style="width: 100%; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; color:var(--x-text-primary); padding: 10px 12px; font-size: 14px; resize: vertical; outline: none; font-family: inherit; line-height: 1.5; box-sizing: border-box; "
 onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='var(--x-border-color)'">${
   worldBook?.content || ""
 }</textarea>
 </div>

 <div style="margin-bottom: 16px;">
 <label style="display: block; color:var(--x-text-primary); font-size: 14px; font-weight: 600; margin-bottom: 4px; ">绑定场景（可多选）</label>
 <div style="color:var(--x-text-secondary); font-size: 12px; margin-bottom: 8px; line-height: 1.4; ">💡 提示：如果不绑定任何场景和目标，世界书将处于闲置状态，不会被应用到任何场景</div>
 <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; ">
 ${[
   "global",
   "messages",
   "search",
   "trending",
   "profile",
   "feed",
   "tweetDetail",
 ]
   .map((scene) => {
     const labels = {
       global: "全局",
       messages: "私信界面",
       search: "搜索界面",
       trending: "热搜界面",
       profile: "角色主页",
       feed: "首页推文",
       tweetDetail: "推文详情",
     };
     const checked = worldBook?.scenes?.includes(scene) || false;
     return `
 <label style="display: flex; align-items: center; padding: 8px 10px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
 <input type="checkbox" name="wb-scenes" value="${scene}" ${
       checked ? "checked" : ""
     }
 style="margin-right: 6px; cursor: pointer;">
 <span style="color:var(--x-text-primary); font-size: 13px;">${
   labels[scene]
 }</span>
 </label>
 `;
   })
   .join("")}
 </div>
 </div>

 <div style="margin-bottom: 16px;">
 <label style="display: block; color:var(--x-text-primary); font-size: 14px; font-weight: 600; margin-bottom: 8px; ">绑定目标（可选）</label>

 <label style="display: flex; align-items: center; padding: 8px 10px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; cursor: pointer; margin-bottom: 6px; ">
 <input type="checkbox" id="wb-bind-all" ${
   worldBook?.bindToAll ? "checked" : ""
 }
 style="margin-right: 6px; cursor: pointer;">
 <span style="color:var(--x-text-primary); font-size: 13px;">绑定到全局对话</span>
 </label>

 <label style="display: flex; align-items: center; padding: 8px 10px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; cursor: pointer; margin-bottom: 6px; ">
 <input type="checkbox" id="wb-bind-character-only" ${
   worldBook?.bindToCharacterOnly ? "checked" : ""
 }
 style="margin-right: 6px; cursor: pointer;">
 <span style="color:var(--x-text-primary); font-size: 13px;">绑定到仅角色对话</span>
 </label>

 <div style="margin-top: 6px;">
 <label style="display: block; color:var(--x-text-secondary); font-size: 12px; margin-bottom: 6px; ">绑定到指定角色（任何相关情景都会使用）：</label>
 <div id="wb-character-list" style="max-height: 160px; overflow-y: auto; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 6px; ">

 </div>
 </div>
 </div>

 <div style="display: flex; gap: 10px; margin-top: 20px;">
 <button type="button" onclick="closeWorldBookModal()" style="flex: 1; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 20px; padding: 11px; color:var(--x-text-primary); font-size: 14px; font-weight: 600; cursor: pointer; box-sizing: border-box; ">取消</button>
 <button type="submit" style="flex: 1; background-color: var(--x-accent); border: none; border-radius: 20px; padding: 11px; color: #fff; font-size: 14px; font-weight: 600; cursor: pointer; box-sizing: border-box; ">${
   isEdit ? "保存修改" : "创建世界书"
 }</button>
 </div>
 </form>
 </div>
 </div>
`; // 添加到 X 社交屏幕容器中以继承主题变量
    const xScreen = document.getElementById("x-social-screen");
    if (xScreen) {
      xScreen.appendChild(modal);
    } else {
      document.body.appendChild(modal);
    }
    // 设置编辑索引
    if (isEdit) {
      modal.setAttribute("data-edit-index", editIndex);
    }
    // 加载角色列表
    loadWorldBookCharactersList(worldBook?.boundCharacters || []); // 点击背景关闭
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        closeWorldBookModal();
      }
    });
  }
  // 加载世界书角色选择列表
  async function loadWorldBookCharactersList(selectedCharacters = []) {
    try {
      const db = getDB();
      const allChats = await db.chats.toArray();
      const characters = allChats.filter((chat) => !chat.isGroup);
      const container = document.getElementById("wb-character-list");
      if (!container) return;
      if (characters.length === 0) {
        container.innerHTML = `
 <div style="color:var(--x-text-secondary); font-size: 12px; text-align: center; padding: 16px; ">暂无可绑定的角色</div>
 `;
        return;
      }
      container.innerHTML = characters
        .map(
          (char) => `
 <label style="display: flex; align-items: center; padding: 6px 8px; border-radius: 6px; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <input type="checkbox" name="wb-characters" value="${char.id}"
 ${selectedCharacters.includes(char.id) ? "checked" : ""}
 style="margin-right: 6px; cursor: pointer;">
 <span style="color:var(--x-text-primary); font-size: 13px;">${char.name}</span>
 </label>
 `
        )
        .join("");
    } catch (error) {
      console.error("加载角色列表失败:", error);
    }
  }
  // 关闭世界书弹窗
  window.closeWorldBookModal = function () {
    const modal = document.getElementById("world-book-modal");
    if (modal) {
      modal.remove();
    }
  }; // 保存世界书
  window.saveWorldBook = async function (event) {
    event.preventDefault();
    const name = document.getElementById("wb-name").value.trim();
    const content = document.getElementById("wb-content").value.trim();
    if (!name || !content) {
      showXToast("请填写完整信息", "error");
      return;
    }
    // 获取选中的场景
    const sceneCheckboxes = document.querySelectorAll(
      'input[name="wb-scenes"]:checked'
    );
    const scenes = Array.from(sceneCheckboxes).map((cb) => cb.value); // 获取绑定目标
    const bindToAll = document.getElementById("wb-bind-all").checked;
    const bindToCharacterOnly = document.getElementById(
      "wb-bind-character-only"
    ).checked; // 获取选中的角色
    const characterCheckboxes = document.querySelectorAll(
      'input[name="wb-characters"]:checked'
    );
    const boundCharacters = Array.from(characterCheckboxes).map(
      (cb) => cb.value
    ); // 确定目标类型和选择的角色列表
    let targetType = "none"; // 'none' = 未绑定（闲置）, 'all' = 全局对话, 'characterOnly' = 仅角色对话, 'specific' = 指定角色
    let selectedCharacters = [];
    if (bindToAll) {
      targetType = "all";
    } else if (bindToCharacterOnly) {
      targetType = "characterOnly";
    } else if (boundCharacters.length > 0) {
      targetType = "specific";
      selectedCharacters = [...boundCharacters];
    }
    // 如果都没有选择，targetType 保持为 'none'
    // 判断是否是闲置状态（没有任何绑定）
    const isIdle = targetType === "none" && (!scenes || scenes.length === 0);
    const worldBook = {
      name,
      content,
      scenes,
      targetType, // 'none' | 'all' | 'characterOnly' | 'specific'
      selectedCharacters, // 角色ID数组
      bindToAll,
      bindToCharacterOnly,
      boundCharacters,
      isIdle, // 标记是否为闲置状态
      createdAt: new Date().toISOString(),
    }; // 检查是否是编辑模式
    const modal = document.getElementById("world-book-modal");
    const editIndex = modal?.getAttribute("data-edit-index");
    if (!xSettingsData.worldBooks) {
      xSettingsData.worldBooks = [];
    }
    if (editIndex !== null && editIndex !== undefined) {
      // 编辑模式
      xSettingsData.worldBooks[parseInt(editIndex)] = worldBook;
      showXToast("世界书已更新", "success");
    } else {
      // 创建模式
      xSettingsData.worldBooks.push(worldBook);
      showXToast("世界书已创建", "success");
    }
    // 保存全局世界书（不再保存到账户设置中）
    await saveGlobalWorldBooks(); // 如果管理面板打开，刷新管理面板的列表
    const manageModal = document.getElementById("world-books-manage-modal");
    if (manageModal) {
      renderWorldBooksManageList();
    }
    closeWorldBookModal();
  }; // 保存为预设
  async function saveXPreset() {
    const presetName = prompt("请输入预设名称:");
    if (!presetName || presetName.trim() === "") {
      showXToast("预设名称不能为空", "error");
      return;
    }
    try {
      // 只保存提示词和世界观设定
      const presetData = {
        systemPrompt: document.getElementById("x-system-prompt").value,
        worldSetting: document.getElementById("x-world-setting").value,
        characterBinding: xSettingsData.characterBinding || false,
        boundCharacters: xSettingsData.boundCharacters || [],
      };
      const db = getXDB();
      await db.xPresets.add({
        name: presetName.trim(),
        ...presetData,
        createdAt: new Date().toISOString(),
      });
      showXToast(`预设"${presetName}"已保存`, "success");
      loadXPresetsList(); // 刷新预设列表
    } catch (error) {
      console.error("保存预设失败:", error);
      showXToast("保存预设失败: " + error.message, "error");
    }
  }
  // 加载预设列表
  async function loadXPresetsList() {
    try {
      const db = getXDB();
      const presets = await db.xPresets
        .orderBy("createdAt")
        .reverse()
        .toArray();
      const presetsList = document.getElementById("x-presets-list");
      if (presets.length === 0) {
        presetsList.innerHTML =
          '<p style="color: #71767b; font-size: 14px; text-align: center; margin: 20px 0;">暂无保存的预设</p>';
        return;
      }
      presetsList.innerHTML = presets
        .map(
          (preset) => `
 <div class="preset-item" style="display: flex; align-items: center; justify-content: space-between; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 12px; margin-bottom: 8px;">
 <div style="flex: 1; min-width: 0;">
 <div style="color: #fff; font-weight: 600; font-size: 15px; margin-bottom: 4px; word-wrap: break-word;">${
   preset.name
 }</div>
 <div style="color: #71767b; font-size: 13px;">${new Date(
   preset.createdAt
 ).toLocaleString()}</div>
 </div>
 <div style="display: flex; gap: 8px; flex-shrink: 0;">
 <button onclick="loadXPreset(${preset.id})"
 style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 15px; padding: 6px 12px; font-size: 12px; cursor: pointer; white-space: nowrap;">
 加载
 </button>
 <button onclick="deleteXPreset(${preset.id})"
 style="background-color: #f4212e; color: #fff; border: none; border-radius: 15px; padding: 6px 12px; font-size: 12px; cursor: pointer; white-space: nowrap;">
 删除
 </button>
 </div>
 </div>
 `
        )
        .join("");
    } catch (error) {
      console.error("加载预设列表失败:", error);
    }
  }
  // 加载预设
  async function loadXPreset(presetId) {
    try {
      const db = getXDB();
      const preset = await db.xPresets.get(presetId);
      if (preset) {
        // 先更新xSettingsData对象
        xSettingsData.systemPrompt = preset.systemPrompt || "";
        xSettingsData.worldSetting = preset.worldSetting || "";
        xSettingsData.characterBinding = preset.characterBinding || false;
        xSettingsData.boundCharacters = preset.boundCharacters || []; // 然后更新UI（会从xSettingsData读取数据）
        await loadXSettingsToUI();
        showXToast(`已加载预设"${preset.name}"`, "success");
      }
    } catch (error) {
      console.error("加载预设失败:", error);
      showXToast("加载预设失败: " + error.message, "error");
    }
  }
  // 删除预设
  async function deleteXPreset(presetId) {
    if (!confirm("确定要删除这个预设吗？")) return;
    try {
      const db = getXDB();
      await db.xPresets.delete(presetId);
      showXToast("预设已删除", "success");
      loadXPresetsList(); // 刷新预设列表
    } catch (error) {
      console.error("删除预设失败:", error);
      showXToast("删除预设失败: " + error.message, "error");
    }
  }
  // 导出所有X数据
  async function exportXData() {
    try {
      const xDb = getXDB(); // 导出所有X数据库内容
      const exportData = {
        // X设置（包含全局世界书）
        xSettings: await xDb.xSettings.toArray(),
        // 用户资料（所有账户）
        xUserProfile: await xDb.xUserProfile.toArray(),
        // 推文数据
        xTweetsData: await xDb.xTweetsData.toArray(),
        // 用户发布的推文（所有账户）
        xUserTweets: await xDb.xUserTweets.toArray(),
        // 角色X资料
        xCharacterProfiles: await xDb.xCharacterProfiles.toArray(),
        // 预设
        xPresets: await xDb.xPresets.toArray(),
        // 用户提问箱数据（所有账户）
        xAskbox: await xDb.xAskbox.toArray(),
        // 当前活跃账户
        xActiveAccount: await xDb.xActiveAccount.toArray(),
        // 账户列表
        xAccountList: await xDb.xAccountList.toArray(),
        // NPC设置（所有账户）
        xNPCs: await xDb.xNPCs.toArray(),
        // 账户主页数据（包含私信对话、陌生人消息、mentions通知等）
        xAccountProfiles: await xDb.xAccountProfiles.toArray(),
        // 账户提问箱数据
        xAccountAskbox: await xDb.xAccountAskbox.toArray(),
        // 书签数据（所有账户）
        xBookmarks: await xDb.xBookmarks.toArray(),
        // 角色关系册数据（所有账户）
        xCharacterRelationships: await xDb.xCharacterRelationships.toArray(),
        // 地图约会数据（所有账户）
        xMapDatingData: await xDb.xMapDatingData.toArray(),
        // 地图用户个人资料
        xMapUserProfile: await xDb.xMapUserProfile.toArray(),
        // 地图聊天数据
        xMapChats: await xDb.xMapChats.toArray(),
        // localStorage中的聊天列表
        xMapSavedChats: localStorage.getItem("xMapSavedChats") || "[]",
        // 咩三三城市报纸数据
        newspaperCachedData: localStorage.getItem("newspaperCachedData") || null,
        newspaperStats: localStorage.getItem("newspaperStats") || null,
        newspaperGenerateHistory: localStorage.getItem("newspaperGenerateHistory") || null,
        // 元数据
        exportTime: new Date().toISOString(),
        version: "2.2",
        dataType: "x-social-full-backup",
      };
      const dataStr = JSON.stringify(exportData, null, 2);
      const dataBlob = new Blob([dataStr], { type: "application/json" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(dataBlob);
      link.download = `x-data-backup-${
        new Date().toISOString().split("T")[0]
      }.json`;
      link.click();
      showXToast("所有数据已导出", "success");
      console.log("✅ X数据导出成功，包含:", {
        设置数: exportData.xSettings.length,
        用户资料数: exportData.xUserProfile.length,
        推文数据数: exportData.xTweetsData.length,
        用户推文数: exportData.xUserTweets.length,
        角色X资料数: exportData.xCharacterProfiles.length,
        预设数: exportData.xPresets.length,
        用户提问箱数: exportData.xAskbox.length,
        活跃账户数: exportData.xActiveAccount.length,
        账户列表数: exportData.xAccountList.length,
        NPC设置数: exportData.xNPCs.length,
        账户主页数据数: exportData.xAccountProfiles.length,
        账户提问箱数: exportData.xAccountAskbox.length,
        书签数: exportData.xBookmarks.length,
        关系册数: exportData.xCharacterRelationships.length,
        地图约会数据数: exportData.xMapDatingData.length,
        地图用户资料数: exportData.xMapUserProfile.length,
        地图聊天数据数: exportData.xMapChats.length,
        保存的聊天列表数: JSON.parse(exportData.xMapSavedChats).length,
      });
    } catch (error) {
      console.error("❌ 导出数据失败:", error);
      showXToast("导出失败: " + error.message, "error");
    }
  }
  // 导入所有X数据
  function importXData() {
    if (
      !confirm(
        "⚠️ 警告：导入数据将完全替换当前所有X数据（包括用户资料、推文、帖子、设置等），此操作不可撤销！\n\n确定要继续吗？"
      )
    ) {
      return;
    }
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".json";
    input.onchange = async function (event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = async function (e) {
        try {
          const importData = JSON.parse(e.target.result); // 验证数据格式
          if (!importData || importData.dataType !== "x-social-full-backup") {
            showXToast("导入失败: 不是有效的X数据备份文件", "error");
            return;
          }
          showXToast("正在导入数据，请稍候...", "info");
          const xDb = getXDB(); // 清空现有数据
          await xDb.xSettings.clear();
          await xDb.xUserProfile.clear();
          await xDb.xTweetsData.clear();
          await xDb.xUserTweets.clear();
          await xDb.xCharacterProfiles.clear();
          await xDb.xPresets.clear();
          await xDb.xAskbox.clear();
          await xDb.xActiveAccount.clear();
          await xDb.xAccountList.clear();
          await xDb.xNPCs.clear();
          await xDb.xAccountProfiles.clear();
          await xDb.xAccountAskbox.clear();
          await xDb.xBookmarks.clear();
          await xDb.xCharacterRelationships.clear();
          await xDb.xMapDatingData.clear();
          await xDb.xMapUserProfile.clear();
          await xDb.xMapChats.clear();
          localStorage.removeItem("xMapSavedChats");
          // 清空报纸数据
          localStorage.removeItem("newspaperCachedData");
          localStorage.removeItem("newspaperStats");
          localStorage.removeItem("newspaperGenerateHistory");
          console.log("✅ 已清空旧数据"); // 导入新数据
          if (importData.xSettings && importData.xSettings.length > 0) {
            await xDb.xSettings.bulkAdd(importData.xSettings);
          }
          if (importData.xUserProfile && importData.xUserProfile.length > 0) {
            await xDb.xUserProfile.bulkAdd(importData.xUserProfile);
          }
          if (importData.xTweetsData && importData.xTweetsData.length > 0) {
            await xDb.xTweetsData.bulkAdd(importData.xTweetsData);
          }
          if (importData.xUserTweets && importData.xUserTweets.length > 0) {
            await xDb.xUserTweets.bulkAdd(importData.xUserTweets);
          }
          if (
            importData.xCharacterProfiles &&
            importData.xCharacterProfiles.length > 0
          ) {
            await xDb.xCharacterProfiles.bulkAdd(importData.xCharacterProfiles);
          }
          if (importData.xPresets && importData.xPresets.length > 0) {
            await xDb.xPresets.bulkAdd(importData.xPresets);
          }
          if (importData.xAskbox && importData.xAskbox.length > 0) {
            await xDb.xAskbox.bulkAdd(importData.xAskbox);
          }
          if (
            importData.xActiveAccount &&
            importData.xActiveAccount.length > 0
          ) {
            await xDb.xActiveAccount.bulkAdd(importData.xActiveAccount);
          }
          if (importData.xAccountList && importData.xAccountList.length > 0) {
            await xDb.xAccountList.bulkAdd(importData.xAccountList);
          }
          if (importData.xNPCs && importData.xNPCs.length > 0) {
            await xDb.xNPCs.bulkAdd(importData.xNPCs);
          }
          if (
            importData.xAccountProfiles &&
            importData.xAccountProfiles.length > 0
          ) {
            await xDb.xAccountProfiles.bulkAdd(importData.xAccountProfiles);
          }
          if (
            importData.xAccountAskbox &&
            importData.xAccountAskbox.length > 0
          ) {
            await xDb.xAccountAskbox.bulkAdd(importData.xAccountAskbox);
          }
          if (importData.xBookmarks && importData.xBookmarks.length > 0) {
            await xDb.xBookmarks.bulkAdd(importData.xBookmarks);
          }
          if (
            importData.xCharacterRelationships &&
            importData.xCharacterRelationships.length > 0
          ) {
            await xDb.xCharacterRelationships.bulkAdd(
              importData.xCharacterRelationships
            );
          }
          if (importData.xMapDatingData && importData.xMapDatingData.length > 0) {
            await xDb.xMapDatingData.bulkAdd(importData.xMapDatingData);
          }
          if (importData.xMapUserProfile && importData.xMapUserProfile.length > 0) {
            await xDb.xMapUserProfile.bulkAdd(importData.xMapUserProfile);
          }
          if (importData.xMapChats && importData.xMapChats.length > 0) {
            await xDb.xMapChats.bulkAdd(importData.xMapChats);
          }
          if (importData.xMapSavedChats) {
            localStorage.setItem("xMapSavedChats", importData.xMapSavedChats);
          }
          // 恢复报纸数据
          if (importData.newspaperCachedData) {
            localStorage.setItem("newspaperCachedData", importData.newspaperCachedData);
          }
          if (importData.newspaperStats) {
            localStorage.setItem("newspaperStats", importData.newspaperStats);
          }
          if (importData.newspaperGenerateHistory) {
            localStorage.setItem("newspaperGenerateHistory", importData.newspaperGenerateHistory);
          }
          console.log("✅ X数据导入成功，包含:", {
            设置数: importData.xSettings?.length || 0,
            用户资料数: importData.xUserProfile?.length || 0,
            推文数据数: importData.xTweetsData?.length || 0,
            用户推文数: importData.xUserTweets?.length || 0,
            角色X资料数: importData.xCharacterProfiles?.length || 0,
            预设数: importData.xPresets?.length || 0,
            用户提问箱数: importData.xAskbox?.length || 0,
            活跃账户数: importData.xActiveAccount?.length || 0,
            账户列表数: importData.xAccountList?.length || 0,
            NPC设置数: importData.xNPCs?.length || 0,
            账户主页数据数: importData.xAccountProfiles?.length || 0,
            账户提问箱数: importData.xAccountAskbox?.length || 0,
            书签数: importData.xBookmarks?.length || 0,
            关系册数: importData.xCharacterRelationships?.length || 0,
            地图约会数据数: importData.xMapDatingData?.length || 0,
            地图用户资料数: importData.xMapUserProfile?.length || 0,
            地图聊天数据数: importData.xMapChats?.length || 0,
            保存的聊天列表数: importData.xMapSavedChats ? JSON.parse(importData.xMapSavedChats).length : 0,
          });
          showXToast("数据导入成功！页面即将刷新...", "success"); // 延迟刷新，让用户看到成功提示
          setTimeout(() => {
            window.location.reload();
          }, 1500);
        } catch (error) {
          console.error("❌ 导入数据失败:", error);
          showXToast("导入失败: " + error.message, "error");
        }
      };
      reader.readAsText(file);
    };
    input.click();
  }
  // 切换角色绑定
  function toggleCharacterBinding() {
    xSettingsData.characterBinding = !xSettingsData.characterBinding;
    updateCharacterToggleUI();
    const bindingArea = document.getElementById("character-binding-area");
    if (xSettingsData.characterBinding) {
      bindingArea.style.display = "block";
      loadCharactersList();
    } else {
      bindingArea.style.display = "none"; // 清空绑定的角色
      if (!xSettingsData.boundCharacters) xSettingsData.boundCharacters = [];
    }
  }
  // 更新角色绑定切换按钮UI
  function updateCharacterToggleUI() {
    const toggle = document.getElementById("x-character-toggle");
    const circle = toggle.querySelector(".toggle-circle");
    if (xSettingsData.characterBinding) {
      toggle.style.backgroundColor = "var(--x-accent)";
      circle.style.left = "22px";
    } else {
      toggle.style.backgroundColor = "#333";
      circle.style.left = "2px";
    }
  }
  // 加载角色列表
  async function loadCharactersList() {
    try {
      // 获取所有聊天中的非群组角色
      const db = getDB(); // 修正：chats表在全局数据库中
      const allChats = await db.chats.toArray();
      const characters = allChats.filter((chat) => !chat.isGroup);
      const charactersList = document.getElementById("characters-list");
      if (characters.length === 0) {
        charactersList.innerHTML =
          TemplateBuilders.buildEmptyState(
            "暂无可绑定的角色，请先创建角色聊天"
          );
        return;
      }
      if (!xSettingsData.boundCharacters) xSettingsData.boundCharacters = [];
      charactersList.innerHTML = characters
        .map((character) => {
          const isChecked = xSettingsData.boundCharacters.includes(
            character.id
          );
          return TemplateBuilders.buildCharacterItem(character, isChecked);
        })
        .join("");
    } catch (error) {
      ValidationUtils.handleError(error, "加载角色列表");
      document.getElementById("characters-list").innerHTML =
        TemplateBuilders.buildErrorState("加载角色列表失败");
    }
  }
  // 切换角色选择状态
  function toggleCharacterSelection(characterId) {
    if (!xSettingsData.boundCharacters) {
      xSettingsData.boundCharacters = [];
    }
    const index = xSettingsData.boundCharacters.indexOf(characterId);
    if (index > -1) {
      xSettingsData.boundCharacters.splice(index, 1);
    } else {
      xSettingsData.boundCharacters.push(characterId);
    }
    // 更新UI
    const checkbox = document.querySelector(
      `[data-character-id="${characterId}"]`
    );
    if (checkbox) {
      const isChecked = xSettingsData.boundCharacters.includes(characterId);
      checkbox.outerHTML = TemplateBuilders.buildCheckbox(
        characterId,
        isChecked
      );
    }
  }
  // 长按相关变量
  let longPressTimer = null;
  let longPressTarget = null; // 开始长按
  function startLongPress(characterId) {
    longPressTarget = characterId;
    longPressTimer = setTimeout(() => {
      if (longPressTarget === characterId) {
        openCharacterXProfile(characterId);
      }
    }, 500); // 500ms长按触发
  }
  // 结束长按
  function endLongPress() {
    if (longPressTimer) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }
    longPressTarget = null;
  }
  // 打开角色X资料设置
  async function openCharacterXProfile(characterId) {
    try {
      // 首先检查弹窗元素是否存在
      const modalElement = document.getElementById("character-x-profile-modal");
      if (!modalElement) {
        console.error("❌ 角色X资料弹窗元素不存在于DOM中");
        showXToast("无法打开X资料设置，请先绑定角色", "error");
        return;
      }
      const db = getDB(); // 修正：chats表在全局数据库中
      const xDb = getXDB(); // X专用数据库用于xCharacterProfiles
      const character = await db.chats.get(characterId);
      if (!character) {
        showXToast("未找到角色信息", "error");
        return;
      }
      // 加载现有的X资料
      let xProfile = await xDb.xCharacterProfiles.get(characterId);
      if (!xProfile) {
        // 创建默认X资料
        xProfile = {
          characterId: characterId,
          xName: character.name,
          xHandle: character.name.toLowerCase().replace(/\s+/g, "_"),
          xAvatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
          xVerified: false,
          xBio: "",
          relationships: [],
        };
      }
      // 确保有relationships字段
      if (!xProfile.relationships) {
        xProfile.relationships = [];
      }
      // 检查表单元素是否存在
      const formElement = document.getElementById("character-x-profile-form");
      if (!formElement) {
        console.error("❌ 角色X资料表单不存在，弹窗可能未正确加载");
        showXToast(
          "弹窗加载失败，请先勾选绑定该角色，然后刷新页面重试",
          "error"
        ); // 关闭弹窗
        const modal = document.getElementById("character-x-profile-modal");
        if (modal) modal.style.display = "none";
        return;
      }
      // 填充弹窗内容
      const infoDisplay = document.getElementById("character-info-display");
      if (infoDisplay) {
        infoDisplay.innerHTML =
          TemplateBuilders.buildCharacterInfoDisplay(character);
      }
      // 获取所有表单元素（使用安全的方式）
      const avatarElement = document.getElementById("character-x-avatar");
      const avatarUrlElement = document.getElementById(
        "character-x-avatar-url"
      );
      const coverPreviewElement = document.getElementById(
        "character-x-cover-preview"
      );
      const coverUrlElement = document.getElementById("character-x-cover-url");
      const nameElement = document.getElementById("character-x-name");
      const handleElement = document.getElementById("character-x-handle");
      const verifiedElement = document.getElementById("character-x-verified");
      const tag1IconElement = document.getElementById("character-tag1-icon");
      const tag1TextElement = document.getElementById("character-custom-tag1");
      const tag1ColorElement = document.getElementById("character-tag1-color");
      const tag2IconElement = document.getElementById("character-tag2-icon");
      const tag2TextElement = document.getElementById("character-custom-tag2");
      const tag2ColorElement = document.getElementById("character-tag2-color");
      const followingCountElement = document.getElementById(
        "character-following-count"
      );
      const followersCountElement = document.getElementById(
        "character-followers-count"
      );
      const bioElement = document.getElementById("character-x-bio");
      const publicIdentityElement = document.getElementById(
        "character-public-identity"
      );
      const showRealNameElement = document.getElementById(
        "character-show-real-name"
      );
      const realNameElement = document.getElementById("character-real-name"); // 安全地设置元素值 - 统一使用默认头像
      const defaultAvatar =
        "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg";
      const defaultCover = "https://i.postimg.cc/qRzMB6nQ/default-cover.jpg"; // 头像设置
      if (avatarElement) avatarElement.src = xProfile.xAvatar || defaultAvatar;
      if (avatarUrlElement)
        avatarUrlElement.value = xProfile.xAvatar || defaultAvatar; // 背景图设置
      if (coverPreviewElement)
        coverPreviewElement.src = xProfile.xCover || defaultCover;
      if (coverUrlElement) coverUrlElement.value = xProfile.xCover || ""; // 基本信息设置（必填字段提供默认值）
      if (nameElement)
        nameElement.value = xProfile.xName || character.name || "";
      if (handleElement) handleElement.value = xProfile.xHandle || "";
      if (verifiedElement)
        verifiedElement.checked = xProfile.xVerified || false; // 自定义标签设置
      if (tag1IconElement)
        tag1IconElement.value = xProfile.customTag1?.icon || "";
      if (tag1TextElement)
        tag1TextElement.value = xProfile.customTag1?.text || "";
      if (tag1ColorElement)
        tag1ColorElement.value = xProfile.customTag1?.color || "#71767b";
      if (tag2IconElement)
        tag2IconElement.value = xProfile.customTag2?.icon || "";
      if (tag2TextElement)
        tag2TextElement.value = xProfile.customTag2?.text || "";
      if (tag2ColorElement)
        tag2ColorElement.value = xProfile.customTag2?.color || "#71767b"; // 关注数量设置
      if (followingCountElement)
        followingCountElement.value = xProfile.followingCount || "";
      if (followersCountElement)
        followersCountElement.value = xProfile.followersCount || ""; // 简介和公众身份设置
      if (bioElement) bioElement.value = xProfile.xBio || "";
      if (publicIdentityElement)
        publicIdentityElement.value = xProfile.publicIdentity || ""; // 真名设置
      if (showRealNameElement)
        showRealNameElement.checked = xProfile.showRealName || false;
      if (realNameElement) realNameElement.value = xProfile.realName || ""; // 根据复选框状态显示/隐藏真名输入框
      toggleCharacterRealNameInput(); // 自动发消息设置
      const autoMessageEnabledElement = document.getElementById(
        "character-auto-message-enabled"
      );
      const autoMessageIntervalElement = document.getElementById(
        "character-auto-message-interval"
      );
      if (autoMessageEnabledElement) {
        autoMessageEnabledElement.checked =
          xProfile.autoMessageEnabled || false;
      }
      if (autoMessageIntervalElement) {
        autoMessageIntervalElement.value = xProfile.autoMessageInterval || 60;
      }
      // 根据复选框状态显示/隐藏时间设置
      window.toggleAutoMessageSettings(); // 更新字符计数
      updateCharacterXProfileCounts(); // 设置当前编辑的角色ID（formElement已在前面声明）
      formElement.setAttribute("data-character-id", characterId); // 渲染关系列表
      console.log(
        "📖 [打开X资料] 加载关系数据，关系数:",
        (xProfile.relationships || []).length
      );
      renderRelationshipsList(xProfile.relationships || []); // 显示弹窗
      const modal = document.getElementById("character-x-profile-modal");
      if (modal) {
        modal.style.display = "block";
      }
    } catch (error) {
      ValidationUtils.handleError(error, "打开角色X资料");
    }
  }
  // 关闭角色X资料设置弹窗
  function closeCharacterXProfileModal() {
    const modal = document.getElementById("character-x-profile-modal");
    if (modal) {
      modal.style.display = "none";
    }
  }
  // 更新角色X头像
  function updateCharacterXAvatar(url) {
    const avatarImg = document.getElementById("character-x-avatar");
    if (!url || url.trim() === "") {
      // 如果URL为空，使用默认头像
      avatarImg.src = "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg";
      return;
    }
    // 验证URL格式
    try {
      new URL(url);
    } catch (e) {
      avatarImg.src = "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg";
      return;
    }
    // 验证是否为图片URL
    const imageExtensions = [".jpg", ".jpeg", ".png", ".gif", ".webp", ".bmp"];
    const isImageUrl = imageExtensions.some((ext) =>
      url.toLowerCase().includes(ext)
    );
    if (!isImageUrl) {
      // 不是明显的图片URL，但仍然尝试加载
      avatarImg.onerror = function () {
        this.src = "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg";
        showXToast("头像链接无效，已使用默认头像", "warning");
      };
    }
    avatarImg.src = url;
  }
  // 更新角色X背景图
  function updateCharacterXCover(url) {
    const coverImg = document.getElementById("character-x-cover-preview");
    if (!url || url.trim() === "") {
      coverImg.src = "https://i.postimg.cc/qRzMB6nQ/default-cover.jpg";
      return;
    }
    try {
      new URL(url);
    } catch (e) {
      coverImg.src = "https://i.postimg.cc/qRzMB6nQ/default-cover.jpg";
      return;
    }
    const imageExtensions = [".jpg", ".jpeg", ".png", ".gif", ".webp", ".bmp"];
    const isImageUrl = imageExtensions.some((ext) =>
      url.toLowerCase().includes(ext)
    );
    if (!isImageUrl) {
      coverImg.onerror = function () {
        this.src = "https://i.postimg.cc/qRzMB6nQ/default-cover.jpg";
        showXToast("背景图链接无效，已使用默认背景", "warning");
      };
    }
    coverImg.src = url;
  }
  // 更新简介字符计数（保持兼容性）
  function updateCharacterBioCount() {
    updateCharacterXProfileCounts();
  }
  // 更新角色X资料所有字符计数
  function updateCharacterXProfileCounts() {
    // 更新简介计数
    const bioTextarea = document.getElementById("character-x-bio");
    const bioCountSpan = document.getElementById("character-bio-count");
    if (bioTextarea && bioCountSpan) {
      bioCountSpan.textContent = bioTextarea.value.length;
    }
    // 角色公众身份已移除字符限制，无需计数
    // 更新真实姓名计数
    const realNameInput = document.getElementById("character-real-name");
    const realNameCountSpan = document.getElementById(
      "character-real-name-count"
    );
    if (realNameInput && realNameCountSpan) {
      realNameCountSpan.textContent = realNameInput.value.length;
    }
  }
  // 保存角色X资料
  async function saveCharacterXProfile(event) {
    event.preventDefault();
    const formElement = document.getElementById("character-x-profile-form");
    if (!formElement) {
      showXToast("表单元素未找到", "error");
      return;
    }
    const characterId = formElement.getAttribute("data-character-id");
    if (!characterId) {
      showXToast("角色ID未找到", "error");
      return;
    }
    // 获取表单值，使用安全的访问方式
    const getElementValue = (id, defaultValue = "") => {
      const element = document.getElementById(id);
      return element ? element.value.trim() : defaultValue;
    };
    const getElementChecked = (id, defaultValue = false) => {
      const element = document.getElementById(id);
      return element ? element.checked : defaultValue;
    };
    const xName = getElementValue("character-x-name");
    const xHandle = getElementValue("character-x-handle");
    const xAvatarUrl = getElementValue("character-x-avatar-url");
    const xAvatar =
      xAvatarUrl || "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg";
    const xVerified = getElementChecked("character-x-verified");
    const xCoverUrl = getElementValue("character-x-cover-url");
    const xCover =
      xCoverUrl || "https://i.postimg.cc/qRzMB6nQ/default-cover.jpg";
    const tag1Icon = getElementValue("character-tag1-icon");
    const tag1Text = getElementValue("character-custom-tag1");
    const tag1ColorElement = document.getElementById("character-tag1-color");
    const tag1Color = tag1ColorElement ? tag1ColorElement.value : "#71767b";
    const tag2Icon = getElementValue("character-tag2-icon");
    const tag2Text = getElementValue("character-custom-tag2");
    const tag2ColorElement = document.getElementById("character-tag2-color");
    const tag2Color = tag2ColorElement ? tag2ColorElement.value : "#71767b";
    const followingCount = getElementValue("character-following-count");
    const followersCount = getElementValue("character-followers-count");
    const xBio = getElementValue("character-x-bio");
    const publicIdentity = getElementValue("character-public-identity");
    const showRealName = getElementChecked("character-show-real-name");
    const realName = getElementValue("character-real-name");
    const autoMessageEnabled = getElementChecked(
      "character-auto-message-enabled"
    );
    const autoMessageInterval =
      parseInt(getElementValue("character-auto-message-interval")) || 60; // 仅验证必填字段（用户名和句柄）
    if (!xName) {
      showXToast("X用户名不能为空", "error");
      return;
    }
    if (!xHandle) {
      showXToast("X句柄不能为空", "error");
      return;
    }
    // 验证长度限制（仅对已填写的字段）
    if (xName.length > 50) {
      showXToast("X用户名不能超过50个字符", "error");
      return;
    }
    if (xHandle.length > 15) {
      showXToast("X句柄不能超过15个字符", "error");
      return;
    }
    if (xBio && xBio.length > 160) {
      showXToast("X简介不能超过160个字符", "error");
      return;
    }
    if (showRealName && realName && realName.length > 50) {
      showXToast("真实姓名不能超过50个字符", "error");
      return;
    }
    // 如果选择公开真名但未填写，给予警告但不阻止保存
    if (showRealName && !realName) {
      showXToast("建议填写真实姓名", "warning");
    }
    // 验证自动发消息间隔
    if (autoMessageEnabled) {
      if (autoMessageInterval < 10) {
        showXToast("自动发消息间隔不能少于10秒", "error");
        return;
      }
      if (autoMessageInterval > 3600) {
        showXToast("自动发消息间隔不能超过3600秒", "error");
        return;
      }
    }
    // 验证头像URL（如果填写了）
    if (xAvatarUrl) {
      try {
        new URL(xAvatarUrl);
      } catch (e) {
        showXToast("头像URL格式无效，将使用默认头像", "warning");
      }
    }
    try {
      const db = getXDB();
      console.log(
        "💾 [保存X资料] 开始保存，当前关系数:",
        currentRelationships.length
      ); // 🔧 修复：先读取现有的xProfile，保留userPersona字段
      const existingProfile = await db.xCharacterProfiles.get(characterId);
      const userPersona = existingProfile?.userPersona || ""; // 保留现有的用户人设
      console.log(
        "💾 [保存X资料] 保留现有用户人设，长度:",
        userPersona.length,
        "字符"
      ); // 保存X资料（使用全局的 currentRelationships，而不是重新从数据库读取）
      await db.xCharacterProfiles.put({
        characterId: characterId,
        xName: xName,
        xHandle: xHandle,
        xAvatar: xAvatar,
        xVerified: xVerified,
        xCover: xCover,
        customTag1: tag1Text
          ? { icon: tag1Icon, text: tag1Text, color: tag1Color }
          : null,
        customTag2: tag2Text
          ? { icon: tag2Icon, text: tag2Text, color: tag2Color }
          : null,
        followingCount: followingCount,
        followersCount: followersCount,
        xBio: xBio,
        publicIdentity: publicIdentity,
        showRealName: showRealName,
        realName: showRealName ? realName : "", // 只有选择公开时才保存真名
        relationships: JSON.parse(JSON.stringify(currentRelationships)), // 深拷贝避免引用问题
        autoMessageEnabled: autoMessageEnabled,
        autoMessageInterval: autoMessageInterval,
        userPersona: userPersona, // 🔧 保留用户人设字段
        lastUpdated: new Date().toISOString(),
      });
      console.log(
        "✅ [保存X资料] X资料已保存，关系数:",
        currentRelationships.length
      );
      showXToast("X资料已保存", "success");

      // 🔧 修复：如果首次开启自动发消息，立即设置初始时间戳（防止立即触发）
      if (
        autoMessageEnabled &&
        typeof window.resetAutoMessageTrigger === "function"
      ) {
        // 设置初始触发时间为当前时间（这样需要等待设定的间隔后才会首次触发）
        if (typeof window.lastAutoMessageTrigger === "undefined") {
          window.lastAutoMessageTrigger = {};
        }
        window.lastAutoMessageTrigger[characterId] = Date.now();
        console.log(
          `⏰ 已为角色 ${characterId} 设置初始触发时间，需等待 ${autoMessageInterval}秒 后首次触发`
        );
      }

      // 重启自动发消息系统以应用新设置（不会立即触发，因为已设置时间戳）
      if (
        typeof stopAutoMessageSystem === "function" &&
        typeof startAutoMessageSystem === "function"
      ) {
        stopAutoMessageSystem();
        setTimeout(() => {
          startAutoMessageSystem();
        }, 500);
      }

      // 🔧 修复：刷新私信列表中该角色的头像（如果存在）
      try {
        const messageId = `msg_${characterId}`;
        const dataId = `messagesList_${currentAccountId || "main"}`;
        const savedData = await db.xAccountProfiles.get(dataId);

        if (savedData && savedData.data) {
          const messagesList = savedData.data;
          const messageIndex = messagesList.findIndex(
            (msg) => msg.id === messageId
          );

          if (messageIndex !== -1) {
            // 更新私信列表中的头像和用户名
            messagesList[messageIndex].userAvatar = xAvatar;
            messagesList[messageIndex].userName = xName;
            messagesList[messageIndex].userHandle = xHandle;

            // 保存到数据库
            await db.xAccountProfiles.put({
              handle: dataId,
              name: "messagesList",
              data: messagesList,
              updatedAt: new Date().toISOString(),
            });

            console.log(
              `✅ [保存X资料] 已更新私信列表数据库中角色 ${characterId} 的信息`
            );

            // 🔧 无条件刷新私信列表UI（如果列表页面存在）
            const messagesPage = document.getElementById("x-messages-page");
            if (messagesPage && typeof window.loadMessagesList === "function") {
              // 不管页面是否显示，都标记需要刷新
              // 如果列表正在显示，立即刷新；否则下次显示时会自动刷新
              if (messagesPage.style.display === "flex") {
                await window.loadMessagesList();
                console.log("✅ [保存X资料] 私信列表UI已立即刷新");
              } else {
                console.log("✅ [保存X资料] 私信列表将在下次显示时自动刷新");
              }
            }

            // 🔧 如果私信详情页正在显示该角色，同步更新详情页头像
            const detailPage = document.getElementById("x-message-detail-page");
            if (detailPage && detailPage.style.display === "flex") {
              // 检查详情页是否显示的是当前角色
              if (
                window.currentMessageConversation &&
                window.currentMessageConversation.id === messageId
              ) {
                // 更新顶部小头像
                const topAvatar = document.getElementById(
                  "message-detail-top-avatar"
                );
                if (topAvatar) {
                  topAvatar.src = xAvatar;
                  console.log("✅ [保存X资料] 已更新详情页顶部头像");
                }
                // 更新中间大头像
                const detailAvatar = document.getElementById(
                  "message-detail-avatar"
                );
                if (detailAvatar) {
                  detailAvatar.src = xAvatar;
                  console.log("✅ [保存X资料] 已更新详情页大头像");
                }
                // 更新用户名
                const topName = document.getElementById(
                  "message-detail-top-name"
                );
                if (topName) {
                  topName.textContent = xName;
                }
                const detailName = document.getElementById(
                  "message-detail-name"
                );
                if (detailName) {
                  detailName.textContent = xName;
                }
                // 更新句柄
                const detailHandle = document.getElementById(
                  "message-detail-handle"
                );
                if (detailHandle) {
                  detailHandle.textContent = xHandle;
                }
                console.log("✅ [保存X资料] 私信详情页UI已实时更新");
              }
            }
          }
        }
      } catch (refreshError) {
        console.warn(
          "⚠️ [保存X资料] 刷新私信显示失败（不影响保存）:",
          refreshError
        );
      }

      closeCharacterXProfileModal();
    } catch (error) {
      console.error("❌ [保存X资料] 保存角色X资料失败:", error);
      showXToast("保存失败: " + error.message, "error");
    }
  }
  // NPC关系绑定功能
  // 当前编辑的关系ID（用于编辑模式）
  let currentEditingRelationshipId = null;
  // 当前关系列表
  let currentRelationships = []; // 渲染关系列表
  function renderRelationshipsList(relationships) {
    // 深拷贝数组，避免引用问题导致数据不同步
    currentRelationships = relationships
      ? JSON.parse(JSON.stringify(relationships))
      : [];
    console.log("📋 [渲染关系列表] 当前关系数:", currentRelationships.length);
    const container = document.getElementById("character-relationships-list");
    if (currentRelationships.length === 0) {
      container.innerHTML = `
 <div style="text-align: center; color: #71767b; font-size: 13px; padding: 20px;">
 暂无绑定关系，点击上方"添加关系"按钮开始绑定NPC
 </div>
 `;
      return;
    }
    container.innerHTML = currentRelationships
      .map(
        (rel) => `
 <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 12px; margin-bottom: 8px;">
 <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
 <div style="flex: 1;">
 <div style="color: #fff; font-weight: 600; font-size: 14px; margin-bottom: 4px;">
 ${rel.npcName} <span style="color: #71767b; font-weight: normal;">${
          rel.npcHandle
        }</span>
 </div>
 <div style="color: var(--x-accent); font-size: 12px; background-color: rgba(29,155,240,0.1); padding: 2px 8px; border-radius: 12px; display: inline-block; margin-bottom: 6px;">
 ${rel.relationshipType}
 </div>
 </div>
 <div style="display: flex; gap: 8px;">
 <button onclick="editRelationship('${rel.id}')"
 style="background: none; border: none; color: var(--x-accent); cursor: pointer; padding: 4px 8px; font-size: 12px;">
 编辑
 </button>
 <button onclick="deleteRelationship('${rel.id}')"
 style="background: none; border: none; color: #f4212e; cursor: pointer; padding: 4px 8px; font-size: 12px;">
 删除
 </button>
 </div>
 </div>
 ${
   rel.description
     ? `<div style="color: #71767b; font-size: 12px; line-height: 1.4;">${rel.description}</div>`
     : ""
 }
 </div>
 `
      )
      .join("");
  }
  // 打开添加关系弹窗
  function openAddRelationshipModal() {
    currentEditingRelationshipId = null;
    document.getElementById("relationship-modal-title").textContent =
      "添加NPC关系"; // 清空表单
    document.getElementById("relationship-npc-name").value = "";
    document.getElementById("relationship-npc-handle").value = "";
    document.getElementById("relationship-type").value = "朋友";
    document.getElementById("relationship-description").value = "";
    updateRelationshipDescCount();
    document.getElementById("relationship-modal").style.display = "block";
  }
  // 编辑关系
  function editRelationship(relationshipId) {
    const relationship = currentRelationships.find(
      (rel) => rel.id === relationshipId
    );
    if (!relationship) return;
    currentEditingRelationshipId = relationshipId;
    document.getElementById("relationship-modal-title").textContent =
      "编辑NPC关系"; // 填充表单
    document.getElementById("relationship-npc-name").value =
      relationship.npcName;
    document.getElementById("relationship-npc-handle").value =
      relationship.npcHandle;
    document.getElementById("relationship-type").value =
      relationship.relationshipType;
    document.getElementById("relationship-description").value =
      relationship.description || "";
    updateRelationshipDescCount();
    document.getElementById("relationship-modal").style.display = "block";
  }
  // 删除关系
  async function deleteRelationship(relationshipId) {
    if (!confirm("确定要删除这个关系绑定吗？")) return;
    try {
      console.log("🗑️ [删除关系] 开始删除关系:", relationshipId);
      console.log("🗑️ [删除关系] 删除前关系数:", currentRelationships.length); // 从当前列表中移除
      const beforeLength = currentRelationships.length;
      currentRelationships = currentRelationships.filter(
        (rel) => rel.id !== relationshipId
      );
      const afterLength = currentRelationships.length;
      console.log("🗑️ [删除关系] 删除后关系数:", afterLength);
      if (beforeLength === afterLength) {
        console.warn("⚠️ [删除关系] 未找到要删除的关系");
        showXToast("未找到要删除的关系", "warning");
        return;
      }
      // 保存到数据库
      await saveRelationshipsToDatabase(); // 更新界面
      renderRelationshipsList(currentRelationships);
      showXToast("关系已删除", "success");
    } catch (error) {
      console.error("❌ [删除关系] 删除关系失败:", error);
      showXToast(`删除失败: ${error.message}`, "error");
    }
  }
  // 关闭关系编辑弹窗
  function closeRelationshipModal() {
    document.getElementById("relationship-modal").style.display = "none";
    currentEditingRelationshipId = null;
  }
  // 更新关系描述字符计数
  function updateRelationshipDescCount() {
    const descTextarea = document.getElementById("relationship-description");
    const countSpan = document.getElementById("relationship-desc-count");
    countSpan.textContent = descTextarea.value.length;
  }
  // 保存关系到数据库
  async function saveRelationshipsToDatabase() {
    const characterId = document
      .getElementById("character-x-profile-form")
      .getAttribute("data-character-id");
    if (!characterId) {
      console.error("❌ [保存关系] 无法获取角色ID");
      throw new Error("无法获取角色ID，保存失败");
    }
    try {
      const db = getXDB(); // 获取当前X资料
      const currentProfile = await db.xCharacterProfiles.get(characterId);
      if (!currentProfile) {
        console.error("❌ [保存关系] 未找到角色资料:", characterId);
        throw new Error("未找到角色资料");
      }
      // 更新关系数据（深拷贝数组，避免引用问题）
      currentProfile.relationships = JSON.parse(
        JSON.stringify(currentRelationships)
      );
      await db.xCharacterProfiles.put(currentProfile);
      console.log(
        "✅ [保存关系] 关系已保存到数据库，当前关系数:",
        currentProfile.relationships.length
      );
    } catch (error) {
      console.error("❌ [保存关系] 保存关系到数据库失败:", error);
      throw error;
    }
  }
  // 保存关系表单
  async function saveRelationshipForm(event) {
    event.preventDefault();
    const npcName = document
      .getElementById("relationship-npc-name")
      .value.trim();
    const npcHandle = document
      .getElementById("relationship-npc-handle")
      .value.trim();
    const relationshipType = document.getElementById("relationship-type").value;
    const description = document
      .getElementById("relationship-description")
      .value.trim(); // 验证数据
    if (!npcName) {
      showXToast("NPC名称不能为空", "error");
      return;
    }
    if (!npcHandle) {
      showXToast("NPC句柄不能为空", "error");
      return;
    }
    // 确保句柄格式正确
    const handleFormatted = npcHandle.startsWith("@")
      ? npcHandle
      : `@${npcHandle}`;
    try {
      if (currentEditingRelationshipId) {
        // 编辑模式
        const relationshipIndex = currentRelationships.findIndex(
          (rel) => rel.id === currentEditingRelationshipId
        );
        if (relationshipIndex !== -1) {
          currentRelationships[relationshipIndex] = {
            ...currentRelationships[relationshipIndex],
            npcName: npcName,
            npcHandle: handleFormatted,
            relationshipType: relationshipType,
            description: description,
            updatedAt: new Date().toISOString(),
          };
        }
      } else {
        // 添加模式
        const newRelationship = {
          id:
            "rel_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9),
          npcName: npcName,
          npcHandle: handleFormatted,
          relationshipType: relationshipType,
          description: description,
          createdAt: new Date().toISOString(),
        };
        currentRelationships.push(newRelationship);
      }
      // 保存到数据库
      await saveRelationshipsToDatabase(); // 更新界面
      renderRelationshipsList(currentRelationships); // 关闭弹窗
      closeRelationshipModal();
      showXToast(
        currentEditingRelationshipId ? "关系已更新" : "关系已添加",
        "success"
      );
    } catch (error) {
      console.error("保存关系失败:", error);
      showXToast("保存失败", "error");
    }
  }
  // ============================================
  // 角色关系册功能
  // ============================================
  // 角色关系册数据结构
  let characterRelationshipData = {
    characters: [], // 已绑定角色列表
    links: [], // 关系连线列表 { id, charA, charB, relationAtoB, relationBtoA }
  }; // 当前编辑的关系连线ID
  let currentEditingLinkId = null; // 切换角色关系册开关
  async function toggleCharacterRelationship() {
    if (!xSettingsData.characterRelationship) {
      xSettingsData.characterRelationship = {};
    }
    xSettingsData.characterRelationship.enabled =
      !xSettingsData.characterRelationship.enabled; // 更新UI
    updateRelationshipToggleUI(); // 显示/隐藏关系册管理区域
    const relationshipArea = document.getElementById(
      "relationship-binding-area"
    );
    if (xSettingsData.characterRelationship.enabled) {
      relationshipArea.style.display = "block";
      await loadRelationshipData(); // 稍微延迟更新预览，确保画布已渲染
      setTimeout(() => {
        updateRelationshipPreview();
      }, 100);
    } else {
      relationshipArea.style.display = "none";
    }
    // 自动保存设置
    await saveXSettings();
  }
  // 更新关系册切换按钮UI
  function updateRelationshipToggleUI() {
    const toggle = document.getElementById("x-relationship-toggle");
    const circle = toggle?.querySelector(".toggle-circle");
    if (!toggle || !circle) return;
    const enabled = xSettingsData.characterRelationship?.enabled || false;
    if (enabled) {
      toggle.style.backgroundColor = "var(--x-accent)";
      circle.style.left = "22px";
    } else {
      toggle.style.backgroundColor = "#333";
      circle.style.left = "2px";
    }
  }
  // 加载关系册数据
  async function loadRelationshipData() {
    try {
      const db = getXDB();
      const currentAccount = currentAccountId || "main";
      const dataId = `xCharacterRelationships_${currentAccount}`;
      const savedData = await db.xCharacterRelationships.get(dataId); // 获取当前绑定的所有角色
      const boundChars = xSettingsData.boundCharacters || [];
      const mainDB = getDB();
      const allChats = await mainDB.chats.toArray();
      const currentBoundCharacters = allChats
        .filter((chat) => !chat.isGroup && boundChars.includes(chat.id))
        .map((chat) => ({
          id: chat.id,
          name: chat.name,
          avatar:
            chat.settings?.aiAvatar ||
            "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
        }));
      if (savedData && savedData.data) {
        // 已有保存数据：合并角色列表，保留关系连线
        characterRelationshipData = savedData.data; // 同步角色列表：添加新绑定的角色，移除已解绑的角色
        const existingCharIds = new Set(
          characterRelationshipData.characters.map((c) => c.id)
        );
        const currentCharIds = new Set(currentBoundCharacters.map((c) => c.id)); // 添加新角色（保留位置信息）
        currentBoundCharacters.forEach((char) => {
          if (!existingCharIds.has(char.id)) {
            characterRelationshipData.characters.push(char);
            console.log("➕ 新增角色到关系册:", char.name);
          }
        }); // 移除已解绑的角色，并删除相关的连线
        characterRelationshipData.characters =
          characterRelationshipData.characters.filter((char) => {
            const isStillBound = currentCharIds.has(char.id);
            if (!isStillBound) {
              console.log("➖ 从关系册移除角色:", char.name); // 删除与该角色相关的所有连线
              characterRelationshipData.links =
                characterRelationshipData.links.filter(
                  (link) => link.charA !== char.id && link.charB !== char.id
                );
            }
            return isStillBound;
          }); // 更新现有角色的名称和头像（可能被修改过）
        characterRelationshipData.characters.forEach((char) => {
          const updatedChar = currentBoundCharacters.find(
            (c) => c.id === char.id
          );
          if (updatedChar) {
            char.name = updatedChar.name;
            char.avatar = updatedChar.avatar;
          }
        });
      } else {
        // 无保存数据：初始化
        characterRelationshipData.characters = currentBoundCharacters;
        characterRelationshipData.links = [];
      }
      console.log("✅ 已加载角色关系数据:", {
        角色数: characterRelationshipData.characters.length,
        关系数: characterRelationshipData.links.length,
        角色列表: characterRelationshipData.characters.map((c) => c.name),
      });
    } catch (error) {
      console.error("❌ 加载关系数据失败:", error);
    }
  }
  // 更新预览画布
  function updateRelationshipPreview() {
    const canvas = document.getElementById("relationship-preview-canvas");
    const placeholder = document.getElementById(
      "relationship-preview-placeholder"
    );
    const stats = document.getElementById("relationship-stats");
    if (!canvas) return;
    const linkCount = characterRelationshipData.links?.length || 0;
    const charCount = characterRelationshipData.characters?.length || 0;
    const chars = characterRelationshipData.characters || [];
    const links = characterRelationshipData.links || [];
    if (charCount > 0) {
      placeholder.style.display = "none";
      stats.style.display = "block";
      document.getElementById("relationship-character-count").textContent =
        charCount;
      document.getElementById("relationship-link-count").textContent =
        linkCount; // 绘制缩小版关系图预览
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height); // 读取当前主题的颜色
      const computedStyle = getComputedStyle(document.documentElement);
      const accentColor =
        computedStyle.getPropertyValue("--x-accent").trim() || "#1d9bf0";
      const bgColor =
        computedStyle.getPropertyValue("--x-bg-primary").trim() || "#000";
      const textColor =
        computedStyle.getPropertyValue("--x-text-primary").trim() || "#fff"; // 缩放比例
      const scale = 0.5;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(canvas.width, canvas.height) / 2 - 20; // 计算角色位置
      chars.forEach((char, index) => {
        const angle = (index / chars.length) * Math.PI * 2 - Math.PI / 2;
        char.previewX = centerX + radius * Math.cos(angle);
        char.previewY = centerY + radius * Math.sin(angle);
      }); // 绘制连线
      ctx.strokeStyle = accentColor;
      ctx.lineWidth = 1.5;
      links.forEach((link) => {
        const charA = chars.find((c) => c.id === link.charA);
        const charB = chars.find((c) => c.id === link.charB);
        if (charA && charB) {
          ctx.beginPath();
          ctx.moveTo(charA.previewX, charA.previewY);
          ctx.lineTo(charB.previewX, charB.previewY);
          ctx.stroke();
        }
      }); // 绘制角色节点
      chars.forEach((char) => {
        ctx.beginPath();
        ctx.arc(char.previewX, char.previewY, 15, 0, Math.PI * 2);
        ctx.fillStyle = accentColor;
        ctx.fill();
        ctx.strokeStyle = bgColor;
        ctx.lineWidth = 2;
        ctx.stroke(); // 绘制首字母
        ctx.fillStyle = textColor;
        ctx.font = "bold 10px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(char.name.charAt(0), char.previewX, char.previewY);
      });
    } else {
      placeholder.style.display = "block";
      stats.style.display = "none";
    }
  }
  // 窗口大小改变时重新渲染（用于处理设备旋转等情况）
  let resizeTimeout;
  function handleRelationshipCanvasResize() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      const modal = document.getElementById(
        "character-relationship-graph-modal"
      );
      if (modal && modal.style.display !== "none") {
        initRelationshipCanvas();
        renderRelationshipGraph();
      }
    }, 300);
  }
  // ESC 键处理函数
  function handleRelationshipGraphKeyPress(event) {
    if (event.key === "Escape" && isSelectingCharsForLink) {
      // 取消选择模式
      isSelectingCharsForLink = false;
      selectedCharForLink = null;
      renderRelationshipGraph();
      showXToast("已取消选择", "info");
      console.log("📍 已退出角色选择模式");
    }
  }
  // 打开关系图编辑器
  async function openCharacterRelationshipGraph() {
    await loadRelationshipData();
    const modal = document.getElementById("character-relationship-graph-modal");
    if (modal) {
      modal.style.display = "block";
      document.body.style.overflow = "hidden"; // 初始化画布
      setTimeout(() => {
        initRelationshipCanvas();
        renderRelationshipGraph();
        renderRelationshipList();
      }, 100); // 监听窗口大小改变
      window.addEventListener("resize", handleRelationshipCanvasResize);
      window.addEventListener(
        "orientationchange",
        handleRelationshipCanvasResize
      ); // 监听键盘事件（用于 ESC 取消选择）
      window.addEventListener("keydown", handleRelationshipGraphKeyPress);
    }
  }
  // 关闭关系图编辑器
  function closeCharacterRelationshipGraph(event) {
    if (event && event.target !== event.currentTarget) return;
    const modal = document.getElementById("character-relationship-graph-modal");
    if (modal) {
      modal.style.display = "none";
      document.body.style.overflow = "auto"; // 重置选择状态
      isSelectingCharsForLink = false;
      selectedCharForLink = null; // 移除事件监听器
      window.removeEventListener("resize", handleRelationshipCanvasResize);
      window.removeEventListener(
        "orientationchange",
        handleRelationshipCanvasResize
      );
      window.removeEventListener("keydown", handleRelationshipGraphKeyPress);
    }
  }
  // 拖拽状态
  let isDragging = false;
  let draggedCharId = null;
  let dragOffsetX = 0;
  let dragOffsetY = 0; // 角色选择状态（用于创建连线）
  let isSelectingCharsForLink = false;
  let selectedCharForLink = null; // 初始化关系图画布
  function initRelationshipCanvas() {
    const canvas = document.getElementById("relationship-graph-canvas");
    if (!canvas) return; // 设置画布实际大小
    const container = canvas.parentElement;
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight; // 绑定鼠标事件
    canvas.onmousedown = handleCanvasMouseDown;
    canvas.onmousemove = handleCanvasMouseMove;
    canvas.onmouseup = handleCanvasMouseUp;
    canvas.onclick = handleCanvasClick; // 绑定触摸事件（移动端支持）
    canvas.addEventListener("touchstart", handleCanvasTouchStart, {
      passive: false,
    });
    canvas.addEventListener("touchmove", handleCanvasTouchMove, {
      passive: false,
    });
    canvas.addEventListener("touchend", handleCanvasTouchEnd, {
      passive: false,
    });
  }
  // 缓存加载的头像图片
  const avatarImageCache = {}; // 渲染关系图
  function renderRelationshipGraph() {
    const canvas = document.getElementById("relationship-graph-canvas");
    const emptyState = document.getElementById("graph-empty-state");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    const chars = characterRelationshipData.characters || [];
    const links = characterRelationshipData.links || []; // 读取当前主题的颜色
    const computedStyle = getComputedStyle(document.documentElement);
    const accentColor =
      computedStyle.getPropertyValue("--x-accent").trim() || "#1d9bf0";
    const bgPrimary =
      computedStyle.getPropertyValue("--x-bg-primary").trim() || "#000";
    const bgSecondary =
      computedStyle.getPropertyValue("--x-bg-secondary").trim() || "#1a1a1a";
    const textPrimary =
      computedStyle.getPropertyValue("--x-text-primary").trim() || "#fff"; // 判断是否为暗色主题（用于设置半透明背景）
    const isDark = bgPrimary.includes("#000") || bgPrimary.includes("0, 0, 0");
    const textBgColor = isDark
      ? "rgba(0, 0, 0, 0.7)"
      : "rgba(255, 255, 255, 0.85)"; // 更新统计
    document.getElementById(
      "graph-character-count"
    ).textContent = `${chars.length} 角色`;
    document.getElementById(
      "graph-link-count"
    ).textContent = `${links.length} 关系`;
    if (chars.length === 0) {
      emptyState.style.display = "block";
      return;
    }
    emptyState.style.display = "none";
    ctx.clearRect(0, 0, canvas.width, canvas.height); // 绘制选择模式提示
    if (isSelectingCharsForLink) {
      const tipText = selectedCharForLink
        ? "请点击第二个角色"
        : "请点击第一个角色";
      ctx.fillStyle = accentColor;
      ctx.font = "bold 16px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(tipText, canvas.width / 2, 30); // 绘制取消按钮提示
      ctx.fillStyle = textPrimary;
      ctx.font = "12px sans-serif";
      ctx.fillText("(按 ESC 键取消)", canvas.width / 2, 50);
    }
    // 初始化位置（圆形布局）- 只在没有位置时设置
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = Math.min(canvas.width, canvas.height) / 3;
    chars.forEach((char, index) => {
      if (char.x === undefined || char.y === undefined) {
        const angle = (index / chars.length) * Math.PI * 2 - Math.PI / 2;
        char.x = centerX + radius * Math.cos(angle);
        char.y = centerY + radius * Math.sin(angle);
      }
    }); // 绘制连线
    links.forEach((link) => {
      const charA = chars.find((c) => c.id === link.charA);
      const charB = chars.find((c) => c.id === link.charB);
      if (charA && charB) {
        ctx.beginPath();
        ctx.moveTo(charA.x, charA.y);
        ctx.lineTo(charB.x, charB.y);
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 2;
        ctx.stroke(); // 绘制关系文本
        const midX = (charA.x + charB.x) / 2;
        const midY = (charA.y + charB.y) / 2; // 动态计算文本框大小
        const isMobile = window.innerWidth < 768;
        const textBoxWidth = isMobile ? 70 : 80;
        const textBoxHeight = isMobile ? 30 : 35;
        const fontSize = isMobile ? "10px" : "11px"; // 绘制文本背景
        ctx.fillStyle = textBgColor;
        ctx.fillRect(
          midX - textBoxWidth / 2,
          midY - textBoxHeight / 2,
          textBoxWidth,
          textBoxHeight
        );
        ctx.fillStyle = accentColor;
        ctx.font = fontSize + " sans-serif";
        ctx.textAlign = "center";
        const lineSpacing = isMobile ? 12 : 15;
        ctx.fillText(link.relationAtoB || "关系", midX, midY - lineSpacing / 2);
        ctx.fillText(link.relationBtoA || "关系", midX, midY + lineSpacing / 2);
      }
    }); // 动态计算头像大小（移动端缩小）
    const isMobile = window.innerWidth < 768;
    const avatarRadius = isMobile ? 25 : 35;
    const avatarInnerRadius = avatarRadius - 2; // 绘制角色头像和名称
    chars.forEach((char) => {
      // 检查是否为选中的角色
      const isSelected =
        isSelectingCharsForLink && selectedCharForLink === char.id; // 绘制选中高亮圈（外圈）
      if (isSelected) {
        ctx.beginPath();
        ctx.arc(char.x, char.y, avatarRadius + 5, 0, Math.PI * 2);
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      // 绘制圆形背景
      ctx.beginPath();
      ctx.arc(char.x, char.y, avatarRadius, 0, Math.PI * 2);
      ctx.fillStyle = isSelected ? "#FFA500" : accentColor; // 选中时使用橙色
      ctx.fill();
      ctx.strokeStyle = bgPrimary;
      ctx.lineWidth = 2;
      ctx.stroke(); // 绘制头像图片
      if (char.avatar) {
        if (avatarImageCache[char.avatar]) {
          // 使用缓存的图片
          const img = avatarImageCache[char.avatar];
          ctx.save();
          ctx.beginPath();
          ctx.arc(char.x, char.y, avatarInnerRadius, 0, Math.PI * 2);
          ctx.closePath();
          ctx.clip();
          ctx.drawImage(
            img,
            char.x - avatarInnerRadius,
            char.y - avatarInnerRadius,
            avatarInnerRadius * 2,
            avatarInnerRadius * 2
          );
          ctx.restore();
        } else {
          // 加载图片
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.onload = () => {
            avatarImageCache[char.avatar] = img;
            renderRelationshipGraph(); // 重新渲染
          };
          img.onerror = () => {
            // 加载失败，显示默认文本
            ctx.fillStyle = textPrimary;
            ctx.font = "bold 14px sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(char.name.charAt(0), char.x, char.y);
          };
          img.src = char.avatar; // 在图片加载前显示首字母
          ctx.fillStyle = textPrimary;
          ctx.font = "bold 14px sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(char.name.charAt(0), char.x, char.y);
        }
      } else {
        // 没有头像，显示首字母
        ctx.fillStyle = textPrimary;
        ctx.font = "bold 14px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(char.name.charAt(0), char.x, char.y);
      }
      // 绘制名称
      ctx.fillStyle = textPrimary;
      ctx.font = isMobile ? "bold 11px sans-serif" : "bold 12px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(char.name, char.x, char.y + avatarRadius + 10); // 保存头像半径到角色数据，用于点击检测
      char.radius = avatarRadius;
    });
  }
  // 鼠标按下处理
  function handleCanvasMouseDown(event) {
    const canvas = event.target;
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    const chars = characterRelationshipData.characters || []; // 检查是否点击了角色
    for (const char of chars) {
      const dx = x - char.x;
      const dy = y - char.y;
      const radius = char.radius || 35;
      if (Math.sqrt(dx * dx + dy * dy) < radius) {
        isDragging = true;
        draggedCharId = char.id;
        dragOffsetX = dx;
        dragOffsetY = dy;
        canvas.style.cursor = "grabbing";
        return;
      }
    }
  }
  // 触摸开始处理（移动端）
  function handleCanvasTouchStart(event) {
    event.preventDefault();
    const canvas = event.target;
    const rect = canvas.getBoundingClientRect();
    const touch = event.touches[0];
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top; // 记录触摸开始信息
    touchStartTime = Date.now();
    touchStartX = x;
    touchStartY = y;
    const chars = characterRelationshipData.characters || []; // 检查是否触摸了角色（但不立即设置为拖拽状态）
    for (const char of chars) {
      const dx = x - char.x;
      const dy = y - char.y;
      const radius = char.radius || 35;
      if (Math.sqrt(dx * dx + dy * dy) < radius) {
        // 记录可能被拖拽的角色，但不立即设置为拖拽状态
        draggedCharId = char.id;
        dragOffsetX = dx;
        dragOffsetY = dy;
        return;
      }
    }
  }
  // 鼠标移动处理
  function handleCanvasMouseMove(event) {
    const canvas = event.target;
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    const chars = characterRelationshipData.characters || [];
    if (isDragging && draggedCharId) {
      // 拖拽角色
      const char = chars.find((c) => c.id === draggedCharId);
      if (char) {
        char.x = x - dragOffsetX;
        char.y = y - dragOffsetY;
        renderRelationshipGraph();
      }
    } else {
      // 检查是否悬停在角色上
      const hoveredChar = chars.find((char) => {
        const dx = x - char.x;
        const dy = y - char.y;
        const radius = char.radius || 35;
        return Math.sqrt(dx * dx + dy * dy) < radius;
      });
      canvas.style.cursor = hoveredChar ? "grab" : "default";
    }
  }
  // 触摸移动处理（移动端）
  function handleCanvasTouchMove(event) {
    event.preventDefault();
    const canvas = event.target;
    const rect = canvas.getBoundingClientRect();
    const touch = event.touches[0];
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    const chars = characterRelationshipData.characters || []; // 如果已记录了拖拽目标但还未进入拖拽状态，检查移动距离
    if (draggedCharId && !isDragging) {
      const dx = x - touchStartX;
      const dy = y - touchStartY;
      const distance = Math.sqrt(dx * dx + dy * dy); // 移动距离超过10px才认为是拖拽
      if (distance > 10) {
        isDragging = true;
        console.log("📍 开始拖拽角色");
      }
    }
    if (isDragging && draggedCharId) {
      // 拖拽角色
      const char = chars.find((c) => c.id === draggedCharId);
      if (char) {
        char.x = x - dragOffsetX;
        char.y = y - dragOffsetY;
        renderRelationshipGraph();
      }
    }
  }
  // 鼠标释放处理
  function handleCanvasMouseUp(event) {
    if (isDragging) {
      isDragging = false;
      draggedCharId = null;
      event.target.style.cursor = "default";
    }
  }
  // 触摸结束处理（移动端）
  let touchStartTime = 0;
  let touchStartX = 0;
  let touchStartY = 0;
  function handleCanvasTouchEnd(event) {
    event.preventDefault();
    const wasDragging = isDragging; // 重置拖拽状态
    if (isDragging) {
      isDragging = false;
      draggedCharId = null;
    } else if (draggedCharId) {
      // 即使没有进入拖拽状态，也要清除记录的角色ID
      draggedCharId = null;
    }
    // 如果没有拖拽，检测是否是点击
    if (
      !wasDragging &&
      event.changedTouches &&
      event.changedTouches.length > 0
    ) {
      const canvas = event.target;
      const rect = canvas.getBoundingClientRect();
      const touch = event.changedTouches[0];
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      const chars = characterRelationshipData.characters || [];
      const links = characterRelationshipData.links || []; // 优先处理选择模式
      if (isSelectingCharsForLink) {
        // 检查是否触摸了角色
        for (const char of chars) {
          const dx = x - char.x;
          const dy = y - char.y;
          const radius = char.radius || 35;
          if (Math.sqrt(dx * dx + dy * dy) < radius) {
            handleCharacterSelection(char);
            return;
          }
        }
        return; // 选择模式下不处理其他点击
      }
      // 检查是否点击了连线
      for (const link of links) {
        const charA = chars.find((c) => c.id === link.charA);
        const charB = chars.find((c) => c.id === link.charB);
        if (charA && charB) {
          const dist = distanceToLine(x, y, charA.x, charA.y, charB.x, charB.y); // 移动端增大点击区域
          if (dist < 20) {
            openEditRelationshipDetailModal(link);
            return;
          }
        }
      }
    }
  }
  // 画布点击处理
  function handleCanvasClick(event) {
    // 如果刚才在拖拽，不触发点击事件
    if (isDragging) return;
    const canvas = event.target;
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    const chars = characterRelationshipData.characters || [];
    const links = characterRelationshipData.links || []; // 优先处理选择模式
    if (isSelectingCharsForLink) {
      // 检查是否点击了角色
      for (const char of chars) {
        const dx = x - char.x;
        const dy = y - char.y;
        const radius = char.radius || 35;
        if (Math.sqrt(dx * dx + dy * dy) < radius) {
          handleCharacterSelection(char);
          return;
        }
      }
      return; // 选择模式下不处理其他点击
    }
    // 检查是否点击了连线
    for (const link of links) {
      const charA = chars.find((c) => c.id === link.charA);
      const charB = chars.find((c) => c.id === link.charB);
      if (charA && charB) {
        const dist = distanceToLine(x, y, charA.x, charA.y, charB.x, charB.y);
        if (dist < 15) {
          openEditRelationshipDetailModal(link);
          return;
        }
      }
    }
  }
  // 处理角色选择（用于创建连线）
  function handleCharacterSelection(char) {
    if (!selectedCharForLink) {
      // 选择第一个角色
      selectedCharForLink = char.id;
      console.log("✅ 已选择第一个角色:", char.name);
      showXToast(`已选择 ${char.name}，请点击第二个角色`, "info");
      renderRelationshipGraph(); // 重新渲染以高亮选中的角色
    } else {
      // 选择第二个角色
      if (selectedCharForLink === char.id) {
        showXToast("请选择不同的角色", "error");
        return;
      }
      // 检查是否已存在这条关系
      const existingLink = characterRelationshipData.links.find(
        (link) =>
          (link.charA === selectedCharForLink && link.charB === char.id) ||
          (link.charA === char.id && link.charB === selectedCharForLink)
      );
      if (existingLink) {
        showXToast("这两个角色已存在关系，请直接点击连线编辑", "error"); // 退出选择模式
        isSelectingCharsForLink = false;
        selectedCharForLink = null;
        renderRelationshipGraph();
        return;
      }
      console.log("✅ 已选择第二个角色:", char.name); // 创建新关系
      const newLink = {
        id: "link_" + Date.now(),
        charA: selectedCharForLink,
        charB: char.id,
        relationAtoB: "",
        relationBtoA: "",
        story: "",
      };
      characterRelationshipData.links.push(newLink); // 退出选择模式
      isSelectingCharsForLink = false;
      selectedCharForLink = null; // 立即渲染
      renderRelationshipGraph();
      renderRelationshipList(); // 更新全局引用
      window.characterRelationshipData = characterRelationshipData; // 延迟打开编辑，确保渲染完成
      setTimeout(() => {
        openEditRelationshipDetailModal(newLink);
      }, 100);
    }
  }
  // 计算点到线段的距离
  function distanceToLine(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;
    if (lenSq !== 0) param = dot / lenSq;
    let xx, yy;
    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x2;
      yy = y2;
    } else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }
    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
  }
  // 添加关系连线
  function addRelationshipLink() {
    const chars = characterRelationshipData.characters || [];
    if (chars.length < 2) {
      showXToast("至少需要2个已绑定角色才能创建关系", "error");
      return;
    }
    // 进入选择模式
    isSelectingCharsForLink = true;
    selectedCharForLink = null;
    showXToast("请点击选择第一个角色", "info");
    console.log("📍 进入角色选择模式"); // 重新渲染以显示选择提示
    renderRelationshipGraph();
  }
  // 打开编辑关系详情弹窗
  function openEditRelationshipDetailModal(link) {
    currentEditingLinkId = link.id;
    const chars = characterRelationshipData.characters || [];
    const charA = chars.find((c) => c.id === link.charA);
    const charB = chars.find((c) => c.id === link.charB);
    if (!charA || !charB) return;
    document.getElementById("char-a-name").textContent = charA.name;
    document.getElementById("char-b-name").textContent = charB.name;
    document.getElementById(
      "char-a-to-b-label"
    ).textContent = `${charA.name} 是 ${charB.name} 的：`;
    document.getElementById(
      "char-b-to-a-label"
    ).textContent = `${charB.name} 是 ${charA.name} 的：`;
    document.getElementById("relationship-a-to-b").value =
      link.relationAtoB || "";
    document.getElementById("relationship-b-to-a").value =
      link.relationBtoA || "";
    document.getElementById("relationship-story").value = link.story || "";
    const modal = document.getElementById("edit-relationship-detail-modal");
    if (modal) {
      modal.style.display = "block";
    }
  }
  // 关闭编辑关系详情弹窗
  function closeEditRelationshipDetail(event) {
    if (event && event.target !== event.currentTarget) return;
    const modal = document.getElementById("edit-relationship-detail-modal");
    if (modal) {
      modal.style.display = "none";
    }
    currentEditingLinkId = null;
  }
  // 保存关系详情
  async function saveRelationshipDetail() {
    if (!currentEditingLinkId) return;
    const link = characterRelationshipData.links.find(
      (l) => l.id === currentEditingLinkId
    );
    if (!link) return;
    link.relationAtoB = document
      .getElementById("relationship-a-to-b")
      .value.trim();
    link.relationBtoA = document
      .getElementById("relationship-b-to-a")
      .value.trim();
    link.story = document.getElementById("relationship-story").value.trim();
    renderRelationshipGraph();
    renderRelationshipList();
    closeEditRelationshipDetail(); // 自动保存到数据库
    try {
      const db = getXDB();
      const currentAccount = currentAccountId || "main";
      const dataId = `xCharacterRelationships_${currentAccount}`;
      await db.xCharacterRelationships.put({
        id: dataId,
        accountId: currentAccount,
        data: characterRelationshipData,
        lastUpdated: new Date().toISOString(),
      });
      updateRelationshipPreview();
      showXToast("关系已更新并保存", "success");
      console.log("✅ 关系已自动保存:", link);
    } catch (error) {
      console.error("❌ 保存关系失败:", error);
      showXToast("关系已更新但保存失败", "error");
    }
  }
  // 删除关系连线
  async function deleteRelationshipLink() {
    if (!currentEditingLinkId) return;
    if (!confirm("确定要删除这条关系吗？")) return;
    characterRelationshipData.links = characterRelationshipData.links.filter(
      (l) => l.id !== currentEditingLinkId
    );
    renderRelationshipGraph();
    renderRelationshipList();
    closeEditRelationshipDetail(); // 自动保存到数据库
    try {
      const db = getXDB();
      const currentAccount = currentAccountId || "main";
      const dataId = `xCharacterRelationships_${currentAccount}`;
      await db.xCharacterRelationships.put({
        id: dataId,
        accountId: currentAccount,
        data: characterRelationshipData,
        lastUpdated: new Date().toISOString(),
      });
      updateRelationshipPreview();
      showXToast("关系已删除", "success");
    } catch (error) {
      console.error("❌ 删除关系失败:", error);
      showXToast("关系已删除但保存失败", "error");
    }
  }
  // 清空所有关系
  async function clearAllRelationships() {
    if (!confirm("确定要清空所有关系吗？此操作不可恢复。")) return;
    characterRelationshipData.links = [];
    renderRelationshipGraph();
    renderRelationshipList(); // 自动保存到数据库
    try {
      const db = getXDB();
      const currentAccount = currentAccountId || "main";
      const dataId = `xCharacterRelationships_${currentAccount}`;
      await db.xCharacterRelationships.put({
        id: dataId,
        accountId: currentAccount,
        data: characterRelationshipData,
        lastUpdated: new Date().toISOString(),
      });
      updateRelationshipPreview();
      showXToast("已清空所有关系", "success");
    } catch (error) {
      console.error("❌ 清空关系失败:", error);
      showXToast("已清空但保存失败", "error");
    }
  }
  // 渲染关系列表
  function renderRelationshipList() {
    const listContainer = document.getElementById("relationship-links-list");
    if (!listContainer) return;
    const links = characterRelationshipData.links || [];
    const chars = characterRelationshipData.characters || [];
    if (links.length === 0) {
      listContainer.innerHTML =
        '<div style="color: #71767b; text-align: center; padding: 20px;">暂无关系</div>';
      return;
    }
    listContainer.innerHTML = links
      .map((link) => {
        const charA = chars.find((c) => c.id === link.charA);
        const charB = chars.find((c) => c.id === link.charB);
        if (!charA || !charB) return "";
        const storyPreview = link.story
          ? `
 <div style="color: #71767b; font-size: 11px; margin-top: 6px; padding-top: 6px; border-top: 1px solid #2f3336;">
 ${link.story.length > 50 ? link.story.substring(0, 50) + "..." : link.story}
 </div>
 `
          : "";
        return `
 <div style="background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 12px; margin-bottom: 8px; cursor: pointer; transition: background-color 0.2s; " onclick="openEditRelationshipDetailModal(window.characterRelationshipData.links.find(l => l.id === '${
   link.id
 }'))"
 onmouseover="this.style.backgroundColor='#2a2a2a'"
 onmouseout="this.style.backgroundColor='#1a1a1a'">
 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
 <div style="display: flex; align-items: center; gap: 8px;">
 <span style="color: #fff; font-weight: 600; font-size: 14px;">${
   charA.name
 }</span>
 <span style="color: #71767b;">⇆</span>
 <span style="color: #fff; font-weight: 600; font-size: 14px;">${
   charB.name
 }</span>
 </div>
 </div>
 <div style="display: flex; gap: 12px; font-size: 12px;">
 <div style="color: var(--x-accent);">${charA.name}: ${
          link.relationAtoB || "(未设置)"
        }</div>
 <div style="color: var(--x-accent);">${charB.name}: ${
          link.relationBtoA || "(未设置)"
        }</div>
 </div>
 ${storyPreview}
 </div>
 `;
      })
      .join("");
  }
  // 保存关系图
  async function saveRelationshipGraph() {
    try {
      const db = getXDB();
      const currentAccount = currentAccountId || "main";
      const dataId = `xCharacterRelationships_${currentAccount}`;
      await db.xCharacterRelationships.put({
        id: dataId,
        accountId: currentAccount,
        data: characterRelationshipData,
        lastUpdated: new Date().toISOString(),
      });
      updateRelationshipPreview();
      closeCharacterRelationshipGraph();
      showXToast("关系图已保存", "success");
      console.log("✅ 关系图已保存:", characterRelationshipData);
    } catch (error) {
      console.error("❌ 保存关系图失败:", error);
      showXToast("保存失败", "error");
    }
  }
  // ============================================
  // NPC绑定功能
  // ============================================
  // 当前编辑的NPC ID
  let currentEditingNPCId = null; // 切换NPC绑定开关
  async function toggleNPCBinding() {
    xSettingsData.npcBinding = !xSettingsData.npcBinding; // 更新UI
    updateNPCToggleUI(); // 显示/隐藏NPC管理区域
    const npcArea = document.getElementById("npc-binding-area");
    if (xSettingsData.npcBinding) {
      npcArea.style.display = "block";
      await loadNPCsList();
    } else {
      npcArea.style.display = "none";
    }
    // 自动保存设置
    await saveXSettings();
  }
  // 更新NPC绑定切换按钮UI
  function updateNPCToggleUI() {
    const toggle = document.getElementById("x-npc-toggle");
    const circle = toggle.querySelector(".toggle-circle");
    if (xSettingsData.npcBinding) {
      toggle.style.backgroundColor = "var(--x-accent)";
      circle.style.left = "22px";
    } else {
      toggle.style.backgroundColor = "#333";
      circle.style.left = "2px";
    }
  }
  // 加载NPC列表
  async function loadNPCsList() {
    try {
      const db = getXDB();
      const npcId = "xNPCs_global"; // 全局存储，所有账号共享
      const npcData = await db.xNPCs.get(npcId);
      const allNPCs = npcData?.npcs || []; // 过滤出绑定了当前账号的NPC
      const currentAccount = currentAccountId || "main";
      const npcs = allNPCs.filter(
        (npc) => npc.boundUsers && npc.boundUsers.includes(currentAccount)
      );
      const npcsList = document.getElementById("npcs-list");
      if (npcs.length === 0) {
        npcsList.innerHTML =
          '<p style="color: #71767b; font-size: 14px; text-align: center; padding: 20px 0;">暂无绑定到此账号的NPC，点击上方按钮创建</p>';
        return;
      }
      npcsList.innerHTML = npcs
        .map(
          (npc) => `
 <div style="background-color: #0a0a0a; border: 1px solid #2f3336; border-radius: 8px; padding: 12px; margin-bottom: 8px; display: flex; align-items: center; gap: 12px; ">
 <img src="${
   npc.avatar || "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg"
 }"
 style="width: 48px; height: 48px; border-radius: 50%; flex-shrink: 0;"
 alt="${npc.name}">
 <div style="flex: 1; min-width: 0;">
 <div style="color: #fff; font-weight: 600; font-size: 15px; margin-bottom: 2px;">${
   npc.name
 }</div>
 <div style="color: #71767b; font-size: 14px;">${npc.handle}</div>
 <div style="color: #71767b; font-size: 13px; margin-top: 4px;">
 绑定用户: ${npc.boundUsers?.length || 0}个
 </div>
 </div>
 <div style="display: flex; gap: 8px; flex-shrink: 0;">
 <button onclick="editNPC('${
   npc.id
 }')" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 15px; padding: 6px 12px; font-size: 13px; cursor: pointer; white-space: nowrap; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'">
 编辑
 </button>
 <button onclick="deleteNPC('${
   npc.id
 }')" style="background-color: #f4212e; color: #fff; border: none; border-radius: 15px; padding: 6px 12px; font-size: 13px; cursor: pointer; white-space: nowrap; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#d11a29'" onmouseout="this.style.backgroundColor='#f4212e'">
 删除
 </button>
 </div>
 </div>
 `
        )
        .join("");
    } catch (error) {
      console.error("加载NPC列表失败:", error);
      document.getElementById("npcs-list").innerHTML =
        '<p style="color: #f4212e; font-size: 14px; text-align: center; padding: 20px 0;">加载失败，请重试</p>';
    }
  }
  // 打开创建NPC弹窗
  function openCreateNPCModal() {
    currentEditingNPCId = null; // 清空表单
    document.getElementById("npc-name").value = "";
    document.getElementById("npc-handle").value = "";
    document.getElementById("npc-avatar").value = "";
    document.getElementById("npc-personality").value = "";
    document.getElementById("npc-posting-habits").value = "";
    document.getElementById("npc-homepage").value = ""; // 更新标题
    document.getElementById("npc-modal-title").textContent = "创建NPC"; // 加载用户列表
    loadNPCBindUsersList(); // 显示弹窗
    document.getElementById("npc-edit-modal").style.display = "block";
    document.body.style.overflow = "hidden";
  }
  // 编辑NPC
  async function editNPC(npcId) {
    try {
      const db = getXDB();
      const npcDataId = "xNPCs_global"; // 全局存储，所有账号共享
      const npcData = await db.xNPCs.get(npcDataId);
      const npcs = npcData?.npcs || [];
      const npc = npcs.find((n) => n.id === npcId);
      if (!npc) {
        showXToast("NPC不存在", "error");
        return;
      }
      currentEditingNPCId = npcId; // 填充表单
      document.getElementById("npc-name").value = npc.name || "";
      document.getElementById("npc-handle").value = npc.handle || "";
      document.getElementById("npc-avatar").value = npc.avatar || "";
      document.getElementById("npc-personality").value = npc.personality || "";
      document.getElementById("npc-posting-habits").value =
        npc.postingHabits || "";
      document.getElementById("npc-homepage").value = npc.homepage || ""; // 更新标题
      document.getElementById("npc-modal-title").textContent = "编辑NPC"; // 加载用户列表并选中已绑定的用户
      await loadNPCBindUsersList(npc.boundUsers || []); // 显示弹窗
      document.getElementById("npc-edit-modal").style.display = "block";
      document.body.style.overflow = "hidden";
    } catch (error) {
      console.error("加载NPC数据失败:", error);
      showXToast("加载失败", "error");
    }
  }
  // 加载绑定用户列表
  async function loadNPCBindUsersList(selectedUsers = []) {
    try {
      const db = getXDB();
      const accounts = await db.xAccountList.toArray();
      const usersList = document.getElementById("npc-bind-users");
      if (accounts.length === 0) {
        usersList.innerHTML =
          '<p style="color: #71767b; font-size: 14px; text-align: center; padding: 10px 0;">暂无账号</p>';
        return;
      }
      usersList.innerHTML = accounts
        .map((account) => {
          const isChecked = selectedUsers.includes(account.accountId);
          return `
 <label style="display: flex; align-items: center; gap: 12px; padding: 8px; cursor: pointer; border-radius: 6px; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.05)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <input
 type="checkbox"
 value="${account.accountId}"
 ${isChecked ? "checked" : ""}
 style="width: 16px; height: 16px; accent-color: var(--x-accent); cursor: pointer;">
 <img src="${
   account.avatar
 }" style="width: 32px; height: 32px; border-radius: 50%;" alt="${
            account.name
          }">
 <div style="flex: 1;">
 <div style="color: #fff; font-size: 14px; font-weight: 600;">${
   account.name
 }</div>
 <div style="color: #71767b; font-size: 13px;">账号ID: ${
   account.accountId
 }</div>
 </div>
 </label>
 `;
        })
        .join("");
    } catch (error) {
      console.error("加载用户列表失败:", error);
    }
  }
  // 保存NPC
  async function saveNPC() {
    try {
      const name = document.getElementById("npc-name").value.trim();
      const handle = document.getElementById("npc-handle").value.trim();
      const avatar = document.getElementById("npc-avatar").value.trim();
      const personality = document
        .getElementById("npc-personality")
        .value.trim();
      const postingHabits = document
        .getElementById("npc-posting-habits")
        .value.trim();
      const homepage = document.getElementById("npc-homepage").value.trim(); // 获取选中的用户
      const boundUsers = Array.from(
        document.querySelectorAll(
          '#npc-bind-users input[type="checkbox"]:checked'
        )
      ).map((input) => input.value); // 验证数据
      if (!name) {
        showXToast("NPC姓名不能为空", "error");
        return;
      }
      if (!handle) {
        showXToast("NPC句柄不能为空", "error");
        return;
      }
      // 确保句柄格式正确
      const handleFormatted = handle.startsWith("@") ? handle : `@${handle}`;
      const db = getXDB();
      const npcDataId = "xNPCs_global"; // 全局存储，所有账号共享
      const npcData = await db.xNPCs.get(npcDataId);
      let npcs = npcData?.npcs || [];
      if (currentEditingNPCId) {
        // 编辑模式
        const index = npcs.findIndex((n) => n.id === currentEditingNPCId);
        if (index !== -1) {
          npcs[index] = {
            ...npcs[index],
            name,
            handle: handleFormatted,
            avatar:
              avatar ||
              "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
            personality,
            postingHabits,
            homepage,
            boundUsers,
            updatedAt: new Date().toISOString(),
          };
        }
      } else {
        // 创建模式
        const newNPC = {
          id:
            "npc_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9),
          name,
          handle: handleFormatted,
          avatar:
            avatar || "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
          personality,
          postingHabits,
          homepage,
          boundUsers,
          createdAt: new Date().toISOString(),
        };
        npcs.push(newNPC);
      }
      // 保存到数据库
      await db.xNPCs.put({
        id: npcDataId,
        npcs,
        lastUpdated: new Date().toISOString(),
      });
      console.log(
        `✅ NPC已${currentEditingNPCId ? "更新" : "创建"}:`,
        name,
        handle
      );
      console.log("📎 绑定账号数量:", boundUsers.length);
      console.log(
        "📎 绑定账号列表:",
        boundUsers.length > 0 ? boundUsers : "无"
      ); // 刷新列表
      await loadNPCsList(); // 关闭弹窗
      closeNPCEditModal();
      showXToast(currentEditingNPCId ? "NPC已更新" : "NPC已创建", "success");
    } catch (error) {
      console.error("保存NPC失败:", error);
      showXToast("保存失败: " + error.message, "error");
    }
  }
  // 删除NPC
  async function deleteNPC(npcId) {
    if (!confirm("确定要删除这个NPC吗？\n此操作将影响所有绑定了此NPC的账号。"))
      return;
    try {
      const db = getXDB();
      const npcDataId = "xNPCs_global"; // 全局存储，所有账号共享
      const npcData = await db.xNPCs.get(npcDataId);
      let npcs = npcData?.npcs || [];
      npcs = npcs.filter((n) => n.id !== npcId);
      await db.xNPCs.put({
        id: npcDataId,
        npcs,
        lastUpdated: new Date().toISOString(),
      });
      await loadNPCsList();
      showXToast("NPC已删除", "success");
    } catch (error) {
      console.error("删除NPC失败:", error);
      showXToast("删除失败", "error");
    }
  }
  // 关闭NPC编辑弹窗
  function closeNPCEditModal(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById("npc-edit-modal").style.display = "none";
    document.body.style.overflow = "auto";
    currentEditingNPCId = null;
  }
  // 用户主页相关功能
  // 切换主页标签
  function switchProfileTab(tabName) {
    // 重置所有标签样式
    document.querySelectorAll(".profile-tab").forEach((tab) => {
      tab.classList.remove("active");
      tab.style.color = "#71767b";
      tab.querySelector(".tab-indicator").style.display = "none";
    }); // 隐藏所有内容区域
    document.querySelectorAll(".profile-tab-content").forEach((content) => {
      content.style.display = "none";
    }); // 激活选中的标签
    const activeTab = document.querySelector(
      `.profile-tab[onclick="switchProfileTab('${tabName}')"]`
    );
    if (activeTab) {
      activeTab.classList.add("active");
      activeTab.style.color = "#fff";
      activeTab.querySelector(".tab-indicator").style.display = "block";
    }
    // 显示对应的内容区域
    const contentArea = document.getElementById(`profile-${tabName}-content`);
    if (contentArea) {
      contentArea.style.display = "block";
    }
    // 根据标签加载相应内容
    if (tabName === "posts") {
      loadUserProfileTweets();
    } else if (tabName === "highlights") {
      loadHighlights();
    } else if (tabName === "likes") {
      loadLikes();
    }
  }
  // 编辑个人资料
  function editProfile() {
    openEditProfileModal();
  }
  // 加载用户资料到UI
  function loadUserProfileToUI() {
    // 使用window.userProfileData确保读取最新数据
    const profile = window.userProfileData; // 更新顶栏头像
    const topBarAvatar = document.getElementById("top-bar-avatar");
    if (topBarAvatar) {
      topBarAvatar.src = profile.avatar;
    }
    // 更新主页信息
    const profileElements = {
      "x-profile-header-name": profile.name,
      "x-profile-user-name": profile.name,
      "x-profile-user-handle": profile.handle,
      "x-profile-bio": profile.bio,
      "x-profile-following-count": profile.following,
      "x-profile-followers-count": profile.followers,
    };
    Object.entries(profileElements).forEach(([id, value]) => {
      const element = document.getElementById(id);
      if (element) {
        element.textContent = value;
      }
    }); // 更新自定义标签内容、图标和颜色
    const tag1Element = document.getElementById("x-profile-tag1");
    const tag1IconElement = document.getElementById("x-profile-tag1-icon");
    const tag2Element = document.getElementById("x-profile-tag2");
    const tag2IconElement = document.getElementById("x-profile-tag2-icon");
    if (tag1Element) {
      tag1Element.textContent = profile.customTag1;
      tag1Element.style.color = profile.customTag1Color || "#71767b";
    }
    if (tag1IconElement) {
      tag1IconElement.textContent = profile.customTag1Icon || "✨";
    }
    if (tag2Element) {
      tag2Element.textContent = profile.customTag2;
      tag2Element.style.color = profile.customTag2Color || "#71767b";
    }
    if (tag2IconElement) {
      tag2IconElement.textContent = profile.customTag2Icon || "📅";
    }
    // 更新头像
    const mainAvatar = document.getElementById("x-profile-main-avatar");
    if (mainAvatar) {
      mainAvatar.src = profile.avatar;
    }
    // 更新封面图
    const coverImage = document.getElementById("x-profile-cover-image");
    if (coverImage) {
      coverImage.src = profile.coverImage;
    }
    // 更新认证徽章
    updateVerificationBadge(); // 更新评论输入区域的头像
    const commentInputAvatar = document.querySelector(
      "#comment-input-area img, .comment-input-area img"
    );
    if (commentInputAvatar) {
      commentInputAvatar.src = profile.avatar;
    }
    // 更新主页评论输入框头像
    const commentUserAvatar = document.getElementById("comment-user-avatar");
    if (commentUserAvatar) {
      commentUserAvatar.src = profile.avatar;
    }
    // 更新详情页评论输入框头像
    const detailCommentUserAvatar = document.getElementById(
      "detail-comment-user-avatar"
    );
    if (detailCommentUserAvatar) {
      detailCommentUserAvatar.src = profile.avatar;
    }
    // 更新所有回复输入框头像
    const replyUserAvatars = document.querySelectorAll(".reply-user-avatar");
    replyUserAvatars.forEach((avatar) => {
      avatar.src = profile.avatar;
    }); // 更新发帖弹窗头像
    const composeUserAvatar = document.getElementById("compose-user-avatar");
    if (composeUserAvatar) {
      composeUserAvatar.src = profile.avatar;
    }
    console.log("✅ UI已更新，当前用户资料:", profile.name);
  }
  // 更新认证徽章显示
  function updateVerificationBadge() {
    const verifiedBadge = document.getElementById("x-profile-verified-badge");
    if (!verifiedBadge) return;
    const verificationType = userProfileData.verificationType || "none"; // 如果是无认证，隐藏徽章
    if (verificationType === "none") {
      verifiedBadge.style.display = "none";
      return;
    }
    // 显示徽章
    verifiedBadge.style.display = "inline-block"; // 根据认证类型设置不同的图标和颜色
    let badgeColor = "#1d9bf0"; // 默认蓝色
    let badgePath = ""; // SVG路径
    switch (verificationType) {
      case "verified": // 蓝色勾 - 已认证（保持原样）
        badgeColor = "#1d9bf0";
        badgePath =
          "M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z";
        break;
      case "couple": // 心形 - 情侣认证（自适应主题颜色：日间黑色，夜间白色）
        badgeColor =
          getComputedStyle(document.getElementById("x-social-screen"))
            .getPropertyValue("--x-text-primary")
            .trim() || "#fff";
        badgePath =
          "M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z";
        break;
      case "married": // 圆环 - 已婚认证（自适应主题颜色：日间黑色，夜间白色）
        badgeColor =
          getComputedStyle(document.getElementById("x-social-screen"))
            .getPropertyValue("--x-text-primary")
            .trim() || "#fff";
        badgePath =
          "M12 4c4.42 0 8 3.58 8 8s-3.58 8-8 8-8-3.58-8-8 3.58-8 8-8zm0 2c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6z";
        break;
      case "vip": // 菱形 - VIP认证（自适应主题颜色：日间黑色，夜间白色）
        badgeColor =
          getComputedStyle(document.getElementById("x-social-screen"))
            .getPropertyValue("--x-text-primary")
            .trim() || "#fff";
        badgePath =
          "M12 3l6 6-6 6-6-6 6-6zm0 2.83L8.83 9 12 12.17 15.17 9 12 5.83z";
        break;
      default: // 默认蓝色勾
        badgeColor = "#1d9bf0";
        badgePath =
          "M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z";
        break;
    }
    // 更新徽章颜色和图标
    verifiedBadge.style.fill = badgeColor; // 更新SVG路径
    const pathElement = verifiedBadge.querySelector("path");
    if (pathElement) {
      pathElement.setAttribute("d", badgePath);
    }
    // 添加情侣认证的特殊提示
    if (verificationType === "couple" && userProfileData.coupleCharacterName) {
      verifiedBadge.setAttribute(
        "title",
        `情侣认证 - 与${userProfileData.coupleCharacterName}是情侣关系`
      );
    } else {
      // 设置其他认证类型的提示
      const titles = {
        verified: "已认证账户",
        married: "已婚认证",
        vip: "VIP认证",
        couple: "情侣认证",
      };
      verifiedBadge.setAttribute(
        "title",
        titles[verificationType] || "已认证账户"
      );
    }
  }
  // 为角色设置情侣认证
  async function setCoupleVerificationForCharacter(
    characterId,
    userNameAsCouple
  ) {
    try {
      const db = getXDB(); // 获取角色的X资料
      let xProfile = await db.xCharacterProfiles.get(characterId);
      if (xProfile) {
        // 为角色设置情侣认证
        xProfile.xVerified = true;
        xProfile.verificationType = "couple";
        xProfile.couplePartnerName = userNameAsCouple; // 保存更新
        await db.xCharacterProfiles.put(xProfile);
        console.log(
          `已为角色 ${xProfile.xName} 设置情侣认证，情侣对象: ${userNameAsCouple}`
        );
      }
    } catch (error) {
      console.error("为角色设置情侣认证失败:", error);
    }
  }
  // 同步用户头像到所有位置
  function syncUserAvatar(newAvatarUrl) {
    userProfileData.avatar = newAvatarUrl; // 更新所有头像位置
    const avatarSelectors = [
      "#top-bar-avatar",
      "#x-profile-main-avatar",
      ".comment-input-area img",
      "#comment-user-avatar",
      "#detail-comment-user-avatar",
      "#compose-user-avatar",
      "#live-page-user-avatar", // 添加直播页面头像
    ];
    avatarSelectors.forEach((selector) => {
      const element = document.querySelector(selector);
      if (element) {
        element.src = newAvatarUrl;
      }
    }); // 更新所有回复输入框头像
    document.querySelectorAll(".reply-user-avatar").forEach((avatar) => {
      avatar.src = newAvatarUrl;
    }); // 更新用户发布的评论中的头像
    document
      .querySelectorAll(
        '.comment-item img[alt="我"], .comment-item img[alt="Your avatar"]'
      )
      .forEach((img) => {
        img.src = newAvatarUrl;
      });
  }
  // 渲染用户的推文到主页
  function renderUserTweets() {
    const container = document.getElementById("x-profile-tweets-container");
    if (!container) return; // 获取用户发布的推文（这里简化为空，实际应该从数据中筛选）
    const userTweets = [];
    if (userTweets.length === 0) {
      container.innerHTML = `
 <div style="padding: 60px 32px; text-align: center;">
 <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;">还没有发帖</div>
 <div style="color: #71767b; font-size: 15px;">当你发布推文时，它们会显示在这里。</div>
 </div>
 `;
    } else {
      container.innerHTML = "";
      userTweets.forEach((tweet) => {
        const tweetElement = createTweetElement(tweet);
        container.appendChild(tweetElement);
      });
    }
    // 更新帖子数量
    const headerCount = document.getElementById("x-profile-header-count");
    if (headerCount) {
      headerCount.textContent = `${userTweets.length} 帖子`;
    }
  }
  // ============================================
  // 粉丝数动态浮动系统
  // ============================================
  let followersFluctuationTimer = null; // 启动粉丝数浮动系统
  function startFollowersFluctuationSystem() {
    if (followersFluctuationTimer) {
      clearInterval(followersFluctuationTimer);
    }
    console.log("📊 [粉丝数浮动] 系统已启动"); // 立即执行一次
    setTimeout(() => {
      triggerFollowersFluctuation();
    }, 5000); // 5秒后首次触发
    // 设置随机间隔触发（10-30分钟）
    const scheduleNext = () => {
      const randomInterval = (10 + Math.random() * 20) * 60 * 1000; // 10-30分钟
      console.log(
        `📊 [粉丝数浮动] 下次触发时间: ${(randomInterval / 60000).toFixed(
          1
        )}分钟后`
      );
      followersFluctuationTimer = setTimeout(() => {
        triggerFollowersFluctuation();
        scheduleNext(); // 递归调度下一次
      }, randomInterval);
    };
    scheduleNext();
  }
  // 停止粉丝数浮动系统
  function stopFollowersFluctuationSystem() {
    if (followersFluctuationTimer) {
      clearTimeout(followersFluctuationTimer);
      followersFluctuationTimer = null;
      console.log("📊 [粉丝数浮动] 系统已停止");
    }
  }
  // 触发粉丝数浮动
  async function triggerFollowersFluctuation() {
    try {
      console.log("📊 [粉丝数浮动] 开始检查所有账户..."); // 1. 更新用户主账户粉丝数
      await updateUserFollowersCount(); // 2. 更新所有已绑定角色的粉丝数
      await updateAllCharactersFollowersCount();
      console.log("✅ [粉丝数浮动] 所有账户粉丝数已更新");
    } catch (error) {
      console.error("❌ [粉丝数浮动] 触发失败:", error);
    }
  }
  // 更新用户主账户粉丝数
  async function updateUserFollowersCount() {
    try {
      const xDb = getXDB(); // 获取用户最近3条推文
      const userTweetsId = `userTweets_${currentAccountId || "main"}`;
      const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
      const recentTweets = userTweetsData?.tweets?.slice(0, 3) || []; // 解析当前粉丝数
      const originalFollowersStr = window.userProfileData.followers || "0";
      const currentFollowersNum = parseFollowersCount(originalFollowersStr); // 计算浮动
      const fluctuation = calculateFollowersFluctuation({
        publicIdentity: window.userProfileData.publicIdentity || "",
        bio: window.userProfileData.bio || "",
        recentTweets: recentTweets,
        currentFollowers: currentFollowersNum,
      });
      if (fluctuation === 0) {
        console.log("📊 [用户粉丝数] 本次无变化");
        return;
      }
      // 计算新粉丝数并格式化
      const newFollowersNum = Math.max(0, currentFollowersNum + fluctuation);
      const newFollowersStr = formatFollowersCount(
        newFollowersNum,
        originalFollowersStr
      );
      window.userProfileData.followers = newFollowersStr;
      window.userProfileData.followersCount = newFollowersStr; // 同步更新
      window.userProfileData.lastUpdated = new Date().toISOString(); // 保存到数据库
      await xDb.xUserProfile.put({
        id: currentAccountId || "main",
        ...window.userProfileData,
      }); // 更新UI
      const followersElement = document.getElementById(
        "x-profile-followers-count"
      );
      if (followersElement) {
        followersElement.textContent = newFollowersStr;
      }
      console.log(
        `📊 [用户粉丝数] ${
          fluctuation > 0 ? "+" : ""
        }${fluctuation} (${originalFollowersStr} → ${newFollowersStr})`
      ); // 显示通知（仅大幅变化时）
      if (Math.abs(fluctuation) >= 50) {
        const isEnglish = currentLanguage === "en";
        showPhoneNotification({
          title: "X",
          message: isEnglish
            ? `Followers ${
                fluctuation > 0 ? "increased" : "decreased"
              } by ${Math.abs(fluctuation)}`
            : `粉丝数${fluctuation > 0 ? "增加" : "减少"}了 ${Math.abs(
                fluctuation
              )}`,
          leftIcon: "x",
          duration: 3000,
        });
      }
    } catch (error) {
      console.error("❌ [用户粉丝数] 更新失败:", error);
    }
  }
  // 更新所有已绑定角色的粉丝数
  async function updateAllCharactersFollowersCount() {
    try {
      const xDb = getXDB(); // 获取所有角色X资料
      const allCharacterProfiles = await xDb.xCharacterProfiles.toArray();
      if (allCharacterProfiles.length === 0) {
        console.log("📊 [角色粉丝数] 无已绑定角色");
        return;
      }
      console.log(`📊 [角色粉丝数] 检查 ${allCharacterProfiles.length} 个角色`);
      for (const xProfile of allCharacterProfiles) {
        // 跳过没有设置粉丝数的角色
        if (!xProfile.followersCount || xProfile.followersCount === "") {
          continue;
        }
        // 获取角色的账户主页数据（如果有）
        const cleanHandle = xProfile.xHandle.replace("@", "");
        const accountProfile = await xDb.xAccountProfiles.get(cleanHandle);
        const recentTweets = accountProfile?.tweets?.slice(0, 3) || []; // 解析当前粉丝数
        const originalFollowersStr = xProfile.followersCount;
        const currentFollowersNum = parseFollowersCount(originalFollowersStr); // 计算浮动
        const fluctuation = calculateFollowersFluctuation({
          publicIdentity: xProfile.publicIdentity || "",
          bio: xProfile.xBio || "",
          recentTweets: recentTweets,
          currentFollowers: currentFollowersNum,
        });
        if (fluctuation === 0) {
          continue;
        }
        // 计算新粉丝数并格式化
        const newFollowersNum = Math.max(0, currentFollowersNum + fluctuation);
        const newFollowersStr = formatFollowersCount(
          newFollowersNum,
          originalFollowersStr
        );
        xProfile.followersCount = newFollowersStr; // 保存到数据库
        await xDb.xCharacterProfiles.put(xProfile);
        console.log(
          `📊 [角色粉丝数] ${xProfile.xName}: ${
            fluctuation > 0 ? "+" : ""
          }${fluctuation} (${originalFollowersStr} → ${newFollowersStr})`
        ); // 同步更新账户主页数据（如果存在）
        if (accountProfile) {
          accountProfile.accountInfo.followersCount = newFollowersStr;
          await xDb.xAccountProfiles.put(accountProfile);
          console.log(` └─ 已同步到账户主页 ${cleanHandle}`);
        }
      }
    } catch (error) {
      console.error("❌ [角色粉丝数] 更新失败:", error);
    }
  }
  // 解析粉丝数字符串为数字
  function parseFollowersCount(followersStr) {
    if (!followersStr || followersStr === "") return 0;
    const str = followersStr.toString().toLowerCase().trim(); // 处理 "k" 格式（千）
    if (str.includes("k")) {
      const num = parseFloat(str.replace("k", ""));
      return Math.round(num * 1000);
    }
    // 处理 "w" 格式（万）
    if (str.includes("w")) {
      const num = parseFloat(str.replace("w", ""));
      return Math.round(num * 10000);
    }
    // 处理 "m" 格式（百万）
    if (str.includes("m")) {
      const num = parseFloat(str.replace("m", ""));
      return Math.round(num * 1000000);
    }
    // 纯数字
    const num = parseInt(str);
    return isNaN(num) ? 0 : num;
  }
  // 格式化粉丝数为字符串（智能选择格式）
  function formatFollowersCount(count, originalFormat = "") {
    if (count === 0) return "0"; // 检测原始格式偏好
    const originalLower = originalFormat.toString().toLowerCase();
    const usesK = originalLower.includes("k");
    const usesW = originalLower.includes("w");
    const usesM = originalLower.includes("m"); // 如果原始是 "w" 格式，优先使用 "w"
    if (usesW) {
      if (count >= 10000) {
        const wValue = count / 10000; // 保留一位小数，但去掉不必要的 .0
        return wValue % 1 === 0
          ? `${Math.round(wValue)}w`
          : `${wValue.toFixed(1)}w`;
      }
      // 小于1w的情况，显示纯数字
      return count.toString();
    }
    // 如果原始是 "m" 格式，优先使用 "m"
    if (usesM) {
      if (count >= 1000000) {
        const mValue = count / 1000000;
        return mValue % 1 === 0
          ? `${Math.round(mValue)}m`
          : `${mValue.toFixed(1)}m`;
      } else if (count >= 1000) {
        const kValue = count / 1000;
        return kValue % 1 === 0
          ? `${Math.round(kValue)}k`
          : `${kValue.toFixed(1)}k`;
      }
      return count.toString();
    }
    // 如果原始是 "k" 格式或没有特定格式，使用国际通用格式（k、m）
    if (usesK || !usesW) {
      if (count >= 1000000) {
        const mValue = count / 1000000;
        return mValue % 1 === 0
          ? `${Math.round(mValue)}m`
          : `${mValue.toFixed(1)}m`;
      } else if (count >= 1000) {
        const kValue = count / 1000;
        return kValue % 1 === 0
          ? `${Math.round(kValue)}k`
          : `${kValue.toFixed(1)}k`;
      }
    }
    // 小于1000，显示纯数字
    return count.toString();
  }
  // 计算粉丝数浮动
  function calculateFollowersFluctuation({
    publicIdentity,
    bio,
    recentTweets,
    currentFollowers,
  }) {
    // 1. 检测身份类型
    const isHighExposure =
      /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
        publicIdentity + " " + bio
      ); // 2. 分析最近推文质量
    let tweetQualityScore = 0; // -1到1之间
    if (recentTweets.length > 0) {
      let totalScore = 0;
      recentTweets.forEach((tweet) => {
        const stats = tweet.stats || {};
        const likes = stats.likes || 0;
        const retweets = stats.retweets || 0;
        const comments = stats.comments || 0;
        const views = stats.views || 0; // 计算互动率（相对于浏览量）
        const engagementRate =
          views > 0 ? (likes + retweets * 2 + comments * 3) / views : 0; // 根据互动率评分
        if (engagementRate > 0.1) {
          totalScore += 1; // 高互动
        } else if (engagementRate > 0.05) {
          totalScore += 0.5; // 中等互动
        } else if (engagementRate > 0.02) {
          totalScore += 0; // 低互动，中性
        } else {
          totalScore -= 0.5; // 极低互动
        }
      });
      tweetQualityScore = totalScore / recentTweets.length;
    }
    console.log(
      ` 📊 推文质量评分: ${tweetQualityScore.toFixed(2)} (${
        recentTweets.length
      }条推文)`
    ); // 3. 确定浮动方向和幅度
    let baseFluctuation = 0;
    let direction = 1; // 1为增长，-1为下降
    // 根据推文质量决定方向概率
    if (tweetQualityScore > 0.5) {
      // 高质量推文：80%增长
      direction = Math.random() < 0.8 ? 1 : -1;
    } else if (tweetQualityScore > 0) {
      // 中等质量：70%增长
      direction = Math.random() < 0.7 ? 1 : -1;
    } else if (tweetQualityScore > -0.5) {
      // 低质量：50%增长（随机波动）
      direction = Math.random() < 0.5 ? 1 : -1;
    } else {
      // 极低质量：30%增长，70%下降
      direction = Math.random() < 0.3 ? 1 : -1;
    }
    // 4. 根据身份和推文情况确定浮动幅度
    if (isHighExposure) {
      // 高曝光身份：大幅浮动
      if (recentTweets.length > 0) {
        baseFluctuation = 100 + Math.random() * 400; // 100-500
      } else {
        baseFluctuation = 50 + Math.random() * 150; // 50-200（无推文时较小）
      }
    } else if (recentTweets.length > 0) {
      // 有推文的普通用户：中等浮动
      baseFluctuation = 20 + Math.random() * 80; // 20-100
    } else {
      // 无推文的普通用户：小幅浮动
      baseFluctuation = 5 + Math.random() * 25; // 5-30
    }
    // 5. 根据推文质量调整幅度
    const qualityMultiplier = 0.5 + Math.abs(tweetQualityScore) * 0.8; // 0.5-1.3倍
    baseFluctuation *= qualityMultiplier; // 6. 根据当前粉丝基数调整（粉丝越多，浮动越大）
    if (currentFollowers > 10000) {
      baseFluctuation *= 1.5;
    } else if (currentFollowers > 5000) {
      baseFluctuation *= 1.2;
    }
    // 7. 随机决定是否触发浮动（60%概率）
    if (Math.random() > 0.6) {
      console.log(" 📊 本次随机跳过浮动");
      return 0;
    }
    // 8. 计算最终浮动值
    const finalFluctuation = Math.round(baseFluctuation * direction);
    console.log(
      ` 📊 浮动计算: ${isHighExposure ? "高曝光" : "普通"}身份, 方向${
        direction > 0 ? "↑" : "↓"
      }, 幅度${Math.abs(finalFluctuation)}`
    );
    return finalFluctuation;
  }
  // ============================================
  // 离开后自动消息触发系统
  // ============================================
  // 触发离开后的自动消息（仅绑定角色）
  window.triggerAutoMessageAfterAway = async function (messageId) {
    try {
      console.log("⏰ [离开后自动消息] 开始触发，messageId:", messageId);
      const xDb = getXDB();
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${messageId}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (!savedConversation) {
        console.log("⚠️ [离开后自动消息] 未找到对话数据");
        return;
      }
      // 检查是否仍然处于离开状态
      if (!savedConversation.isAway) {
        console.log("⚠️ [离开后自动消息] 对话已不再处于离开状态");
        return;
      }
      // 检查离开时间是否已到
      const now = new Date();
      const awayUntil = new Date(savedConversation.awayUntil);
      if (now < awayUntil) {
        console.log("⚠️ [离开后自动消息] 离开时间尚未结束");
        return;
      }
      // 清除离开状态
      savedConversation.isAway = false;
      delete savedConversation.awayUntil;
      delete savedConversation.awayDuration;
      await xDb.xAccountProfiles.put(savedConversation);
      console.log("✅ [离开后自动消息] 已清除离开状态"); // 检查是否是绑定角色
      const isCharacterMessage =
        messageId && messageId.startsWith("msg_") && messageId !== "msg_001";
      if (!isCharacterMessage) {
        console.log("⚠️ [离开后自动消息] 不是绑定角色，跳过");
        return;
      }
      // 🔍 获取角色信息（从xCharacterProfiles或从对话数据中）
      let userName = "未知";
      let userHandle = "@unknown";
      let userAvatar = "";
      try {
        const characterId = messageId.replace("msg_", "");
        const xProfile = await xDb.xCharacterProfiles.get(characterId);
        if (xProfile) {
          userName = xProfile.xName;
          userHandle = xProfile.xHandle;
          userAvatar = xProfile.xAvatar;
          console.log(
            `✅ [离开后自动消息] 从xCharacterProfiles获取角色信息: ${userName}`
          );
        } else if (
          savedConversation.data &&
          savedConversation.data.senderProfile
        ) {
          // 从对话数据中获取
          userName = savedConversation.data.senderProfile.name || "未知";
          userHandle =
            savedConversation.data.senderProfile.handle || "@unknown";
          userAvatar = savedConversation.data.senderProfile.avatar || "";
          console.log(
            `✅ [离开后自动消息] 从senderProfile获取角色信息: ${userName}`
          );
        } else if (savedConversation.data && savedConversation.data.user) {
          // 兼容旧格式
          userName = savedConversation.data.user.name || "未知";
          userHandle = savedConversation.data.user.handle || "@unknown";
          userAvatar = savedConversation.data.user.avatar || "";
          console.log(`✅ [离开后自动消息] 从user获取角色信息: ${userName}`);
        }
      } catch (error) {
        console.error("❌ [离开后自动消息] 获取角色信息失败:", error);
      }
      // 构建消息数据
      const messageData = {
        id: messageId,
        user: {
          name: userName,
          handle: userHandle,
          avatar: userAvatar,
        },
      }; // 调用AI生成离开后的主动消息
      console.log("📤 [离开后自动消息] 开始生成AI主动消息");
      const aiMessages = await generateMessageConversation(messageData, true, {
        isAutoMessage: true,
        timeSinceLastMessage: savedConversation.awayDuration * 60 || 3600, // 使用离开时长作为时间间隔
        isAwayReturn: true, // 标记为离开后返回
      });
      if (aiMessages && aiMessages.length > 0) {
        // 保存AI消息到数据库
        const updatedConversation = await xDb.xAccountProfiles.get(
          conversationId
        );
        if (
          updatedConversation &&
          updatedConversation.data &&
          updatedConversation.data.messages
        ) {
          updatedConversation.data.messages.push(...aiMessages);
          await xDb.xAccountProfiles.put(updatedConversation);
          console.log("✅ [离开后自动消息] AI消息已保存");
        }
        // 标记为未读并显示通知
        const dataId = `messagesList_${currentAccountId || "main"}`;
        const savedData = await xDb.xAccountProfiles.get(dataId);
        if (savedData && savedData.data) {
          const messagesList = savedData.data;
          const messageIndex = messagesList.findIndex(
            (msg) => msg.id === messageId
          );
          if (messageIndex !== -1) {
            messagesList[messageIndex].unread = true;
            messagesList[messageIndex].unreadCount =
              (messagesList[messageIndex].unreadCount || 0) + aiMessages.length;
            await xDb.xAccountProfiles.put({
              handle: dataId,
              name: "messagesList",
              data: messagesList,
              updatedAt: new Date().toISOString(),
            }); // 同步更新全局数据
            sampleMessagesData = messagesList; // 显示手机样式通知
            showMessageNotification(
              messageData.user.name,
              messageData.user.avatar,
              aiMessages.length
            ); // 显示私信提醒点
            showNavNotificationDot("messages");
            console.log("✅ [离开后自动消息] 已标记为未读并显示提醒");
          }
        }
      } else {
        console.log("⚠️ [离开后自动消息] AI未生成消息");
      }
    } catch (error) {
      console.error("❌ [离开后自动消息] 触发失败:", error);
    }
  }; // 多账户管理功能
  // 当前激活的账户ID - 使用全局变量确保所有地方都能访问
  window.currentAccountId = window.currentAccountId || "main";
  let currentAccountId = window.currentAccountId; // 切换个人主页菜单
  function toggleProfileMenu() {
    const menu = document.getElementById("profile-dropdown-menu");
    const isVisible = menu.style.display !== "none";
    if (isVisible) {
      menu.style.display = "none";
    } else {
      menu.style.display = "block";
    }
  }
  // 点击其他地方关闭菜单
  document.addEventListener("click", function (event) {
    const menuBtn = document.getElementById("profile-menu-btn");
    const menu = document.getElementById("profile-dropdown-menu");
    if (!menuBtn || !menu) return;
    if (!menuBtn.contains(event.target) && !menu.contains(event.target)) {
      menu.style.display = "none";
    }
  }); // 打开账号管理弹窗
  async function openAccountManager() {
    // 关闭下拉菜单
    document.getElementById("profile-dropdown-menu").style.display = "none"; // 显示账号管理弹窗
    showAccountManagerModal();
  }
  // 显示账号管理弹窗
  async function showAccountManagerModal() {
    // 获取所有账户
    const accounts = await getAllAccounts(); // 创建弹窗
    const modal = document.createElement("div");
    modal.id = "account-manager-modal";
    modal.style.cssText = `
 position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10000; backdrop-filter: blur(4px); `;
    modal.innerHTML = `
 <div style="background-color: #1a1a1a; border-radius: 16px; width: 90%; max-width: 480px; max-height: 70vh; overflow-y: auto; border: 1px solid #333; position: relative; ">

 <div style="padding: 20px; border-bottom: 1px solid #333; display: flex; align-items: center; justify-content: space-between; position: sticky; top: 0; background-color: #1a1a1a; z-index: 10; ">
 <div>
 <h3 style="margin: 0; color: #fff; font-size: 20px; font-weight: 700;">账号管理</h3>
 <p style="margin: 4px 0 0; color: #71767b; font-size: 14px;">管理你的多个X账户</p>
 </div>
 <button onclick="closeAccountManager()" style="background: transparent; border: none; color: #71767b; cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </button>
 </div>

 <div style="padding: 20px;">
 <div id="accounts-list" style="margin-bottom: 20px;">
 ${await renderAccountsList(accounts)}
 </div>

 <button onclick="createNewAccount()" style="width: 100%; background-color: var(--x-accent); color: #fff; border: none; border-radius: 12px; padding: 16px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 8px; " onmouseover="this.style.backgroundColor='#1a8cd8'"
 onmouseout="this.style.backgroundColor='var(--x-accent)'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
 <g><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></g>
 </svg>
 新建账户
 </button>
 </div>
 </div>
 `;
    document.body.appendChild(modal);
    document.body.style.overflow = "hidden"; // 点击背景关闭弹窗
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        closeAccountManager();
      }
    });
  }
  // 获取所有账户
  async function getAllAccounts() {
    try {
      const db = getXDB();
      const accounts = await db.xAccountList.orderBy("createdAt").toArray();
      const activeAccount = await db.xActiveAccount.get("current"); // 如果没有账户记录，创建默认账户
      if (accounts.length === 0) {
        const defaultAccount = {
          accountId: "main",
          name: userProfileData.name || "我",
          avatar:
            userProfileData.avatar ||
            "https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg",
          createdAt: new Date().toISOString(),
          isActive: true,
        };
        await db.xAccountList.put(defaultAccount);
        await db.xActiveAccount.put({ id: "current", accountId: "main" });
        return [defaultAccount];
      }
      // 标记当前激活的账户
      accounts.forEach((account) => {
        account.isActive =
          activeAccount && activeAccount.accountId === account.accountId;
      });
      return accounts;
    } catch (error) {
      console.error("获取账户列表失败:", error);
      return [];
    }
  }
  // 渲染账户列表
  async function renderAccountsList(accounts) {
    if (accounts.length === 0) {
      return `
 <div style="text-align: center; color: #71767b; padding: 40px 20px;">
 <div style="font-size: 16px; margin-bottom: 8px;">暂无账户</div>
 <div style="font-size: 14px;">创建你的第一个账户</div>
 </div>
 `;
    }
    return accounts
      .map(
        (account) => `
 <div style="border: 2px solid ${
   account.isActive ? "var(--x-accent)" : "#333"
 }; border-radius: 12px; padding: 16px; margin-bottom: 12px; cursor: pointer; transition: all 0.2s; background-color: ${
          account.isActive
            ? "color-mix(in srgb, var(--x-accent) , 0.05)"
            : "transparent"
        }; " onclick="switchAccount('${account.accountId}')"
 onmouseover="if (!${account.isActive}) this.style.borderColor='#536471'"
 onmouseout="if (!${account.isActive}) this.style.borderColor='#333'">
 <div style="display: flex; align-items: center; gap: 12px;">
 <img src="${
   account.avatar
 }" style="width: 48px; height: 48px; border-radius: 50%;" alt="${
          account.name
        }">
 <div style="flex: 1;">
 <div style="color: #fff; font-size: 16px; font-weight: 700; margin-bottom: 4px;">
 ${account.name}
 ${
   account.isActive
     ? '<span style="color: var(--x-accent); font-size: 12px; margin-left: 8px;">● 当前账户</span>'
     : ""
 }
 </div>
 <div style="color: #71767b; font-size: 14px;">
 创建于 ${new Date(account.createdAt).toLocaleDateString("zh-CN")}
 </div>
 </div>
 ${
   !account.isActive && account.accountId !== "main"
     ? `
 <button onclick="event.stopPropagation(); deleteAccount('${account.accountId}')" style="background: transparent; border: 1px solid #ef4444; color: #ef4444; border-radius: 8px; padding: 6px 8px; font-size: 12px; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='rgba(239, 68, 68, 0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 删除
 </button>
 `
     : ""
 }
 </div>
 </div>
 `
      )
      .join("");
  }
  // 关闭账号管理弹窗
  function closeAccountManager() {
    const modal = document.getElementById("account-manager-modal");
    if (modal) {
      modal.remove();
    }
    document.body.style.overflow = "auto";
  }
  // 切换账户
  async function switchAccount(accountId) {
    if (accountId === currentAccountId) {
      closeAccountManager();
      return;
    }
    try {
      // 先停止当前账户的聊天记忆检测服务
      if (chatHistoryDetectionTimer) {
        clearInterval(chatHistoryDetectionTimer);
        chatHistoryDetectionTimer = null;
        chatHistoryDetectionEnabled = false;
      }
      const db = getXDB(); // 更新激活账户记录
      await db.xActiveAccount.put({ id: "current", accountId: accountId }); // 更新当前账户ID（同步到全局和局部）
      currentAccountId = accountId;
      window.currentAccountId = accountId; // 加载新账户的数据
      await loadUserProfileFromDB(accountId); // 重新加载 X 设置（按账号加载）
      await initializeXSettings(); // 更新UI显示
      loadUserProfileToUI(); // 同步头像到所有位置
      syncUserAvatar(userProfileData.avatar); // 重新加载个人主页推文（按账户隔离）
      if (document.getElementById("x-profile-page").style.display !== "none") {
        loadUserProfileTweets();
      }
      // 重新加载提问箱数据（按账户隔离）- 无论是否在提问箱页面都要加载
      await loadAskboxDataFromDB(); // 如果当前正在提问箱页面，立即更新UI
      if (document.getElementById("x-askbox-page").style.display !== "none") {
        await loadAskboxData();
      }
      // 更新发帖弹窗的用户信息
      const composeAvatar = document.getElementById("compose-user-avatar");
      if (composeAvatar) {
        composeAvatar.src = userProfileData.avatar;
      }
      // 重新加载主题色偏好（按账户隔离）
      await loadAccentColorPreference(); // 🔧 重新加载钱包数据（按账户隔离）
      await loadWalletData(); // 🔧 重新加载私信和通知数据（按账户隔离）
      // 如果当前在私信页面，重新加载私信列表
      const messagesPage = document.getElementById("x-messages-page");
      if (messagesPage && messagesPage.style.display === "flex") {
        await loadMessagesList();
      }
      // 如果当前在通知页面，重新加载通知
      const notificationsPage = document.getElementById("x-notifications-page");
      if (notificationsPage && notificationsPage.style.display === "flex") {
        await loadNotifications();
      }
      // 关闭弹窗
      closeAccountManager();
      showXToast(`已切换到账户：${userProfileData.name}`, "success");
      console.log(
        "✅ 已切换账户，绑定角色数:",
        xSettingsData.boundCharacters?.length || 0
      );
    } catch (error) {
      console.error("切换账户失败:", error);
      showXToast("切换账户失败", "error");
    }
  }
  // 创建新账户
  async function createNewAccount() {
    try {
      const db = getXDB(); // 生成新的账户ID
      const newAccountId = "account_" + Date.now(); // 使用统一的默认用户资料配置
      const defaultProfile = getDefaultUserProfile(newAccountId); // 保存新账户的用户资料
      await db.xUserProfile.put(defaultProfile); // 添加到账户列表
      const newAccount = {
        accountId: newAccountId,
        name: "新用户",
        avatar: "https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg",
        createdAt: new Date().toISOString(),
      };
      await db.xAccountList.put(newAccount); // 为新账户创建空的提问箱数据
      const askboxId = `askbox_${newAccountId}`;
      await db.xAskbox.put({
        id: askboxId,
        avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
        nickname: "= =",
        prompt: "请向我匿名提问!waiting...",
        background: "https://i.postimg.cc/7LqVqxt4/mmexport1759588659314.jpg",
        answeredQuestions: [], // 新账户必须从空列表开始
      });
      console.log("✅ 已为新账户创建空提问箱:", newAccountId); // 自动切换到新账户
      await switchAccount(newAccountId);
    } catch (error) {
      console.error("创建新账户失败:", error);
      showXToast("创建新账户失败", "error");
    }
  }
  // 删除账户
  async function deleteAccount(accountId) {
    if (accountId === "main") {
      showXToast("无法删除默认账户", "error");
      return;
    }
    if (!confirm("确定要删除这个账户吗？此操作无法撤销。")) {
      return;
    }
    try {
      const db = getXDB(); // 删除账户的用户资料
      await db.xUserProfile.delete(accountId); // 从账户列表中删除
      await db.xAccountList.delete(accountId); // 删除账户的提问箱数据
      const askboxId = `askbox_${accountId}`;
      await db.xAskbox.delete(askboxId); // 🔧 删除账户的私信和通知数据
      // 删除私信列表
      const messagesListId = `messagesList_${accountId}`;
      await db.xAccountProfiles.delete(messagesListId); // 删除陌生人私信
      const strangerMessagesId = `strangerMessages_${accountId}`;
      await db.xAccountProfiles.delete(strangerMessagesId); // 删除Mentions通知
      const mentionsId = `mentions_${accountId}`;
      await db.xAccountProfiles.delete(mentionsId); // 删除所有该账户的私信对话数据
      const allConversations = await db.xAccountProfiles
        .where("name")
        .equals("messageConversation")
        .toArray();
      for (const conv of allConversations) {
        if (
          conv.accountId === accountId ||
          conv.handle.startsWith(`messageConversation_${accountId}_`)
        ) {
          await db.xAccountProfiles.delete(conv.handle);
        }
      }
      // 删除账户的X设置和用户推文
      await db.xSettings.delete(`xSettings_${accountId}`);
      await db.xUserTweets.delete(`userTweets_${accountId}`); // 删除账户的书签数据
      const bookmarks = await db.xBookmarks
        .where("accountId")
        .equals(accountId)
        .toArray();
      for (const bookmark of bookmarks) {
        await db.xBookmarks.delete(bookmark.id);
      }
      // 🔧 删除账户的钱包数据
      const walletId = `wallet_${accountId}`;
      await db.xAccountProfiles.delete(walletId);
      console.log(`✅ 已清理账户 ${accountId} 的所有相关数据`);
      showXToast("账户已删除", "success"); // 重新显示账户管理弹窗
      closeAccountManager();
      setTimeout(() => {
        showAccountManagerModal();
      }, 300);
    } catch (error) {
      console.error("删除账户失败:", error);
      showXToast("删除账户失败", "error");
    }
  }
  // 清空当前账户的提问箱数据（调试用）
  window.clearCurrentAskboxData = async function () {
    try {
      const xDb = getXDB();
      const accountId = currentAccountId || "main";
      const askboxId = `askbox_${accountId}`;
      await xDb.xAskbox.put({
        id: askboxId,
        avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
        nickname: "= =",
        prompt: "请向我匿名提问!waiting...",
        background: "https://i.postimg.cc/7LqVqxt4/mmexport1759588659314.jpg",
        answeredQuestions: [],
      }); // 重新加载数据
      await loadAskboxDataFromDB(); // 如果在提问箱页面，刷新UI
      if (document.getElementById("x-askbox-page").style.display !== "none") {
        renderAnsweredQuestions();
      }
      console.log("✅ 已清空账户提问箱数据:", accountId);
      showXToast("提问箱数据已清空", "success");
    } catch (error) {
      console.error("❌ 清空提问箱数据失败:", error);
      showXToast("清空失败: " + error.message, "error");
    }
  }; // 初始化用户主页
  async function initializeUserProfile() {
    // 首先加载当前激活的账户
    await loadActiveAccount();
    await loadUserProfileFromDB();
    loadUserProfileToUI(); // 同步头像到所有位置
    syncUserAvatar(userProfileData.avatar); // 加载当前账户的推文
    loadUserProfileTweets(); // 🔧 加载钱包数据
    await loadWalletData();
  }
  // 加载当前激活的账户
  async function loadActiveAccount() {
    try {
      const db = getXDB(); // 初始化多账户系统
      await initializeMultiAccountSystem();
      const activeAccount = await db.xActiveAccount.get("current");
      if (activeAccount) {
        currentAccountId = activeAccount.accountId;
        window.currentAccountId = activeAccount.accountId; // 同步到全局
      } else {
        // 如果没有激活账户记录，使用默认账户
        currentAccountId = "main";
        window.currentAccountId = "main"; // 同步到全局
        await db.xActiveAccount.put({ id: "current", accountId: "main" });
      }
      console.log("✅ 已加载激活账户:", currentAccountId);
    } catch (error) {
      console.error("加载激活账户失败:", error);
      currentAccountId = "main";
      window.currentAccountId = "main"; // 同步到全局
    }
  }
  // 初始化多账户系统
  async function initializeMultiAccountSystem() {
    try {
      const db = getXDB(); // 检查是否存在默认账户记录
      const defaultAccount = await db.xAccountList.get("main");
      if (!defaultAccount) {
        // 从现有的用户资料创建默认账户记录
        const existingProfile = await db.xUserProfile.get("main");
        const defaultAccountData = {
          accountId: "main",
          name: existingProfile?.name || "我",
          avatar:
            existingProfile?.avatar ||
            "https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg",
          createdAt: existingProfile?.lastUpdated || new Date().toISOString(),
        };
        await db.xAccountList.put(defaultAccountData);
        console.log("已创建默认账户记录");
      }
      // 确保有激活账户记录
      const activeAccount = await db.xActiveAccount.get("current");
      if (!activeAccount) {
        await db.xActiveAccount.put({ id: "current", accountId: "main" });
        console.log("已设置默认激活账户");
      }
    } catch (error) {
      console.error("初始化多账户系统失败:", error);
    }
  }
  // 从数据库加载用户资料（多账户系统专用）
  async function loadUserProfileFromDB(accountId = null) {
    try {
      const db = getXDB();
      const targetAccountId = accountId || currentAccountId || "main";
      const savedProfile = await db.xUserProfile.get(targetAccountId);
      if (savedProfile) {
        // 更新现有对象的属性（保持引用一致）
        Object.assign(window.userProfileData, savedProfile);
      } else {
        // 如果没有找到用户资料，使用默认值（新账户的情况）
        console.log("⚠️ 未找到账户资料，使用默认值:", targetAccountId);
        const defaultProfile = getDefaultUserProfile(targetAccountId);
        Object.assign(window.userProfileData, defaultProfile);
      }
      // 确保所有必要字段存在（使用统一的字段验证）
      ensureProfileFields(window.userProfileData);
      console.log("✅ 已加载用户资料数据:", targetAccountId);
      if (
        window.userProfileData.knownIdentityCharacters &&
        window.userProfileData.knownIdentityCharacters.length > 0
      ) {
        console.log(
          "📌 已知身份角色数量:",
          window.userProfileData.knownIdentityCharacters.length
        );
      }
    } catch (error) {
      console.error("❌ 加载用户资料失败，使用默认数据:", error);
      const defaultProfile = getDefaultUserProfile("main");
      Object.assign(window.userProfileData, defaultProfile);
    }
  }
  // 保存用户资料到数据库
  async function saveUserProfileToDB() {
    try {
      const db = getXDB();
      const targetAccountId = currentAccountId || "main";
      await db.xUserProfile.put({
        id: targetAccountId,
        ...window.userProfileData, // 使用window.userProfileData确保使用最新数据
        lastUpdated: new Date().toISOString(),
      }); // 同时更新账户列表中的基本信息
      const existingAccount = await db.xAccountList.get(targetAccountId);
      if (existingAccount) {
        existingAccount.name = window.userProfileData.name;
        existingAccount.avatar = window.userProfileData.avatar;
        await db.xAccountList.put(existingAccount);
      }
      console.log("用户资料已保存到数据库，账户ID:", targetAccountId);
      if (
        window.userProfileData.knownIdentityCharacters &&
        window.userProfileData.knownIdentityCharacters.length > 0
      ) {
        console.log(
          "已知身份角色:",
          window.userProfileData.knownIdentityCharacters.length + "个"
        );
      }
    } catch (error) {
      console.error("保存用户资料失败:", error);
      throw error;
    }
  }
  // ============================================
  // 账户钱包功能
  // ============================================
  // 钱包数据
  let walletData = {
    accountId: "main",
    isActivated: false,
    balance: 0,
    currency: "USD",
    transactions: [],
    activatedAt: null,
    initialAmount: 0,
    creditScore: 100, // 信用值，初始100，影响商业转账的接收和发起
  }; // 打开账户钱包
  async function openAccountWallet() {
    // 关闭下拉菜单
    document.getElementById("profile-dropdown-menu").style.display = "none"; // 加载钱包数据
    await loadWalletData(); // 启动商业转账状态检查
    startBusinessTransferCheck(); // 显示钱包弹窗
    showWalletModal();
  }
  // 显示钱包弹窗
  function showWalletModal() {
    const xSocialScreen = document.getElementById("x-social-screen");
    const isLightMode =
      xSocialScreen && xSocialScreen.classList.contains("x-theme-light"); // 创建弹窗遮罩
    const modal = document.createElement("div");
    modal.id = "wallet-modal";
    modal.style.cssText = `
 position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: ${
   isLightMode ? "rgba(255, 255, 255, 0.85)" : "rgba(0, 0, 0, 0.85)"
 }; display: flex; align-items: center; justify-content: center; z-index: 25; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
`; // 创建钱包界面
    modal.innerHTML = `
 <div style="background-color: ${
   isLightMode ? "rgba(255, 255, 255, 0.95)" : "rgba(0, 0, 0, 0.95)"
 }; backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 24px; width: 90%; max-width: 360px; position: relative; overflow: hidden; box-shadow: ${
      isLightMode
        ? "0 20px 60px rgba(0, 0, 0, 0.15), 0 8px 32px rgba(0, 0, 0, 0.1)"
        : "0 20px 60px rgba(0, 0, 0, 0.8), 0 8px 32px rgba(255, 255, 255, 0.05)"
    }; border: 2px solid ${
      isLightMode ? "rgba(0, 0, 0, 0.1)" : "rgba(255, 255, 255, 0.1)"
    }; " onclick="event.stopPropagation()">

 <div style="background: linear-gradient(135deg, ${
   isLightMode ? "rgba(248, 250, 252, 0.8)" : "rgba(22, 24, 28, 0.8)"
 } 0%, ${
      isLightMode ? "rgba(255, 255, 255, 0.6)" : "rgba(0, 0, 0, 0.6)"
    } 100%); padding: 24px; text-align: center; border-bottom: 2px solid ${
      isLightMode ? "rgba(0, 0, 0, 0.08)" : "rgba(255, 255, 255, 0.08)"
    }; position: relative; ">

 <button onclick="closeWalletModal()" style="position: absolute; top: 16px; right: 16px; background: transparent; border: none; color: ${
   isLightMode ? "#536471" : "#71767b"
 }; cursor: pointer; padding: 8px; border-radius: 50%; transition: all 0.2s; " onmouseover="this.style.backgroundColor='${
      isLightMode ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
    }';"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </button>

 <div style="margin-bottom: 16px;">
 <img src="${
   window.userProfileData?.avatar || userProfileData.avatar
 }" style="width: 64px; height: 64px; border-radius: 50%; border: 3px solid var(--x-accent); object-fit: cover; " alt="${
      window.userProfileData?.name || userProfileData.name
    }">
 </div>

 <div style="color: ${
   isLightMode ? "#0f1419" : "#ffffff"
 }; font-size: 18px; font-weight: 700; margin-bottom: 4px; ">${
      window.userProfileData?.name || userProfileData.name
    }</div>

 <div style="color: ${
   isLightMode ? "#536471" : "#71767b"
 }; font-size: 14px; margin-bottom: 16px; ">Digital Wallet</div>

 <div id="wallet-status" style="display: inline-block; padding: 8px 16px; border-radius: 20px; font-size: 12px; font-weight: 700; letter-spacing: 1px; ${
   walletData.isActivated
     ? "background-color: rgba(34, 197, 94, 0.15); color: #22c55e; border: 2px solid rgba(34, 197, 94, 0.4);"
     : `background-color: ${
         isLightMode ? "rgba(156, 163, 175, 0.15)" : "rgba(156, 163, 175, 0.1)"
       }; color: ${isLightMode ? "#6b7280" : "#9ca3af"}; border: 2px solid ${
         isLightMode ? "rgba(156, 163, 175, 0.3)" : "rgba(156, 163, 175, 0.2)"
       };`
 }
 ">${walletData.isActivated ? "ACTIVATED" : "INACTIVE"}</div>
 </div>

 <div style="padding: 24px; background-color: ${
   isLightMode ? "rgba(255, 255, 255, 0.3)" : "rgba(0, 0, 0, 0.3)"
 }; ">
 ${
   walletData.isActivated
     ? renderActivatedWallet(isLightMode)
     : renderInactiveWallet(isLightMode)
 }
 </div>

 <div style="display: flex; justify-content: center; align-items: center; padding: 16px 24px; gap: 24px; border-top: 2px solid ${
   isLightMode ? "rgba(0, 0, 0, 0.08)" : "rgba(255, 255, 255, 0.08)"
 }; background-color: ${
      isLightMode ? "rgba(248, 250, 252, 0.5)" : "rgba(22, 24, 28, 0.5)"
    }; ">
 <div onclick="openBusinessTransferManager()" style="padding: 12px; border-radius: 50%; cursor: pointer; transition: all 0.2s; color: ${
   isLightMode ? "#536471" : "#71767b"
 }; " onmouseover="this.style.backgroundColor='${
      isLightMode ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
    }'; this.style.color='var(--x-accent)';"
 onmouseout="this.style.backgroundColor='transparent'; this.style.color='${
   isLightMode ? "#536471" : "#71767b"
 }';" title="商业转账管理">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
 <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path><path d="M12 10L14.5 14L17 10L14.5 12L12 10ZM10 10L7.5 12L10 14L7.5 14L10 10Z"></path></g>
 </svg>
 </div>
 <div onclick="exportWallet()" style="padding: 12px; border-radius: 50%; cursor: pointer; transition: all 0.2s; color: ${
   isLightMode ? "#536471" : "#71767b"
 }; " onmouseover="this.style.backgroundColor='${
      isLightMode ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
    }'; this.style.color='var(--x-accent)';"
 onmouseout="this.style.backgroundColor='transparent'; this.style.color='${
   isLightMode ? "#536471" : "#71767b"
 }';" title="导出钱包">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
 <g><path d="M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2v9.67z"></path></g>
 </svg>
 </div>
 <div onclick="copyWalletInfo()" style="padding: 12px; border-radius: 50%; cursor: pointer; transition: all 0.2s; color: ${
   isLightMode ? "#536471" : "#71767b"
 }; " onmouseover="this.style.backgroundColor='${
      isLightMode ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
    }'; this.style.color='var(--x-accent)';"
 onmouseout="this.style.backgroundColor='transparent'; this.style.color='${
   isLightMode ? "#536471" : "#71767b"
 }';" title="复制钱包信息">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
 <g><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></g>
 </svg>
 </div>
 </div>
 </div>
`;
    document.body.appendChild(modal);
    document.body.style.overflow = "hidden"; // 点击背景关闭弹窗
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        closeWalletModal();
      }
    }); // 添加入场动画
    const walletCard = modal.querySelector("div");
    walletCard.style.transform = "scale(0.8) translateY(20px)";
    walletCard.style.opacity = "0";
    requestAnimationFrame(() => {
      walletCard.style.transition = "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)";
      walletCard.style.transform = "scale(1) translateY(0)";
      walletCard.style.opacity = "1";
    });
  }
  // 渲染未激活钱包界面
  function renderInactiveWallet(isLightMode = false) {
    return `
 <div style="text-align: center;">

 <div style="width: 80px; height: 80px; margin: 0 auto 20px; background: linear-gradient(135deg, ${
   isLightMode ? "rgba(248, 250, 252, 0.8)" : "rgba(22, 24, 28, 0.8)"
 } 0%, ${
      isLightMode ? "rgba(229, 231, 235, 0.6)" : "rgba(55, 65, 81, 0.6)"
    } 100%); border-radius: 16px; display: flex; align-items: center; justify-content: center; border: 2px solid ${
      isLightMode ? "rgba(0, 0, 0, 0.1)" : "rgba(255, 255, 255, 0.1)"
    }; ">
 <svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${
   isLightMode ? "#6b7280" : "#9ca3af"
 };">
 <g><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></g>
 </svg>
 </div>

 <div style="color: ${
   isLightMode ? "#0f1419" : "#ffffff"
 }; font-size: 16px; font-weight: 600; margin-bottom: 8px; ">激活你的数字钱包</div>
 <div style="color: ${
   isLightMode ? "#536471" : "#71767b"
 }; font-size: 14px; line-height: 1.5; margin-bottom: 24px; ">点击下方按钮激活钱包<br>初始金额将根据你的公众身份随机生成</div>

 <button id="activate-wallet-btn" onclick="activateWallet()" style="width: 100%; background: linear-gradient(135deg, var(--x-accent) 0%, #1a8cd8 100%); color: #fff; border: none; border-radius: 12px; padding: 16px 24px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.3s; position: relative; overflow: hidden; " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(29, 155, 240, 0.3)'"
 onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
 <span id="activate-btn-text">🚀 激活钱包</span>
 <div id="activate-btn-loader" style="display: none;">
 <svg style="animation: spin 1s linear infinite; width: 20px; height: 20px;" viewBox="0 0 24 24">
 <circle cx="12" cy="12" r="10" stroke="rgba(255,255,255,0.3)" stroke-width="2" fill="none"/>
 <path d="M4,12a8,8 0 1,1 16,0" stroke="#fff" stroke-width="2" fill="none" stroke-linecap="round"/>
 </svg>
 </div>
 </button>
 </div>
`;
  }
  // 渲染已激活钱包界面
  function renderActivatedWallet(isLightMode = false) {
    return `
 <div>

 <div style="background: linear-gradient(135deg, ${
   isLightMode ? "rgba(248, 250, 252, 0.8)" : "rgba(22, 24, 28, 0.8)"
 } 0%, ${
      isLightMode ? "rgba(229, 231, 235, 0.6)" : "rgba(55, 65, 81, 0.6)"
    } 100%); border: 2px solid ${
      isLightMode ? "rgba(0, 0, 0, 0.1)" : "rgba(255, 255, 255, 0.1)"
    }; border-radius: 16px; padding: 20px; margin-bottom: 20px; text-align: center; ">
 <div style="color: ${
   isLightMode ? "#6b7280" : "#9ca3af"
 }; font-size: 12px; font-weight: 600; letter-spacing: 1px; margin-bottom: 8px; text-transform: uppercase; ">Balance</div>
 <div style="color: ${
   isLightMode ? "#0f1419" : "#ffffff"
 }; font-size: 32px; font-weight: 700; margin-bottom: 4px; ">$${walletData.balance.toFixed(
      2
    )}</div>
 <div style="color: ${
   isLightMode ? "#6b7280" : "#9ca3af"
 }; font-size: 13px; ">${walletData.currency}</div>
 </div>

 <div style="margin-bottom: 16px;">
 <div style="color: ${
   isLightMode ? "#6b7280" : "#9ca3af"
 }; font-size: 12px; font-weight: 600; letter-spacing: 1px; margin-bottom: 12px; text-transform: uppercase; ">Recent Activity</div>
 ${
   walletData.transactions.length > 0
     ? renderTransactions(isLightMode)
     : renderNoTransactions(isLightMode)
 }
 </div>

 <div style="display: flex; gap: 12px;">
 <button onclick="showIncomeHistory()" style="flex: 1; background-color: var(--x-accent); color: ${
   isLightMode ? "#0f1419" : "#ffffff"
 }; border: none; border-radius: 12px; padding: 12px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; position: relative; " onmouseover="this.style.backgroundColor='#1a8cd8'"
 onmouseout="this.style.backgroundColor='var(--x-accent)'">
 + Add Funds
 ${
   getIncomeRecordsCount() > 0
     ? `<span style="position: absolute; top: -2px; right: -2px; background: #22c55e; color: white; border-radius: 50%; width: 16px; height: 16px; font-size: 10px; display: flex; align-items: center; justify-content: center; font-weight: 700; ">${getIncomeRecordsCount()}</span>`
     : ""
 }
 </button>
 <button onclick="showExpenseHistory()" style="flex: 1; background-color: transparent; color: ${
   isLightMode ? "#0f1419" : "#ffffff"
 }; border: none; border-radius: 12px; padding: 12px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; position: relative; " onmouseover="this.style.backgroundColor='${
      isLightMode ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
    }';"
 onmouseout="this.style.backgroundColor='transparent'">
 Send
 ${
   getExpenseRecordsCount() > 0
     ? `<span style="position: absolute; top: -2px; right: -2px; background: #ef4444; color: white; border-radius: 50%; width: 16px; height: 16px; font-size: 10px; display: flex; align-items: center; justify-content: center; font-weight: 700; ">${getExpenseRecordsCount()}</span>`
     : ""
 }
 </button>
 </div>
 </div>
`;
  }
  // 渲染交易记录
  function renderTransactions(isLightMode = false) {
    return walletData.transactions
      .slice(0, 2)
      .map(
        (transaction) => `
 <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 2px solid ${
   isLightMode ? "rgba(0, 0, 0, 0.08)" : "rgba(255, 255, 255, 0.08)"
 }; ">
 <div>
 <div style="color: ${
   isLightMode ? "#0f1419" : "#ffffff"
 }; font-size: 14px; font-weight: 600; margin-bottom: 2px; ">${
          transaction.description
        }</div>
 <div style="color: ${
   isLightMode ? "#6b7280" : "#9ca3af"
 }; font-size: 12px; ">${new Date(
          transaction.timestamp
        ).toLocaleDateString()}</div>
 </div>
 <div style="color: ${
   transaction.amount > 0 ? "#22c55e" : "#ef4444"
 }; font-size: 14px; font-weight: 700; ">${
          transaction.amount > 0 ? "+" : ""
        }$${Math.abs(transaction.amount).toFixed(2)}</div>
 </div>
`
      )
      .join("");
  }
  // 渲染无交易记录
  function renderNoTransactions(isLightMode = false) {
    return `
 <div style="text-align: center; padding: 20px; color: ${
   isLightMode ? "#6b7280" : "#9ca3af"
 }; font-size: 14px; ">
 <div style="margin-bottom: 8px; opacity: 0.6;">📋</div>
 <div>No transactions yet</div>
 </div>
`;
  }
  // 激活钱包
  async function activateWallet() {
    const activateBtn = document.getElementById("activate-wallet-btn");
    const btnText = document.getElementById("activate-btn-text");
    const btnLoader = document.getElementById("activate-btn-loader"); // 显示加载状态
    btnText.style.display = "none";
    btnLoader.style.display = "block";
    activateBtn.disabled = true;
    activateBtn.style.cursor = "not-allowed"; // 模拟激活过程
    await new Promise((resolve) => setTimeout(resolve, 2000));
    try {
      // 根据公众身份生成初始金额
      const initialAmount = generateInitialAmount(); // 更新钱包数据
      walletData.isActivated = true;
      walletData.balance = initialAmount;
      walletData.initialAmount = initialAmount;
      walletData.activatedAt = new Date().toISOString();
      walletData.transactions = [
        {
          id: "init_" + Date.now(),
          description: "Initial Deposit",
          amount: initialAmount,
          timestamp: new Date().toISOString(),
          type: "deposit",
        },
      ]; // 保存到数据库
      await saveWalletData(); // 显示成功动画
      showWalletActivationSuccess(initialAmount);
    } catch (error) {
      console.error("激活钱包失败:", error);
      showXToast("钱包激活失败", "error"); // 恢复按钮状态
      btnText.style.display = "block";
      btnLoader.style.display = "none";
      activateBtn.disabled = false;
      activateBtn.style.cursor = "pointer";
    }
  }
  // 根据公众身份生成初始金额
  function generateInitialAmount() {
    // 使用window.userProfileData确保获取最新数据
    const publicIdentity = window.userProfileData?.publicIdentity || "";
    const identityLower = publicIdentity.toLowerCase(); // 定义不同身份的金额范围
    const amountRanges = {
      // 超高知名度身份 (1000-5000)
      celebrity: {
        min: 1000,
        max: 5000,
        keywords: [
          "明星",
          "演员",
          "歌手",
          "导演",
          "艺人",
          "celebrity",
          "star",
          "actor",
          "singer",
        ],
      },
      // 高知名度身份 (500-1500)
      influencer: {
        min: 500,
        max: 1500,
        keywords: [
          "网红",
          "博主",
          "主播",
          "influencer",
          "streamer",
          "youtuber",
          "blogger",
        ],
      },
      // 专业身份 (200-800)
      professional: {
        min: 200,
        max: 800,
        keywords: [
          "专家",
          "教授",
          "医生",
          "律师",
          "工程师",
          "expert",
          "professor",
          "doctor",
          "lawyer",
          "engineer",
        ],
      },
      // 企业相关 (300-1000)
      business: {
        min: 300,
        max: 1000,
        keywords: [
          "企业家",
          "CEO",
          "总裁",
          "创始人",
          "entrepreneur",
          "founder",
          "executive",
        ],
      },
      // 艺术创作者 (150-600)
      creator: {
        min: 150,
        max: 600,
        keywords: [
          "作家",
          "画家",
          "设计师",
          "摄影师",
          "writer",
          "artist",
          "designer",
          "photographer",
        ],
      },
      // 普通用户 (50-200)
      regular: { min: 50, max: 200, keywords: [] },
    }; // 检查身份匹配
    for (const [category, config] of Object.entries(amountRanges)) {
      if (category === "regular") continue; // 跳过普通用户，作为默认值
      const hasMatch = config.keywords.some((keyword) =>
        identityLower.includes(keyword)
      );
      if (hasMatch) {
        const amount = Math.random() * (config.max - config.min) + config.min;
        console.log(
          `💰 根据身份类型 "${category}" 生成初始金额: $${amount.toFixed(2)}`
        );
        return Math.round(amount * 100) / 100; // 保留两位小数
      }
    }
    // 默认为普通用户
    const regularRange = amountRanges.regular;
    const amount =
      Math.random() * (regularRange.max - regularRange.min) + regularRange.min;
    console.log(`💰 默认身份生成初始金额: $${amount.toFixed(2)}`);
    return Math.round(amount * 100) / 100;
  }
  // 显示钱包激活成功动画
  function showWalletActivationSuccess(amount) {
    // 关闭当前钱包弹窗
    closeWalletModal(); // 显示成功弹窗
    const successModal = document.createElement("div");
    successModal.style.cssText = `
 position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: flex; align-items: center; justify-content: center; z-index: 30; backdrop-filter: blur(12px);
`;
    successModal.innerHTML = `
 <div style="background-color:var(--x-bg-primary); border-radius: 24px; padding: 40px; text-align: center; border: 1px solid var(--x-border-color); max-width: 320px; width: 90%; animation: walletSuccessIn 0.6s cubic-bezier(0.4, 0, 0.2, 1); ">

 <div style="width: 80px; height: 80px; margin: 0 auto 24px; background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; animation: walletSuccessCheck 0.8s ease-in-out 0.3s both; ">
 <svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: white;">
 <g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"/></g>
 </svg>
 </div>

 <div style="color:var(--x-text-primary); font-size: 20px; font-weight: 700; margin-bottom: 8px; ">钱包激活成功！</div>
 <div style="color: #22c55e; font-size: 24px; font-weight: 700; margin-bottom: 16px; ">+$${amount.toFixed(
   2
 )}</div>
 <div style="color:var(--x-text-secondary); font-size: 14px; line-height: 1.5; margin-bottom: 24px; ">恭喜！你的数字钱包已成功激活<br>初始资金已到账</div>

 <button onclick="this.parentElement.parentElement.remove(); document.body.style.overflow='auto'; openAccountWallet();" style="background: linear-gradient(135deg, var(--x-accent) 0%, #1a8cd8 100%); color: #fff; border: none; border-radius: 12px; padding: 12px 24px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; ">查看钱包</button>
 </div>
`;
    document.body.appendChild(successModal); // 3秒后自动关闭
    setTimeout(() => {
      if (successModal.parentElement) {
        successModal.remove();
        document.body.style.overflow = "auto";
      }
    }, 3000);
  }
  // 关闭钱包弹窗
  function closeWalletModal() {
    const modal = document.getElementById("wallet-modal");
    if (modal) {
      const walletCard = modal.querySelector("div");
      walletCard.style.transform = "scale(0.9) translateY(20px)";
      walletCard.style.opacity = "0";
      setTimeout(() => {
        modal.remove();
        document.body.style.overflow = "auto";
      }, 200);
    }
  }
  // 加载钱包数据
  async function loadWalletData() {
    try {
      const db = getXDB();
      const walletId = `wallet_${currentAccountId || "main"}`;
      const savedWallet = await db.xAccountProfiles.get(walletId);
      if (savedWallet && savedWallet.data) {
        Object.assign(walletData, savedWallet.data);
        walletData.accountId = currentAccountId || "main";
      } else {
        // 重置为默认状态
        walletData = {
          accountId: currentAccountId || "main",
          isActivated: false,
          balance: 0,
          currency: "USD",
          transactions: [],
          activatedAt: null,
          initialAmount: 0,
          creditScore: 100, // 信用值，初始100
        };
      }
      console.log(
        "✅ 钱包数据已加载:",
        walletData.accountId,
        walletData.isActivated ? "已激活" : "未激活"
      );
    } catch (error) {
      console.error("加载钱包数据失败:", error); // 使用默认数据
      walletData = {
        accountId: currentAccountId || "main",
        isActivated: false,
        balance: 0,
        currency: "USD",
        transactions: [],
        activatedAt: null,
        initialAmount: 0,
        creditScore: 100, // 信用值，初始100
      };
    }
  }
  // 保存钱包数据
  async function saveWalletData() {
    try {
      const db = getXDB();
      const walletId = `wallet_${currentAccountId || "main"}`;
      await db.xAccountProfiles.put({
        handle: walletId,
        name: "wallet",
        accountId: currentAccountId || "main",
        data: { ...walletData },
        updatedAt: new Date().toISOString(),
      });
      console.log("✅ 钱包数据已保存");
    } catch (error) {
      console.error("保存钱包数据失败:", error);
      throw error;
    }
  }
  // 获取收款记录数量
  function getIncomeRecordsCount() {
    return walletData.transactions.filter((t) => t.amount > 0).length;
  }
  // 获取付款记录数量
  function getExpenseRecordsCount() {
    return walletData.transactions.filter((t) => t.amount < 0).length;
  }
  // 显示收款历史
  window.showIncomeHistory = function () {
    const incomeRecords = walletData.transactions.filter((t) => t.amount > 0);
    showTransactionHistory("收款记录", incomeRecords, "#22c55e");
  }; // 显示付款历史
  window.showExpenseHistory = function () {
    const expenseRecords = walletData.transactions.filter((t) => t.amount < 0);
    showTransactionHistory("付款记录", expenseRecords, "#ef4444");
  }; // 显示交易历史弹窗
  function showTransactionHistory(title, transactions, accentColor) {
    const xSocialScreen = document.getElementById("x-social-screen");
    const isLightMode =
      xSocialScreen && xSocialScreen.classList.contains("x-theme-light"); // 创建弹窗遮罩
    const modal = document.createElement("div");
    modal.id = "transaction-history-modal";
    modal.style.cssText = `
 position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: ${
   isLightMode ? "rgba(255, 255, 255, 0.85)" : "rgba(0, 0, 0, 0.85)"
 }; display: flex; align-items: center; justify-content: center; z-index: 26; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
`;
    modal.innerHTML = `
 <div style="background-color: ${
   isLightMode ? "rgba(255, 255, 255, 0.95)" : "rgba(0, 0, 0, 0.95)"
 }; backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 24px; width: 90%; max-width: 400px; max-height: 80vh; position: relative; overflow: hidden; box-shadow: ${
      isLightMode
        ? "0 20px 60px rgba(0, 0, 0, 0.15), 0 8px 32px rgba(0, 0, 0, 0.1)"
        : "0 20px 60px rgba(0, 0, 0, 0.8), 0 8px 32px rgba(255, 255, 255, 0.05)"
    }; border: 2px solid ${
      isLightMode ? "rgba(0, 0, 0, 0.1)" : "rgba(255, 255, 255, 0.1)"
    }; " onclick="event.stopPropagation()">

 <div style="background: linear-gradient(135deg, ${
   isLightMode ? "rgba(0, 0, 0, 0.03)" : "rgba(255, 255, 255, 0.05)"
 } 0%, ${
      isLightMode ? "rgba(0, 0, 0, 0.01)" : "rgba(255, 255, 255, 0.02)"
    } 100%); padding: 24px; text-align: center; border-bottom: 1px dashed ${
      isLightMode ? "rgba(0, 0, 0, 0.15)" : "rgba(255, 255, 255, 0.15)"
    }; position: relative; ">

 <div style="position: absolute; left: -10px; bottom: -10px; width: 20px; height: 20px; border-radius: 50%; background-color: ${
   isLightMode ? "rgba(255, 255, 255, 0.85)" : "rgba(0, 0, 0, 0.85)"
 }; "></div>
 <div style="position: absolute; right: -10px; bottom: -10px; width: 20px; height: 20px; border-radius: 50%; background-color: ${
   isLightMode ? "rgba(255, 255, 255, 0.85)" : "rgba(0, 0, 0, 0.85)"
 }; "></div>

 <button onclick="closeTransactionHistoryModal()" style="position: absolute; top: 16px; right: 16px; background: transparent; border: none; color: ${
   isLightMode ? "#536471" : "#71767b"
 }; cursor: pointer; padding: 8px; border-radius: 50%; transition: all 0.2s; " onmouseover="this.style.backgroundColor='${
      isLightMode ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
    }';"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </button>

 <div style="color: ${
   isLightMode ? "#0f1419" : "#ffffff"
 }; font-size: 20px; font-weight: 700; margin-bottom: 8px; letter-spacing: 0.5px; ">${title}</div>
 <div style="color: ${
   isLightMode ? "#666666" : "#999999"
 }; font-size: 12px; font-weight: 600; font-family: monospace; letter-spacing: 1px; text-transform: uppercase; ">${
      transactions.length
    } Records</div>
 </div>

 <div style="max-height: 50vh; overflow-y: auto; padding: 16px 24px; ">
 ${
   transactions.length > 0
     ? renderFullTransactionList(transactions, isLightMode)
     : renderNoRecords(isLightMode, title)
 }
 </div>
 </div>
`;
    document.body.appendChild(modal);
    document.body.style.overflow = "hidden"; // 点击背景关闭弹窗
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        closeTransactionHistoryModal();
      }
    }); // 添加入场动画
    const historyCard = modal.querySelector("div");
    historyCard.style.transform = "scale(0.8) translateY(20px)";
    historyCard.style.opacity = "0";
    requestAnimationFrame(() => {
      historyCard.style.transition = "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)";
      historyCard.style.transform = "scale(1) translateY(0)";
      historyCard.style.opacity = "1";
    });
  }
  // 渲染完整交易记录列表
  function renderFullTransactionList(transactions, isLightMode = false) {
    return transactions
      .map(
        (transaction) => `
 <div style="margin-bottom: 12px; background: linear-gradient(135deg, ${
   isLightMode ? "rgba(0, 0, 0, 0.02)" : "rgba(255, 255, 255, 0.03)"
 } 0%, ${
          isLightMode ? "rgba(0, 0, 0, 0.01)" : "rgba(255, 255, 255, 0.01)"
        } 100%); border: 1px solid ${
          isLightMode ? "rgba(0, 0, 0, 0.08)" : "rgba(255, 255, 255, 0.08)"
        }; border-radius: 10px; padding: 14px; position: relative; overflow: hidden; ">

 <div style="position: absolute; bottom: 0; left: 0; right: 0; height: 4px; background: repeating-linear-gradient(
 90deg,
 ${isLightMode ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"} 0px,
 ${isLightMode ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"} 4px,
 transparent 4px,
 transparent 8px
 ); "></div>
 <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
 <div style="flex: 1; min-width: 0;">
 <div style="color: ${
   isLightMode ? "#0f1419" : "#ffffff"
 }; font-size: 14px; font-weight: 600; margin-bottom: 6px; word-wrap: break-word; ">${
          transaction.description
        }</div>
 <div style="color: ${
   isLightMode ? "#6b7280" : "#9ca3af"
 }; font-size: 11px; margin-bottom: 4px; font-family: monospace; letter-spacing: 0.3px; ">${new Date(
          transaction.timestamp
        ).toLocaleDateString("zh-CN")} ${new Date(
          transaction.timestamp
        ).toLocaleTimeString("zh-CN", {
          hour12: false,
        })}</div>
 </div>
 <div style="color: ${
   transaction.amount > 0
     ? isLightMode
       ? "#0f1419"
       : "#ffffff"
     : isLightMode
     ? "#666666"
     : "#999999"
 }; font-size: 16px; font-weight: 700; margin-left: 12px; flex-shrink: 0; font-family: monospace; ">${
          transaction.amount > 0 ? "+" : ""
        }$${Math.abs(transaction.amount).toFixed(2)}</div>
 </div>

 <div style="display: inline-block; padding: 3px 8px; background: ${
   isLightMode ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.08)"
 }; border: 1px solid ${
          isLightMode ? "rgba(0, 0, 0, 0.1)" : "rgba(255, 255, 255, 0.12)"
        }; border-radius: 6px; font-size: 10px; color: ${
          isLightMode ? "#666666" : "#999999"
        }; font-weight: 600; letter-spacing: 0.5px; ">${getTransactionTypeText(
          transaction.type
        )}</div>
 </div>
`
      )
      .join("");
  }
  // 渲染无记录状态
  function renderNoRecords(isLightMode = false, title) {
    return `
 <div style="text-align: center; padding: 40px 20px; color: ${
   isLightMode ? "#6b7280" : "#9ca3af"
 }; font-size: 15px; ">
 <svg viewBox="0 0 24 24" style="width: 48px; height: 48px; fill: currentColor; opacity: 0.3; margin: 0 auto 12px;">
 <g><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></g>
 </svg>
 <div style="font-weight: 600; margin-bottom: 8px;">暂无${title}</div>
 <div style="font-size: 13px; opacity: 0.8;">
 ${title.includes("收款") ? "收到的资金会显示在这里" : "转出的资金会显示在这里"}
 </div>
 </div>
`;
  }
  // 获取交易类型文本
  function getTransactionTypeText(type) {
    const typeMap = {
      deposit: "充值",
      transfer_in: "收款",
      transfer_out: "转账",
      refund: "退款",
      init: "初始化",
      tip: "打赏",
      penalty: "违约费",
      fan_group_fee: "粉丝群入群费",
    };
    return typeMap[type] || type;
  }
  // 关闭交易历史弹窗
  window.closeTransactionHistoryModal = function () {
    const modal = document.getElementById("transaction-history-modal");
    if (modal) {
      const historyCard = modal.querySelector("div");
      historyCard.style.transform = "scale(0.9) translateY(20px)";
      historyCard.style.opacity = "0";
      setTimeout(() => {
        modal.remove();
        document.body.style.overflow = "auto";
      }, 200);
    }
  }; // 添加资金 (占位函数，保持兼容性)
  function addFunds() {
    showIncomeHistory();
  }
  // 发送金钱 (占位函数，保持兼容性)
  function sendMoney() {
    showExpenseHistory();
  }
  // 分享钱包 (占位函数)
  function shareWallet() {
    showXToast("分享功能开发中...", "info");
  }
  // 导出钱包 (占位函数)
  function exportWallet() {
    showXToast("导出功能开发中...", "info");
  }
  // 复制钱包信息 (占位函数)
  function copyWalletInfo() {
    const userName =
      window.userProfileData?.name || userProfileData.name || "用户";
    const info = `${userName}的数字钱包\n余额: $${walletData.balance.toFixed(
      2
    )}\n状态: ${walletData.isActivated ? "已激活" : "未激活"}`;
    if (navigator.clipboard) {
      navigator.clipboard
        .writeText(info)
        .then(() => {
          showXToast("钱包信息已复制", "success");
        })
        .catch(() => {
          showXToast("复制失败", "error");
        });
    } else {
      showXToast("复制功能不支持", "error");
    }
  }
  // 编辑个人资料弹窗相关功能
  // 打开编辑个人资料弹窗
  function openEditProfileModal() {
    const modal = document.getElementById("edit-profile-modal");
    modal.style.display = "flex"; // 禁止背景滚动
    document.body.style.overflow = "hidden"; // 加载当前数据到编辑表单
    loadDataToEditForm();
  }
  // 关闭编辑个人资料弹窗
  function closeEditProfileModal(event) {
    // 如果有事件参数，检查是否点击的是背景区域
    if (event && event.target !== event.currentTarget) {
      return;
    }
    const modal = document.getElementById("edit-profile-modal");
    modal.style.display = "none"; // 恢复背景滚动
    document.body.style.overflow = "auto";
  }
  // 加载当前用户数据到编辑表单
  function loadDataToEditForm() {
    // 使用window.userProfileData确保读取最新数据
    const profile = window.userProfileData; // 加载基本信息
    document.getElementById("edit-user-name").value = profile.name;
    document.getElementById("edit-user-handle").value = profile.handle.replace(
      "@",
      ""
    );
    document.getElementById("edit-user-bio").value = profile.bio;
    document.getElementById("edit-custom-tag1").value = profile.customTag1;
    document.getElementById("edit-custom-tag2").value = profile.customTag2;
    document.getElementById("edit-following-count").value = profile.following;
    document.getElementById("edit-followers-count").value = profile.followers; // 加载标签图标和颜色
    document.getElementById("edit-tag1-icon").value =
      profile.customTag1Icon || "✨";
    document.getElementById("edit-tag2-icon").value =
      profile.customTag2Icon || "📅";
    document.getElementById("edit-tag1-color").value =
      profile.customTag1Color || "#71767b";
    document.getElementById("edit-tag2-color").value =
      profile.customTag2Color || "#71767b";
    document.getElementById("edit-tag1-color-text").value =
      profile.customTag1Color || "#71767b";
    document.getElementById("edit-tag2-color-text").value =
      profile.customTag2Color || "#71767b"; // 加载图片
    document.getElementById("edit-cover-image").src = profile.coverImage;
    document.getElementById("edit-main-avatar").src = profile.avatar; // 加载公众身份和真名设置
    document.getElementById("edit-public-identity").value =
      profile.publicIdentity || "";
    document.getElementById("edit-show-real-name").checked =
      profile.showRealName || false;
    document.getElementById("edit-real-name").value = profile.realName || ""; // 根据复选框状态显示/隐藏真名输入框
    toggleRealNameInput(); // 更新字符计数
    updateCharacterCounts(); // 加载认证类型设置
    loadVerificationTypeData(); // 加载角色身份识别设置
    loadIdentityCharactersList();
    console.log("✅ 已加载用户数据到编辑表单");
  }
  // 加载认证类型数据到编辑表单
  function loadVerificationTypeData() {
    // 使用window.userProfileData确保读取最新数据
    const profile = window.userProfileData; // 设置认证类型选择
    const verificationTypeSelect = document.getElementById(
      "edit-verification-type"
    );
    if (verificationTypeSelect) {
      verificationTypeSelect.value = profile.verificationType || "none";
    }
    // 设置情侣绑定角色
    const coupleCharacterSelect = document.getElementById(
      "edit-couple-character"
    );
    if (coupleCharacterSelect) {
      coupleCharacterSelect.value = profile.coupleCharacterId || "";
    }
    // 加载可选择的角色到情侣绑定下拉框
    loadCoupleCharacterOptions(); // 更新UI显示
    updateVerificationTypeUI();
  }
  // 更新认证类型UI显示
  function updateVerificationTypeUI() {
    const verificationTypeSelect = document.getElementById(
      "edit-verification-type"
    );
    const coupleBindingSection = document.getElementById(
      "couple-binding-section"
    );
    if (!verificationTypeSelect || !coupleBindingSection) return;
    const selectedType = verificationTypeSelect.value; // 根据选择的认证类型显示/隐藏情侣绑定选项
    if (selectedType === "couple") {
      coupleBindingSection.style.display = "block";
    } else {
      coupleBindingSection.style.display = "none";
    }
  }
  // 加载可选择的角色到情侣绑定下拉框
  async function loadCoupleCharacterOptions() {
    try {
      const db = getDB(); // chats表在主数据库中
      const xDb = getXDB(); // X资料在X专用数据库中
      // 获取所有聊天角色
      const allChats = await db.chats.toArray();
      const characters = allChats.filter((chat) => !chat.isGroup);
      const coupleCharacterSelect = document.getElementById(
        "edit-couple-character"
      );
      if (!coupleCharacterSelect) return; // 清空现有选项（保留默认选项）
      coupleCharacterSelect.innerHTML =
        '<option value="" style="background-color:#000; color: #fff;">未选择角色</option>'; // 获取所有角色的X资料（从X专用数据库）
      const characterProfiles = await xDb.xCharacterProfiles.toArray();
      const profileMap = new Map();
      characterProfiles.forEach((profile) => {
        profileMap.set(profile.characterId, profile);
      }); // 添加角色选项
      characters.forEach((character) => {
        const option = document.createElement("option");
        option.value = character.id; // 优先使用X平台名称，如果没有设置则使用角色名
        const xProfile = profileMap.get(character.id);
        const displayName = xProfile?.xName || character.name;
        option.textContent = displayName;
        option.style.backgroundColor = "#000";
        option.style.color = "#fff";
        coupleCharacterSelect.appendChild(option);
      }); // 设置当前选中的角色
      if (userProfileData.coupleCharacterId) {
        coupleCharacterSelect.value = userProfileData.coupleCharacterId;
      }
    } catch (error) {
      console.error("加载情侣角色选项失败:", error);
    }
  }
  // 更新字符计数显示
  function updateCharacterCounts() {
    const nameInput = document.getElementById("edit-user-name");
    const handleInput = document.getElementById("edit-user-handle");
    const bioInput = document.getElementById("edit-user-bio");
    const tag1Input = document.getElementById("edit-custom-tag1");
    const tag2Input = document.getElementById("edit-custom-tag2"); // 更新名称计数
    if (nameInput) {
      const nameCount = nameInput.value.length;
      nameInput.parentNode.querySelector(
        "div"
      ).textContent = `${nameCount} / 50`;
    }
    // 更新用户名计数
    if (handleInput) {
      const handleCount = handleInput.value.length;
      handleInput.parentNode.querySelector(
        "div"
      ).textContent = `${handleCount} / 15`;
    }
    // 更新简介计数
    if (bioInput) {
      const bioCount = bioInput.value.length;
      bioInput.parentNode.querySelector(
        "div"
      ).textContent = `${bioCount} / 160`;
    }
    // 更新标签1计数
    if (tag1Input) {
      const tag1Count = tag1Input.value.length;
      const tag1Container = tag1Input.closest(".form-group");
      const countDiv = tag1Container.querySelector("div:last-child");
      countDiv.textContent = `${tag1Count} / 30`;
    }
    // 更新标签2计数
    if (tag2Input) {
      const tag2Count = tag2Input.value.length;
      const tag2Container = tag2Input.closest(".form-group");
      const countDiv = tag2Container.querySelector("div:last-child");
      countDiv.textContent = `${tag2Count} / 30`;
    }
    // 公众身份已移除字符限制，无需计数
    // 更新真实姓名计数
    const realNameInput = document.getElementById("edit-real-name");
    if (realNameInput) {
      const realNameCount = realNameInput.value.length;
      realNameInput.parentNode.querySelector(
        "div"
      ).textContent = `${realNameCount} / 50`;
    }
  }
  // 切换真名输入框显示
  function toggleRealNameInput() {
    const checkbox = document.getElementById("edit-show-real-name");
    const container = document.getElementById("real-name-input-container"); // 添加 null 检查，防止元素不存在时报错
    if (!checkbox || !container) {
      console.warn("用户真名相关元素未找到");
      return;
    }
    if (checkbox.checked) {
      container.style.display = "block";
    } else {
      container.style.display = "none"; // 清空真名输入框
      const realNameInput = document.getElementById("edit-real-name");
      if (realNameInput) {
        realNameInput.value = "";
        updateCharacterCounts();
      }
    }
  }
  // 切换角色真名输入框显示
  function toggleCharacterRealNameInput() {
    const checkbox = document.getElementById("character-show-real-name");
    const container = document.getElementById(
      "character-real-name-input-container"
    ); // 添加 null 检查，防止元素不存在时报错
    if (!checkbox || !container) {
      console.warn("角色真名相关元素未找到");
      return;
    }
    if (checkbox.checked) {
      container.style.display = "block";
    } else {
      container.style.display = "none"; // 清空真名输入框
      const realNameInput = document.getElementById("character-real-name");
      if (realNameInput) {
        realNameInput.value = "";
        updateCharacterXProfileCounts();
      }
    }
  }
  // 切换自动发消息设置显示
  window.toggleAutoMessageSettings = function () {
    const checkbox = document.getElementById("character-auto-message-enabled");
    const settingsContainer = document.getElementById(
      "auto-message-time-settings"
    );
    if (!checkbox || !settingsContainer) {
      return;
    }
    if (checkbox.checked) {
      settingsContainer.style.display = "block";
    } else {
      settingsContainer.style.display = "none";
    }
  }; // 标签1颜色同步功能
  function updateTag1ColorFromText() {
    const colorText = document.getElementById("edit-tag1-color-text");
    const colorPicker = document.getElementById("edit-tag1-color");
    if (colorText && colorPicker) {
      const colorValue = colorText.value.trim();
      if (colorValue.match(/^#[0-9A-Fa-f]{6}$/)) {
        colorPicker.value = colorValue;
      }
    }
  }
  function updateTag1ColorFromPicker() {
    const colorText = document.getElementById("edit-tag1-color-text");
    const colorPicker = document.getElementById("edit-tag1-color");
    if (colorText && colorPicker) {
      colorText.value = colorPicker.value;
    }
  }
  // 标签2颜色同步功能
  function updateTag2ColorFromText() {
    const colorText = document.getElementById("edit-tag2-color-text");
    const colorPicker = document.getElementById("edit-tag2-color");
    if (colorText && colorPicker) {
      const colorValue = colorText.value.trim();
      if (colorValue.match(/^#[0-9A-Fa-f]{6}$/)) {
        colorPicker.value = colorValue;
      }
    }
  }
  function updateTag2ColorFromPicker() {
    const colorText = document.getElementById("edit-tag2-color-text");
    const colorPicker = document.getElementById("edit-tag2-color");
    if (colorText && colorPicker) {
      colorText.value = colorPicker.value;
    }
  }
  // 简化的关注数处理 - 直接使用字符串
  function getFollowCountValue(input) {
    if (!input) return "";
    return input.toString().trim();
  }
  // 编辑封面图
  // 编辑封面图 - 使用链接上传
  function editCoverImage() {
    const currentCover = document.getElementById("edit-cover-image").src;
    const coverUrl = prompt("请输入封面图片链接：", currentCover);
    if (coverUrl === null) return; // 用户点击取消
    if (!coverUrl.trim()) {
      showXToast("请输入有效的图片链接", "error");
      return;
    }
    // 验证是否为有效的URL
    try {
      new URL(coverUrl);
    } catch (e) {
      showXToast("请输入有效的图片链接", "error");
      return;
    }
    // 测试图片是否可以加载
    const testImg = new Image();
    testImg.onload = function () {
      document.getElementById("edit-cover-image").src = coverUrl;
      showXToast("封面图已更新", "success");
    };
    testImg.onerror = function () {
      showXToast("无法加载该图片，请检查链接是否正确", "error");
    };
    testImg.src = coverUrl;
  }
  // 移除封面图
  function removeCoverImage() {
    const defaultCover = "https://i.postimg.cc/qRzMB6nQ/default-cover.jpg";
    document.getElementById("edit-cover-image").src = defaultCover;
    showXToast("已移除封面图", "success");
  }
  // 编辑头像 - 使用链接上传
  function editAvatarImage() {
    const currentAvatar = document.getElementById("edit-main-avatar").src;
    const avatarUrl = prompt("请输入头像图片链接：", currentAvatar);
    if (avatarUrl === null) return; // 用户点击取消
    if (!avatarUrl.trim()) {
      showXToast("请输入有效的图片链接", "error");
      return;
    }
    // 验证是否为有效的URL
    try {
      new URL(avatarUrl);
    } catch (e) {
      showXToast("请输入有效的图片链接", "error");
      return;
    }
    // 测试图片是否可以加载
    const testImg = new Image();
    testImg.onload = function () {
      document.getElementById("edit-main-avatar").src = avatarUrl;
      showXToast("头像已更新", "success");
    };
    testImg.onerror = function () {
      showXToast("无法加载该图片，请检查链接是否正确", "error");
    };
    testImg.src = avatarUrl;
  }
  // 角色身份识别管理函数
  // 加载已绑定X资料的角色列表
  async function loadIdentityCharactersList() {
    console.log(`🔄 [加载角色身份识别列表] 开始加载`);
    try {
      const db = getDB(); // 修正：chats表在全局数据库中
      const xDb = getXDB(); // X专用数据库用于其他数据
      // 获取X设置中的绑定角色（使用当前账号的设置）
      const settingsId = `xSettings_${currentAccountId || "main"}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const boundCharacters = xSettings?.boundCharacters || [];
      console.log(
        `🔄 [加载角色身份识别列表] 绑定角色数: ${boundCharacters.length}`
      );
      if (boundCharacters.length === 0) {
        console.log(`⚠️ [加载角色身份识别列表] 无绑定角色`);
        renderIdentityCharactersList([]);
        return;
      }
      // 获取所有聊天角色
      const allChats = await db.chats.toArray();
      const characters = allChats.filter(
        (chat) => !chat.isGroup && boundCharacters.includes(chat.id)
      );
      console.log(
        `🔄 [加载角色身份识别列表] 过滤后角色数: ${characters.length}`
      ); // 筛选出已绑定X资料的角色
      const charactersWithXProfile = [];
      for (const character of characters) {
        const xProfile = await xDb.xCharacterProfiles.get(character.id);
        if (xProfile) {
          const personaLength = (xProfile.userPersona || "").length;
          console.log(
            `🔄 [加载角色身份识别列表] 角色 ${character.name} (${character.id})`
          );
          console.log(` - X名称: ${xProfile.xName}`);
          console.log(` - 用户人设长度: ${personaLength} 字符`);
          console.log(
            ` - 人设预览: "${(xProfile.userPersona || "").substring(0, 50)}${
              personaLength > 50 ? "..." : ""
            }"`
          );
          charactersWithXProfile.push({
            id: character.id,
            name: character.name,
            originalName: character.originalName,
            xProfile: xProfile,
          });
        }
      }
      console.log(
        `✅ [加载角色身份识别列表] 最终角色数: ${charactersWithXProfile.length}`
      );
      renderIdentityCharactersList(charactersWithXProfile);
    } catch (error) {
      console.error("❌ [加载角色身份识别列表] 加载失败:", error);
      console.error(
        "❌ [加载角色身份识别列表] 错误详情:",
        error.message,
        error.stack
      );
      renderIdentityCharactersList([]);
    }
  }
  // 渲染角色身份识别列表
  function renderIdentityCharactersList(characters) {
    const container = document.getElementById("identity-characters-list");
    if (characters.length === 0) {
      container.innerHTML = `
 <div style="text-align: center; color: #71767b; font-size: 13px; padding: 20px;">
 暂无已绑定X资料的角色<br>
 <span style="font-size: 12px; margin-top: 4px; display: block;">
 请先在X设置中绑定角色并设置X资料
 </span>
 </div>
 `;
      return;
    }
    // 确保knownIdentityCharacters数组存在
    if (!userProfileData.knownIdentityCharacters) {
      userProfileData.knownIdentityCharacters = [];
    }
    container.innerHTML = characters
      .map((character) => {
        const isSelected = userProfileData.knownIdentityCharacters.includes(
          character.id
        );
        return `
 <div style="display: flex; align-items: center; gap: 12px; padding: 8px; border-radius: 6px; margin-bottom: 6px; cursor: pointer; transition: background-color 0.2s;"
 onmouseover="this.style.backgroundColor='rgba(255,255,255,0.05)'"
 onmouseout="this.style.backgroundColor='transparent'"
 onclick="toggleIdentityCharacter('${character.id}')">

 <div style="width: 18px; height: 18px; border: 2px solid ${
   isSelected ? "var(--x-accent)" : "#71767b"
 }; border-radius: 3px; background-color: ${
          isSelected ? "var(--x-accent)" : "transparent"
        }; display: flex; align-items: center; justify-content: center; transition: all 0.2s; flex-shrink: 0; ">
 ${
   isSelected
     ? '<svg viewBox="0 0 24 24" style="width: 12px; height: 12px; fill: #fff;"><path d="M9 16.17L5.53 12.7l-1.06 1.06L9 18.3l9.54-9.54-1.06-1.06L9 16.17z"/></svg>'
     : ""
 }
 </div>

 <img src="${character.xProfile.xAvatar}" alt="${character.xProfile.xName}"
 style="width: 32px; height: 32px; border-radius: 50%; flex-shrink: 0;">

 <div style="flex: 1; min-width: 0;">
 <div style="color: #fff; font-weight: 600; font-size: 14px;">
 ${character.xProfile.xName}
 ${
   character.xProfile.xVerified
     ? '<svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: var(--x-accent); margin-left: 4px; display: inline;"><path d="M22.5 12.5c0-1.58-.875-2.95-2.148-3.6.154-.435.238-.905.238-1.4 0-2.21-1.71-3.998-3.818-3.998-.47 0-.92.084-1.336.25C14.818 2.415 13.51 1.5 12 1.5s-2.816.917-3.437 2.25c-.415-.165-.866-.25-1.336-.25-2.11 0-3.818 1.79-3.818 4 0 .494.083.964.237 1.4-1.272.65-2.147 2.018-2.147 3.6 0 1.495.782 2.798 1.942 3.486-.02.17-.032.34-.032.514 0 2.21 1.708 4 3.818 4 .47 0 .92-.086 1.335-.25.62 1.334 1.926 2.25 3.437 2.25 1.512 0 2.818-.916 3.437-2.25.415.163.865.248 1.336.248 2.11 0 3.818-1.79 3.818-4 0-.174-.012-.344-.033-.513 1.158-.687 1.943-1.99 1.943-3.484zm-6.616-3.334l-4.334 6.5c-.145.217-.382.334-.625.334-.143 0-.288-.04-.416-.126l-2.5-1.668c-.326-.217-.413-.656-.196-.982.217-.326.656-.414.982-.196l1.875 1.25 3.75-5.625c.22-.33.66-.418.99-.196.33.22.418.66.196.99z"/></svg>'
     : ""
 }
 </div>
 <div style="color: #71767b; font-size: 12px;">
 ${character.xProfile.xHandle} • ${character.name}
 ${
   character.xProfile &&
   character.xProfile.userPersona &&
   character.xProfile.userPersona.trim()
     ? '<span style="color: #10b981; font-size: 11px; margin-left: 8px;">✓ 已设置人设</span>'
     : '<span style="color: #f59e0b; font-size: 11px; margin-left: 8px;">⚠ 未设置人设</span>'
 }
 </div>
 </div>

 <div class="persona-setting-btn" onclick="event.stopPropagation(); window.openUserPersonaEditor('${
   character.id
 }')"
 style="width: 32px; height: 32px; border-radius: 50%; background-color: ${
   character.xProfile &&
   character.xProfile.userPersona &&
   character.xProfile.userPersona.trim()
     ? "#10b981"
     : "#1d9bf0"
 }; color: #fff; display: flex; align-items: center; justify-content: center; cursor: pointer; flex-shrink: 0; transition: all 0.2s; margin-left: 8px; "
 onmouseover="this.style.backgroundColor='${
   character.xProfile &&
   character.xProfile.userPersona &&
   character.xProfile.userPersona.trim()
     ? "#059669"
     : "#1a8cd8"
 }'; this.style.transform='scale(1.05)'"
 onmouseout="this.style.backgroundColor='${
   character.xProfile &&
   character.xProfile.userPersona &&
   character.xProfile.userPersona.trim()
     ? "#10b981"
     : "#1d9bf0"
 }'; this.style.transform='scale(1)'"
 title="${
   character.xProfile &&
   character.xProfile.userPersona &&
   character.xProfile.userPersona.trim()
     ? "编辑用户人设"
     : "设置用户人设"
 }">
 ${
   character.xProfile &&
   character.xProfile.userPersona &&
   character.xProfile.userPersona.trim()
     ? '<svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;"><g><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></g></svg>'
     : '<svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;"><g><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></g></svg>'
 }
 </div>
 </div>
 `;
      })
      .join("");
  }
  // 切换角色身份识别状态
  function toggleIdentityCharacter(characterId) {
    // 确保knownIdentityCharacters数组存在
    if (!userProfileData.knownIdentityCharacters) {
      userProfileData.knownIdentityCharacters = [];
    }
    const index = userProfileData.knownIdentityCharacters.indexOf(characterId);
    if (index === -1) {
      // 添加到已知身份列表
      userProfileData.knownIdentityCharacters.push(characterId);
    } else {
      // 从已知身份列表中移除
      userProfileData.knownIdentityCharacters.splice(index, 1);
    }
    // 重新渲染列表以更新UI
    loadIdentityCharactersList();
  }
  // 用户人设编辑功能 - 使用+按钮触发
  // 打开用户人设编辑器 - 全局函数
  window.openUserPersonaEditor = async function (characterId) {
    console.log(`📖 [打开用户人设编辑器] 角色ID: ${characterId}`);
    try {
      const mainDB = getDB(); // 用于访问 chats 表
      const xDB = getXDB(); // 用于访问 xCharacterProfiles 表
      const chat = await mainDB.chats.get(characterId);
      const xProfile = await xDB.xCharacterProfiles.get(characterId);
      console.log(
        `📖 [打开用户人设编辑器] 角色数据:`,
        chat ? "存在" : "不存在"
      );
      console.log(
        `📖 [打开用户人设编辑器] X资料数据:`,
        xProfile ? "存在" : "不存在"
      );
      if (!chat || !xProfile) {
        console.error(`❌ [打开用户人设编辑器] 无法获取角色信息`);
        showXToast("无法获取角色信息", "error");
        return;
      }
      // 获取现有的用户人设（如果有的话）
      const existingPersona = xProfile.userPersona || "";
      console.log(
        `📖 [打开用户人设编辑器] 现有人设长度: ${existingPersona.length} 字符`
      );
      console.log(
        `📖 [打开用户人设编辑器] 人设内容预览: "${existingPersona.substring(
          0,
          100
        )}${existingPersona.length > 100 ? "..." : ""}"`
      ); // 显示编辑弹窗
      window.showUserPersonaModal(
        characterId,
        chat.name,
        xProfile.xName,
        existingPersona
      );
    } catch (error) {
      console.error("❌ [打开用户人设编辑器] 失败:", error);
      console.error(
        "❌ [打开用户人设编辑器] 错误详情:",
        error.message,
        error.stack
      );
      showXToast("打开编辑器失败: " + error.message, "error");
    }
  }; // 显示用户人设编辑弹窗 - 全局函数
  window.showUserPersonaModal = function (
    characterId,
    characterName,
    xName,
    existingPersona
  ) {
    console.log(`🖼️ [显示用户人设弹窗] 角色: ${xName} (${characterName})`);
    console.log(`🖼️ [显示用户人设弹窗] 角色ID: ${characterId}`);
    console.log(
      `🖼️ [显示用户人设弹窗] 传入的人设长度: ${existingPersona.length} 字符`
    );
    const modal = document.createElement("div");
    modal.id = "user-persona-modal";
    modal.style.cssText = `
 position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10000; backdrop-filter: blur(4px); `;
    modal.innerHTML = `
 <div style="background-color: #1a1a1a; border-radius: 16px; width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto; position: relative; border: 1px solid #333; ">

 <div style="padding: 20px; border-bottom: 1px solid #333; display: flex; align-items: center; justify-content: space-between; ">
 <div>
 <h3 style="margin: 0; color: #fff; font-size: 18px; font-weight: 700;">
 编辑用户人设
 </h3>
 <p style="margin: 4px 0 0; color: #71767b; font-size: 14px;">
 为 ${xName} (${characterName}) 设置你的身份信息
 </p>
 </div>
 <button onclick="window.closeUserPersonaModal()" style="background: transparent; border: none; color: #71767b; cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </button>
 </div>

 <div style="padding: 20px;">

 <div style="background-color: #003d82; border: 1px solid var(--x-accent); border-radius: 8px; padding: 12px; margin-bottom: 20px; ">
 <div style="color: var(--x-accent); font-size: 14px; font-weight: 600; margin-bottom: 4px;">
 💡 如何设置用户人设
 </div>
 <div style="color: #e1e8ed; font-size: 13px; line-height: 1.4;">
 • 描述你希望这个角色了解的关于你的信息<br>
 • 例如：性格特点、兴趣爱好、职业背景等<br>
 • 这些信息将帮助角色更自然地与你互动
 </div>
 </div>

 <div style="margin-bottom: 20px;">
 <label style="display: block; color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 8px; ">用户人设</label>
 <textarea id="user-persona-input" placeholder="请描述你希望${xName}了解的关于你的信息..." style="width: 100%; min-height: 120px; max-height: 300px; background-color: #0a0a0a; border: 1px solid #333; border-radius: 8px; color: #fff; font-size: 14px; padding: 12px; resize: vertical; outline: none; box-sizing: border-box; font-family: inherit; line-height: 1.4; " oninput="window.updatePersonaCharCount()">${existingPersona}</textarea>
 <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px; ">
 <div style="color: #71767b; font-size: 12px;">
 建议详细描述，帮助角色更好地理解你
 </div>
 <div id="persona-char-count" style="color: #71767b; font-size: 12px;">
 ${existingPersona.length} 字符
 </div>
 </div>
 </div>

 <div style="display: flex; gap: 12px; justify-content: flex-end;">
 <button onclick="window.closeUserPersonaModal()" style="background: transparent; color: #71767b; border: 1px solid #333; border-radius: 20px; padding: 8px 20px; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.05)'"
 onmouseout="this.style.backgroundColor='transparent'">
 取消
 </button>
 <button onclick="window.saveUserPersona('${characterId}')" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 8px 20px; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'"
 onmouseout="this.style.backgroundColor='var(--x-accent)'">
 保存
 </button>
 </div>
 </div>
 </div>
 `;
    document.body.appendChild(modal); // 点击背景关闭弹窗
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        window.closeUserPersonaModal();
      }
    });
  }; // 更新字符计数 - 全局函数
  window.updatePersonaCharCount = function () {
    const textarea = document.getElementById("user-persona-input");
    const countEl = document.getElementById("persona-char-count");
    if (textarea && countEl) {
      countEl.textContent = `${textarea.value.length} 字符`;
    }
  }; // 关闭用户人设编辑弹窗 - 全局函数
  window.closeUserPersonaModal = function () {
    console.log(`🚪 [关闭用户人设弹窗] 关闭编辑弹窗`);
    const modal = document.getElementById("user-persona-modal");
    if (modal) {
      // 记录关闭时的数据状态
      const textarea = document.getElementById("user-persona-input");
      if (textarea) {
        console.log(
          `🚪 [关闭用户人设弹窗] 弹窗中当前内容长度: ${textarea.value.length} 字符`
        );
      }
      modal.remove();
      console.log(`✅ [关闭用户人设弹窗] 弹窗已移除`);
    }
  }; // 保存用户人设 - 全局函数
  window.saveUserPersona = async function (characterId) {
    const textarea = document.getElementById("user-persona-input");
    const persona = textarea.value.trim();
    console.log(`💾 [保存用户人设] 开始保存角色 ${characterId} 的用户人设`);
    console.log(`💾 [保存用户人设] 人设内容长度: ${persona.length} 字符`);
    try {
      const db = getXDB(); // 获取现有的角色X资料
      let xProfile = await db.xCharacterProfiles.get(characterId);
      console.log(
        `💾 [保存用户人设] 获取到的角色资料:`,
        xProfile ? "存在" : "不存在"
      );
      if (xProfile) {
        // 保存前记录旧值
        const oldPersona = xProfile.userPersona || "";
        console.log(`💾 [保存用户人设] 旧人设长度: ${oldPersona.length} 字符`);
        console.log(`💾 [保存用户人设] 新人设长度: ${persona.length} 字符`); // 更新用户人设
        xProfile.userPersona = persona; // 确保数据被正确保存
        await db.xCharacterProfiles.put(xProfile); // 验证保存结果 - 重新读取确认
        const verifyProfile = await db.xCharacterProfiles.get(characterId);
        const savedPersona = verifyProfile?.userPersona || "";
        console.log(
          `✅ [保存用户人设] 验证保存结果 - 实际保存长度: ${savedPersona.length} 字符`
        );
        if (savedPersona === persona) {
          console.log(`✅ [保存用户人设] 数据验证成功，保存一致`);
        } else {
          console.warn(
            `⚠️ [保存用户人设] 数据验证失败！保存的内容与预期不一致`
          );
          console.warn(
            `⚠️ [保存用户人设] 预期: "${persona.substring(0, 50)}..."`
          );
          console.warn(
            `⚠️ [保存用户人设] 实际: "${savedPersona.substring(0, 50)}..."`
          );
        }
        showXToast(persona ? "用户人设已保存" : "用户人设已清空", "success");
        window.closeUserPersonaModal(); // 重新加载角色列表以更新UI显示
        console.log(`🔄 [保存用户人设] 重新加载角色身份识别列表`);
        await loadIdentityCharactersList();
      } else {
        console.error(
          `❌ [保存用户人设] 无法找到角色资料，角色ID: ${characterId}`
        );
        showXToast("无法找到角色资料", "error");
      }
    } catch (error) {
      console.error("❌ [保存用户人设] 保存失败:", error);
      console.error("❌ [保存用户人设] 错误详情:", error.message, error.stack);
      showXToast("保存失败: " + error.message, "error");
    }
  }; // 保存个人资料更改
  async function saveProfileChanges() {
    // 获取表单数据
    const newName = document.getElementById("edit-user-name").value.trim();
    const newHandle = document.getElementById("edit-user-handle").value.trim();
    const newBio = document.getElementById("edit-user-bio").value.trim();
    const newTag1 = document.getElementById("edit-custom-tag1").value.trim();
    const newTag2 = document.getElementById("edit-custom-tag2").value.trim();
    const newTag1Icon =
      document.getElementById("edit-tag1-icon").value.trim() || "✨";
    const newTag2Icon =
      document.getElementById("edit-tag2-icon").value.trim() || "📅";
    const newTag1Color =
      document.getElementById("edit-tag1-color").value || "#71767b";
    const newTag2Color =
      document.getElementById("edit-tag2-color").value || "#71767b";
    const newFollowing = getFollowCountValue(
      document.getElementById("edit-following-count").value
    );
    const newFollowers = getFollowCountValue(
      document.getElementById("edit-followers-count").value
    );
    const newCover = document.getElementById("edit-cover-image").src;
    const newAvatar = document.getElementById("edit-main-avatar").src; // 获取认证类型数据
    const newVerificationType = document.getElementById(
      "edit-verification-type"
    ).value;
    const newCoupleCharacterId = document.getElementById(
      "edit-couple-character"
    ).value; // 获取情侣角色的X平台身份信息（如果有选择）
    let newCoupleCharacterName = "";
    if (newCoupleCharacterId) {
      try {
        const db = getXDB();
        const coupleCharacterProfile = await db.xCharacterProfiles.get(
          newCoupleCharacterId
        );
        if (coupleCharacterProfile) {
          // 使用X平台的handle和name组合
          newCoupleCharacterName = `@${coupleCharacterProfile.xHandle}（${coupleCharacterProfile.xName}）`;
        } else {
          // 如果没有X资料，从选项中获取，并生成默认格式
          const coupleOption = document.querySelector(
            `#edit-couple-character option[value="${newCoupleCharacterId}"]`
          );
          const displayName = coupleOption ? coupleOption.textContent : "";
          if (displayName) {
            const defaultHandle = displayName
              .toLowerCase()
              .replace(/\s+/g, "_");
            newCoupleCharacterName = `@${defaultHandle}（${displayName}）`;
          }
        }
      } catch (error) {
        console.error("获取情侣角色X资料失败:", error); // 备用方案：从选项中获取
        const coupleOption = document.querySelector(
          `#edit-couple-character option[value="${newCoupleCharacterId}"]`
        );
        const displayName = coupleOption ? coupleOption.textContent : "";
        if (displayName) {
          const defaultHandle = displayName.toLowerCase().replace(/\s+/g, "_");
          newCoupleCharacterName = `@${defaultHandle}（${displayName}）`;
        }
      }
    }
    // 获取公众身份和真名设置
    const newPublicIdentity = document
      .getElementById("edit-public-identity")
      .value.trim();
    const newShowRealName = document.getElementById(
      "edit-show-real-name"
    ).checked;
    const newRealName = document.getElementById("edit-real-name").value.trim(); // 验证数据
    if (!newName) {
      showXToast("名称不能为空", "error");
      return;
    }
    if (!newHandle) {
      showXToast("用户名不能为空", "error");
      return;
    }
    if (newName.length > 50) {
      showXToast("名称不能超过50个字符", "error");
      return;
    }
    if (newHandle.length > 15) {
      showXToast("用户名不能超过15个字符", "error");
      return;
    }
    if (newBio.length > 160) {
      showXToast("自我介绍不能超过160个字符", "error");
      return;
    }
    if (newTag1.length > 30) {
      showXToast("自定义标签1不能超过30个字符", "error");
      return;
    }
    if (newTag2.length > 30) {
      showXToast("自定义标签2不能超过30个字符", "error");
      return;
    }
    if (newFollowing.length > 20) {
      showXToast("关注数量过长", "error");
      return;
    }
    if (newFollowers.length > 20) {
      showXToast("关注者数量过长", "error");
      return;
    }
    // 公众身份已移除字符限制
    if (newShowRealName && newRealName.length > 50) {
      showXToast("真实姓名不能超过50个字符", "error");
      return;
    }
    if (newShowRealName && !newRealName) {
      showXToast("选择公开真名时必须填写真实姓名", "error");
      return;
    }
    // 更新用户数据（使用window.userProfileData确保数据持久化）
    window.userProfileData.name = newName;
    window.userProfileData.handle = "@" + newHandle;
    window.userProfileData.bio = newBio;
    window.userProfileData.customTag1 = newTag1;
    window.userProfileData.customTag2 = newTag2;
    window.userProfileData.customTag1Icon = newTag1Icon;
    window.userProfileData.customTag2Icon = newTag2Icon;
    window.userProfileData.customTag1Color = newTag1Color;
    window.userProfileData.customTag2Color = newTag2Color;
    window.userProfileData.following = newFollowing;
    window.userProfileData.followers = newFollowers;
    window.userProfileData.coverImage = newCover;
    window.userProfileData.avatar = newAvatar; // 更新认证类型数据
    window.userProfileData.verificationType = newVerificationType;
    window.userProfileData.coupleCharacterId = newCoupleCharacterId;
    window.userProfileData.coupleCharacterName = newCoupleCharacterName; // 更新公众身份和真名设置
    window.userProfileData.publicIdentity = newPublicIdentity;
    window.userProfileData.showRealName = newShowRealName;
    window.userProfileData.realName = newShowRealName ? newRealName : ""; // 只有选择公开时才保存真名
    // 根据认证类型更新verified字段
    window.userProfileData.verified = newVerificationType !== "none"; // ⚠️ 注意：knownIdentityCharacters已通过toggleIdentityCharacter函数实时更新到window.userProfileData
    // 这里不需要重新收集，直接保存即可
    // 确保字段存在
    if (!window.userProfileData.knownIdentityCharacters) {
      window.userProfileData.knownIdentityCharacters = [];
    }
    // 如果是情侣认证且绑定了角色，为该角色也设置情侣认证
    if (newVerificationType === "couple" && newCoupleCharacterId) {
      setCoupleVerificationForCharacter(
        newCoupleCharacterId,
        window.userProfileData.name
      );
    }
    try {
      // 调试：保存前检查
      console.log("📝 准备保存用户资料...");
      console.log(
        "👤 已知身份角色数:",
        window.userProfileData.knownIdentityCharacters?.length || 0
      );
      console.log(
        "👤 已知身份角色列表:",
        window.userProfileData.knownIdentityCharacters || []
      ); // 保存到数据库
      await saveUserProfileToDB(); // 更新UI显示
      loadUserProfileToUI(); // 更新认证徽章显示
      updateVerificationBadge(); // 同步头像到所有位置
      syncUserAvatar(newAvatar); // 关闭弹窗
      closeEditProfileModal();
      let successMessage = "个人资料已更新";
      if (
        window.userProfileData.knownIdentityCharacters &&
        window.userProfileData.knownIdentityCharacters.length > 0
      ) {
        successMessage += `，已设置 ${window.userProfileData.knownIdentityCharacters.length} 个角色知道您的身份`;
      }
      showXToast(successMessage, "success"); // 调试：输出身份识别设置
      if (
        window.userProfileData.knownIdentityCharacters &&
        window.userProfileData.knownIdentityCharacters.length > 0
      ) {
        console.log(
          "✅ 已保存的用户身份识别设置:",
          window.userProfileData.knownIdentityCharacters
        );
        console.log("✅ 这些角色现在知道您的身份，可以在X平台上与您自然互动");
      }
    } catch (error) {
      console.error("保存个人资料失败:", error);
      showXToast("保存失败: " + error.message, "error");
    }
  }
  // 发帖弹窗相关功能
  // 隐私设置状态：'public' = 所有人可见，'private' = 仅自己可见，'business' = 商业化推贴
  let tweetPrivacySetting = "public";
  let selectedBusinessTransferId = null; // 选中的商业转账任务ID
  // 打开发帖弹窗
  function openComposeTweetModal() {
    const modal = document.getElementById("compose-tweet-modal");
    modal.style.display = "flex";
    document.body.style.overflow = "hidden"; // 重置弹窗内容
    resetComposeModal(); // 同步用户头像
    const avatar = document.querySelector(
      '#compose-tweet-modal img[alt="用户头像"]'
    );
    if (avatar) {
      avatar.src = userProfileData.avatar;
    }
  }
  // 关闭发帖弹窗
  function closeComposeTweetModal(event) {
    if (event && event.target !== event.currentTarget) {
      return;
    }
    const modal = document.getElementById("compose-tweet-modal");
    modal.style.display = "none";
    document.body.style.overflow = "auto"; // 清理引用内容
    if (typeof removeQuoteContent === "function") {
      removeQuoteContent();
    }
    // 清理粉丝群引用
    const fanGroupQuoteSection = document.getElementById(
      "compose-fangroup-quote-section"
    );
    if (fanGroupQuoteSection) {
      fanGroupQuoteSection.remove();
    }
    window.currentQuoteFanGroup = null;
  }
  // 重置弹窗内容
  function resetComposeModal() {
    // 清空文本输入
    document.getElementById("compose-text-input").value = "";
    updateComposeCharCount();
    updateComposeTweetButton(); // 隐藏所有功能区域
    document.getElementById("compose-image-section").style.display = "none";
    document.getElementById("compose-location-section").style.display = "none";
    document.getElementById("compose-link-section").style.display = "none"; // 重置功能按钮状态
    resetFunctionButtonStates(); // 清空各功能区域的内容
    clearImageSection();
    clearLocationSection();
    clearLinkSection(); // 重置隐私设置为默认值
    tweetPrivacySetting = "public";
    selectedBusinessTransferId = null;
    const iconPath = document.getElementById("privacy-icon-path");
    const textElement = document.getElementById("privacy-text");
    iconPath.setAttribute(
      "d",
      "M12 1.75C6.34 1.75 1.75 6.34 1.75 12S6.34 22.25 12 22.25 22.25 17.66 22.25 12 17.66 1.75 12 1.75zm-.81 14.68l-4.1-3.27 1.25-1.57 2.47 1.98 3.97-5.47 1.62 1.18-5.21 7.15z"
    );
    textElement.textContent = "所有人可以回复";
    textElement.style.color = "var(--x-accent)"; // 隐藏商业任务选择区域
    const businessSection = document.getElementById("business-task-selection");
    if (businessSection) businessSection.style.display = "none"; // 清理引用内容
    if (typeof removeQuoteContent === "function") {
      removeQuoteContent();
    }
    // 清理粉丝群引用
    const fanGroupQuoteSection = document.getElementById(
      "compose-fangroup-quote-section"
    );
    if (fanGroupQuoteSection) {
      fanGroupQuoteSection.remove();
    }
    window.currentQuoteFanGroup = null;
  }
  // 处理文本输入
  function handleComposeInput() {
    updateComposeCharCount();
    updateComposeTweetButton();
    processHashtagsAndMentions();
  }
  // 更新字符计数
  function updateComposeCharCount() {
    const textInput = document.getElementById("compose-text-input");
    const charCount = document.getElementById("compose-char-count");
    const length = textInput.value.length;
    charCount.textContent = `${length} / 280`; // 根据字符数更改颜色
    if (length > 260) {
      charCount.style.color = "#f4212e";
    } else if (length > 240) {
      charCount.style.color = "#ffad1f";
    } else {
      charCount.style.color = "#71767b";
    }
  }
  // 更新发帖按钮状态
  function updateComposeTweetButton() {
    const textInput = document.getElementById("compose-text-input");
    const tweetBtn = document.getElementById("compose-tweet-btn");
    const hasContent = textInput.value.trim().length > 0;
    if (hasContent) {
      tweetBtn.disabled = false;
      tweetBtn.style.opacity = "1";
      tweetBtn.style.cursor = "pointer";
    } else {
      tweetBtn.disabled = true;
      tweetBtn.style.opacity = "0.5";
      tweetBtn.style.cursor = "not-allowed";
    }
  }
  // 处理话题标签和提及
  function processHashtagsAndMentions() {
    const textInput = document.getElementById("compose-text-input");
    const text = textInput.value; // 这里可以添加实时高亮#和@的逻辑
    // 由于textarea的限制，我们暂时不实现实时高亮
    // 在实际发布时会处理这些标签
  }
  // 切换图片区域
  function toggleImageSection() {
    const section = document.getElementById("compose-image-section");
    const btn = document.getElementById("image-btn");
    if (section.style.display === "none") {
      section.style.display = "block";
      btn.style.backgroundColor = "rgba(29,155,240,0.1)";
    } else {
      section.style.display = "none";
      btn.style.backgroundColor = "transparent";
      clearImageSection();
    }
  }
  // 选择图片添加方式
  function selectImageMethod(method) {
    const descBtn = document.getElementById("img-desc-btn");
    const uploadBtn = document.getElementById("img-upload-btn");
    const descInput = document.getElementById("image-description-input");
    const uploadArea = document.getElementById("image-upload-area"); // 重置按钮样式
    descBtn.style.backgroundColor = "#333";
    descBtn.style.borderColor = "#536471";
    uploadBtn.style.backgroundColor = "#333";
    uploadBtn.style.borderColor = "#536471"; // 隐藏所有区域
    descInput.style.display = "none";
    uploadArea.style.display = "none";
    if (method === "description") {
      descBtn.style.backgroundColor = "var(--x-accent)";
      descBtn.style.borderColor = "var(--x-accent)";
      descInput.style.display = "block";
    } else if (method === "upload") {
      uploadBtn.style.backgroundColor = "var(--x-accent)";
      uploadBtn.style.borderColor = "var(--x-accent)";
      uploadArea.style.display = "block";
    }
  }
  // 触发图片上传
  function triggerImageUpload() {
    document.getElementById("image-file-input").click();
  }
  // 存储上传的图片数据（支持多图）
  let uploadedImagesData = []; // 处理图片上传（支持多图）
  function handleImageUpload(event) {
    const files = event.target.files;
    if (!files || files.length === 0) return; // 验证图片数量（最多4张）
    if (uploadedImagesData.length + files.length > 4) {
      showXToast("最多只能上传4张图片", "error");
      return;
    }
    const previewContainer = document.getElementById(
      "preview-images-container"
    );
    const previewArea = document.getElementById("uploaded-image-preview");
    let loadedCount = 0;
    const totalFiles = files.length;
    for (let i = 0; i < files.length; i++) {
      const file = files[i]; // 验证文件类型
      if (!file.type.startsWith("image/")) {
        showXToast("请选择图片文件", "error");
        continue;
      }
      // 验证文件大小
      if (file.size > 5 * 1024 * 1024) {
        showXToast("图片文件不能超过5MB", "error");
        continue;
      }
      const reader = new FileReader();
      reader.onload = function (e) {
        const imageData = e.target.result;
        uploadedImagesData.push(imageData); // 创建预览元素
        const previewItem = document.createElement("div");
        previewItem.style.cssText =
          "position: relative; border-radius: 8px; overflow: hidden;";
        previewItem.innerHTML = `
 <img src="${imageData}" style="width: 100%; height: 150px; object-fit: cover; display: block;" alt="预览图片">
 <div onclick="removeUploadedImage(${
   uploadedImagesData.length - 1
 })" style="position: absolute; top: 4px; right: 4px; background-color: rgba(0,0,0,0.7); border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(0,0,0,0.9)'" onmouseout="this.style.backgroundColor='rgba(0,0,0,0.7)'">
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #fff;">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>
 `;
        previewContainer.appendChild(previewItem);
        previewArea.style.display = "block";
        loadedCount++;
        if (loadedCount === totalFiles) {
          showXToast(`成功上传${totalFiles}张图片`, "success");
        }
      };
      reader.readAsDataURL(file);
    }
  }
  // 移除单张上传的图片
  window.removeUploadedImage = function (index) {
    uploadedImagesData.splice(index, 1); // 重新渲染预览
    const previewContainer = document.getElementById(
      "preview-images-container"
    );
    const previewArea = document.getElementById("uploaded-image-preview");
    previewContainer.innerHTML = "";
    if (uploadedImagesData.length === 0) {
      previewArea.style.display = "none";
    } else {
      uploadedImagesData.forEach((imageData, idx) => {
        const previewItem = document.createElement("div");
        previewItem.style.cssText =
          "position: relative; border-radius: 8px; overflow: hidden;";
        previewItem.innerHTML = `
 <img src="${imageData}" style="width: 100%; height: 150px; object-fit: cover; display: block;" alt="预览图片">
 <div onclick="removeUploadedImage(${idx})" style="position: absolute; top: 4px; right: 4px; background-color: rgba(0,0,0,0.7); border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(0,0,0,0.9)'" onmouseout="this.style.backgroundColor='rgba(0,0,0,0.7)'">
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #fff;">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>
 `;
        previewContainer.appendChild(previewItem);
      });
    }
    showXToast("已移除图片", "info");
  }; // 移除图片
  function removeImage() {
    clearImageSection();
    toggleImageSection(); // 关闭图片区域
  }
  // 清空图片区域
  function clearImageSection() {
    // 重置文件输入
    document.getElementById("image-file-input").value = ""; // 清空上传的图片数据
    uploadedImagesData = []; // 隐藏预览
    document.getElementById("uploaded-image-preview").style.display = "none"; // 清空预览容器
    const previewContainer = document.getElementById(
      "preview-images-container"
    );
    if (previewContainer) {
      previewContainer.innerHTML = "";
    }
    // 清空描述文本
    const descTextarea = document.querySelector(
      "#image-description-input textarea"
    );
    if (descTextarea) {
      descTextarea.value = "";
    }
    // 重置按钮状态
    const descBtn = document.getElementById("img-desc-btn");
    const uploadBtn = document.getElementById("img-upload-btn");
    descBtn.style.backgroundColor = "#333";
    descBtn.style.borderColor = "#536471";
    uploadBtn.style.backgroundColor = "#333";
    uploadBtn.style.borderColor = "#536471"; // 隐藏输入区域
    document.getElementById("image-description-input").style.display = "none";
    document.getElementById("image-upload-area").style.display = "none";
  }
  // 切换位置区域
  function toggleLocationSection() {
    const section = document.getElementById("compose-location-section");
    const btn = document.getElementById("location-btn");
    if (section.style.display === "none") {
      section.style.display = "block";
      btn.style.backgroundColor = "rgba(29,155,240,0.1)";
    } else {
      section.style.display = "none";
      btn.style.backgroundColor = "transparent";
      clearLocationSection();
    }
  }
  // 移除位置
  function removeLocation() {
    clearLocationSection();
    toggleLocationSection(); // 关闭位置区域
  }
  // 清空位置区域
  function clearLocationSection() {
    document.getElementById("location-input").value = "";
  }
  // 切换链接区域
  function toggleLinkSection() {
    const section = document.getElementById("compose-link-section");
    const btn = document.getElementById("attach-btn");
    if (section.style.display === "none") {
      section.style.display = "block";
      btn.style.backgroundColor = "rgba(29,155,240,0.1)";
    } else {
      section.style.display = "none";
      btn.style.backgroundColor = "transparent";
      clearLinkSection();
    }
  }
  // 移除链接
  function removeLink() {
    clearLinkSection();
    toggleLinkSection(); // 关闭链接区域
  }
  // 清空链接区域
  function clearLinkSection() {
    document.getElementById("link-title-input").value = "";
    document.getElementById("link-url-input").value = "";
    document.getElementById("link-description-input").value = "";
  }
  // 重置功能按钮状态
  function resetFunctionButtonStates() {
    const buttons = ["image-btn", "location-btn", "attach-btn"];
    buttons.forEach((btnId) => {
      const btn = document.getElementById(btnId);
      btn.style.backgroundColor = "transparent";
    });
  }
  // 切换隐私设置
  async function togglePrivacySettings() {
    // 三种模式循环切换：public → private → business → public
    if (tweetPrivacySetting === "public") {
      tweetPrivacySetting = "private";
    } else if (tweetPrivacySetting === "private") {
      // 检查是否有待完成的商业转账任务
      const hasBusinessTasks = await checkPendingBusinessTasks();
      if (hasBusinessTasks) {
        tweetPrivacySetting = "business";
      } else {
        tweetPrivacySetting = "public";
        showXToast("当前没有待完成的商业转账任务", "info");
      }
    } else {
      tweetPrivacySetting = "public";
    }
    updatePrivacySettingUI();
  }
  // 更新隐私设置UI
  function updatePrivacySettingUI() {
    const iconPath = document.getElementById("privacy-icon-path");
    const textElement = document.getElementById("privacy-text");
    if (tweetPrivacySetting === "public") {
      // 所有人可见
      iconPath.setAttribute(
        "d",
        "M12 1.75C6.34 1.75 1.75 6.34 1.75 12S6.34 22.25 12 22.25 22.25 17.66 22.25 12 17.66 1.75 12 1.75zm-.81 14.68l-4.1-3.27 1.25-1.57 2.47 1.98 3.97-5.47 1.62 1.18-5.21 7.15z"
      );
      textElement.textContent = "所有人可以回复";
      textElement.style.color = "var(--x-accent)"; // 隐藏商业任务选择区域
      const businessSection = document.getElementById(
        "business-task-selection"
      );
      if (businessSection) businessSection.style.display = "none";
      showXToast("已切换为所有人可见", "success");
    } else if (tweetPrivacySetting === "private") {
      // 仅自己可见
      iconPath.setAttribute(
        "d",
        "M17.863 13.44c1.477 1.58 2.366 3.8 2.632 6.46l.11 1.1H3.395l.11-1.1c.266-2.66 1.155-4.88 2.632-6.46C7.627 11.85 9.648 11 12 11s4.373.85 5.863 2.44zM12 2C9.791 2 8 3.79 8 6s1.791 4 4 4 4-1.79 4-4-1.791-4-4-4z"
      );
      textElement.textContent = "仅自己可见";
      textElement.style.color = "var(--x-accent)"; // 隐藏商业任务选择区域
      const businessSection = document.getElementById(
        "business-task-selection"
      );
      if (businessSection) businessSection.style.display = "none";
      showXToast("已切换为仅自己可见", "success");
    } else {
      // 商业化推贴
      iconPath.setAttribute(
        "d",
        "M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"
      );
      textElement.textContent = "商业化推贴";
      textElement.style.color = "var(--x-accent)"; // 显示商业任务选择区域
      showBusinessTaskSelection();
      showXToast("已切换为商业化推贴", "success");
    }
  }
  // 检查是否有待完成的商业转账任务
  async function checkPendingBusinessTasks() {
    try {
      const xDb = getXDB();
      const businessTransfersId = `businessTransfers_${
        currentAccountId || "main"
      }`;
      const savedData = await xDb.xAccountProfiles.get(businessTransfersId);
      console.log("🔍 [检查商业任务] 数据:", savedData);
      if (!savedData || !savedData.data) {
        console.log("🔍 [检查商业任务] 没有保存的数据");
        return false;
      }
      console.log("🔍 [检查商业任务] 总任务数:", savedData.data.length); // 筛选接收的、进行中且未过期的商业转账
      const now = new Date();
      const pendingTasks = savedData.data.filter((t) => {
        console.log("🔍 [检查任务]", {
          direction: t.direction,
          taskStatus: t.taskStatus,
          taskDeadline: t.taskDeadline,
          acceptedAt: t.acceptedAt,
          taskDeadlineHours: t.taskDeadlineHours,
        });
        if (t.direction !== "received" || t.taskStatus !== "in_progress")
          return false; // 检查是否有 taskDeadline 字段，如果没有则尝试动态计算
        let deadline;
        if (!t.taskDeadline) {
          if (t.acceptedAt && t.taskDeadlineHours) {
            // 动态计算截止时间
            const acceptedTime = new Date(t.acceptedAt);
            const deadlineHours = parseFloat(t.taskDeadlineHours) || 24;
            deadline = new Date(
              acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000
            );
            console.log(
              "⚠️ [检查任务] 动态计算截止时间:",
              deadline.toISOString()
            );
          } else {
            console.warn(
              "⚠️ [检查任务] 任务没有足够信息计算截止时间，仍然认为有效",
              t
            );
            return true; // 如果没有截止时间，认为任务有效
          }
        } else {
          deadline = new Date(t.taskDeadline);
        }
        const isValid = deadline.getTime() > now.getTime();
        console.log(
          "🔍 [检查任务] 是否有效:",
          isValid,
          "截止时间:",
          deadline,
          "现在:",
          now
        );
        return isValid; // 只保留未过期的任务
      });
      console.log("🔍 [检查商业任务] 有效任务数:", pendingTasks.length);
      return pendingTasks.length > 0;
    } catch (error) {
      console.error("检查商业任务失败:", error);
      return false;
    }
  }
  // 显示商业任务选择区域
  async function showBusinessTaskSelection() {
    try {
      const xDb = getXDB();
      const businessTransfersId = `businessTransfers_${
        currentAccountId || "main"
      }`;
      const savedData = await xDb.xAccountProfiles.get(businessTransfersId);
      const businessSection = document.getElementById(
        "business-task-selection"
      );
      const tasksList = document.getElementById("business-tasks-list");
      if (!businessSection || !tasksList) return;
      businessSection.style.display = "block";
      tasksList.innerHTML = "";
      if (!savedData || !savedData.data) {
        tasksList.innerHTML = `
 <div style="text-align: center; padding: 24px 12px; color: #71767b; font-size: 13px; ">
 <svg viewBox="0 0 24 24" style="width: 40px; height: 40px; fill: currentColor; opacity: 0.3; margin: 0 auto 8px;">
 <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path></g>
 </svg>
 <div>没有待完成的任务</div>
 </div>
 `;
        return;
      }
      // 筛选接收的、进行中的商业转账，并排除已过期的任务
      const now = new Date();
      console.log("📋 [显示任务列表] 开始筛选，总数:", savedData.data.length);
      const pendingTasks = savedData.data.filter((t) => {
        console.log("📋 [筛选任务]", {
          direction: t.direction,
          taskStatus: t.taskStatus,
          taskDeadline: t.taskDeadline,
          acceptedAt: t.acceptedAt,
          taskDeadlineHours: t.taskDeadlineHours,
        });
        if (t.direction !== "received" || t.taskStatus !== "in_progress")
          return false; // 如果没有截止时间，尝试动态计算
        let deadline;
        if (!t.taskDeadline) {
          if (t.acceptedAt && t.taskDeadlineHours) {
            // 动态计算截止时间
            const acceptedTime = new Date(t.acceptedAt);
            const deadlineHours = parseFloat(t.taskDeadlineHours) || 24;
            deadline = new Date(
              acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000
            );
            console.log(
              "⚠️ [筛选任务] 动态计算截止时间:",
              deadline.toISOString()
            );
          } else {
            console.warn(
              "⚠️ [筛选任务] 任务没有足够信息计算截止时间，仍然显示",
              t.transferId
            );
            return true;
          }
        } else {
          deadline = new Date(t.taskDeadline);
        }
        const isValid = deadline.getTime() > now.getTime();
        console.log("📋 [筛选任务] 是否有效:", isValid);
        return isValid; // 只保留未过期的任务
      });
      console.log("📋 [显示任务列表] 筛选后:", pendingTasks.length);
      if (pendingTasks.length === 0) {
        tasksList.innerHTML = `
 <div style="text-align: center; padding: 24px 12px; color: #71767b; font-size: 13px; ">
 <svg viewBox="0 0 24 24" style="width: 40px; height: 40px; fill: currentColor; opacity: 0.3; margin: 0 auto 8px;">
 <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path></g>
 </svg>
 <div>没有待完成的任务</div>
 </div>
 `;
        return;
      }
      // 渲染任务列表
      pendingTasks.forEach((task) => {
        // 获取或计算截止时间
        let deadline;
        if (task.taskDeadline) {
          deadline = new Date(task.taskDeadline);
        } else if (task.acceptedAt && task.taskDeadlineHours) {
          const acceptedTime = new Date(task.acceptedAt);
          const deadlineHours = parseFloat(task.taskDeadlineHours) || 24;
          deadline = new Date(
            acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000
          );
        } else {
          // 无法计算截止时间，使用默认24小时
          deadline = new Date(now.getTime() + 24 * 60 * 60 * 1000);
        }
        const remainingMs = deadline.getTime() - now.getTime(); // 计算剩余时间
        const hours = Math.floor(remainingMs / (1000 * 60 * 60));
        const minutes = Math.floor(
          (remainingMs % (1000 * 60 * 60)) / (1000 * 60)
        );
        const deadlineText =
          hours > 0 ? `剩余 ${hours}小时${minutes}分钟` : `剩余 ${minutes}分钟`;
        const isSelected = selectedBusinessTransferId === task.transferId;
        const taskCard = document.createElement("div");
        taskCard.style.cssText = `
 padding: 14px; margin-bottom: 10px; background: linear-gradient(135deg, ${
   isSelected ? "rgba(255, 255, 255, 0.08)" : "rgba(255, 255, 255, 0.03)"
 } 0%, ${
          isSelected ? "rgba(255, 255, 255, 0.04)" : "rgba(255, 255, 255, 0.01)"
        } 100%); border: 1px solid ${
          isSelected ? "rgba(255, 255, 255, 0.25)" : "rgba(255, 255, 255, 0.1)"
        }; border-radius: 10px; cursor: pointer; transition: all 0.2s; position: relative; overflow: hidden; `;
        taskCard.innerHTML = `

 <div style="position: absolute; top: 50%; right: -25px; transform: translateY(-50%) rotate(15deg); font-size: 28px; color: rgba(255, 255, 255, 0.02); font-weight: 700; pointer-events: none; ">TASK</div>
 <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
 <div style="flex: 1;">
 <div style="color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 4px;">
 来自 ${task.senderName}
 </div>
 <div style="color: #71767b; font-size: 11px; font-family: monospace; letter-spacing: 0.3px;">${
   task.senderHandle
 }</div>
 </div>
 <div style="padding: 4px 10px; background: linear-gradient(135deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.06) 100%); color: #e5e5e5; font-size: 10px; font-weight: 600; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.15); letter-spacing: 0.5px; display: flex; align-items: center; gap: 4px; ">
 <svg viewBox="0 0 24 24" style="width: 10px; height: 10px; fill: currentColor;">
 <g><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"></path></g>
 </svg>
 ${deadlineText}
 </div>
 </div>

 <div style="color: #e5e5e5; font-size: 13px; line-height: 1.4; margin-bottom: 12px; padding: 10px; background: rgba(255, 255, 255, 0.02); border-left: 2px solid rgba(255, 255, 255, 0.15); border-radius: 4px; ">${
   task.taskDescription
 }</div>

 <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 10px; border-top: 1px dashed rgba(255, 255, 255, 0.1); ">
 <div style="color: #71767b; font-size: 11px; font-family: monospace; ">$${
   task.amount
 } <span style="opacity: 0.6;">(定金 $${task.depositAmount})</span></div>
 ${
   isSelected
     ? `<div style="display: inline-flex; align-items: center; gap: 4px; padding: 3px 8px; background: linear-gradient(135deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.06) 100%); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; font-size: 10px; font-weight: 600; color: #fff; letter-spacing: 0.5px; ">
 <svg viewBox="0 0 24 24" style="width: 10px; height: 10px; fill: currentColor;">
 <g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"></path></g>
 </svg>
 已选择
 </div>`
     : ""
 }
 </div>
 `;
        taskCard.onclick = () => {
          selectedBusinessTransferId = task.transferId;
          showBusinessTaskSelection(); // 重新渲染以更新选中状态
        };
        taskCard.onmouseover = function () {
          if (!isSelected) {
            this.style.borderColor = "rgba(255, 255, 255, 0.2)";
            this.style.background =
              "linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%)";
          }
        };
        taskCard.onmouseout = function () {
          if (!isSelected) {
            this.style.borderColor = "rgba(255, 255, 255, 0.1)";
            this.style.background =
              "linear-gradient(135deg, rgba(255, 255, 255, 0.03) 0%, rgba(255, 255, 255, 0.01) 100%)";
          }
        };
        tasksList.appendChild(taskCard);
      });
    } catch (error) {
      console.error("显示商业任务失败:", error);
    }
  }
  // 发布推文
  async function publishTweet() {
    const textInput = document.getElementById("compose-text-input");
    const content = textInput.value.trim();
    if (!content) {
      showXToast("请输入推文内容", "error");
      return;
    }
    // 验证商业化推贴的必填项
    if (tweetPrivacySetting === "business") {
      if (!selectedBusinessTransferId) {
        showXToast("请选择要完成的商业任务", "error");
        return;
      }
    }
    // 获取附加内容（使用window.userProfileData确保获取最新账号数据）
    const tweetData = {
      id: "user_" + Date.now(),
      content: content,
      image: getImageData(),
      location: getLocationData(),
      link: getLinkData(),
      timestamp: new Date(),
      user: {
        name: window.userProfileData.name,
        handle: window.userProfileData.handle,
        avatar: window.userProfileData.avatar,
        verified: window.userProfileData.verified,
      },
      stats: {
        comments: 0,
        retweets: 0,
        likes: 0,
        views: 0,
      },
      comments: [],
      privacy: tweetPrivacySetting,
    }; // 如果是商业化推贴，添加商业转账信息
    if (tweetPrivacySetting === "business") {
      tweetData.businessTransferId = selectedBusinessTransferId;
      tweetData.isBusinessPost = true;
    }
    // 如果有引用内容，添加到推文中
    if (typeof currentQuoteData !== "undefined" && currentQuoteData) {
      tweetData.quotedTweet = {
        type: currentQuoteData.type,
        user: {
          name: currentQuoteData.user.name,
          handle: currentQuoteData.user.handle,
          avatar: currentQuoteData.user.avatar,
          verified: currentQuoteData.user.verified,
        },
        content: currentQuoteData.content,
        time: currentQuoteData.time,
        image: currentQuoteData.image || null, // 保存图片数据
        link: currentQuoteData.link || null, // 保存链接数据
        location: currentQuoteData.location || null, // 保存位置数据
      };
    }
    // 如果有粉丝群引用，添加到推文中
    if (
      typeof window.currentQuoteFanGroup !== "undefined" &&
      window.currentQuoteFanGroup
    ) {
      tweetData.quotedFanGroup = {
        id: window.currentQuoteFanGroup.id,
        name: window.currentQuoteFanGroup.name,
        avatar: window.currentQuoteFanGroup.avatar,
        memberCount: window.currentQuoteFanGroup.memberCount,
        threshold: window.currentQuoteFanGroup.threshold,
      };
      console.log(
        "📤 [发帖] 已添加粉丝群引用到推文数据:",
        tweetData.quotedFanGroup
      );
    }
    console.log("推文数据:", tweetData); // 关闭弹窗
    closeComposeTweetModal(); // 保存用户发布的帖子到个人页面
    await saveUserTweet(tweetData); // 如果当前在个人主页，刷新推文显示
    if (document.getElementById("x-profile-page").style.display !== "none") {
      loadUserProfileTweets();
    }
    // 显示推文详情页面
    showTweetDetail(tweetData);
    showXToast(currentQuoteData ? "引用转发已发布！" : "发帖成功！", "success"); // 如果是商业化推贴，触发AI任务评估
    if (tweetPrivacySetting === "business") {
      showXToast("正在提交任务成果...", "info");
      await handleBusinessPostSubmission(tweetData, selectedBusinessTransferId);
    }
    // 如果设置为所有人可见，触发AI回复
    else if (tweetPrivacySetting === "public") {
      showXToast("正在等待回复...", "info");
      await generateAIResponseForTweet(tweetData); // 如果推文包含粉丝群引用，触发粉丝群申请生成器
      if (tweetData.quotedFanGroup) {
        console.log("📤 [粉丝群] 检测到粉丝群引用推文，准备触发申请生成器");
        setTimeout(async () => {
          await triggerFanGroupApplicationGenerator(tweetData);
        }, 2000); // 延迟2秒，让AI回复先完成渲染
      }
    }
  }
  // 获取图片数据（支持多图）
  function getImageData() {
    const imageSection = document.getElementById("compose-image-section");
    if (imageSection.style.display === "none") return null;
    const descTextarea = document.querySelector(
      "#image-description-input textarea"
    ); // 文字描述类型（单图）
    if (
      descTextarea &&
      descTextarea.style.display !== "none" &&
      descTextarea.value.trim()
    ) {
      return {
        type: "description",
        content: descTextarea.value.trim(),
      };
    }
    // 本地上传类型（多图）
    else if (uploadedImagesData && uploadedImagesData.length > 0) {
      return {
        type: "uploads", // 注意：复数形式表示多图
        images: uploadedImagesData.map((data) => ({ content: data })),
      };
    }
    return null;
  }
  // 获取位置数据
  function getLocationData() {
    const locationSection = document.getElementById("compose-location-section");
    if (locationSection.style.display === "none") return null;
    const locationInput = document.getElementById("location-input");
    const location = locationInput.value.trim();
    return location ? location : null;
  }
  // 保存功能相关函数
  function saveImageData() {
    showXToast("图片数据已保存", "success");
  }
  function saveLocationData() {
    const locationInput = document.getElementById("location-input");
    if (locationInput.value.trim()) {
      showXToast("位置信息已保存", "success");
    } else {
      showXToast("请先输入位置信息", "error");
    }
  }
  function saveLinkData() {
    const title = document.getElementById("link-title-input").value.trim();
    const url = document.getElementById("link-url-input").value.trim();
    const description = document
      .getElementById("link-description-input")
      .value.trim();
    if (title || url || description) {
      showXToast("链接信息已保存", "success");
    } else {
      showXToast("请先填写链接信息", "error");
    }
  }
  // 处理链接首图上传
  function triggerLinkImageUpload() {
    document.getElementById("link-image-input").click();
  }
  function handleLinkImageUpload(event) {
    const file = event.target.files[0];
    if (!file) return; // 验证文件类型
    if (!file.type.startsWith("image/")) {
      showXToast("请选择图片文件", "error");
      return;
    }
    // 验证文件大小
    if (file.size > 5 * 1024 * 1024) {
      showXToast("图片文件不能超过5MB", "error");
      return;
    }
    const reader = new FileReader();
    reader.onload = function (e) {
      const previewArea = document.getElementById("link-image-preview");
      const previewImg = document.getElementById("link-preview-image");
      previewImg.src = e.target.result;
      previewArea.style.display = "block";
      showXToast("链接首图上传成功", "success");
    };
    reader.readAsDataURL(file);
  }
  // 更新获取链接数据函数
  function getLinkData() {
    const linkSection = document.getElementById("compose-link-section");
    if (linkSection.style.display === "none") return null;
    const title = document.getElementById("link-title-input").value.trim();
    const url = document.getElementById("link-url-input").value.trim();
    const description = document
      .getElementById("link-description-input")
      .value.trim();
    const previewImg = document.getElementById("link-preview-image");
    const thumbnail =
      previewImg && previewImg.src.startsWith("data:") ? previewImg.src : null;
    if (title || url || description || thumbnail) {
      return {
        title: title,
        url: url,
        description: description,
        thumbnail: thumbnail,
      };
    }
    return null;
  }
  // 清空链接区域
  function clearLinkSection() {
    document.getElementById("link-title-input").value = "";
    document.getElementById("link-url-input").value = "";
    document.getElementById("link-description-input").value = "";
    document.getElementById("link-image-input").value = "";
    document.getElementById("link-image-preview").style.display = "none";
  }
  // 从推文详情返回
  window.goBackFromTweetDetail = function () {
    const currentTweetData = sessionStorage.getItem("currentTweetData");
    if (currentTweetData) {
      try {
        const tweet = JSON.parse(currentTweetData); // 根据推文来源返回到正确的页面
        if (tweet._source === "account") {
          // 返回账户主页时，重置推进模式
          if (isTweetProgressMode) {
            isTweetProgressMode = false;
            updateTweetRerollButtonUI();
            console.log("📖 [返回] 已重置推进模式");
          }
          document.getElementById("x-tweet-detail-page").style.display = "none";
          document.getElementById("account-profile-page").style.display =
            "flex";
          return;
        } else if (tweet._source === "search") {
          // 返回搜索页面时，重置推进模式
          if (isTweetProgressMode) {
            isTweetProgressMode = false;
            updateTweetRerollButtonUI();
            console.log("📖 [返回] 已重置推进模式");
          }
          document.getElementById("x-tweet-detail-page").style.display = "none"; // 恢复搜索结果视图
          if (isInSearchResults && currentSearchQuery) {
            document.getElementById("trending-view").style.display = "none";
            document.getElementById("search-results-view").style.display =
              "flex"; // 显示返回按钮，隐藏刷新按钮
            const backBtn = document.getElementById("search-back-btn");
            if (backBtn) backBtn.style.display = "flex";
            const refreshBtn = document.querySelector(".refresh-trends-btn");
            if (refreshBtn) refreshBtn.style.display = "none";
          }
          switchXPage("search");
          return;
        }
      } catch (e) {
        console.warn("解析推文数据失败:", e);
      }
    }
    // 默认返回主页
    switchXPage("home");
  }; // 显示推文详情页面
  async function showTweetDetail(tweetData) {
    console.log("📖 [显示详情] 开始显示推文详情，推文ID:", tweetData.id); // 从数据库加载最新的推文数据（包括所有评论）
    let latestTweetData = tweetData;
    try {
      const xDb = getXDB();
      const isUserTweet = tweetData.id.startsWith("user_");
      if (isUserTweet) {
        console.log("📖 [显示详情] 从用户推文数据库加载");
        const userTweetsId = `userTweets_${currentAccountId || "main"}`;
        const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
        if (userTweetsData && userTweetsData.tweets) {
          const dbTweet = userTweetsData.tweets.find(
            (t) => t.id === tweetData.id
          );
          if (dbTweet) {
            latestTweetData = dbTweet;
            console.log(
              "✅ [显示详情] 已加载最新用户推文数据，评论数:",
              dbTweet.comments?.length || 0
            );
          } else {
            console.warn("⚠️ [显示详情] 数据库中未找到该用户推文");
          }
        }
      } else {
        console.log("📖 [显示详情] 从主页推文数据库加载");
        const tweetsData = await xDb.xTweetsData.get("tweets");
        if (tweetsData) {
          let dbTweet = null;
          if (tweetsData.forYouTweets) {
            dbTweet = tweetsData.forYouTweets.find(
              (t) => t.id === tweetData.id
            );
          }
          if (!dbTweet && tweetsData.followingTweets) {
            dbTweet = tweetsData.followingTweets.find(
              (t) => t.id === tweetData.id
            );
          }
          if (dbTweet) {
            latestTweetData = dbTweet;
            console.log(
              "✅ [显示详情] 已加载最新主页推文数据，评论数:",
              dbTweet.comments?.length || 0
            );
          } else {
            console.warn("⚠️ [显示详情] 数据库中未找到该主页推文");
          }
        }
      }
    } catch (loadError) {
      console.error("❌ [显示详情] 从数据库加载推文失败:", loadError);
    }
    // 保存最新推文数据到sessionStorage，供重回功能使用
    sessionStorage.setItem("currentTweetData", JSON.stringify(latestTweetData));
    console.log("📖 [显示详情] sessionStorage 已更新"); // 隐藏所有页面
    document.querySelectorAll(".x-page").forEach((page) => {
      page.style.display = "none";
    }); // 显示推文详情页面
    const detailPage = document.getElementById("x-tweet-detail-page");
    detailPage.style.display = "flex"; // 判断是否为账户推文或搜索结果推文，如果是则强制进入推进模式
    const isAccountTweet = latestTweetData._source === "account";
    const isSearchTweet = latestTweetData._source === "search";
    const isUserTweet =
      latestTweetData.id && latestTweetData.id.startsWith("user_");
    if (isAccountTweet || isSearchTweet) {
      const sourceType = isAccountTweet ? "账户推文" : "搜索结果推文";
      console.log(
        `📖 [显示详情] 检测到${sourceType}，强制启用推进模式（该类型推文仅支持推进）`
      ); // 强制设置为推进模式（账户推文/搜索推文只能推进，不能重回）
      if (!isTweetProgressMode) {
        isTweetProgressMode = true;
        updateTweetRerollButtonUI();
      }
    } else if (isUserTweet) {
      console.log(`📖 [显示详情] 检测到用户推文，支持重回+推进模式`); // 用户推文：保持当前模式设置，支持切换
      updateTweetRerollButtonUI();
    }
    // 渲染推文详情
    renderTweetDetail(latestTweetData);
    console.log("✅ [显示详情] 推文详情页面已显示"); // 确保用户资料头像正确显示
    setTimeout(() => {
      const detailCommentUserAvatar = document.getElementById(
        "detail-comment-user-avatar"
      );
      if (detailCommentUserAvatar) {
        detailCommentUserAvatar.src = userProfileData.avatar;
      }
      // 更新所有回复输入框头像
      const replyUserAvatars = document.querySelectorAll(".reply-user-avatar");
      replyUserAvatars.forEach((avatar) => {
        avatar.src = userProfileData.avatar;
      });
    }, 100);
  }
  // 渲染推文详情
  function renderTweetDetail(tweet) {
    const container = document.getElementById("tweet-detail-container");
    container.setAttribute("data-tweet-id", tweet.id); // 创建详情HTML
    const detailHTML = `
 <div class="tweet-detail-item" style="padding: 16px 16px 4px 16px;">

 <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 16px;">
 <img src="${tweet.user.avatar}" alt="${tweet.user.name}"
 onclick="openAccountProfile('${tweet.user.name.replace(/'/g, "\\'")}', '${
      tweet.user.handle
    }', '${
      tweet.user.avatar
    }', {source: 'tweetDetail'});event.stopPropagation();"
 style="width: 48px; height: 48px; border-radius: 50%; cursor: pointer; transition: opacity 0.2s;"
 onmouseover="this.style.opacity='0.8'"
 onmouseout="this.style.opacity='1'">
 <div>
 <div style="display: flex; align-items: center; gap: 4px;">
 <span onclick="openAccountProfile('${tweet.user.name.replace(
   /'/g,
   "\\'"
 )}', '${tweet.user.handle}', '${
      tweet.user.avatar
    }', {source: 'tweetDetail'});event.stopPropagation();" style="color: #fff; font-weight: 700; font-size: 17px; cursor: pointer;">${
      tweet.user.name
    }</span>
 ${
   tweet.user.verified
     ? '<svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'
     : ""
 }
 </div>
 <div style="color: #71767b; font-size: 15px;">${
   tweet.user.handle.startsWith("@")
     ? tweet.user.handle
     : "@" + tweet.user.handle
 }</div>
 </div>
 </div>

 <div style="color: #fff; font-size: 16px; line-height: 1.3; margin-bottom: 16px; word-wrap: break-word;">
 ${processContent(tweet.content)}
 </div>
 ${renderTweetMedia(tweet)}
 ${renderTweetLink(tweet)}
 ${renderQuotedTweet(tweet)}
 ${renderQuotedFanGroup(tweet)}

 <div style="display: flex; align-items: center; justify-content: space-between; margin: 12px 0 16px 0;">
 <div style="display: flex; align-items: center; gap: 16px;">
 <span style="color: #71767b; font-size: 15px;">${formatDetailTime(
   tweet.timestamp || tweet.createdAt
 )}</span>
 <span style="color: #71767b; font-size: 15px;">·</span>
 <span id="tweet-detail-views" style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(
   tweet.stats.views
 )}</span>
 <span id="tweet-detail-views-label" style="color: #71767b; font-size: 15px;">${getI18nText(
   "tweetDetailViews"
 )}</span>
 </div>
 ${
   tweet.location
     ? `
 <div style="display: flex; align-items: center; gap: 4px; color: var(--x-accent); font-size: 15px;">
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;">
 <g>
 <path d="M12 7c-1.93 0-3.5 1.57-3.5 3.5S10.07 14 12 14s3.5-1.57 3.5-3.5S13.93 7 12 7zm0 5c-.827 0-1.5-.673-1.5-1.5S11.173 9 12 9s1.5.673 1.5 1.5S12.827 12 12 12zm0-10c-4.687 0-8.5 3.813-8.5 8.5 0 5.967 7.621 11.116 7.945 11.332l.555.37.555-.37C12.879 21.616 20.5 16.467 20.5 10.5 20.5 5.813 16.687 2 12 2zm0 17.77c-1.665-1.241-6.5-5.196-6.5-9.27C5.5 6.916 8.416 4 12 4s6.5 2.916 6.5 6.5c0 4.073-4.835 8.028-6.5 9.27z"></path>
 </g>
 </svg>
 <span>${tweet.location}</span>
 </div>
 `
     : ""
 }
 </div>

 <div id="tweet-detail-stats" style="display: flex; align-items: center; gap: 32px; padding: 16px 0; border-top: 1px solid #2f3336; border-bottom: 1px solid #2f3336;">
 <div style="display: flex; align-items: center; gap: 4px;">
 <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(
   tweet.stats.retweets
 )}</span>
 <span style="color: #71767b; font-size: 15px;">${getI18nText(
   "tweetDetailRetweets"
 )}</span>
 </div>
 <div style="display: flex; align-items: center; gap: 4px;">
 <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(
   tweet.stats.likes
 )}</span>
 <span style="color: #71767b; font-size: 15px;">${getI18nText(
   "tweetDetailLikes"
 )}</span>
 </div>
 <div style="display: flex; align-items: center; gap: 4px;">
 <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(
   tweet.stats.comments
 )}</span>
 <span style="color: #71767b; font-size: 15px;">${getI18nText(
   "tweetDetailBookmarks"
 )}</span>
 </div>
 </div>

 <div style="display: flex; justify-content: space-between; padding: 12px 0 0 0;">
 <div class="tweet-action comment" style="display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'; this.style.color='#1d9bf0';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#71767b';">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;">
 <g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g>
 </svg>
 </div>
 <div class="tweet-action retweet" style="display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(0,186,124,0.1)'; this.style.color='#00ba7c';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#71767b';">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;">
 <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g>
 </svg>
 </div>
 <div class="tweet-action like" onclick="toggleDetailLike('${
   tweet.id
 }', this)" data-liked="false" data-likes="${
      tweet.stats.likes
    }" style="display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(249,24,128,0.1)'; this.style.color='#f91880';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#71767b';">
 <svg class="action-icon like-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;">
 <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>
 </svg>
 </div>
 <div class="tweet-action bookmark" style="display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'; this.style.color='#1d9bf0';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#71767b';">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;">
 <g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g>
 </svg>
 </div>
 <div class="tweet-action share" id="tweet-detail-share-btn" style="display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 50%; cursor: pointer; color: #71767b; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(29,155,240,0.1)'; this.style.color='#1d9bf0';" onmouseout="this.style.backgroundColor='transparent'; this.style.color='#71767b';">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor" style="width: 20px; height: 20px;">
 <g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.29 3.3-1.42-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g>
 </svg>
 </div>
 </div>
 </div>
 `;
    container.innerHTML = detailHTML; // 同步用户头像
    const commentInputAvatar = document.querySelector(
      "#x-tweet-detail-page .detail-comment-input-area img"
    );
    if (commentInputAvatar) {
      commentInputAvatar.src = userProfileData.avatar;
    }
    // 添加分享按钮点击事件
    const shareBtn = document.getElementById("tweet-detail-share-btn");
    if (shareBtn) {
      shareBtn.onclick = () => {
        showShareContentModal(
          {
            user: tweet.user,
            content: tweet.content,
            time: tweet.time || formatDetailTime(tweet.timestamp),
            image: tweet.image,
            // 包含完整推文和评论区数据
            fullTweet: tweet,
            comments: tweet.comments || [],
          },
          "tweet"
        );
      };
    }
    // 渲染评论（如果有）
    renderDetailComments(tweet.comments);
  }
  // 渲染推文媒体内容（支持多图）
  function renderTweetMedia(tweet) {
    // 支持两种格式：tweet.image（旧格式）和 tweet.media（账户推文格式）
    // 1. 处理账户推文的 media 数组格式
    if (tweet.media && Array.isArray(tweet.media) && tweet.media.length > 0) {
      const media = tweet.media[0];
      if (media.type === "description" && media.description) {
        return `
 <div style="margin-bottom: 16px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 16px; padding: 16px;">
 <div style="color:var(--x-text-primary); font-size: 15px; line-height: 20px;">${media.description}</div>
 </div>
 `;
      } else if (media.type === "upload" && media.url) {
        return `
 <div style="margin-bottom: 16px; border-radius: 16px; overflow: hidden;">
 <img src="${media.url}" style="width: 100%; max-height: 400px; object-fit: cover; display: block;" alt="推文图片">
 </div>
 `;
      }
    }
    // 2. 处理旧的 image 格式（兼容性）
    if (!tweet.image) return ""; // 文字描述类型
    if (tweet.image.type === "description") {
      return `
 <div style="margin-bottom: 16px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 12px; padding: 16px; box-sizing: border-box;">
 <div style="color:var(--x-text-primary); font-size: 15px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${tweet.image.content}</div>
 </div>
 `;
    }
    // 单图上传
    else if (tweet.image.type === "upload") {
      return `
 <div style="margin-bottom: 16px; border-radius: 16px; overflow: hidden;">
 <img src="${tweet.image.content}" style="width: 100%; max-height: 400px; object-fit: cover; display: block;" alt="推文图片">
 </div>
 `;
    }
    // 多图上传
    else if (
      tweet.image.type === "uploads" &&
      tweet.image.images &&
      tweet.image.images.length > 0
    ) {
      const imageCount = tweet.image.images.length;
      let gridTemplate = "";
      if (imageCount === 1) {
        gridTemplate = "grid-template-columns: 1fr;";
      } else if (imageCount === 2) {
        gridTemplate = "grid-template-columns: repeat(2, 1fr);";
      } else if (imageCount === 3) {
        gridTemplate = "grid-template-columns: repeat(2, 1fr);";
      } else {
        gridTemplate = "grid-template-columns: repeat(2, 1fr);";
      }
      const imagesHtml = tweet.image.images
        .map((img, index) => {
          const spanStyle =
            imageCount === 3 && index === 0 ? "grid-column: span 2;" : "";
          return `
 <div style="${spanStyle}border-radius: 12px; overflow: hidden;">
 <img src="${img.content}" style="width: 100%; height: ${
            imageCount === 1 ? "400px" : "280px"
          }; object-fit: cover; display: block;" alt="推文图片${index + 1}">
 </div>
 `;
        })
        .join("");
      return `
 <div style="margin-bottom: 16px; display: grid; ${gridTemplate} gap: 4px;">
 ${imagesHtml}
 </div>
 `;
    }
    return "";
  }
  // 渲染推文链接
  function renderTweetLink(tweet) {
    if (!tweet.link) return "";
    return `
 <div style="margin-bottom: 16px; border: 1px solid #333; border-radius: 12px; overflow: hidden; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'" onmouseout="this.style.backgroundColor='transparent'">
 ${
   tweet.link.thumbnail
     ? `
 <div style="width: 100%; height: 200px; background-color: #333;">
 <img src="${tweet.link.thumbnail}" style="width: 100%; height: 100%; object-fit: cover;" alt="链接预览图">
 </div>
 `
     : ""
 }
 <div style="padding: 12px;">
 <div style="color: #71767b; font-size: 13px; margin-bottom: 4px;">${
   tweet.link.url || "链接"
 }</div>
 ${
   tweet.link.title
     ? `<div style="color: #fff; font-size: 15px; font-weight: 600; margin-bottom: 4px; line-height: 1.3;">${tweet.link.title}</div>`
     : ""
 }
 ${
   tweet.link.description
     ? `<div style="color: #71767b; font-size: 14px; line-height: 1.4;">${tweet.link.description}</div>`
     : ""
 }
 </div>
 </div>
 `;
  }
  // 渲染引用推文内容（详情页版本）
  function renderQuotedTweet(tweet) {
    if (!tweet.quotedTweet) return "";
    const quoted = tweet.quotedTweet;
    const typeText = quoted.type === "tweet" ? "推文" : "评论";
    return `
 <div style="margin-bottom: 16px; border: 1px solid var(--x-border-color); border-radius: 16px; padding: 16px; background-color: var(--x-bg-hover); transition: background-color 0.2s;">
 <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
 <img src="${quoted.user.avatar}"
 onclick="openAccountProfile('${quoted.user.name.replace(/'/g, "\\'")}', '${
      quoted.user.handle
    }', '${
      quoted.user.avatar
    }', {source: 'quotedTweet'});event.stopPropagation();"
 style="width: 24px; height: 24px; border-radius: 50%; cursor: pointer; transition: opacity 0.2s;"
 onmouseover="this.style.opacity='0.8'"
 onmouseout="this.style.opacity='1'"
 alt="${quoted.user.name}">
 <div style="display: flex; align-items: center; gap: 4px;">
 <span onclick="openAccountProfile('${quoted.user.name.replace(
   /'/g,
   "\\'"
 )}', '${quoted.user.handle}', '${
      quoted.user.avatar
    }', {source: 'quotedTweet'});event.stopPropagation();" style="color:var(--x-text-primary); font-size: 15px; font-weight: 700; cursor: pointer;">${
      quoted.user.name
    }</span>
 ${
   quoted.user.verified
     ? '<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'
     : ""
 }
 <span style="color:var(--x-text-secondary); font-size: 15px;">${
   quoted.user.handle
 }</span>
 <span style="color:var(--x-text-secondary); font-size: 15px;">·${
   quoted.time
 }</span>
 </div>
 </div>
 <div style="color:var(--x-text-primary); font-size: 17px; line-height: 1.3; word-wrap: break-word;">${
   quoted.content
 }</div>
 ${renderQuotedTweetMedia(quoted)}
 <div style="color:var(--x-text-secondary); font-size: 13px; margin-top: 12px; font-style: italic;">引用${typeText}</div>
 </div>
 `;
  }
  // 渲染引用内容的媒体（图片）
  function renderQuotedTweetMedia(quoted) {
    if (!quoted.image) return "";
    if (quoted.image.type === "description") {
      return `
 <div style="margin-top: 8px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 8px; box-sizing: border-box;">
 <div style="color:var(--x-text-primary); font-size: 13px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${quoted.image.content}</div>
 </div>
 `;
    } else if (quoted.image.type === "upload") {
      return `
 <div style="margin-top: 8px; border-radius: 8px; overflow: hidden;">
 <img src="${quoted.image.content}" style="width: 100%; max-height: 120px; object-fit: cover; display: block;" alt="引用图片">
 </div>
 `;
    }
    return "";
  }
  // 渲染引用的粉丝群（详情页版本）
  function renderQuotedFanGroup(tweet) {
    if (!tweet.quotedFanGroup) return "";
    const fanGroup = tweet.quotedFanGroup;
    return `
 <div style="margin-bottom: 16px; border: 1px solid var(--x-border-color); border-radius: 16px; padding: 16px; background-color: var(--x-bg-hover); transition: background-color 0.2s; cursor: pointer; " onclick="event.stopPropagation(); showXToast('粉丝群详情功能开发中', 'info');"
 onmouseover="this.style.backgroundColor='var(--x-bg-secondary)'"
 onmouseout="this.style.backgroundColor='var(--x-bg-hover)'">
 <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
 <img src="${fanGroup.avatar}"
 style="width: 48px; height: 48px; border-radius: 50%; object-fit: cover;"
 alt="${fanGroup.name}">
 <div style="flex: 1; min-width: 0;">
 <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
 <span style="color:var(--x-text-primary); font-size: 17px; font-weight: 700;">${
   fanGroup.name
 }</span>
 <span style="padding: 2px 8px; background-color:var(--x-bg-primary); color: var(--x-accent); font-size: 11px; border-radius: 4px; font-weight: 600; border: 1px solid var(--x-accent); ">粉丝群</span>
 </div>
 <div style="color:var(--x-text-secondary); font-size: 15px;">
 ${fanGroup.memberCount} 位成员
 </div>
 </div>
 </div>
 ${
   fanGroup.threshold
     ? `
 <div style="padding: 12px; background-color:var(--x-bg-primary); border-radius: 8px; border-left: 3px solid var(--x-accent); margin-bottom: 12px; ">
 <div style="color:var(--x-text-primary); font-weight: 600; font-size: 13px; margin-bottom: 6px;">
 入群门槛
 </div>
 <div style="color:var(--x-text-secondary); font-size: 15px; line-height: 1.4;">
 ${fanGroup.threshold}
 </div>
 </div>
 `
     : ""
 }
 <div style="display: flex; align-items: center; justify-content: space-between; padding-top: 12px; border-top: 1px solid var(--x-border-color); ">
 <div style="color:var(--x-text-secondary); font-size: 13px; font-style: italic;">
 引用粉丝群
 </div>
 <div style="display: flex; align-items: center; gap: 4px; color: var(--x-accent); font-size: 13px; font-weight: 600; ">
 <span>申请加入</span>
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;">
 <g><path d="M8.58 7.17l4.24 4.24-4.24 4.24 1.42 1.42 5.66-5.66-5.66-5.66z"></path></g>
 </svg>
 </div>
 </div>
 </div>
 `;
  }
  // 格式化详情页时间
  function formatDetailTime(timestamp) {
    // 如果没有timestamp，返回默认值
    if (!timestamp) {
      return "未知时间";
    }
    const date = new Date(timestamp); // 检查日期是否有效
    if (isNaN(date.getTime())) {
      return "未知时间";
    }
    const formatter = new Intl.DateTimeFormat("zh-CN", {
      year: "numeric",
      month: "long",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
    return formatter.format(date);
  }
  // 详情页点赞功能
  function toggleDetailLike(tweetId, element) {
    const isLiked = element.dataset.liked === "true";
    const currentLikes = parseInt(element.dataset.likes);
    if (isLiked) {
      element.dataset.liked = "false";
      element.dataset.likes = (currentLikes - 1).toString();
      element.style.color = "#71767b";
    } else {
      element.dataset.liked = "true";
      element.dataset.likes = (currentLikes + 1).toString();
      element.style.color = "#f91880";
    }
  }
  // 详情页评论相关功能
  function handleDetailCommentInput(event) {
    const textarea = event.target;
    updateDetailReplyButtonState();

    // 回车发送评论
    if (event.key === "Enter" && !event.shiftKey) {
      event.preventDefault();
      const hasText = textarea.value.trim().length > 0;
      const hasSticker = window.getSelectedCommentSticker
        ? window.getSelectedCommentSticker() !== null
        : selectedCommentSticker !== null;
      if (hasText || hasSticker) {
        submitDetailComment();
      }
    }
  }
  // 更新回复按钮状态（支持表情包）
  function updateDetailReplyButtonState() {
    const textarea = document.getElementById("detail-comment-input");
    const replyBtn = document.getElementById("detail-reply-btn");
    if (!replyBtn) return;

    const hasText = textarea && textarea.value.trim().length > 0;
    const hasSticker = window.getSelectedCommentSticker
      ? window.getSelectedCommentSticker() !== null
      : selectedCommentSticker !== null;

    if (hasText || hasSticker) {
      replyBtn.style.opacity = "1";
      replyBtn.disabled = false;
    } else {
      replyBtn.style.opacity = "0.5";
      replyBtn.disabled = true;
    }
  }

  function autoResizeDetail(textarea) {
    textarea.style.height = "20px";
    textarea.style.height = Math.min(textarea.scrollHeight, 120) + "px";
    updateDetailReplyButtonState();
  }
  async function submitDetailComment() {
    const textarea = document.getElementById("detail-comment-input");
    const content = textarea.value.trim();

    // 获取当前选中的表情包
    const currentSticker = window.getSelectedCommentSticker
      ? window.getSelectedCommentSticker()
      : selectedCommentSticker;

    console.log("📝 [表情包调试] currentSticker:", currentSticker);

    // 检查是否有内容或表情包
    if (content.length === 0 && !currentSticker) return; // 获取当前推文数据
    const currentTweetData = sessionStorage.getItem("currentTweetData");
    if (!currentTweetData) {
      showXToast("无法获取推文信息", "error");
      return;
    }
    let tweetData;
    try {
      tweetData = JSON.parse(currentTweetData);
    } catch (e) {
      showXToast("推文数据解析失败", "error");
      return;
    }
    console.log("📝 [提交评论] 开始处理评论提交");
    console.log("📝 [提交评论] 推文ID:", tweetData.id);
    console.log("📝 [提交评论] 推文作者:", tweetData.user.handle);
    console.log("📝 [提交评论] 当前用户:", window.userProfileData.handle);
    console.log(
      "📝 [提交评论] 是否为用户推文:",
      tweetData.id.startsWith("user_")
    ); // 检查是否为仅自己可见的帖子
    if (tweetData.privacy === "private") {
      showXToast("私有帖子不支持回复功能", "error");
      return;
    }
    const newComment = {
      id: "detail_" + Date.now(),
      user: {
        name: window.userProfileData.name,
        handle: window.userProfileData.handle,
        avatar: window.userProfileData.avatar,
        verified: window.userProfileData.verified,
      },
      content: content,
      time: "刚刚",
      replies: [],
    }; // 如果有图片，添加图片数据
    if (detailCommentImageData) {
      newComment.image = {
        type: "upload",
        content: detailCommentImageData,
      };
    }

    // 如果有表情包，添加表情包数据
    if (currentSticker) {
      newComment.sticker = {
        url: currentSticker.url,
        description: currentSticker.description,
      };
      console.log(
        "📝 [表情包调试] 表情包已添加到newComment:",
        newComment.sticker
      );
    } else {
      console.log("📝 [表情包调试] 没有表情包数据");
    }
    console.log("📝 [提交评论] 新评论数据:", {
      id: newComment.id,
      content: newComment.content.substring(0, 50) + "...",
      hasImage: !!newComment.image,
      hasSticker: !!newComment.sticker,
    }); // 将评论添加到推文数据中
    if (!tweetData.comments) {
      tweetData.comments = [];
    }
    tweetData.comments.push(newComment); // 更新评论数量统计
    if (!tweetData.stats) {
      tweetData.stats = { comments: 0, retweets: 0, likes: 0, views: 0 };
    }
    tweetData.stats.comments = tweetData.comments.length;
    console.log(
      "📝 [提交评论] 评论已添加到推文数据，当前评论总数:",
      tweetData.stats.comments
    ); // 保存到数据库
    try {
      const xDb = getXDB(); // 判断推文类型
      const isUserTweet = tweetData.id.startsWith("user_");
      const isRetweetMention = tweetData._source === "retweet_mention";
      const isNewTweetMention = tweetData._source === "newtweet_mention";
      if (isRetweetMention) {
        console.log("📝 [提交评论] 这是 Mentions 转帖，保存到 Mentions 数据");
        const mentionsId = `mentions_${currentAccountId || "main"}`;
        const mentionsData = await xDb.xAccountProfiles.get(mentionsId);
        if (mentionsData && mentionsData.data) {
          const retweetIndex = mentionsData.data.findIndex(
            (m) => m.id === tweetData.id && m.type === "retweet"
          );
          if (retweetIndex !== -1) {
            // 更新评论数据
            mentionsData.data[retweetIndex].comments = tweetData.comments; // 同步更新 stats
            if (!mentionsData.data[retweetIndex].stats) {
              mentionsData.data[retweetIndex].stats = tweetData.stats;
            } else {
              mentionsData.data[retweetIndex].stats.comments =
                tweetData.stats.comments;
            }
            await xDb.xAccountProfiles.put(mentionsData);
            console.log(
              "✅ [提交评论] Mentions 转帖通知已更新，评论总数:",
              tweetData.comments.length
            );
          } else {
            console.warn(
              "⚠️ [提交评论] 未在 Mentions 数据中找到对应的转帖通知:",
              tweetData.id
            );
          }
        } else {
          console.warn("⚠️ [提交评论] 未找到 Mentions 数据:", mentionsId);
        }
      } else if (isNewTweetMention) {
        console.log(
          "📝 [提交评论] 这是 Mentions New Tweet，保存到 Mentions 数据"
        );
        const mentionsId = `mentions_${currentAccountId || "main"}`;
        const mentionsData = await xDb.xAccountProfiles.get(mentionsId);
        if (mentionsData && mentionsData.data) {
          const newTweetIndex = mentionsData.data.findIndex(
            (m) => m.id === tweetData._mentionId && m.type === "newTweet"
          );
          if (newTweetIndex !== -1) {
            // 更新推文的评论数据
            if (!mentionsData.data[newTweetIndex].tweet) {
              mentionsData.data[newTweetIndex].tweet = {};
            }
            mentionsData.data[newTweetIndex].tweet.comments =
              tweetData.comments; // 同步更新 stats
            if (!mentionsData.data[newTweetIndex].tweet.stats) {
              mentionsData.data[newTweetIndex].tweet.stats = tweetData.stats;
            } else {
              mentionsData.data[newTweetIndex].tweet.stats.comments =
                tweetData.stats.comments;
            }
            await xDb.xAccountProfiles.put(mentionsData);
            console.log(
              "✅ [提交评论] Mentions New Tweet 通知已更新，评论总数:",
              tweetData.comments.length
            );
          } else {
            console.warn(
              "⚠️ [提交评论] 未在 Mentions 数据中找到对应的 New Tweet 通知:",
              tweetData._mentionId
            );
          }
        } else {
          console.warn("⚠️ [提交评论] 未找到 Mentions 数据:", mentionsId);
        }
      } else if (isUserTweet) {
        console.log("📝 [提交评论] 这是用户自己的推文，保存到 xUserTweets"); // 获取用户推文数据ID（按账号隔离）
        const userTweetsId = `userTweets_${currentAccountId || "main"}`;
        const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
        if (userTweetsData && userTweetsData.tweets) {
          console.log(
            "📝 [提交评论] 找到用户推文数据，推文总数:",
            userTweetsData.tweets.length
          );
          const tweetIndex = userTweetsData.tweets.findIndex(
            (t) => t.id === tweetData.id
          );
          if (tweetIndex !== -1) {
            console.log("📝 [提交评论] 找到目标推文，索引:", tweetIndex); // 更新推文数据
            userTweetsData.tweets[tweetIndex] = tweetData; // 保存到数据库
            await xDb.xUserTweets.put(userTweetsData);
            console.log("✅ [提交评论] 用户推文数据已保存到数据库");
          } else {
            console.warn("⚠️ [提交评论] 未找到目标推文，推文ID:", tweetData.id);
          }
        } else {
          console.warn("⚠️ [提交评论] 未找到用户推文数据");
        }
      } else {
        console.log("📝 [提交评论] 这是主页推文，保存到 xTweetsData"); // 这是主页推文，更新到主页数据
        const tweetsData = await xDb.xTweetsData.get("tweets");
        if (tweetsData) {
          let updated = false; // 更新 forYouTweets
          if (tweetsData.forYouTweets) {
            const index = tweetsData.forYouTweets.findIndex(
              (t) => t.id === tweetData.id
            );
            if (index !== -1) {
              tweetsData.forYouTweets[index] = tweetData;
              updated = true;
              console.log("📝 [提交评论] 已更新 forYouTweets");
            }
          }
          // 更新 followingTweets
          if (tweetsData.followingTweets && !updated) {
            const index = tweetsData.followingTweets.findIndex(
              (t) => t.id === tweetData.id
            );
            if (index !== -1) {
              tweetsData.followingTweets[index] = tweetData;
              updated = true;
              console.log("📝 [提交评论] 已更新 followingTweets");
            }
          }
          if (updated) {
            await xDb.xTweetsData.put(tweetsData);
            console.log("✅ [提交评论] 主页推文数据已保存到数据库");
          } else {
            console.warn("⚠️ [提交评论] 未在主页数据中找到目标推文");
          }
        }
      }
      // 更新 sessionStorage 中的数据
      sessionStorage.setItem("currentTweetData", JSON.stringify(tweetData));
      console.log("✅ [提交评论] sessionStorage 已更新");
    } catch (saveError) {
      console.error("❌ [提交评论] 保存评论到数据库失败:", saveError);
      showXToast("评论保存失败: " + saveError.message, "error");
    }
    // 渲染新评论
    const commentsContainer = document.getElementById(
      "detail-comments-container"
    );
    console.log(
      "📝 [表情包调试] 渲染前的newComment:",
      JSON.stringify(newComment, null, 2)
    );
    const commentElement = createCommentElement(newComment);
    commentsContainer.appendChild(commentElement);
    console.log("📝 [提交评论] 评论已渲染到页面"); // 更新新添加的回复输入框头像（使用window.userProfileData确保获取最新账号数据）
    const replyUserAvatars = document.querySelectorAll(".reply-user-avatar");
    replyUserAvatars.forEach((avatar) => {
      avatar.src = window.userProfileData.avatar;
    }); // 清空输入框和所有附件（使用统一的清理函数）
    if (window.clearCommentInput) {
      window.clearCommentInput();
    } else {
      // 后备清理逻辑
      textarea.value = "";
      textarea.style.height = "20px";
      if (detailCommentImageData) {
        removeDetailCommentImage();
      }
      // 清除表情包预览
      const preview = document.getElementById("comment-sticker-preview");
      if (preview) {
        preview.remove();
      }
      // 重置表情包选择
      if (window.setSelectedCommentSticker) {
        window.setSelectedCommentSticker(null);
      } else {
        selectedCommentSticker = null;
      }

      const replyBtn = document.getElementById("detail-reply-btn");
      replyBtn.style.opacity = "0.5";
      replyBtn.disabled = true;
    }
    showXToast("你的评论等待回复中", "info"); // 触发AI回复 - 判断是否为用户自己的帖子
    const isOwnPost =
      tweetData.user &&
      (tweetData.user.handle === userProfileData.handle ||
        tweetData.id.startsWith("user_"));
    console.log("📝 [提交评论] 准备触发AI回复，isOwnPost:", isOwnPost); // 🔧 使用异步非阻塞方式触发AI回复，避免用户离开页面时中断导致的问题
    setTimeout(async () => {
      try {
        await generateUnifiedAIResponse(tweetData, newComment, {
          isOwnPost,
          commentType: "main_comment",
          pageType: "detail",
          parentComment: null,
        });
        console.log("✅ [提交评论] AI回复生成完成");
      } catch (error) {
        console.error("❌ [提交评论] AI回复生成失败:", error);
      }
    }, 100);
    console.log("✅ [提交评论] 评论提交流程完成（AI回复已异步触发）");
  }
  function renderDetailComments(comments) {
    const container = document.getElementById("detail-comments-container");
    container.innerHTML = "";
    if (!comments || comments.length === 0) return;
    console.log("📋 [渲染评论] 开始渲染评论，主评论数:", comments.length);
    comments.forEach((comment) => {
      // 渲染主评论
      const commentElement = createCommentElement(comment);
      container.appendChild(commentElement); // 如果有楼中楼回复，也渲染它们
      if (comment.replies && comment.replies.length > 0) {
        console.log(
          "📋 [渲染评论] 评论",
          comment.id,
          "有",
          comment.replies.length,
          "条楼中楼回复"
        );
        comment.replies.forEach((reply) => {
          const replyElement = createCommentElement(reply, true);
          container.appendChild(replyElement);
        });
      }
    });
    console.log("✅ [渲染评论] 评论渲染完成"); // 更新所有回复输入框头像
    const replyUserAvatars = document.querySelectorAll(".reply-user-avatar");
    replyUserAvatars.forEach((avatar) => {
      avatar.src = userProfileData.avatar;
    });
  }
  // ============================================
  // 商业推贴提交处理
  // ============================================
  // 处理商业推贴提交
  async function handleBusinessPostSubmission(tweetData, businessTransferId) {
    try {
      console.log("💼 [商业推贴] 开始处理任务提交"); // 获取商业转账信息
      const xDb = getXDB();
      const businessTransfersId = `businessTransfers_${
        currentAccountId || "main"
      }`;
      const savedData = await xDb.xAccountProfiles.get(businessTransfersId);
      if (!savedData || !savedData.data) {
        console.error("❌ 未找到商业转账数据");
        return;
      }
      const businessTransfer = savedData.data.find(
        (t) => t.transferId === businessTransferId
      );
      if (!businessTransfer) {
        console.error("❌ 未找到对应的商业转账");
        return;
      }
      console.log("✅ [商业推贴] 找到商业转账:", businessTransfer); // 查找对应的AI对话
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${businessTransfer.conversationId}`;
      const conversation = await xDb.xAccountProfiles.get(conversationId);
      if (!conversation) {
        console.error("❌ 未找到对话信息");
        showXToast("无法找到对应的对话，请手动联系对方", "error");
        return;
      }
      console.log("✅ [商业推贴] 找到对话:", conversation); // 构建正确的对话数据结构
      const conversationData = {
        id: businessTransfer.conversationId,
        user: {
          name: businessTransfer.senderName,
          handle: businessTransfer.senderHandle,
          avatar: businessTransfer.senderAvatar,
          verified: false,
        },
      }; // 触发AI评估并发送私信
      await triggerBusinessTaskEvaluation(
        tweetData,
        businessTransfer,
        conversationData
      );
    } catch (error) {
      console.error("❌ [商业推贴] 处理失败:", error);
      showXToast("提交失败: " + error.message, "error");
    }
  }
  // 触发商业任务评估（AI自动发送私信）
  async function triggerBusinessTaskEvaluation(
    tweetData,
    businessTransfer,
    conversationData
  ) {
    try {
      console.log("🤖 [商业任务评估] 开始AI评估流程"); // 第一步：先触发AI评论生成（第二个情景）
      console.log("📝 [商业任务评估] 步骤1：生成AI评论..."); // 标记这是商业化推贴
      const businessTweetData = {
        ...tweetData,
        _isBusinessPost: true,
        _businessTransferId: businessTransfer.transferId,
        _taskDescription: businessTransfer.taskDescription,
      }; // 调用发帖生成器
      await generateAIResponseForTweet(businessTweetData); // 第二步：等待评论生成完成后，延迟3秒再发送评估私信
      setTimeout(async () => {
        console.log("💬 [商业任务评估] 步骤2：发送AI评估私信...");
        showPhoneNotification({
          title: "X",
          message: `${conversationData.user.name} 正在评估你的任务完成情况...`,
          avatar: conversationData.user.avatar,
          leftIcon: "x",
        }); // 调用第九个情景的AI私信评估
        await generateBusinessTaskEvaluationMessage(
          tweetData,
          businessTransfer,
          conversationData
        );
      }, 3000); // 等待3秒让用户看到评论
    } catch (error) {
      console.error("❌ [商业任务评估] 失败:", error);
      showXToast("任务评估失败: " + error.message, "error");
    }
  }
  // 生成商业任务评估私信（调用第九个情景）
  async function generateBusinessTaskEvaluationMessage(
    tweetData,
    businessTransfer,
    conversationData
  ) {
    try {
      console.log("💼 [AI评估] 开始生成评估私信"); // 构建评估上下文
      const evaluationContext = {
        isBusinessTaskEvaluation: true,
        tweetData: tweetData,
        businessTransfer: businessTransfer,
      }; // 调用第九个情景的私信生成器（续写模式）
      const messageData = {
        id: conversationData.id,
        user: conversationData.user,
      };
      const aiMessages = await generateMessageConversation(messageData, true, {
        isAutoMessage: true,
        businessTaskEvaluation: evaluationContext,
      });
      if (!aiMessages || aiMessages.length === 0) {
        console.error("❌ [AI评估] 未生成评估消息");
        return;
      }
      console.log("✅ [AI评估] 生成了评估消息:", aiMessages); // 保存AI评估消息到私信数据库
      const xDb = getXDB();
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${conversationData.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (savedConversation && savedConversation.data) {
        // 添加AI消息到对话记录
        aiMessages.forEach((msg) => {
          savedConversation.data.messages.push({
            ...msg,
            isOwn: false,
            timestamp: new Date().toISOString(),
          });
        });
        await xDb.xAccountProfiles.put(savedConversation);
        console.log("✅ [AI评估] 评估消息已保存到数据库"); // 检查是否有转账消息（支付尾款、扣款或额外奖励）
        const transferMessages = aiMessages.filter(
          (msg) => msg.type === "transfer"
        );
        if (transferMessages.length > 0) {
          // 处理AI发起的转账（尾款支付）
          for (const transferMsg of transferMessages) {
            await handleAIBusinessPayment(
              transferMsg,
              businessTransfer,
              conversationData
            );
          }
        }
        // 显示通知
        setTimeout(() => {
          showPhoneNotification({
            title: "X",
            message: `${conversationData.user.name} 已完成任务评估`,
            avatar: conversationData.user.avatar,
            leftIcon: "x",
          });
        }, 1000);
      }
    } catch (error) {
      console.error("❌ [AI评估] 生成评估私信失败:", error);
    }
  }
  // 处理AI商业任务付款
  async function handleAIBusinessPayment(
    transferMessage,
    businessTransfer,
    conversationData
  ) {
    try {
      console.log("💰 [AI付款] 处理商业任务付款:", transferMessage);
      const amount = parseFloat(transferMessage.amount || 0);
      if (amount <= 0) return; // 更新钱包余额
      await loadWalletData();
      const currentBalance = parseFloat(walletData.balance) || 0;
      walletData.balance = currentBalance + amount; // 添加交易记录
      const senderName = conversationData.user?.name || "对方";
      let transactionDesc = "";
      if (transferMessage.note) {
        transactionDesc = `${senderName} - ${transferMessage.note}`;
      } else {
        transactionDesc = `商业转账尾款 - ${senderName}`;
      }
      const transaction = {
        id: "business_payment_" + Date.now(),
        description: transactionDesc,
        amount: amount,
        timestamp: new Date().toISOString(),
        type: "business_transfer_remaining_in",
      };
      walletData.transactions.unshift(transaction);
      await saveWalletData(); // 更新商业转账状态
      const xDb = getXDB();
      const businessTransfersId = `businessTransfers_${
        currentAccountId || "main"
      }`;
      const savedData = await xDb.xAccountProfiles.get(businessTransfersId);
      if (savedData && savedData.data) {
        const transfer = savedData.data.find(
          (t) => t.transferId === businessTransfer.transferId
        );
        if (transfer) {
          transfer.taskStatus = "completed";
          transfer.completedAt = new Date().toISOString();
          await xDb.xAccountProfiles.put(savedData);
          console.log("✅ [AI付款] 商业转账状态已更新为已完成");
        }
      }
      console.log(
        "✅ [AI付款] 付款完成，金额:",
        amount,
        "新余额:",
        walletData.balance
      ); // 显示收款通知
      setTimeout(() => {
        showPhoneNotification({
          title: "X Wallet",
          message: `已收款 $${amount.toFixed(
            2
          )}, 当前余额 $${walletData.balance.toFixed(2)}`,
          avatar: window.userProfileData?.avatar,
          leftIcon: "x",
        });
      }, 2000);
    } catch (error) {
      console.error("❌ [AI付款] 处理付款失败:", error);
    }
  }
  // ▼▼▼ 【主要！！！】第二个情景：发帖生成器▼▼▼
  // 推进模式状态（发帖生成器专用）
  let isTweetProgressMode = false;
  let tweetProgressLongPressTimer = null; // 计算两个字符串的相似度（0-1之间，1表示完全相同）
  function calculateSimilarity(str1, str2) {
    if (str1 === str2) return 1;
    if (str1.length === 0 || str2.length === 0) return 0; // 使用最长公共子序列（LCS）算法的简化版本
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1; // 计算字符匹配度
    let matches = 0;
    const shorterChars = shorter.split("");
    const longerChars = longer.split("");
    shorterChars.forEach((char) => {
      const index = longerChars.indexOf(char);
      if (index !== -1) {
        matches++;
        longerChars.splice(index, 1); // 移除已匹配的字符，避免重复计数
      }
    }); // 相似度 = 匹配字符数 / 较长字符串长度
    const similarity = matches / longer.length; // 额外检测：如果较短字符串完全包含在较长字符串中，提高相似度
    if (longer.includes(shorter)) {
      return Math.max(similarity, shorter.length / longer.length);
    }
    return similarity;
  }
  async function generateAIResponseForTweet(
    tweetData,
    isReroll = false,
    isProgressMode = false
  ) {
    try {
      // 🔧 使用统一的API配置加载工具
      const { db, xDb, apiConfig, xSettings } =
        await APIUtils.loadConfigAndSettings();
      const { userPrompt, worldSetting, boundCharacters } = xSettings; // 检测推文类型
      const isAccountTweet = tweetData._source === "account";
      const isUserTweet = tweetData.id && tweetData.id.startsWith("user_");
      const isBusinessPost = tweetData.isBusinessPost === true;
      let targetProfileInfo;
      let isBoundCharacterAccount = false; // 是否为绑定角色的账户
      let boundCharacterIdForAccount = null; // 绑定角色的ID
      let isUserOwnTweet = isUserTweet; // 是否为用户自己的推文
      console.log("🔍 [发帖生成器] 推文类型检测:", {
        isAccountTweet,
        isUserTweet,
        isBusinessPost,
        tweetId: tweetData.id,
      });
      if (isAccountTweet) {
        // 账户推文：构建账户资料信息
        console.log("🔍 [AI生成] 检测到账户推文，加载账户资料"); // 尝试从当前查看的账户获取资料
        let accountData = currentViewingAccount; // 如果没有，尝试从数据库加载
        if (!accountData && tweetData._accountHandle) {
          const cleanHandle = tweetData._accountHandle.replace("@", "");
          accountData = await xDb.xAccountProfiles.get(cleanHandle);
        }
        if (accountData) {
          const accountInfo = accountData.accountInfo || accountData;
          targetProfileInfo = {
            name: accountInfo.name,
            handle: accountInfo.handle,
            avatar: accountInfo.avatar,
            verified: accountInfo.verified || false,
            verificationType: accountInfo.verificationType || "none",
            publicIdentity: accountInfo.publicIdentity || "",
            bio: accountInfo.bio || "",
            knownIdentityCharacters: [], // 账户没有已知身份角色概念
          };
          console.log("✅ [AI生成] 已加载账户资料:", targetProfileInfo.name); // 检查该账户是否为绑定角色
          if (boundCharacters && boundCharacters.length > 0) {
            const allXProfiles = await xDb.xCharacterProfiles.toArray();
            const cleanHandle = accountInfo.handle.replace("@", "");
            for (const charId of boundCharacters) {
              const xProfile = allXProfiles.find(
                (p) => p.characterId === charId
              );
              if (xProfile && xProfile.xHandle === cleanHandle) {
                isBoundCharacterAccount = true;
                boundCharacterIdForAccount = charId;
                console.log(
                  "🎭 [AI生成] 识别到绑定角色账户:",
                  accountInfo.name,
                  "(",
                  charId,
                  ")"
                );
                break;
              }
            }
          }
        } else {
          // 如果找不到账户资料，使用推文中的用户信息
          console.warn("⚠️ [AI生成] 未找到账户资料，使用推文用户信息");
          targetProfileInfo = {
            name: tweetData.user.name,
            handle: tweetData.user.handle,
            avatar: tweetData.user.avatar,
            verified: tweetData.user.verified || false,
            verificationType: tweetData.user.verificationType || "none",
            publicIdentity: "",
            bio: "",
            knownIdentityCharacters: [],
          };
        }
      } else if (isUserTweet) {
        // 用户自己的推文：使用用户X个人资料信息
        console.log("✅ [发帖生成器] 检测到用户推文，使用用户资料");
        targetProfileInfo = StringBuilders.buildUserXProfileInfo(
          window.userProfileData
        );
      } else {
        // 主页推文（其他人发的）：使用统一资料获取系统获取发帖人资料
        console.log(
          "🔍 [发帖生成器] 检测到主页推文，查询发帖人资料:",
          tweetData.user.handle
        );
        try {
          const posterProfile = await StringBuilders.getUnifiedProfile(
            tweetData.user.handle,
            {
              userProfileInfo: window.userProfileData,
            }
          );
          if (posterProfile) {
            console.log(
              "✅ [发帖生成器] 已获取发帖人资料:",
              posterProfile.name
            ); // 检查发帖人是否为绑定角色
            if (
              posterProfile.type === "character" &&
              boundCharacters.includes(posterProfile.characterId)
            ) {
              isBoundCharacterAccount = true;
              boundCharacterIdForAccount = posterProfile.characterId;
              console.log(
                "🎭 [发帖生成器] 发帖人是绑定角色:",
                posterProfile.name
              );
            }
            targetProfileInfo = {
              name: posterProfile.name,
              handle: posterProfile.handle,
              avatar: posterProfile.avatar,
              verified: posterProfile.verified || false,
              verificationType: posterProfile.xProfile?.xVerified
                ? "verified"
                : "none",
              publicIdentity: posterProfile.publicIdentity || "",
              bio: posterProfile.bio || "",
              knownIdentityCharacters: [], // 其他人的推文，不使用用户的已知身份角色
            };
            isUserOwnTweet = false; // 明确标记这不是用户自己的推文
          } else {
            console.warn("⚠️ [发帖生成器] 未找到发帖人资料，使用推文用户信息");
            targetProfileInfo = {
              name: tweetData.user.name,
              handle: tweetData.user.handle,
              avatar: tweetData.user.avatar,
              verified: tweetData.user.verified || false,
              verificationType: tweetData.user.verificationType || "none",
              publicIdentity: "",
              bio: "",
              knownIdentityCharacters: [],
            };
            isUserOwnTweet = false;
          }
        } catch (error) {
          console.error("❌ [发帖生成器] 获取发帖人资料失败:", error); // 回退到使用推文中的用户信息
          targetProfileInfo = {
            name: tweetData.user.name,
            handle: tweetData.user.handle,
            avatar: tweetData.user.avatar,
            verified: tweetData.user.verified || false,
            verificationType: tweetData.user.verificationType || "none",
            publicIdentity: "",
            bio: "",
            knownIdentityCharacters: [],
          };
          isUserOwnTweet = false;
        }
      }
      const userXProfileInfo = targetProfileInfo;
      console.log("📋 [发帖生成器] 最终资料信息:", {
        name: userXProfileInfo.name,
        handle: userXProfileInfo.handle,
        isUserOwnTweet,
        isBoundCharacterAccount,
        boundCharacterIdForAccount,
      }); // 获取知道用户身份的角色信息（仅用于用户自己的推文）
      let knownIdentityCharactersInfo = "";
      if (
        isUserOwnTweet &&
        userXProfileInfo.knownIdentityCharacters.length > 0 &&
        boundCharacters.length > 0
      ) {
        const allChats = await db.chats.toArray();
        const knownCharacters = allChats.filter(
          (chat) =>
            !chat.isGroup &&
            userXProfileInfo.knownIdentityCharacters.includes(chat.id)
        );
        if (knownCharacters.length > 0) {
          knownIdentityCharactersInfo = "\n\n【知道用户身份的角色】：";
          for (const char of knownCharacters) {
            let xProfile = await xDb.xCharacterProfiles.get(char.id);
            if (xProfile) {
              knownIdentityCharactersInfo += `\n- ${xProfile.xName} (${xProfile.xHandle}): 知道用户身份，可能会对用户的帖子进行互动`;
              if (char.history && char.history.length > 0) {
                const recentHistory = char.history.slice(-5);
                knownIdentityCharactersInfo += "\n 最近互动记忆：";
                recentHistory.forEach((msg) => {
                  if (msg.role === "assistant" && msg.content) {
                    knownIdentityCharactersInfo += `\n - ${msg.content.substring(
                      0,
                      80
                    )}...`;
                  }
                });
              }
            }
          }
          knownIdentityCharactersInfo +=
            "\n\n注意：这些角色可能会对用户的帖子进行评论，但概率不要太高，要自然。";
        }
      }
      // Token计数器
      let tokenCount = 0; // 1. 提示词 + 世界书
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage(
        "发帖生成器",
        "基础系统提示词",
        systemPrompt,
        tokenCount
      ); // 1.5. 获取适用的世界书内容
      const worldBooksOptions = { boundCharacters: [] };
      if (isBoundCharacterAccount && boundCharacterIdForAccount) {
        // 如果发帖人是绑定角色，只传入该角色ID
        worldBooksOptions.boundCharacters = [boundCharacterIdForAccount];
        console.log("📚 [发帖生成器] 加载绑定角色的世界书");
      } else if (isUserOwnTweet) {
        // 用户自己的推文：传入所有绑定角色
        worldBooksOptions.boundCharacters = boundCharacters;
        console.log("📚 [发帖生成器] 加载用户所有绑定角色的世界书");
      } else {
        // 其他人的推文：不加载世界书
        worldBooksOptions.boundCharacters = [];
        console.log("📚 [发帖生成器] 跳过世界书（非用户推文）");
      }
      const worldBooksContent = await StringBuilders.getApplicableWorldBooks(
        "tweetDetail",
        worldBooksOptions
      );
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage(
          "发帖生成器",
          "世界书内容",
          worldBooksContent,
          tokenCount
        );
      }

      // 1.7. 🌍 读取世界运转大事件（如果启用）
      const isPublicFigure =
        /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
          (userXProfileInfo.publicIdentity || "") +
            " " +
            (userXProfileInfo.bio || "")
        );

      const worldEventsPrompt = await getWorldEventsPrompt("发帖生成器", {
        usageRate: 0.25, // 25%的评论涉及大事件
        isPublicFigure: isPublicFigure,
        usageDescription: `**发帖评论场景的大事件使用**：
1. **询问看法**：${
          isPublicFigure ? "高曝光用户" : "用户"
        }发推文时，评论区可能有人询问对大事件的看法
   - "怎么看最近的XXX事件？"
   - "能说说你对XXX的态度吗？"
2. **要求表态**：${
          isPublicFigure
            ? "遇到灾难/慈善事件，可能被要求捐款或声援"
            : "可能涉及灾难事件的讨论"
        }
   - ${isPublicFigure ? '"什么时候捐款？"、"请为XXX发声！"' : "表达同情或关注"}
   - ${isPublicFigure ? '"明星就该有社会责任感"' : ""}
3. **立场站队**：遇到争议事件，${
          isPublicFigure ? "可能被要求表明立场" : "评论可能涉及争议话题"
        }
   - ${isPublicFigure ? '"你支持哪一方？"、"保持沉默就是默认"' : "讨论不同观点"}
4. **网络生态**：评论区要真实（有支持、有质疑、有键盘侠、有理性讨论）
5. **自然融入**：只有约25%的评论涉及大事件，其余仍然围绕推文本身`,
      });

      if (worldEventsPrompt) {
        systemPrompt += worldEventsPrompt;
        tokenCount = TokenUtils.logTokenUsage(
          "发帖生成器",
          "世界运转大事件",
          worldEventsPrompt,
          tokenCount
        );
      }

      // 2. 核心任务说明（根据模式不同调整）
      const tweetAuthor = isUserOwnTweet
        ? "用户"
        : `${userXProfileInfo.name} (${userXProfileInfo.handle})`;
      if (isProgressMode) {
        // 计算时间流逝
        const tweetTimestamp = tweetData.timestamp || Date.now();
        const now = Date.now();
        const minutesPassed = Math.floor((now - tweetTimestamp) / (1000 * 60));
        const hoursPassed = Math.floor(minutesPassed / 60);
        const daysPassed = Math.floor(hoursPassed / 24);
        let timePassedDesc;
        if (daysPassed > 0) {
          timePassedDesc = `${daysPassed}天${hoursPassed % 24}小时`;
        } else if (hoursPassed > 0) {
          timePassedDesc = `${hoursPassed}小时${minutesPassed % 60}分钟`;
        } else {
          timePassedDesc = `${minutesPassed}分钟`;
        }
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务：推进帖子互动 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的互动生成器。${tweetAuthor}的帖子已发布一段时间，你的任务是：
✅ 生成**新的**评论和互动（在已有评论基础上继续）
✅ 更新互动数据（点赞、转发、浏览量应该增加）
❌ 绝对不能生成${tweetAuthor}本人发表的任何内容
❌ 绝对不能重复已有评论的内容或观点
**时间信息**：
- 帖子发布已过去：${timePassedDesc}
- 已有评论数量：${tweetData.comments?.length || 0} 条
**推进模式生成策略**：
1. **优先生成楼中楼回复**（70%）：
- 对已有评论进行回复、补充或讨论
- 使用 replyTo 字段指定回复对象
- 可以赞同、质疑、或提出新角度
2. **次要生成新顶层评论**（30%）：
- 必须带有明显的时间感（"刚看到"、"终于找到"、"现在才发现"等）
- 角度必须与所有已有评论完全不同
- 可以是迟到者的独特视角或冷静分析
3. **内容创新要求**：
- 不要重复任何已有的观点、表达或句式
- 提供新的信息、角度或情绪
- 互动数据应反映热度持续（点赞、转发、浏览量增加）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`;
      } else {
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🚫 核心任务说明 🚫
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的互动生成器。${tweetAuthor}刚发布了一条新帖子，你的任务是：
✅ 生成其他X平台用户对这条帖子的评论和反应
❌ 绝对不能生成${tweetAuthor}本人发表的任何内容
**明确：${tweetAuthor}已经发布了推文，你只负责生成别人的回应！**
${
  !isUserOwnTweet && !isBoundCharacterAccount
    ? `⚠️ **特别注意**：这是${tweetAuthor}发布的推文，与当前用户无关。
- 应该生成普通路人用户的评论
- 评论者是看到这条推文的陌生网友
- 不要假设评论者与${tweetAuthor}有任何私人关系`
    : ""
}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`;
      }
      const coreTaskSection = systemPrompt.substring(
        systemPrompt.lastIndexOf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "发帖生成器",
        "核心任务说明",
        coreTaskSection,
        tokenCount
      ); // 3. 角色资料（互动反应场景）
      let charactersInfo = ""; // 🔧 确定传递给角色资料的用户信息
      // 如果是绑定角色的推文，需要传递真实的用户资料（用于判断身份识别）
      // 如果是用户自己的推文，传递用户资料
      // 如果是其他人的推文，不加载角色资料
      const userInfoForCharacter =
        isBoundCharacterAccount || isUserOwnTweet
          ? StringBuilders.buildUserXProfileInfo(window.userProfileData)
          : null;
      if (isBoundCharacterAccount && boundCharacterIdForAccount) {
        // 如果发帖人是绑定角色，只加载该角色的信息
        console.log(
          "📋 [发帖生成器] 发帖人是绑定角色，只加载该角色信息（传递真实用户资料以判断身份识别）"
        );
        charactersInfo = await StringBuilders.buildCompleteCharacterInfo(
          [boundCharacterIdForAccount],
          userInfoForCharacter, // 传递真实用户资料
          "reaction"
        );
      } else if (isUserOwnTweet) {
        // 用户自己的推文：加载所有绑定角色信息（这些角色可能会评论）
        console.log("📋 [发帖生成器] 用户推文，加载所有绑定角色信息");
        charactersInfo = await StringBuilders.buildCompleteCharacterInfo(
          boundCharacters,
          userInfoForCharacter,
          "reaction"
        );
      } else {
        // 其他人的推文（非绑定角色）：不加载任何角色信息，让AI生成路人评论
        console.log(
          "📋 [发帖生成器] 其他人的推文，不加载用户角色（将生成路人评论）"
        );
        charactersInfo = "";
      }
      if (charactersInfo) {
        systemPrompt += charactersInfo;
        tokenCount = TokenUtils.logTokenUsage(
          "发帖生成器",
          "角色资料信息",
          charactersInfo,
          tokenCount
        );
      } else {
        console.log("ℹ️ [发帖生成器] 跳过角色资料（非用户推文或无绑定角色）");
      }
      // 添加角色关系册（仅在用户推文或绑定角色推文时）
      if (
        (isUserOwnTweet || isBoundCharacterAccount) &&
        boundCharacters &&
        boundCharacters.length > 0
      ) {
        const relationshipsInfo =
          await StringBuilders.buildCharacterRelationships(
            boundCharacters,
            currentAccountId
          );
        if (relationshipsInfo) {
          systemPrompt += relationshipsInfo;
          tokenCount = TokenUtils.logTokenUsage(
            "发帖生成器",
            "角色关系网络",
            relationshipsInfo,
            tokenCount
          );
        }
      }
      if (knownIdentityCharactersInfo) {
        systemPrompt += knownIdentityCharactersInfo;
        tokenCount = TokenUtils.logTokenUsage(
          "发帖生成器",
          "已知身份角色",
          knownIdentityCharactersInfo,
          tokenCount
        );
      }
      // 3.5. 检测推文中的@提及，读取被提及账户的资料
      let mentionedAccountsInfo = "";
      const mentionRegex = /@(\w+)/g;
      const mentions = [...tweetData.content.matchAll(mentionRegex)];
      if (mentions.length > 0) {
        console.log(`📢 [发帖生成器] 检测到${mentions.length}个@提及`);
        const mentionHandles = [...new Set(mentions.map((m) => m[1]))]; // 去重
        for (const handle of mentionHandles) {
          try {
            // 使用统一资料获取系统
            // 如果是用户自己的推文，传递用户资料；否则传递发帖人资料
            const mentionedProfile = await StringBuilders.getUnifiedProfile(
              `@${handle}`,
              {
                userProfileInfo: isUserOwnTweet ? window.userProfileData : null,
              }
            );
            if (mentionedProfile) {
              const mentionStart = systemPrompt.length;
              systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📢 被@提及的账户资料 📢
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
推文中提到了 ${mentionedProfile.handle}，以下是该账户的详细信息：
`; // 格式化资料
              systemPrompt += StringBuilders.formatProfileForPrompt(
                mentionedProfile,
                {
                  includeType: true,
                  includeTweets: true,
                  includeRelationships: true,
                }
              );
              systemPrompt += `
⚠️ 被@提及的影响：
- 该账户看到自己被@提及后，可能会来评论区互动
- 出现概率根据以下因素决定：
* 与发帖者的关系（认识/陌生）
* 推文内容的相关性
* 该账户的活跃度和性格
- 如果该账户来评论，必须严格使用上述资料信息
- 评论内容要符合被@的情境（如被请教、被吐槽、被感谢等）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
              const mentionSection = systemPrompt.substring(mentionStart);
              tokenCount = TokenUtils.logTokenUsage(
                "发帖生成器",
                `@提及账户 ${mentionedProfile.handle}`,
                mentionSection,
                tokenCount
              );
            }
          } catch (error) {
            console.error(`❌ [发帖生成器] 读取@${handle}资料失败:`, error);
          }
        }
      }
      // 4. 用户资料
      const userConstraintsStart = systemPrompt.length;
      systemPrompt +=
        StringBuilders.buildUniversalConstraints(userXProfileInfo);
      const userConstraints = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage(
        "发帖生成器",
        "用户资料约束",
        userConstraints,
        tokenCount
      ); // 4.5. 如果是推进模式，添加现有评论上下文
      if (
        isProgressMode &&
        tweetData.comments &&
        tweetData.comments.length > 0
      ) {
        const existingCommentsStart = systemPrompt.length;
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ 【已有评论上下文 - 严禁重复】⚠️
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
以下是该帖子**已存在**的所有评论（共${tweetData.comments.length}条），**绝对不能**生成与这些内容相似或重复的评论：
`;
        tweetData.comments.forEach((comment, index) => {
          systemPrompt += `${index + 1}. ${comment.user.name} (${
            comment.user.handle
          }): "${comment.content}"`;
          if (comment.sticker) {
            systemPrompt += ` [含表情包: ${comment.sticker.description}]`;
          }
          if (comment.image) {
            systemPrompt += ` [含图片]`;
          }
          systemPrompt += `\n`;
          if (comment.replies && comment.replies.length > 0) {
            comment.replies.forEach((reply) => {
              systemPrompt += ` └─ ${reply.user.name} (${reply.user.handle}): "${reply.content}"`;
              if (reply.sticker) {
                systemPrompt += ` [含表情包: ${reply.sticker.description}]`;
              }
              if (reply.image) {
                systemPrompt += ` [含图片]`;
              }
              systemPrompt += `\n`;
            });
          }
        });
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🚫 【严格要求 - 必须遵守】🚫
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. **绝对禁止**重复上述任何评论的观点、内容或表达方式
2. **绝对禁止**使用与上述评论相似的句式或措辞
3. **必须生成**全新的、不同角度的评论
4. 新评论应该：
- 提出完全不同的观点或看法
- 使用不同的表达方式和语气
- 可以是对已有评论的**补充回复**（楼中楼，使用replyTo字段）
- 可以从时间角度切入（如"刚看到"、"终于找到这个帖子"等）
- 可以是新角度的提问、质疑或讨论
5. 如果实在找不到新角度，优先生成楼中楼回复而非新评论
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        const existingComments = systemPrompt.substring(existingCommentsStart);
        tokenCount = TokenUtils.logTokenUsage(
          "发帖生成器",
          "已有评论上下文",
          existingComments,
          tokenCount
        );
      }
      systemPrompt += `
【生成要求】：
- 生成${
        isProgressMode ? "3-8" : "3-15"
      }条评论，内容多样化（简短/深度/表情符号），支持楼中楼回复，全年龄适宜
${
  isProgressMode
    ? `- ⚠️ **推进模式特殊要求**：
* 优先生成楼中楼回复（对已有评论的回复）而非新的顶层评论
* 新顶层评论必须有明显的时间感（如"刚看到"、"现在才发现"等）
* 新评论角度要与已有评论**完全不同**，不要重复任何观点
* 可以是后来者的补充、质疑、或从全新角度的讨论`
    : ""
}
${
  isBusinessPost
    ? `- 💼 **商业推文特殊要求**：
* 这是一条商业化推文（广告/推广性质），数据应该更高
* 互动数据（点赞、转发、浏览量）应该是普通推文的1.5-3倍
* 评论区应该有30-50%是正面支持性评论（"支持！"、"好棒"、"已下单"等）
* 20-30%是询问相关信息的评论（"在哪买"、"多少钱"、"怎么联系"等）
* 10-20%可以是中性或轻微质疑的评论（保持真实感）
* 评论风格应该更像粉丝/潜在客户，而非批评者
* 如果用户有较高知名度，应该体现出粉丝经济效应`
    : ""
}
- 引用转发处理：如帖子含引用内容，评论可涉及用户观点和被引用原内容
- 公众身份影响：知名度越高，讨论热度和互动数据越多
- 除了绑定角色外，其他用户头像统一：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
- 图片支持：评论可以包含文字图片（10-20%的评论带图），用于展示图片视频等媒体，图片描述应详细具体
【🔒 隐私保护规则 - 路人评论限制】：
🚨 路人评论者（非绑定角色/关系NPC的普通用户）只能基于X平台公开信息：
✅ 可以使用：X姓名、X句柄、X简介、公开身份
❌ 禁止提及：真实姓名、真实职业、私人关系、未公开的身份信息
❌ 禁止使用：只有亲密关系才知道的称呼（如"老师"、"同学"、"同事"等，除非是公开身份）
❌ 禁止提及：角色人设描述中的私密细节
示例说明：
- ✅ 正确："@handle 姐姐太美了"（基于公开身份"网红"）
- ❌ 错误："@handle 张老师这节课讲得真好"（泄露了真实职业"老师"和真实姓氏）
- ❌ 错误："@handle 李老师今天也这么漂亮"（泄露了真实姓名）
⚠️ 只有已绑定的关系NPC才能提及私密信息（因为他们是角色的私人关系）
【情侣角色回复规则】：
${
  userXProfileInfo.verificationType === "couple" &&
  userXProfileInfo.coupleCharacterName
    ? `- 用户的情侣是 ${userXProfileInfo.coupleCharacterName}（公开关系）
- 出现概率应很低（10-20%，与帖子无关时更低）
- 评论围绕帖子主题，自然体现亲密关系但不过分强调
- 粉丝群体限制：仅当双方为明星/网红/公众人物时才可能生成1-2条CP粉丝评论，普通情侣严禁生成"磕CP""嗑糖"等粉丝向评论`
    : ""
}
【JSON返回格式】：
\`\`\`json
{
"stats": {retweets, likes, views, comments},
"comments": [评论数组]${
        isUserOwnTweet && !isReroll && !isProgressMode
          ? `,
"mentions": {
  "likes": [点赞通知数组，1-2条],
  "retweets": [转帖通知数组，1-3条]
}${
              isBusinessPost
                ? `,
"tips": [打赏记录数组，3-8条]`
                : ""
            }`
          : ""
      }
}
\`\`\`
评论对象结构：
- user: {name, handle, avatar, verified}
- content: 评论文本 (可与sticker同时存在)
- timeOffset: 相对推文发布的分钟数（负数，如-5表示推文发布后5分钟的评论）
- sticker: {url: "表情包链接", description: "表情包描述"} (可选，约10-15%评论使用)
- image: {type: "description", content: "图片文字描述"} (可选，10-20%的评论带图)
- replies: [回复数组] (可选，楼中楼回复，不超过3层)
- replyTo: "@被回复者句柄" (楼中楼回复时必填)
${
  isUserOwnTweet && !isReroll && !isProgressMode
    ? `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔔 Mentions通知对象结构（必须生成）🔔
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
点赞通知对象：
{
  "id": "mention_like_xxx",
  "type": "like",
  "users": [{name, handle, avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg", verified: false}], // 3个用户
  "othersCount": ${
    /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
      (userXProfileInfo.publicIdentity || "") +
        " " +
        (userXProfileInfo.bio || "")
    )
      ? "50-500之间的数字（用户是公众人物）"
      : "5-50之间的数字（用户是普通用户）"
  },
  "time": "时间描述（如'2小时前'）",
  "tweet": {"content": "被点赞的推文内容（与用户推文一致）", "image": null或图片描述}
}

转帖通知对象：
{
  "id": "mention_retweet_xxx",
  "type": "retweet",
  "user": {name, handle, avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg", verified: false},
  "retweetContent": "转帖者添加的评论内容",
  "time": "时间描述",
  "quotedTweet": {
    "user": {"name": "${userXProfileInfo.name}", "handle": "${
        userXProfileInfo.handle
      }", "avatar": "${userXProfileInfo.avatar}", "verified": ${
        userXProfileInfo.verified || false
      }},
    "content": "原推文内容（与用户推文一致）",
    "stats": {comments, retweets, likes}
  },
  "stats": {
    "comments": ${
      /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
        (userXProfileInfo.publicIdentity || "") +
          " " +
          (userXProfileInfo.bio || "")
      )
        ? "100-500"
        : "5-20"
    },
    "retweets": ${
      /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
        (userXProfileInfo.publicIdentity || "") +
          " " +
          (userXProfileInfo.bio || "")
      )
        ? "500-2000"
        : "10-50"
    },
    "likes": ${
      /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
        (userXProfileInfo.publicIdentity || "") +
          " " +
          (userXProfileInfo.bio || "")
      )
        ? "1000-5000"
        : "20-100"
    },
    "views": ${
      /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
        (userXProfileInfo.publicIdentity || "") +
          " " +
          (userXProfileInfo.bio || "")
      )
        ? "5000-50000"
        : "100-1000"
    }
  },
  "comments": [2-5条评论，结构同上]
}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`
    : ""
}${
        isUserOwnTweet && !isReroll && !isProgressMode && isBusinessPost
          ? `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎁 打赏记录对象结构（商业推文必须生成）🎁
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
{
  "name": "打赏者姓名",
  "handle": "@username",
  "amount": 25.00（数字，${
    /明星|网红|博主|演员|歌手|艺人|主播|up主|偶像|导演|制片|编剧|作家|influencer|celebrity|singer|actor|artist|streamer|idol/i.test(
      (userXProfileInfo.publicIdentity || "") +
        " " +
        (userXProfileInfo.bio || "")
    )
      ? "15-80"
      : "5-30"
  }），
  "note": "打赏备注（简短、真诚、与推文内容相关）"
}
生成3-8条打赏记录，根据推文数据表现：
- 浏览量<1000：3-4条
- 浏览量1000-5000：4-6条
- 浏览量>5000：6-8条
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`
          : ""
      }
【表情包使用规则】：
- 表情包仅限使用世界书中提供的真实链接，严禁虚构或编造链接
- 表情包与文字内容可以同时存在，用于增强表达效果
- 使用频率控制在约10-15%的评论中，保持自然
- sticker对象包含url和description两个必需字段

关键规则：
1. verified字段必须是布尔值(true/false)
2. stats中所有数字必须是纯数字
3. timeOffset必须是负数，表示评论发布在推文之后多少分钟（如-5, -10, -30等）
4. 支持多层对话链：A评论 → B回复A(replyTo:"@A") → C回复B(replyTo:"@B")
5. sticker字段只能使用世界书中存在的真实链接，禁止虚构${
        isUserOwnTweet && !isReroll && !isProgressMode
          ? `
6. 🔔 **mentions字段必须生成**（点赞和转帖通知）
7. 所有通知的头像统一使用：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
8. 转帖必须包含comments数组（2-5条评论）`
          : ""
      }${
        isUserOwnTweet && !isReroll && !isProgressMode && isBusinessPost
          ? `
9. 🎁 **tips字段必须生成**（商业推文的打赏记录）
10. amount必须是数字类型，保留两位小数`
          : ""
      }`;
      const formatSection = systemPrompt.substring(
        systemPrompt.lastIndexOf("【JSON返回格式】")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "发帖生成器",
        "JSON格式要求",
        formatSection,
        tokenCount
      ); // 构建消息内容，支持图片识别
      const messageContent = []; // 添加基础文本内容
      let contentText = `请为这条推文生成社交互动数据：
推文内容："${tweetData.content}"
${tweetData.location ? `位置：${tweetData.location}` : ""}`; // 如果有附带链接，添加完整链接信息
      if (tweetData.link) {
        contentText += "\n\n【附带链接】：";
        if (tweetData.link.title)
          contentText += `\n标题：${tweetData.link.title}`;
        if (tweetData.link.url) contentText += `\n地址：${tweetData.link.url}`;
        if (tweetData.link.description)
          contentText += `\n描述：${tweetData.link.description}`;
        if (tweetData.link.thumbnail) contentText += "\n[含链接首图]";
      }
      // 如果有引用内容，添加引用信息
      if (tweetData.quotedTweet) {
        const quoted = tweetData.quotedTweet;
        const quotedType = quoted.type === "tweet" ? "推文" : "评论";
        contentText += `
【引用${quotedType}】：
原作者：${quoted.user.name} (${quoted.user.handle})${
          quoted.user.verified ? " ✓已认证" : ""
        }
发布时间：${quoted.time}
原内容："${quoted.content}"`; // 如果引用内容包含图片，添加图片信息
        if (quoted.image) {
          if (quoted.image.type === "description") {
            contentText += `
原图片描述：${quoted.image.content}`;
          } else if (quoted.image.type === "upload") {
            contentText += `
原图片：包含上传的图片内容`;
          }
        }
        // 如果引用内容包含位置信息
        if (quoted.location) {
          contentText += `
原位置：${quoted.location}`;
        }
        contentText += `
注意：这是一条引用转发，用户对原${quotedType}进行了评论并转发。AI回复应该考虑到这个引用关系和上下文，生成的评论可能会同时涉及用户的评论和被引用的原内容。`;
      }
      // 如果有粉丝群引用，添加粉丝群信息
      if (tweetData.quotedFanGroup) {
        const fanGroup = tweetData.quotedFanGroup;
        contentText += `
【引用粉丝群】：
群名：${fanGroup.name}
当前成员数：${fanGroup.memberCount || 0} 位
入群门槛：${fanGroup.threshold || "无"}
注意：这是一条转发粉丝群链接的推文，用户在宣传/分享自己的粉丝群。AI回复应该：
1. 考虑粉丝群的主题和门槛要求
2. 评论者可能对加入粉丝群表示兴趣，询问详情
3. 评论者可能讨论入群门槛是否合理
4. 如果门槛涉及金钱，可能有人讨论价格
5. 真实粉丝会表示支持，普通路人会好奇询问，也可能有质疑的声音
6. 评论应该围绕"粉丝群招募"这个核心话题展开`;
      }
      messageContent.push({ type: "text", text: contentText }); // 如果有上传的图片，添加图片内容
      if (tweetData.image) {
        if (tweetData.image.type === "upload" && tweetData.image.content) {
          // 单图上传
          messageContent.push({
            type: "image_url",
            image_url: { url: tweetData.image.content },
          });
        } else if (
          tweetData.image.type === "uploads" &&
          tweetData.image.images &&
          tweetData.image.images.length > 0
        ) {
          // 多图上传
          tweetData.image.images.forEach((img, index) => {
            if (img.content) {
              messageContent.push({
                type: "image_url",
                image_url: { url: img.content },
              });
            }
          });
        } else if (tweetData.image.type === "description") {
          // 文字描述
          messageContent.push({
            type: "text",
            text: `图片描述：${tweetData.image.content}`,
          });
        }
      }
      const messages = [{ role: "user", content: messageContent }]; // 记录上下文信息token
      const contextText = messageContent
        .map((c) => c.text || "[图片]")
        .join(" ");
      tokenCount = TokenUtils.logTokenUsage(
        "发帖生成器",
        "上下文信息",
        contextText,
        tokenCount
      ); // 最终统计
      TokenUtils.logFinalPrompt("发帖生成器", systemPrompt, contextText); // 🔧 使用统一的API请求工具
      const aiResponseContent = await APIUtils.sendAIRequest({
        apiConfig,
        systemPrompt,
        messages,
        temperature: 0.8,
      }); // 调试用户身份识别信息
      console.log("用户身份识别调试信息（发帖AI回复）:");
      console.log("- 用户X资料:", userXProfileInfo);
      console.log(
        "- 知道用户身份的角色数量:",
        userXProfileInfo.knownIdentityCharacters.length
      );
      if (knownIdentityCharactersInfo) {
        console.log("- 知道用户身份的角色信息已添加到AI上下文");
      }
      // 🔧 使用统一的JSON解析工具
      let interactionData = APIUtils.parseJSONResponse(aiResponseContent); // 🔧 使用统一的后处理工具
      interactionData = await APIUtils.postProcessData(
        interactionData,
        userXProfileInfo
      ); // 验证数据格式
      if (!interactionData.stats || !interactionData.comments) {
        throw new Error("AI返回的数据格式不正确");
      }
      // 如果是推进模式，检测并过滤重复评论
      if (
        isProgressMode &&
        tweetData.comments &&
        tweetData.comments.length > 0
      ) {
        const existingComments = tweetData.comments;
        const newComments = interactionData.comments || []; // 过滤重复评论
        const filteredComments = newComments.filter((newComment) => {
          const newContent = newComment.content.toLowerCase().trim(); // 检查是否与现有评论重复
          const isDuplicate = existingComments.some((existingComment) => {
            const existingContent = existingComment.content
              .toLowerCase()
              .trim(); // 相似度检测：完全相同或高度相似（超过70%相同）
            if (existingContent === newContent) return true; // 计算简单的相似度（基于公共子串）
            const similarity = calculateSimilarity(newContent, existingContent);
            if (similarity > 0.7) {
              console.log(
                `🔍 [重复检测] 发现相似评论 (${(similarity * 100).toFixed(
                  0
                )}%):`,
                {
                  existing: existingComment.content,
                  new: newComment.content,
                }
              );
              return true;
            }
            // 检查楼中楼回复是否重复
            if (existingComment.replies && existingComment.replies.length > 0) {
              return existingComment.replies.some((reply) => {
                const replyContent = reply.content.toLowerCase().trim();
                if (replyContent === newContent) return true;
                const replySimilarity = calculateSimilarity(
                  newContent,
                  replyContent
                );
                if (replySimilarity > 0.7) {
                  console.log(
                    `🔍 [重复检测] 发现与楼中楼回复相似的评论 (${(
                      replySimilarity * 100
                    ).toFixed(0)}%)`
                  );
                  return true;
                }
                return false;
              });
            }
            return false;
          });
          return !isDuplicate;
        });
        const removedCount = newComments.length - filteredComments.length;
        if (removedCount > 0) {
          console.log(
            `✅ [去重] 移除了 ${removedCount} 条重复评论，保留 ${filteredComments.length} 条新评论`
          );
          interactionData.comments = filteredComments;
        }
        // 如果所有新评论都被过滤掉了，提示用户
        if (filteredComments.length === 0) {
          showXToast("AI生成的评论与已有内容重复，已自动过滤", "warning");
          return; // 不保存重复内容
        }
      }
      // 为评论分配ID和时间戳
      const timestamp = Date.now();
      let tweetTimestamp = tweetData.timestamp || timestamp; // 确保 tweetTimestamp 是数字格式（处理可能的Date对象或ISO字符串）
      if (typeof tweetTimestamp !== "number") {
        if (tweetTimestamp instanceof Date) {
          tweetTimestamp = tweetTimestamp.getTime();
        } else if (typeof tweetTimestamp === "string") {
          tweetTimestamp = new Date(tweetTimestamp).getTime();
        } else {
          tweetTimestamp = timestamp;
        }
      }
      // 验证转换后的时间戳有效性
      if (isNaN(tweetTimestamp) || tweetTimestamp <= 0) {
        console.warn("⚠️ [发帖生成器] 推文时间戳无效，使用当前时间");
        tweetTimestamp = timestamp;
      }
      interactionData.comments.forEach((comment, index) => {
        comment.id = `ai_${timestamp}_${index}`; // 将timeOffset转换为实际时间戳
        if (isProgressMode) {
          // 推进模式：新评论应该是最近发布的，使用当前时间附近
          // 忽略AI生成的timeOffset，因为它是相对于推文发布时间的
          const minutesAgo = Math.floor(Math.random() * 60); // 0-60分钟前
          comment.timestamp = timestamp - minutesAgo * 60 * 1000;
          delete comment.timeOffset;
        } else {
          // 正常模式：基于推文发布时间计算
          if (comment.timeOffset !== undefined) {
            // timeOffset是负数，表示推文发布后多少分钟
            comment.timestamp =
              tweetTimestamp + Math.abs(comment.timeOffset) * 60 * 1000;
            delete comment.timeOffset; // 删除临时字段
          } else if (!comment.timestamp) {
            // 如果没有timeOffset，随机生成一个时间戳
            comment.timestamp =
              tweetTimestamp + (5 + Math.random() * 30) * 60 * 1000;
          }
        }
        // 为回复分配ID和时间戳
        if (comment.replies && comment.replies.length > 0) {
          comment.replies.forEach((reply, replyIndex) => {
            reply.id = `ai_${timestamp}_${index}_${replyIndex}`;
            if (isProgressMode) {
              // 推进模式：回复时间应该在评论之后几分钟
              reply.timestamp =
                comment.timestamp + (1 + Math.random() * 10) * 60 * 1000;
              delete reply.timeOffset;
            } else {
              // 正常模式：基于推文发布时间计算
              if (reply.timeOffset !== undefined) {
                reply.timestamp =
                  tweetTimestamp + Math.abs(reply.timeOffset) * 60 * 1000;
                delete reply.timeOffset;
              } else if (!reply.timestamp) {
                // 回复时间晚于评论
                reply.timestamp =
                  comment.timestamp + (1 + Math.random() * 10) * 60 * 1000;
              }
            }
          });
        }
      }); // 更新推文详情页面的数据
      await updateTweetDetailWithAI(
        tweetData.id,
        interactionData,
        isReroll,
        isProgressMode
      ); // 如果当前显示的是这条推文的详情页，重新加载完整数据并显示
      const detailPage = document.getElementById("x-tweet-detail-page");
      if (detailPage && detailPage.style.display === "flex") {
        const currentTweetData = sessionStorage.getItem("currentTweetData");
        if (currentTweetData) {
          const currentTweet = JSON.parse(currentTweetData);
          if (currentTweet.id === tweetData.id) {
            // 从数据库重新加载最新的推文数据（包含AI反应）
            const db = getXDB();
            const accountTweetsId = `userTweets_${currentAccountId || "main"}`;
            const userTweets = await db.xUserTweets.get(accountTweetsId);
            if (userTweets) {
              const updatedTweet = userTweets.tweets.find(
                (t) => t.id === tweetData.id
              );
              if (updatedTweet) {
                await showTweetDetail(updatedTweet);
                console.log("✅ 详情页已刷新，显示最新AI反应");
              }
            }
          }
        }
      }
      // 显示手机样式通知
      const isEnglish = currentLanguage === "en";
      const userAvatar =
        window.userProfileData?.avatar ||
        "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg";
      showPhoneNotification({
        title: "X",
        message: isProgressMode
          ? isEnglish
            ? "Your post interaction has been progressed!"
            : "帖子互动已推进！"
          : isEnglish
          ? "Someone replied to your post!"
          : "你的帖子有人回复了哦！",
        avatar: userAvatar,
        leftIcon: "x",
      });

      // 🔔🎁 如果是用户自己的推文且不是重新生成/推进模式，处理Mentions通知和打赏
      if (isUserOwnTweet && !isReroll && !isProgressMode) {
        // 处理Mentions通知
        if (interactionData.mentions) {
          console.log("🔔 [Mentions] AI已生成通知数据，开始处理");
          try {
            const notificationsData = interactionData.mentions;

            // 为通知添加时间戳
            const timestamp = Date.now();
            if (
              notificationsData.likes &&
              Array.isArray(notificationsData.likes)
            ) {
              notificationsData.likes.forEach((like, index) => {
                if (!like.id) like.id = `mention_like_${timestamp}_${index}`;
                like.timestamp =
                  timestamp - (5 + Math.random() * 30) * 60 * 1000; // 5-35分钟前
              });
            }
            if (
              notificationsData.retweets &&
              Array.isArray(notificationsData.retweets)
            ) {
              notificationsData.retweets.forEach((retweet, index) => {
                if (!retweet.id)
                  retweet.id = `mention_retweet_${timestamp}_${index}`;
                retweet.timestamp =
                  timestamp - (10 + Math.random() * 50) * 60 * 1000; // 10-60分钟前
                retweet.originalTweetId = tweetData.id;

                // 为转帖的评论分配ID和时间戳
                if (retweet.comments && retweet.comments.length > 0) {
                  retweet.comments.forEach((comment, cIndex) => {
                    if (!comment.id) {
                      comment.id = `mention_retweet_${timestamp}_${index}_c${cIndex}`;
                    }
                    if (!comment.timestamp) {
                      comment.timestamp =
                        retweet.timestamp +
                        (5 + Math.random() * 30) * 60 * 1000;
                    }
                  });
                }
              });
            }

            // 保存到数据库
            const xDb = getXDB();
            const dataId = `mentions_${currentAccountId || "main"}`;
            let savedData = await xDb.xAccountProfiles.get(dataId);
            if (!savedData) {
              savedData = { handle: dataId, id: dataId, data: [] };
            }

            const allNotifications = [
              ...(notificationsData.likes || []),
              ...(notificationsData.retweets || []),
            ];
            savedData.data = [...allNotifications, ...savedData.data];
            await xDb.xAccountProfiles.put(savedData);

            console.log(
              `✅ [Mentions] 已保存 ${
                notificationsData.likes?.length || 0
              } 条点赞通知，${
                notificationsData.retweets?.length || 0
              } 条转帖通知`
            );

            // 显示通知提示点
            showNavNotificationDot("notifications");
          } catch (error) {
            console.error("❌ [Mentions] 保存通知失败:", error);
          }
        }

        // 处理打赏数据
        if (
          isBusinessPost &&
          interactionData.tips &&
          Array.isArray(interactionData.tips)
        ) {
          console.log(
            `🎁 [打赏] AI已生成 ${interactionData.tips.length} 条打赏数据，开始调度`
          );
          try {
            // 调度打赏通知（在5小时内随机时间触发）
            const FIVE_HOURS_MS = 5 * 60 * 60 * 1000;
            interactionData.tips.forEach((tip, index) => {
              const randomDelay = Math.random() * FIVE_HOURS_MS;
              console.log(
                `🎁 [打赏调度] 打赏 #${index + 1} 将在 ${Math.round(
                  randomDelay / 1000 / 60
                )} 分钟后触发`
              );

              setTimeout(async () => {
                try {
                  // 更新钱包余额
                  await loadWalletData();
                  if (!walletData.isActivated) {
                    console.warn("🎁 [打赏通知] 钱包未激活，跳过打赏");
                    return;
                  }

                  const amount = parseFloat(tip.amount);
                  walletData.balance += amount;

                  // 添加交易记录
                  const transaction = {
                    id:
                      "tip_" +
                      Date.now() +
                      "_" +
                      Math.random().toString(36).substr(2, 9),
                    description: `来自 ${tip.name} 的打赏`,
                    amount: amount,
                    timestamp: new Date().toISOString(),
                    type: "tip",
                    note: tip.note,
                    tipper: { name: tip.name, handle: tip.handle },
                    tweetId: tweetData.id,
                  };
                  walletData.transactions.unshift(transaction);
                  await saveWalletData();

                  console.log(
                    `🎁 [打赏通知] 打赏已入账: +$${amount.toFixed(2)}`
                  );

                  // 显示通知
                  showPhoneNotification({
                    title: `收到来自 ${tip.name} 的赠金`,
                    message: `+$${amount.toFixed(2)} - ${tip.note}`,
                    avatar: window.userProfileData?.avatar,
                    leftIcon: "custom",
                    leftIconHtml: `<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #22c55e;"><g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.31-8.86c-1.77-.45-2.34-.94-2.34-1.67 0-.84.79-1.43 2.1-1.43 1.38 0 1.9.66 1.94 1.64h1.71c-.05-1.34-.87-2.57-2.49-2.97V5H10.9v1.69c-1.51.32-2.72 1.3-2.72 2.81 0 1.79 1.49 2.69 3.66 3.21 1.95.46 2.34 1.15 2.34 1.87 0 .53-.39 1.39-2.1 1.39-1.6 0-2.23-.72-2.32-1.64H8.04c.1 1.7 1.36 2.66 2.86 2.97V19h2.34v-1.67c1.52-.29 2.72-1.16 2.73-2.77-.01-2.2-1.9-2.96-3.66-3.42z"></path></g></svg>`,
                    duration: 4000,
                  });
                  showXToast(`收到打赏 +$${amount.toFixed(2)}`, "success");
                } catch (error) {
                  console.error("🎁 [打赏通知] 处理打赏失败:", error);
                }
              }, randomDelay);
            });
          } catch (error) {
            console.error("🎁 [打赏] 调度失败:", error);
          }
        }
      }
      // 🔓 检测拉黑解除触发（如果推文中@了某人）
      if (!isReroll && !isProgressMode) {
        const mentionRegex = /@(\w+)/g;
        const mentions = [...tweetData.content.matchAll(mentionRegex)];
        if (
          mentions.length > 0 &&
          userXProfileInfo &&
          userXProfileInfo.handle
        ) {
          const userHandle = userXProfileInfo.handle; // 异步检测每个@提及
          mentions.forEach((match) => {
            const targetHandle = `@${match[1]}`;
            checkUnblockTrigger(
              userHandle,
              targetHandle,
              "mention",
              tweetData.content
            ).catch((err) => {
              console.error("拉黑解除检测失败（静默）:", err);
            });
          });
        }
      }
    } catch (error) {
      console.error("生成AI回复失败:", error);
      showXToast(`回复生成失败: ${error.message}`, "error");
    }
  }
  // 切换推进模式（发帖生成器专用）
  window.toggleTweetProgressMode = function () {
    // 检查当前推文类型
    const currentTweetData = sessionStorage.getItem("currentTweetData");
    if (currentTweetData) {
      try {
        const tweet = JSON.parse(currentTweetData);
        const isAccountTweet = tweet._source === "account";
        const isSearchTweet = tweet._source === "search"; // 账户推文和搜索推文只能使用推进模式，不允许切换到重回
        if ((isAccountTweet || isSearchTweet) && isTweetProgressMode) {
          showXToast("该推文只支持推进模式", "warning");
          return;
        }
      } catch (e) {
        console.warn("解析推文数据失败:", e);
      }
    }
    isTweetProgressMode = !isTweetProgressMode;
    updateTweetRerollButtonUI();
    if (isTweetProgressMode) {
      showXToast("已切换到推进模式 - 将追加新评论", "success");
    } else {
      showXToast("已切换到重新生成模式 - 将覆盖现有评论", "info");
    }
  }; // 更新重回按钮UI（发帖生成器专用）
  function updateTweetRerollButtonUI() {
    const rerollBtn = document.getElementById("reroll-replies-btn");
    if (!rerollBtn) return; // 获取当前主题的文本颜色
    const textColor =
      getComputedStyle(document.getElementById("x-social-screen"))
        .getPropertyValue("--x-text-primary")
        .trim() || "#fff"; // 检查当前推文类型
    let isAccountOrSearchTweet = false;
    const currentTweetData = sessionStorage.getItem("currentTweetData");
    if (currentTweetData) {
      try {
        const tweet = JSON.parse(currentTweetData);
        isAccountOrSearchTweet =
          tweet._source === "account" || tweet._source === "search";
      } catch (e) {
        console.warn("解析推文数据失败:", e);
      }
    }
    if (isTweetProgressMode) {
      // 推进模式 - 心电图图标
      rerollBtn.innerHTML = `
 <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="${textColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
 <path d="M3 12h4l3 8l4 -16l3 8h4" />
 </svg>
 `;
      rerollBtn.setAttribute(
        "title",
        isAccountOrSearchTweet
          ? "推进帖子互动（追加新评论）"
          : "推进帖子互动（追加新评论）\n长按切换到重新生成模式"
      );
    } else {
      // 重新生成模式 - 星形图标（仅用户推文可用）
      rerollBtn.innerHTML = `
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: ${textColor};">
 <g>
 <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
 </g>
 </svg>
 `;
      rerollBtn.setAttribute("title", "重新生成回复\n长按切换到推进模式");
    }
  }
  // 长按事件处理（发帖生成器专用）
  window.handleTweetRerollButtonMouseDown = function () {
    tweetProgressLongPressTimer = setTimeout(() => {
      toggleTweetProgressMode();
    }, 800);
  };
  window.handleTweetRerollButtonMouseUp = function () {
    if (tweetProgressLongPressTimer) {
      clearTimeout(tweetProgressLongPressTimer);
      tweetProgressLongPressTimer = null;
    }
  }; // 重新生成AI回复或推进评论
  async function rerollAIReplies() {
    // 清除长按定时器
    if (tweetProgressLongPressTimer) {
      clearTimeout(tweetProgressLongPressTimer);
      tweetProgressLongPressTimer = null;
    }
    try {
      // 获取当前推文ID
      const currentTweetId = getCurrentTweetId();
      if (!currentTweetId) {
        showXToast("无法获取当前推文信息", "error");
        return;
      }
      // 获取推文数据
      const xTweetsData = await getXTweetsData();
      const currentTweet = xTweetsData.find(
        (tweet) => tweet.id === currentTweetId
      );
      if (!currentTweet) {
        showXToast("未找到推文数据", "error");
        return;
      }
      // 检查推文类型并记录日志
      const isAccountTweet = currentTweet._source === "account";
      const isSearchTweet = currentTweet._source === "search";
      const isUserTweet =
        currentTweet.id && currentTweet.id.startsWith("user_");
      console.log(`🔄 [重回/推进] 推文类型:`, {
        isAccountTweet,
        isSearchTweet,
        isUserTweet,
        currentMode: isTweetProgressMode ? "推进模式" : "重回模式",
        tweetId: currentTweetId,
      }); // 安全检查：账户推文和搜索推文只能使用推进模式
      if ((isAccountTweet || isSearchTweet) && !isTweetProgressMode) {
        console.warn(
          "⚠️ [重回/推进] 账户/搜索推文不支持重回模式，自动切换到推进模式"
        );
        isTweetProgressMode = true;
        updateTweetRerollButtonUI();
      }
      // 显示加载状态
      const rerollBtn = document.getElementById("reroll-replies-btn");
      const originalHTML = rerollBtn.innerHTML;
      const textColor =
        getComputedStyle(document.getElementById("x-social-screen"))
          .getPropertyValue("--x-text-primary")
          .trim() || "#fff";
      rerollBtn.innerHTML = `
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: ${textColor}; animation: spin 1s linear infinite;">
 <g>
 <path d="M12 4V2A10 10 0 0 0 2 12h2a8 8 0 0 1 8-8z" />
 </g>
 </svg>
 `;
      rerollBtn.style.pointerEvents = "none"; // 根据模式和推文类型显示不同提示
      let toastMessage = "正在推进帖子互动...";
      if (!isTweetProgressMode && isUserTweet) {
        toastMessage = "正在重新生成回复...";
      } else if (isAccountTweet) {
        toastMessage = "正在推进账户推文互动...";
      } else if (isSearchTweet) {
        toastMessage = "正在推进搜索推文互动...";
      }
      showXToast(toastMessage, "info"); // 调用AI生成（传递推进模式参数）
      await generateAIResponseForTweet(
        currentTweet,
        !isTweetProgressMode,
        isTweetProgressMode
      ); // 恢复按钮状态
      rerollBtn.innerHTML = originalHTML;
      rerollBtn.style.pointerEvents = "auto";
    } catch (error) {
      console.error("AI回复操作失败:", error);
      showXToast(
        isTweetProgressMode
          ? "推进失败，请检查网络连接"
          : "重新生成失败，请检查网络连接",
        "error"
      ); // 恢复按钮状态
      const rerollBtn = document.getElementById("reroll-replies-btn");
      updateTweetRerollButtonUI();
      rerollBtn.style.pointerEvents = "auto";
    }
  }
  // 获取当前显示的推文ID
  function getCurrentTweetId() {
    const tweetDetailContainer = document.getElementById(
      "tweet-detail-container"
    );
    return tweetDetailContainer
      ? tweetDetailContainer.getAttribute("data-tweet-id")
      : null;
  }
  // 获取推文数据 - 简化版本，直接返回当前推文数据
  async function getXTweetsData() {
    // 因为推文详情页面只显示单个推文，我们可以从DOM中重构数据
    const currentTweetId = getCurrentTweetId();
    if (!currentTweetId) return []; // 从sessionStorage获取推文数据（如果有）
    const tweetData = sessionStorage.getItem("currentTweetData");
    if (tweetData) {
      try {
        return [JSON.parse(tweetData)];
      } catch (e) {
        console.warn("无法解析推文数据:", e);
      }
    }
    return [];
  }
  // ▲▲▲ 【主要！！！】第二个情景：发帖生成器 ▲▲▲
  // 保存用户发布的帖子
  async function saveUserTweet(tweetData) {
    try {
      const db = getXDB();
      const accountTweetsId = `userTweets_${currentAccountId || "main"}`; // 获取当前账户的推文数据
      let userTweets = await db.xUserTweets.get(accountTweetsId);
      if (!userTweets) {
        userTweets = { id: accountTweetsId, tweets: [] };
      }
      // 为推文添加账户ID标识
      tweetData.accountId = currentAccountId || "main"; // 添加新推文到开头（最新的在前面）
      userTweets.tweets.unshift(tweetData); // 保存更新后的数据
      await db.xUserTweets.put(userTweets);
      console.log("用户推文已保存到账户:", currentAccountId, tweetData);
    } catch (error) {
      console.error("保存用户推文失败:", error);
    }
  }
  // 获取当前账户发布的所有帖子
  async function getUserTweets() {
    try {
      const db = getXDB();
      const accountTweetsId = `userTweets_${currentAccountId || "main"}`;
      const userTweets = await db.xUserTweets.get(accountTweetsId);
      return userTweets ? userTweets.tweets : [];
    } catch (error) {
      console.error("获取用户推文失败:", error);
      return [];
    }
  }
  // 多选删除相关变量
  let isMultiSelectMode = false;
  let selectedTweets = new Set(); // 显示推文操作菜单（置顶/删除）
  function showTweetActionMenu(tweetId, event) {
    // 阻止事件冒泡
    if (event) {
      event.preventDefault();
      event.stopPropagation();
    }
    // 移除已存在的菜单
    const existingMenu = document.getElementById("tweet-action-menu");
    if (existingMenu) {
      existingMenu.remove();
    }
    // 获取推文数据
    getUserTweets().then((userTweets) => {
      const tweet = userTweets.find((t) => t.id === tweetId);
      if (!tweet) return;
      const isPinned = tweet.pinned || false; // 创建菜单
      const menu = document.createElement("div");
      menu.id = "tweet-action-menu";
      menu.style.cssText = `
 position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color:#000; border: 1px solid #2f3336; border-radius: 16px; min-width: 280px; z-index: 10000; box-shadow: 0 8px 24px rgba(0,0,0,0.5); `;
      menu.innerHTML = `
 <div style="padding: 12px 0;">
 <div onclick="toggleTweetPin('${tweetId}')" style="padding: 12px 16px; color: #fff; font-size: 15px; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'" onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 32 32" style="width: 18px; height: 18px; fill: currentColor;">
 <path d="M20.743 14.815l-0.933-12.065h5.191c0.414 0 0.75-0.336 0.75-0.75s-0.336-0.75-0.75-0.75v0h-18c-0.414 0-0.75 0.336-0.75 0.75s0.336 0.75 0.75 0.75v0h5.432l-1.275 12.103c-3.213 0.959-5.574 3.738-5.904 7.113l-0.003 0.034c0 0.414 0.336 0.75 0.75 0.75h9.25v7.25c0 0.414 0.336 0.75 0.75 0.75s0.75-0.336 0.75-0.75v0-7.25h9.25c0.414-0 0.75-0.336 0.75-0.75v0c0-3.017-2.35-5.787-6.007-7.185zM12.104 16.081c0.096-0.035 0.179-0.085 0.249-0.148l-0.001 0.001 0.005-0.003c0.126-0.117 0.211-0.275 0.233-0.453l0-0.004 0.011-0.022 1.337-12.701h4.367l0.979 12.681c0.033 0.35 0.303 0.627 0.647 0.67l0.004 0c2.542 0.682 4.512 2.623 5.222 5.096l0.013 0.052h-18.341c0.729-2.54 2.714-4.49 5.222-5.157l0.052-0.012z"></path>
 </svg>
 <span>${isPinned ? "取消置顶" : "置顶到个人资料"}</span>
 </div>
 <div onclick="enterMultiSelectModeFromMenu('${tweetId}')" style="padding: 12px 16px; color: #fff; font-size: 15px; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'" onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;">
 <g><path d="M9 2C6.243 2 4 4.243 4 7v10c0 2.757 2.243 5 5 5h6c2.757 0 5-2.243 5-5V7c0-2.757-2.243-5-5-5H9zm0 2h6c1.654 0 3 1.346 3 3v10c0 1.654-1.346 3-3 3H9c-1.654 0-3-1.346-3-3V7c0-1.654 1.346-3 3-3zm6.207 3.793l-5.5 5.5-2.414-2.414-1.414 1.414 3.121 3.121.707.707.707-.707 6.207-6.207-1.414-1.414z"></path></g>
 </svg>
 <span>选择多条推文</span>
 </div>
 <div onclick="deleteSingleTweet('${tweetId}')" style="padding: 12px 16px; color: #f4212e; font-size: 15px; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(244,33,46,0.1)'" onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;">
 <g><path d="M16 6V4.5C16 3.12 14.88 2 13.5 2h-3C9.11 2 8 3.12 8 4.5V6H3v2h1.06l.81 11.21C4.98 20.78 6.28 22 7.86 22h8.27c1.58 0 2.88-1.22 3-2.79L19.93 8H21V6h-5zm-6-1.5c0-.28.22-.5.5-.5h3c.27 0 .5.22.5.5V6h-4V4.5zm7.13 14.57c-.04.52-.47.93-1 .93H7.86c-.53 0-.96-.41-1-.93L6.07 8h11.85l-.79 11.07zM9 17v-6h2v6H9zm4 0v-6h2v6h-2z"></path></g>
 </svg>
 <span>删除</span>
 </div>
 </div>
 <div onclick="closeTweetActionMenu()" style="padding: 12px 16px; color: #71767b; font-size: 15px; font-weight: 500; cursor: pointer; text-align: center; border-top: 1px solid #2f3336; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.03)'" onmouseout="this.style.backgroundColor='transparent'">
 取消
 </div>
 `;
      document.body.appendChild(menu); // 点击菜单外部关闭
      setTimeout(() => {
        document.addEventListener("click", function closeMenuOnClickOutside(e) {
          if (!menu.contains(e.target)) {
            menu.remove();
            document.removeEventListener("click", closeMenuOnClickOutside);
          }
        });
      }, 100);
    });
  }
  // 关闭操作菜单
  window.closeTweetActionMenu = function () {
    const menu = document.getElementById("tweet-action-menu");
    if (menu) {
      menu.remove();
    }
  }; // 切换推文置顶状态
  window.toggleTweetPin = async function (tweetId) {
    try {
      const db = getXDB();
      const accountTweetsId = `userTweets_${currentAccountId || "main"}`;
      const userTweets = await db.xUserTweets.get(accountTweetsId);
      if (userTweets && userTweets.tweets) {
        const tweet = userTweets.tweets.find((t) => t.id === tweetId);
        if (tweet) {
          const wasPinned = tweet.pinned || false; // 如果要置顶，先取消其他推文的置顶
          if (!wasPinned) {
            userTweets.tweets.forEach((t) => {
              if (t.pinned) {
                t.pinned = false;
              }
            });
          }
          // 切换当前推文的置顶状态
          tweet.pinned = !wasPinned; // 保存到数据库
          await db.xUserTweets.put(userTweets);
          showXToast(wasPinned ? "已取消置顶" : "推文已置顶", "success"); // 关闭菜单并刷新显示
          closeTweetActionMenu();
          loadUserProfileTweets();
        }
      }
    } catch (error) {
      console.error("切换置顶状态失败:", error);
      showXToast("操作失败", "error");
    }
  }; // 删除单条推文
  window.deleteSingleTweet = async function (tweetId) {
    const confirmDelete = confirm("确定要删除这条推文吗？删除后无法恢复。");
    if (!confirmDelete) return;
    try {
      const db = getXDB();
      const accountTweetsId = `userTweets_${currentAccountId || "main"}`;
      const userTweets = await db.xUserTweets.get(accountTweetsId);
      if (userTweets && userTweets.tweets) {
        userTweets.tweets = userTweets.tweets.filter(
          (tweet) => tweet.id !== tweetId
        );
        await db.xUserTweets.put(userTweets); // 同时从主推文数据中删除
        const tweetsData = await db.xTweetsData.get("tweets");
        if (tweetsData) {
          let updated = false;
          if (tweetsData.forYouTweets) {
            const originalLength = tweetsData.forYouTweets.length;
            tweetsData.forYouTweets = tweetsData.forYouTweets.filter(
              (tweet) => tweet.id !== tweetId
            );
            if (tweetsData.forYouTweets.length !== originalLength)
              updated = true;
          }
          if (tweetsData.followingTweets) {
            const originalLength = tweetsData.followingTweets.length;
            tweetsData.followingTweets = tweetsData.followingTweets.filter(
              (tweet) => tweet.id !== tweetId
            );
            if (tweetsData.followingTweets.length !== originalLength)
              updated = true;
          }
          if (updated) {
            await db.xTweetsData.put(tweetsData);
          }
        }
        showXToast("推文已删除", "success");
        closeTweetActionMenu();
        loadUserProfileTweets();
      }
    } catch (error) {
      console.error("删除推文失败:", error);
      showXToast("删除失败", "error");
    }
  }; // 切换推文选择状态（用于多选模式）
  function toggleTweetSelection(tweetId) {
    if (!isMultiSelectMode) {
      enterMultiSelectMode();
    }
    const tweetEl = document.querySelector(`[data-tweet-id="${tweetId}"]`);
    if (!tweetEl) return;
    if (selectedTweets.has(tweetId)) {
      selectedTweets.delete(tweetId);
      tweetEl.classList.remove("selected");
      tweetEl.style.backgroundColor = "";
    } else {
      selectedTweets.add(tweetId);
      tweetEl.classList.add("selected");
      tweetEl.style.backgroundColor =
        "color-mix(in srgb, var(--x-accent) , 0.1)";
    }
    updateDeleteUI();
  }
  // 从菜单进入多选模式并选中当前推文
  window.enterMultiSelectModeFromMenu = function (tweetId) {
    closeTweetActionMenu();
    enterMultiSelectMode();
    // 自动选中触发菜单的推文
    if (tweetId) {
      toggleTweetSelection(tweetId);
    }
  }; // 进入多选模式
  function enterMultiSelectMode() {
    isMultiSelectMode = true; // 显示删除工具栏
    showDeleteToolbar(); // 改变所有推文的样式
    document.querySelectorAll(".user-tweet-item").forEach((item) => {
      item.style.borderLeft = "3px solid var(--x-accent)";
    });
  }
  // 退出多选模式
  window.exitMultiSelectMode = function () {
    isMultiSelectMode = false;
    selectedTweets.clear(); // 隐藏删除工具栏
    hideDeleteToolbar(); // 恢复所有推文的样式
    document.querySelectorAll(".user-tweet-item").forEach((item) => {
      item.classList.remove("selected");
      item.style.backgroundColor = "";
      item.style.borderLeft = "";
    });
  }; // 显示删除工具栏
  function showDeleteToolbar() {
    let toolbar = document.getElementById("delete-toolbar");
    if (!toolbar) {
      toolbar = document.createElement("div");
      toolbar.id = "delete-toolbar";
      toolbar.style.cssText = `
 position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background-color:#000; border: 1px solid #333; border-radius: 20px; padding: 8px 16px; display: flex; align-items: center; gap: 12px; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.5); `;
      toolbar.innerHTML = `
 <button onclick="selectAllTweets()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 16px; padding: 6px 12px; font-size: 13px; cursor: pointer;">
 全选
 </button>
 <span id="selected-count" style="color: #fff; font-size: 14px;">已选择 0 条</span>
 <button onclick="deleteSelectedTweets()" style="background-color: #f91880; color: #fff; border: none; border-radius: 16px; padding: 6px 12px; font-size: 13px; cursor: pointer;">
 删除
 </button>
 <button onclick="exitMultiSelectMode()" style="background-color: #333; color: #fff; border: none; border-radius: 16px; padding: 6px 12px; font-size: 13px; cursor: pointer;">
 取消
 </button>
 `;
      document.body.appendChild(toolbar);
    }
    toolbar.style.display = "flex";
  }
  // 隐藏删除工具栏
  function hideDeleteToolbar() {
    const toolbar = document.getElementById("delete-toolbar");
    if (toolbar) {
      toolbar.style.display = "none";
    }
  }
  // 更新删除UI
  function updateDeleteUI() {
    const countEl = document.getElementById("selected-count");
    if (countEl) {
      countEl.textContent = `已选择 ${selectedTweets.size} 条`;
    }
  }
  // 全选推文
  window.selectAllTweets = function () {
    document.querySelectorAll(".user-tweet-item").forEach((item) => {
      const tweetId = item.dataset.tweetId;
      if (!selectedTweets.has(tweetId)) {
        selectedTweets.add(tweetId);
        item.classList.add("selected");
        item.style.backgroundColor =
          "color-mix(in srgb, var(--x-accent) , 0.1)";
      }
    });
    updateDeleteUI();
  }; // 删除选中的推文
  window.deleteSelectedTweets = async function () {
    if (selectedTweets.size === 0) return;
    const confirmDelete = confirm(
      `确定要删除选中的 ${selectedTweets.size} 条推文吗？删除后无法恢复。`
    );
    if (!confirmDelete) return;
    try {
      const db = getXDB(); // 获取当前账户的推文数据
      const accountTweetsId = `userTweets_${currentAccountId || "main"}`;
      const userTweets = await db.xUserTweets.get(accountTweetsId);
      if (userTweets && userTweets.tweets) {
        // 过滤掉选中的推文
        userTweets.tweets = userTweets.tweets.filter(
          (tweet) => !selectedTweets.has(tweet.id)
        ); // 保存更新后的数据
        await db.xUserTweets.put(userTweets); // 同时从主推文数据中删除（如果存在）
        const tweetsData = await db.xTweetsData.get("tweets");
        if (tweetsData) {
          let updated = false;
          if (tweetsData.forYouTweets) {
            const originalLength = tweetsData.forYouTweets.length;
            tweetsData.forYouTweets = tweetsData.forYouTweets.filter(
              (tweet) => !selectedTweets.has(tweet.id)
            );
            if (tweetsData.forYouTweets.length !== originalLength)
              updated = true;
          }
          if (tweetsData.followingTweets) {
            const originalLength = tweetsData.followingTweets.length;
            tweetsData.followingTweets = tweetsData.followingTweets.filter(
              (tweet) => !selectedTweets.has(tweet.id)
            );
            if (tweetsData.followingTweets.length !== originalLength)
              updated = true;
          }
          if (updated) {
            await db.xTweetsData.put(tweetsData);
          }
        }
        showXToast(`已删除 ${selectedTweets.size} 条推文`, "success"); // 退出多选模式并刷新显示
        exitMultiSelectMode();
        loadUserProfileTweets();
      }
    } catch (error) {
      console.error("删除推文失败:", error);
      showXToast("删除失败", "error");
    }
  }; // 加载用户个人页面的推文
  async function loadUserProfileTweets() {
    try {
      const userTweets = await getUserTweets();
      const container = document.getElementById("x-profile-tweets-container");
      if (userTweets.length === 0) {
        container.innerHTML = `
 <div style="padding: 60px 32px; text-align: center;">
 <div style="color: #71767b; font-size: 31px; font-weight: 800; margin-bottom: 8px;">还没有推文</div>
 <div style="color: #71767b; font-size: 15px;">当你发送第一条推文时，它会显示在这里。</div>
 </div>
 `;
      } else {
        // 将置顶推文排在最前面
        const sortedTweets = [...userTweets].sort((a, b) => {
          const aPinned = a.pinned || false;
          const bPinned = b.pinned || false;
          if (aPinned && !bPinned) return -1;
          if (!aPinned && bPinned) return 1;
          return 0; // 保持原有顺序
        });
        container.innerHTML = "";
        sortedTweets.forEach((tweet) => {
          const tweetElement = createUserTweetElement(tweet);
          container.appendChild(tweetElement);
        });
      }
      // 更新帖子数量显示
      const headerCount = document.getElementById("x-profile-header-count");
      if (headerCount) {
        headerCount.textContent = `${userTweets.length} 帖子`;
      }
    } catch (error) {
      console.error("加载用户推文失败:", error);
    }
  }
  // 创建用户推文元素(个人页面版本)
  function createUserTweetElement(tweet) {
    const tweetEl = document.createElement("div");
    tweetEl.className = "user-tweet-item";
    tweetEl.dataset.tweetId = tweet.id;
    tweetEl.style.cursor = "pointer";
    tweetEl.style.position = "relative";
    tweetEl.style.borderBottom = "1px solid var(--x-border-color)";
    tweetEl.style.display = "block"; // 触摸事件处理变量
    let longPressTimer;
    let isLongPressed = false;
    let touchStartX = 0;
    let touchStartY = 0;
    let hasMoved = false;
    let lastTouchEndTime = 0; // 上次触摸结束时间，用于防抖
    const TOUCH_THRESHOLD = 15; // 滑动阈值（像素）
    const DEBOUNCE_TIME = 300; // 防抖时间（毫秒）
    tweetEl.addEventListener("touchstart", (e) => {
      // 记录初始触摸位置
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      hasMoved = false;
      longPressTimer = setTimeout(() => {
        if (!hasMoved) {
          // 只有没有移动时才触发长按
          isLongPressed = true; // 显示操作菜单（置顶/删除）
          showTweetActionMenu(tweet.id, e);
          e.preventDefault();
        }
      }, 800);
    });
    tweetEl.addEventListener("touchmove", (e) => {
      const touch = e.touches[0];
      const deltaX = Math.abs(touch.clientX - touchStartX);
      const deltaY = Math.abs(touch.clientY - touchStartY); // 如果移动距离超过阈值，标记为滑动
      if (deltaX > TOUCH_THRESHOLD || deltaY > TOUCH_THRESHOLD) {
        hasMoved = true;
        clearTimeout(longPressTimer); // 取消长按
      }
    });
    tweetEl.addEventListener("touchend", (e) => {
      clearTimeout(longPressTimer); // 防抖：防止快速重复触发
      const now = Date.now();
      if (now - lastTouchEndTime < DEBOUNCE_TIME) {
        console.log("🚫 [触摸] 防抖拦截，忽略重复触摸");
        e.preventDefault();
        return;
      }
      lastTouchEndTime = now; // 只有在没有滑动且没有长按的情况下才触发点击
      if (!isLongPressed && !hasMoved) {
        // 阻止后续的点击事件，防止移动端触发两次
        e.preventDefault();
        if (isMultiSelectMode) {
          toggleTweetSelection(tweet.id);
        } else {
          showTweetDetail(tweet);
        }
      } else if (isLongPressed) {
        // 长按后也要阻止点击事件
        e.preventDefault();
      }
      isLongPressed = false;
      hasMoved = false;
    }); // 桌面端鼠标事件保持原有逻辑
    let lastMouseUpTime = 0;
    tweetEl.addEventListener("mousedown", (e) => {
      // 只处理左键点击
      if (e.button !== 0) return;
      longPressTimer = setTimeout(() => {
        isLongPressed = true; // 显示操作菜单（置顶/删除）
        showTweetActionMenu(tweet.id, e);
        e.preventDefault();
      }, 800);
    });
    tweetEl.addEventListener("mouseup", (e) => {
      // 只处理左键点击
      if (e.button !== 0) return;
      clearTimeout(longPressTimer); // 防抖：防止快速重复点击
      const now = Date.now();
      if (now - lastMouseUpTime < DEBOUNCE_TIME) {
        console.log("🚫 [鼠标] 防抖拦截，忽略重复点击");
        return;
      }
      lastMouseUpTime = now;
      if (!isLongPressed) {
        if (isMultiSelectMode) {
          toggleTweetSelection(tweet.id);
        } else {
          showTweetDetail(tweet);
        }
      }
      isLongPressed = false;
    }); // 阻止默认的点击事件，防止与触摸/鼠标事件冲突
    tweetEl.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
    }); // 格式化时间
    function formatTimeForProfile(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diffInHours = Math.floor((now - date) / (1000 * 60 * 60));
      if (diffInHours < 1) {
        const diffInMinutes = Math.floor((now - date) / (1000 * 60));
        return diffInMinutes < 1 ? "刚刚" : `${diffInMinutes}分钟`;
      } else if (diffInHours < 24) {
        return `${diffInHours}小时`;
      } else {
        const diffInDays = Math.floor(diffInHours / 24);
        return diffInDays === 1 ? "1天" : `${diffInDays}天`;
      }
    }
    // 渲染媒体内容（支持多图）
    function renderProfileTweetMedia(tweet) {
      if (!tweet.image) return ""; // 文字描述类型
      if (tweet.image.type === "description") {
        return `
 <div style="margin-top: 12px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 12px; padding: 12px; box-sizing: border-box;">
 <div style="color:var(--x-text-primary); font-size: 14px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${tweet.image.content}</div>
 </div>
 `;
      }
      // 单图上传
      else if (tweet.image.type === "upload") {
        return `
 <div style="margin-top: 12px; border-radius: 12px; overflow: hidden;">
 <img src="${tweet.image.content}" style="width: 100%; max-height: 200px; object-fit: cover; display: block;" alt="推文图片">
 </div>
 `;
      }
      // 多图上传
      else if (
        tweet.image.type === "uploads" &&
        tweet.image.images &&
        tweet.image.images.length > 0
      ) {
        const imageCount = tweet.image.images.length;
        let gridTemplate = "";
        if (imageCount === 1) {
          gridTemplate = "grid-template-columns: 1fr;";
        } else if (imageCount === 2) {
          gridTemplate = "grid-template-columns: repeat(2, 1fr);";
        } else if (imageCount === 3) {
          gridTemplate = "grid-template-columns: repeat(2, 1fr);";
        } else {
          gridTemplate = "grid-template-columns: repeat(2, 1fr);";
        }
        const imagesHtml = tweet.image.images
          .map((img, index) => {
            const spanStyle =
              imageCount === 3 && index === 0 ? "grid-column: span 2;" : "";
            return `
 <div style="${spanStyle}border-radius: 8px; overflow: hidden;">
 <img src="${img.content}" style="width: 100%; height: ${
              imageCount === 1 ? "200px" : "150px"
            }; object-fit: cover; display: block;" alt="推文图片${index + 1}">
 </div>
 `;
          })
          .join("");
        return `
 <div style="margin-top: 12px; display: grid; ${gridTemplate} gap: 4px;">
 ${imagesHtml}
 </div>
 `;
      }
      return "";
    }
    // 渲染链接内容
    function renderProfileTweetLink(tweet) {
      if (!tweet.link) return "";
      return `
 <div style="margin-top: 12px; border: 1px solid #333; border-radius: 12px; overflow: hidden;">
 ${
   tweet.link.thumbnail
     ? `
 <div style="width: 100%; height: 150px; background-color: #333;">
 <img src="${tweet.link.thumbnail}" style="width: 100%; height: 100%; object-fit: cover;" alt="链接预览图">
 </div>
 `
     : ""
 }
 <div style="padding: 12px;">
 <div style="color: #71767b; font-size: 13px; margin-bottom: 4px;">${
   tweet.link.url || "链接"
 }</div>
 ${
   tweet.link.title
     ? `<div style="color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 4px;">${tweet.link.title}</div>`
     : ""
 }
 ${
   tweet.link.description
     ? `<div style="color: #71767b; font-size: 13px;">${tweet.link.description}</div>`
     : ""
 }
 </div>
 </div>
 `;
    }
    // 渲染个人主页引用内容的媒体（图片）
    function renderProfileQuotedTweetMedia(quoted) {
      if (!quoted.image) return "";
      if (quoted.image.type === "description") {
        return `
 <div style="margin-top: 6px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 6px; padding: 6px; box-sizing: border-box;">
 <div style="color:var(--x-text-primary); font-size: 12px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${quoted.image.content}</div>
 </div>
 `;
      } else if (quoted.image.type === "upload") {
        return `
 <div style="margin-top: 6px; border-radius: 6px; overflow: hidden;">
 <img src="${quoted.image.content}" style="width: 100%; max-height: 80px; object-fit: cover; display: block;" alt="引用图片">
 </div>
 `;
      }
      return "";
    }
    // 渲染引用推文内容
    function renderProfileQuotedTweet(tweet) {
      if (!tweet.quotedTweet) return "";
      const quoted = tweet.quotedTweet;
      const typeText = quoted.type === "tweet" ? "推文" : "评论";
      return `
 <div style="margin-top: 12px; border: 1px solid var(--x-border-color); border-radius: 12px; padding: 12px; background-color: var(--x-bg-hover);">
 <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
 <img src="${
   quoted.user.avatar
 }" style="width: 20px; height: 20px; border-radius: 50%;" alt="${
        quoted.user.name
      }">
 <span style="color:var(--x-text-primary); font-size: 13px; font-weight: 600;">${
   quoted.user.name
 }</span>
 ${
   quoted.user.verified
     ? '<svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'
     : ""
 }
 <span style="color:var(--x-text-secondary); font-size: 13px;">${
   quoted.user.handle
 }</span>
 <span style="color:var(--x-text-secondary); font-size: 13px;">·${
   quoted.time
 }</span>
 </div>
 <div style="color:var(--x-text-primary); font-size: 14px; line-height: 1.4;">${
   quoted.content
 }</div>
 ${renderProfileQuotedTweetMedia(quoted)}
 <div style="color:var(--x-text-secondary); font-size: 12px; margin-top: 8px;">引用${typeText}</div>
 </div>
 `;
    }
    // 检查是否置顶
    const isPinned = tweet.pinned || false;
    tweetEl.innerHTML = `
 ${
   isPinned
     ? `
 <div style="padding: 12px 16px 0; display: flex; align-items: center; gap: 12px;">
 <div style="width: 40px; display: flex; justify-content: flex-end;">
 <svg viewBox="0 0 32 32" style="width: 16px; height: 16px; fill: #71767b;">
 <path d="M20.743 14.815l-0.933-12.065h5.191c0.414 0 0.75-0.336 0.75-0.75s-0.336-0.75-0.75-0.75v0h-18c-0.414 0-0.75 0.336-0.75 0.75s0.336 0.75 0.75 0.75v0h5.432l-1.275 12.103c-3.213 0.959-5.574 3.738-5.904 7.113l-0.003 0.034c0 0.414 0.336 0.75 0.75 0.75h9.25v7.25c0 0.414 0.336 0.75 0.75 0.75s0.75-0.336 0.75-0.75v0-7.25h9.25c0.414-0 0.75-0.336 0.75-0.75v0c0-3.017-2.35-5.787-6.007-7.185zM12.104 16.081c0.096-0.035 0.179-0.085 0.249-0.148l-0.001 0.001 0.005-0.003c0.126-0.117 0.211-0.275 0.233-0.453l0-0.004 0.011-0.022 1.337-12.701h4.367l0.979 12.681c0.033 0.35 0.303 0.627 0.647 0.67l0.004 0c2.542 0.682 4.512 2.623 5.222 5.096l0.013 0.052h-18.341c0.729-2.54 2.714-4.49 5.222-5.157l0.052-0.012z"></path>
 </svg>
 </div>
 <span style="color: #71767b; font-size: 13px; font-weight: 700;">已置顶</span>
 </div>
 `
     : ""
 }
 <div style="display: flex; gap: 12px; padding: 12px 16px;">
 <img src="${tweet.user.avatar}" alt="${
      tweet.user.name
    }" style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0;">
 <div style="flex: 1; min-width: 0;" class="tweet-main">
 <div class="tweet-user-info">
 <span class="tweet-user-name">${tweet.user.name}</span>
 ${
   tweet.user.verified
     ? '<svg class="tweet-verified" viewBox="0 0 24 24"><g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.27 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.46 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g></svg>'
     : ""
 }
 <span class="tweet-user-handle">${tweet.user.handle}</span>
 <span class="tweet-time" data-timestamp="${tweet.timestamp || Date.now()}">·${
      tweet.timestamp ? getRelativeTime(tweet.timestamp) : "刚刚"
    }</span>
 ${
   tweet.location
     ? `
 <div style="display: flex; align-items: center; gap: 4px; margin-left: 8px;">
 <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: var(--x-accent);">
 <g><path d="M12 7c-1.93 0-3.5 1.57-3.5 3.5S10.07 14 12 14s3.5-1.57 3.5-3.5S13.93 7 12 7zm0 5c-.827 0-1.5-.673-1.5-1.5S11.173 9 12 9s1.5.673 1.5 1.5S12.827 12 12 12zm0-10c-4.687 0-8.5 3.813-8.5 8.5 0 5.967 7.621 11.116 7.945 11.332l.555.37.555-.37C12.879 21.616 20.5 16.467 20.5 10.5 20.5 5.813 16.687 2 12 2zm0 17.77c-1.665-1.241-6.5-5.196-6.5-9.27C5.5 6.916 8.416 4 12 4s6.5 2.916 6.5 6.5c0 4.073-4.835 8.028-6.5 9.27z"></path></g>
 </svg>
 <span style="color: var(--x-accent); font-size: 13px;">${tweet.location}</span>
 </div>
 `
     : ""
 }
 </div>
 <div class="tweet-content">${processContent(tweet.content)}</div>
 ${renderProfileTweetMedia(tweet)}
 ${renderProfileTweetLink(tweet)}
 ${renderProfileQuotedTweet(tweet)}
 <div class="tweet-actions">
 <div class="tweet-action comment">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
 <g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g>
 </svg>
 <span>${DataUtils.formatNumber(tweet.stats.comments)}</span>
 </div>
 <div class="tweet-action retweet" onclick="handleQuoteRetweetFromData('tweet', '${
   tweet.id
 }')">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
 <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g>
 </svg>
 <span>${DataUtils.formatNumber(tweet.stats.retweets)}</span>
 </div>
 <div class="tweet-action like" data-liked="false" data-likes="${
   tweet.stats.likes
 }">
 <svg class="action-icon like-icon" viewBox="0 0 24 24" fill="currentColor">
 <g><path d="M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g>
 </svg>
 <span class="like-count">${DataUtils.formatNumber(tweet.stats.likes)}</span>
 </div>
 <div class="tweet-action view">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
 <g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10H6v10H4zm9.248 0v-7h2v7h-2z"></path></g>
 </svg>
 <span>${DataUtils.formatNumber(tweet.stats.views)}</span>
 </div>
 <div class="tweet-action bookmark">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
 <g><path d="M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z"></path></g>
 </svg>
 </div>
 <div class="tweet-action share">
 <svg class="action-icon" viewBox="0 0 24 24" fill="currentColor">
 <g><path d="M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.29 3.3-1.42-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z"></path></g>
 </svg>
 </div>
 </div>
 </div>
 </div>
 `;
    return tweetEl;
  }
  // 刷新个人页面的推文显示（用于AI回复后同步数据）
  function refreshUserProfileTweets() {
    const container = document.getElementById("x-profile-tweets-container");
    if (container && container.parentElement.style.display !== "none") {
      loadUserProfileTweets();
    }
  }
  // 更新推文详情页面的AI数据
  async function updateTweetDetailWithAI(
    tweetId,
    interactionData,
    isReroll = false,
    isProgressMode = false
  ) {
    // 使用ID精确更新元素
    // 更新互动数据显示区域
    const statsDiv = document.getElementById("tweet-detail-stats");
    if (statsDiv) {
      statsDiv.innerHTML = `
 <div style="display: flex; align-items: center; gap: 4px;">
 <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(
   interactionData.stats.retweets
 )}</span>
 <span style="color: #71767b; font-size: 15px;">${getI18nText(
   "tweetDetailRetweets"
 )}</span>
 </div>
 <div style="display: flex; align-items: center; gap: 4px;">
 <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(
   interactionData.stats.likes
 )}</span>
 <span style="color: #71767b; font-size: 15px;">${getI18nText(
   "tweetDetailLikes"
 )}</span>
 </div>
 <div style="display: flex; align-items: center; gap: 4px;">
 <span style="color: #fff; font-weight: 700; font-size: 15px;">${formatNumber(
   interactionData.stats.comments
 )}</span>
 <span style="color: #71767b; font-size: 15px;">${getI18nText(
   "tweetDetailBookmarks"
 )}</span>
 </div>
 `;
    }
    // 更新查看数据
    const viewElement = document.getElementById("tweet-detail-views");
    const viewLabelElement = document.getElementById(
      "tweet-detail-views-label"
    );
    if (viewElement) {
      viewElement.textContent = formatNumber(interactionData.stats.views);
    }
    if (viewLabelElement) {
      viewLabelElement.textContent = getI18nText("tweetDetailViews");
    }
    // 添加AI生成的评论
    const commentsContainer = document.getElementById(
      "detail-comments-container"
    ); // 如果是重回，清除现有评论；如果是推进，保留现有评论
    if (isReroll && !isProgressMode && commentsContainer) {
      commentsContainer.innerHTML = "";
    }
    if (commentsContainer && interactionData.comments.length > 0) {
      interactionData.comments.forEach((comment) => {
        // 创建评论组容器
        const commentGroup = document.createElement("div");
        commentGroup.style.cssText = "position: relative;"; // 添加主评论
        const commentElement = createCommentElement(comment); // 如果有回复，给主评论添加特殊类
        if (comment.replies && comment.replies.length > 0) {
          commentElement.classList.add("has-replies");
        }
        commentGroup.appendChild(commentElement); // 渲染回复
        if (comment.replies && comment.replies.length > 0) {
          comment.replies.forEach((reply) => {
            const replyElement = createCommentElement(reply, true);
            commentGroup.appendChild(replyElement);
          });
        }
        commentsContainer.appendChild(commentGroup);
      });
    }
    // 更新存储的推文数据
    await updateStoredTweetData(tweetId, interactionData, isProgressMode);
  }
  // 更新存储的推文数据（包含AI生成的互动数据和评论）
  async function updateStoredTweetData(
    tweetId,
    interactionData,
    isProgressMode = false
  ) {
    try {
      const db = getXDB(); // 检查推文类型
      const currentTweetData = sessionStorage.getItem("currentTweetData");
      let isAccountTweet = false;
      let isSearchTweet = false;
      let accountHandle = null;
      if (currentTweetData) {
        try {
          const tweet = JSON.parse(currentTweetData);
          isAccountTweet = tweet._source === "account";
          isSearchTweet = tweet._source === "search";
          accountHandle = tweet._accountHandle;
        } catch (e) {
          console.warn("解析推文数据失败:", e);
        }
      }
      // 处理搜索推文
      if (isSearchTweet) {
        console.log("📝 [更新数据] 检测到搜索结果推文，更新搜索数据");
        const tweetsData = await db.xTweetsData.get("tweets");
        if (tweetsData) {
          let updated = false; // 更新 forYouTweets
          if (tweetsData.forYouTweets) {
            const index = tweetsData.forYouTweets.findIndex(
              (t) => t.id === tweetId
            );
            if (index !== -1) {
              if (isProgressMode) {
                // 推进模式：累加互动数据，追加评论
                const currentStats = tweetsData.forYouTweets[index].stats;
                tweetsData.forYouTweets[index].stats = {
                  comments: Math.max(
                    currentStats.comments,
                    interactionData.stats.comments
                  ),
                  retweets: Math.max(
                    currentStats.retweets,
                    interactionData.stats.retweets
                  ),
                  likes: Math.max(
                    currentStats.likes,
                    interactionData.stats.likes
                  ),
                  views: Math.max(
                    currentStats.views,
                    interactionData.stats.views
                  ),
                };
                const existingComments =
                  tweetsData.forYouTweets[index].comments || [];
                tweetsData.forYouTweets[index].comments = [
                  ...existingComments,
                  ...(interactionData.comments || []),
                ];
              } else {
                // 重新生成模式（搜索推文不应该使用，但防御性代码）
                tweetsData.forYouTweets[index].stats = {
                  ...tweetsData.forYouTweets[index].stats,
                  ...interactionData.stats,
                };
                tweetsData.forYouTweets[index].comments =
                  interactionData.comments || [];
              }
              updated = true;
              console.log(
                `📈 [搜索推文] forYouTweets 新增 ${
                  interactionData.comments?.length || 0
                } 条评论`
              );
            }
          }
          // 更新 followingTweets
          if (tweetsData.followingTweets && !updated) {
            const index = tweetsData.followingTweets.findIndex(
              (t) => t.id === tweetId
            );
            if (index !== -1) {
              if (isProgressMode) {
                const currentStats = tweetsData.followingTweets[index].stats;
                tweetsData.followingTweets[index].stats = {
                  comments: Math.max(
                    currentStats.comments,
                    interactionData.stats.comments
                  ),
                  retweets: Math.max(
                    currentStats.retweets,
                    interactionData.stats.retweets
                  ),
                  likes: Math.max(
                    currentStats.likes,
                    interactionData.stats.likes
                  ),
                  views: Math.max(
                    currentStats.views,
                    interactionData.stats.views
                  ),
                };
                const existingComments =
                  tweetsData.followingTweets[index].comments || [];
                tweetsData.followingTweets[index].comments = [
                  ...existingComments,
                  ...(interactionData.comments || []),
                ];
              } else {
                tweetsData.followingTweets[index].stats = {
                  ...tweetsData.followingTweets[index].stats,
                  ...interactionData.stats,
                };
                tweetsData.followingTweets[index].comments =
                  interactionData.comments || [];
              }
              updated = true;
              console.log(
                `📈 [搜索推文] followingTweets 新增 ${
                  interactionData.comments?.length || 0
                } 条评论`
              );
            }
          }
          if (updated) {
            await db.xTweetsData.put(tweetsData); // 更新 sessionStorage
            if (currentTweetData) {
              try {
                const currentTweet = JSON.parse(currentTweetData);
                if (currentTweet.id === tweetId) {
                  currentTweet.stats = interactionData.stats;
                  currentTweet.comments = currentTweet.comments || [];
                  if (isProgressMode) {
                    currentTweet.comments = [
                      ...currentTweet.comments,
                      ...(interactionData.comments || []),
                    ];
                  } else {
                    currentTweet.comments = interactionData.comments || [];
                  }
                  sessionStorage.setItem(
                    "currentTweetData",
                    JSON.stringify(currentTweet)
                  );
                }
              } catch (e) {
                console.warn("更新 sessionStorage 失败:", e);
              }
            }
            console.log(
              "✅ 搜索推文AI反应已保存:",
              tweetId,
              isProgressMode ? "(推进模式)" : ""
            );
            return;
          }
        }
      }
      // 处理账户推文
      if (isAccountTweet && accountHandle) {
        // 更新账户主页数据
        console.log("📝 [更新数据] 检测到账户推文，更新账户主页数据");
        const cleanHandle = accountHandle.replace("@", "");
        const accountProfile = await db.xAccountProfiles.get(cleanHandle);
        if (accountProfile && accountProfile.tweets) {
          const tweetIndex = accountProfile.tweets.findIndex(
            (t) => t.id === tweetId
          );
          if (tweetIndex !== -1) {
            if (isProgressMode) {
              // 推进模式：累加互动数据，追加评论
              const currentStats = accountProfile.tweets[tweetIndex].stats;
              accountProfile.tweets[tweetIndex].stats = {
                comments: Math.max(
                  currentStats.comments,
                  interactionData.stats.comments
                ),
                retweets: Math.max(
                  currentStats.retweets,
                  interactionData.stats.retweets
                ),
                likes: Math.max(
                  currentStats.likes,
                  interactionData.stats.likes
                ),
                views: Math.max(
                  currentStats.views,
                  interactionData.stats.views
                ),
              }; // 追加新评论
              const existingComments =
                accountProfile.tweets[tweetIndex].comments || [];
              accountProfile.tweets[tweetIndex].comments = [
                ...existingComments,
                ...(interactionData.comments || []),
              ];
              console.log(
                `📈 [账户推文] 新增 ${
                  interactionData.comments?.length || 0
                } 条评论`
              );
            } else {
              // 重新生成模式：覆盖互动数据和评论
              accountProfile.tweets[tweetIndex].stats = {
                ...accountProfile.tweets[tweetIndex].stats,
                ...interactionData.stats,
              };
              accountProfile.tweets[tweetIndex].comments =
                interactionData.comments || [];
            }
            // 保存到数据库
            await db.xAccountProfiles.put(accountProfile); // 更新 sessionStorage
            if (currentTweetData) {
              try {
                const currentTweet = JSON.parse(currentTweetData);
                if (currentTweet.id === tweetId) {
                  currentTweet.stats = accountProfile.tweets[tweetIndex].stats;
                  currentTweet.comments =
                    accountProfile.tweets[tweetIndex].comments;
                  sessionStorage.setItem(
                    "currentTweetData",
                    JSON.stringify(currentTweet)
                  );
                }
              } catch (e) {
                console.warn("更新 sessionStorage 失败:", e);
              }
            }
            console.log(
              "✅ 账户推文AI反应已保存:",
              tweetId,
              isProgressMode ? "(推进模式)" : ""
            );
            return;
          }
        }
      }
      // 检查是否为用户推文
      const isUserTweet = tweetId && tweetId.startsWith("user_");
      if (!isUserTweet) {
        // 非用户推文：尝试从主页推文数据中更新
        console.log("📝 [更新数据] 检测到主页推文，更新主页数据");
        const tweetsData = await db.xTweetsData.get("tweets");
        if (tweetsData) {
          let updated = false; // 更新 forYouTweets
          if (tweetsData.forYouTweets) {
            const index = tweetsData.forYouTweets.findIndex(
              (t) => t.id === tweetId
            );
            if (index !== -1) {
              if (isProgressMode) {
                // 推进模式：累加互动数据，追加评论
                const currentStats = tweetsData.forYouTweets[index].stats;
                tweetsData.forYouTweets[index].stats = {
                  comments: Math.max(
                    currentStats.comments,
                    interactionData.stats.comments
                  ),
                  retweets: Math.max(
                    currentStats.retweets,
                    interactionData.stats.retweets
                  ),
                  likes: Math.max(
                    currentStats.likes,
                    interactionData.stats.likes
                  ),
                  views: Math.max(
                    currentStats.views,
                    interactionData.stats.views
                  ),
                };
                const existingComments =
                  tweetsData.forYouTweets[index].comments || [];
                tweetsData.forYouTweets[index].comments = [
                  ...existingComments,
                  ...(interactionData.comments || []),
                ];
              } else {
                // 重新生成模式
                tweetsData.forYouTweets[index].stats = {
                  ...tweetsData.forYouTweets[index].stats,
                  ...interactionData.stats,
                };
                tweetsData.forYouTweets[index].comments =
                  interactionData.comments || [];
              }
              updated = true;
              console.log(
                `📈 [主页推文] forYouTweets 新增 ${
                  interactionData.comments?.length || 0
                } 条评论`
              );
            }
          }
          // 更新 followingTweets
          if (tweetsData.followingTweets && !updated) {
            const index = tweetsData.followingTweets.findIndex(
              (t) => t.id === tweetId
            );
            if (index !== -1) {
              if (isProgressMode) {
                const currentStats = tweetsData.followingTweets[index].stats;
                tweetsData.followingTweets[index].stats = {
                  comments: Math.max(
                    currentStats.comments,
                    interactionData.stats.comments
                  ),
                  retweets: Math.max(
                    currentStats.retweets,
                    interactionData.stats.retweets
                  ),
                  likes: Math.max(
                    currentStats.likes,
                    interactionData.stats.likes
                  ),
                  views: Math.max(
                    currentStats.views,
                    interactionData.stats.views
                  ),
                };
                const existingComments =
                  tweetsData.followingTweets[index].comments || [];
                tweetsData.followingTweets[index].comments = [
                  ...existingComments,
                  ...(interactionData.comments || []),
                ];
              } else {
                tweetsData.followingTweets[index].stats = {
                  ...tweetsData.followingTweets[index].stats,
                  ...interactionData.stats,
                };
                tweetsData.followingTweets[index].comments =
                  interactionData.comments || [];
              }
              updated = true;
              console.log(
                `📈 [主页推文] followingTweets 新增 ${
                  interactionData.comments?.length || 0
                } 条评论`
              );
            }
          }
          if (updated) {
            await db.xTweetsData.put(tweetsData); // 更新 sessionStorage
            if (currentTweetData) {
              try {
                const currentTweet = JSON.parse(currentTweetData);
                if (currentTweet.id === tweetId) {
                  currentTweet.stats = interactionData.stats;
                  currentTweet.comments = currentTweet.comments || [];
                  if (isProgressMode) {
                    currentTweet.comments = [
                      ...currentTweet.comments,
                      ...(interactionData.comments || []),
                    ];
                  } else {
                    currentTweet.comments = interactionData.comments || [];
                  }
                  sessionStorage.setItem(
                    "currentTweetData",
                    JSON.stringify(currentTweet)
                  );
                }
              } catch (e) {
                console.warn("更新 sessionStorage 失败:", e);
              }
            }
            console.log(
              "✅ 主页推文AI反应已保存:",
              tweetId,
              isProgressMode ? "(推进模式)" : ""
            );
            return;
          } else {
            console.warn("⚠️ 未在主页数据中找到要更新的推文:", tweetId);
          }
        }
        return; // 非用户推文处理结束
      }
      // 用户推文的处理逻辑
      // 使用正确的账户ID获取用户推文数据
      const accountTweetsId = `userTweets_${currentAccountId || "main"}`;
      let userTweets = await db.xUserTweets.get(accountTweetsId);
      if (!userTweets) {
        console.warn("未找到用户推文数据，账户ID:", accountTweetsId);
        return;
      }
      // 查找并更新对应的推文
      const tweetIndex = userTweets.tweets.findIndex(
        (tweet) => tweet.id === tweetId
      );
      if (tweetIndex !== -1) {
        if (isProgressMode) {
          // 推进模式：累加互动数据，追加评论
          const currentStats = userTweets.tweets[tweetIndex].stats;
          userTweets.tweets[tweetIndex].stats = {
            comments: Math.max(
              currentStats.comments,
              interactionData.stats.comments
            ),
            retweets: Math.max(
              currentStats.retweets,
              interactionData.stats.retweets
            ),
            likes: Math.max(currentStats.likes, interactionData.stats.likes),
            views: Math.max(currentStats.views, interactionData.stats.views),
          }; // 追加新评论（保留旧评论）
          const existingComments = userTweets.tweets[tweetIndex].comments || [];
          userTweets.tweets[tweetIndex].comments = [
            ...existingComments,
            ...(interactionData.comments || []),
          ];
          console.log(
            `📈 [推进模式] 新增 ${interactionData.comments?.length || 0} 条评论`
          );
        } else {
          // 重新生成模式：覆盖互动数据和评论
          userTweets.tweets[tweetIndex].stats = {
            ...userTweets.tweets[tweetIndex].stats,
            ...interactionData.stats,
          }; // 更新评论数据
          userTweets.tweets[tweetIndex].comments =
            interactionData.comments || [];
        }
        // 保存更新后的数据
        await db.xUserTweets.put(userTweets); // 同时更新 sessionStorage 中的当前推文数据
        if (currentTweetData) {
          try {
            const currentTweet = JSON.parse(currentTweetData);
            if (currentTweet.id === tweetId) {
              currentTweet.stats = userTweets.tweets[tweetIndex].stats;
              currentTweet.comments = userTweets.tweets[tweetIndex].comments;
              sessionStorage.setItem(
                "currentTweetData",
                JSON.stringify(currentTweet)
              );
            }
          } catch (e) {
            console.warn("更新 sessionStorage 失败:", e);
          }
        }
        console.log(
          "✅ 推文AI反应已保存到数据库:",
          tweetId,
          "账户:",
          accountTweetsId,
          isProgressMode ? "(推进模式)" : ""
        ); // 刷新个人页面显示
        refreshUserProfileTweets();
      } else {
        console.warn("⚠️ 未找到要更新的推文:", tweetId);
      }
    } catch (error) {
      console.error("❌ 更新存储推文数据失败:", error);
    }
  }
  // ▼▼▼ 【主要！！！】第三个情景：统一AI回复生成器▼▼▼
  async function generateUnifiedAIResponse(
    tweetData,
    userComment,
    options = {}
  ) {
    try {
      const {
        isOwnPost = false,
        commentType = "main_comment", // 'main_comment' | 'reply_comment'
        pageType = "detail", // 'detail' | 'main'
        parentComment = null,
        mainCommentId = null, // 用于楼中楼回复的主评论ID
      } = options; // 🔧 使用统一的API配置加载工具
      const { apiConfig, xSettings, xDb } =
        await APIUtils.loadConfigAndSettings();
      const { userPrompt, worldSetting, boundCharacters } = xSettings;
      // 🚨 关键修复：重新从数据库加载最新的推文数据，避免丢失用户刚发的评论
      console.log("🔄 [AI回复] 重新加载最新推文数据，避免覆盖用户评论");
      const tweetId = tweetData.id;
      const isUserTweet = tweetId.startsWith("user_");
      const isRetweetMention = tweetData._source === "retweet_mention";
      let latestTweetData = null;
      if (isRetweetMention) {
        // 从 Mentions 数据库加载转帖通知
        console.log("🔄 [AI回复] 从 Mentions 数据库加载转帖通知");
        const mentionsId = `mentions_${currentAccountId || "main"}`;
        const mentionsData = await xDb.xAccountProfiles.get(mentionsId);
        if (mentionsData && mentionsData.data) {
          const mention = mentionsData.data.find(
            (m) => m.id === tweetId && m.type === "retweet"
          );
          if (mention) {
            // 重新构建 tweetData 结构，使用最新的评论数据
            latestTweetData = {
              ...tweetData,
              comments: mention.comments || [],
              stats: mention.stats || tweetData.stats,
            };
            console.log(
              "✅ [AI回复] 已从 Mentions 加载转帖数据，评论数:",
              latestTweetData.comments.length
            );
          }
        }
      } else if (isUserTweet) {
        const userTweetsId = `userTweets_${currentAccountId || "main"}`;
        const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
        if (userTweetsData && userTweetsData.tweets) {
          latestTweetData = userTweetsData.tweets.find((t) => t.id === tweetId);
        }
      } else {
        const tweetsData = await xDb.xTweetsData.get("tweets");
        if (tweetsData) {
          latestTweetData =
            tweetsData.forYouTweets?.find((t) => t.id === tweetId) ||
            tweetsData.followingTweets?.find((t) => t.id === tweetId);
        }
      }
      // 如果成功加载到最新数据，使用最新数据；否则使用传入的数据
      if (latestTweetData) {
        console.log(
          "✅ [AI回复] 已加载最新推文数据，评论数:",
          latestTweetData.comments?.length || 0
        );
        tweetData = latestTweetData;
      } else {
        console.warn("⚠️ [AI回复] 未能加载最新推文数据，使用传入数据");
      } // 使用工具函数构建用户X个人资料信息（使用window.userProfileData确保获取最新数据）
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(
        window.userProfileData
      ); // Token计数器
      let tokenCount = 0; // 1. 提示词 + 世界书
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage(
        "统一AI回复生成器",
        "基础系统提示词",
        systemPrompt,
        tokenCount
      ); // 2. 角色定义（评论回复生成专用）
      systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🚫 核心任务说明 🚫
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的互动生成器。你的任务是：
✅ 为用户的评论生成其他人的回应/反应
❌ 绝对不能再生成用户本人的评论或回复
**明确：用户已经发表了评论，你只负责生成别人对这条评论的反应！**
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`;
      const coreTaskSection = systemPrompt.substring(
        systemPrompt.lastIndexOf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "统一AI回复生成器",
        "核心任务说明",
        coreTaskSection,
        tokenCount
      ); // 添加场景分支提示词（评论场景特有的详细逻辑）
      const scenarioPromptStart = systemPrompt.length;
      systemPrompt += StringBuilders.buildScenarioPrompt({
        isOwnPost,
        commentType,
        pageType,
        parentComment,
      });
      const scenarioPrompt = systemPrompt.substring(scenarioPromptStart);
      tokenCount = TokenUtils.logTokenUsage(
        "统一AI回复生成器",
        "场景分支提示词",
        scenarioPrompt,
        tokenCount
      ); // 3. 角色资料（回复场景）
      const charactersInfo = await StringBuilders.buildCompleteCharacterInfo(
        boundCharacters,
        userXProfileInfo,
        "reply"
      );
      if (charactersInfo) {
        systemPrompt += charactersInfo;
        tokenCount = TokenUtils.logTokenUsage(
          "统一AI回复生成器",
          "角色资料信息",
          charactersInfo,
          tokenCount
        );
      }
      // 4. 用户资料
      const userConstraintsStart = systemPrompt.length;
      systemPrompt +=
        StringBuilders.buildUniversalConstraints(userXProfileInfo);
      const userConstraints = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage(
        "统一AI回复生成器",
        "用户资料约束",
        userConstraints,
        tokenCount
      );

      // 4.5. 🌍 读取世界运转大事件（如果启用）
      const worldEventsPrompt = await getWorldEventsPrompt("统一AI回复生成器", {
        usageRate: 0.2, // 20%的回复涉及大事件
        usageDescription: `**评论回复场景的大事件使用**：
1. **话题延伸**：如果用户的评论涉及某个大事件，回复可以展开讨论
2. **观点碰撞**：对大事件持不同看法的网友可能在回复中辩论
3. **信息补充**：回复可能补充大事件的相关信息或最新进展
4. **轻度关联**：即使推文不直接涉及大事件，回复也可能自然提及（如"最近XXX事闹得，都没心情看这个了"）
5. **自然融入**：只有约20%的回复涉及大事件，保持多样性`,
      });

      if (worldEventsPrompt) {
        systemPrompt += worldEventsPrompt;
        tokenCount = TokenUtils.logTokenUsage(
          "统一AI回复生成器",
          "世界运转大事件",
          worldEventsPrompt,
          tokenCount
        );
      }

      systemPrompt += `
【评论回复要求】：
- 生成1-5条回复，内容多样化（简短/深度/表情符号）
- 环境贴合：参考评论区现有讨论，基于主题和氛围生成贴合回复
- 回复内容必须围绕推文主题和用户评论内容，不要偏离主题
- 除了绑定角色外，其他用户头像统一：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
${
  boundCharacters.length > 0
    ? `**角色回复要点**：根据设定判断是否适合发言，符合人设特点，可生成0-2个角色回复，严格使用角色X资料信息。`
    : "**当前状态**：无绑定角色，生成普通用户回复。"
}
【🔒 隐私保护规则 - 路人回复限制】：
🚨 路人回复者（非绑定角色/关系NPC的普通用户）只能基于X平台公开信息：
✅ 可以使用：X姓名、X句柄、X简介、公开身份
❌ 禁止提及：真实姓名、真实职业、私人关系、未公开的身份信息
❌ 禁止使用：只有亲密关系才知道的称呼（如"老师"、"同学"、"老板"等，除非是公开身份）
❌ 禁止提及：角色人设描述中的私密细节
示例说明：
- ✅ 正确："姐姐说得对"（基于公开的社交称呼）
- ❌ 错误："王老师说得好"（泄露了真实姓氏和职业）
- ❌ 错误："同学你好厉害"（假装是同学关系，路人不可能知道）
⚠️ 只有已绑定的关系NPC才能提及私密信息或使用私密称呼（因为他们是角色的私人关系）
【情侣角色回复规则】：
${
  userXProfileInfo.verificationType === "couple" &&
  userXProfileInfo.coupleCharacterName
    ? `- 用户的情侣是 ${userXProfileInfo.coupleCharacterName}
- **关键限制**：在他人帖子下回复用户评论时，出现概率极低（5-15%）
* 评论与情侣角色无关 → 不出现
* 话题普通/日常 → 很少出现
* 只有评论内容与情侣角色相关、或确有理由参与讨论时才可能出现
- 回复围绕帖子主题和讨论，不只是"秀恩爱"
- 粉丝群体严格限制：仅当双方为明星/网红/公众人物时才可能有1条CP粉丝评论（概率极低），普通情侣绝无"磕学家""CP粉"等粉丝群体`
    : ""
}
【JSON返回格式】：
\`\`\`json
{
"${
        commentType === "reply_comment" && pageType === "main"
          ? "replies"
          : "comments"
      }": [回复数组]
}
\`\`\`
回复对象结构：
- user: {name, handle, avatar, verified}
- content: 回复文本 (可与sticker同时存在)
- timeOffset: 相对推文发布的分钟数（负数，如-5表示推文发布后5分钟的回复）
- sticker: {url: "表情包链接", description: "表情包描述"} (可选，约10-15%回复使用)
- replyTo: "${userComment.user.handle}" (必须回复用户刚发表的评论)
- replies: []
【表情包使用规则】：
- 表情包仅限使用世界书中提供的真实链接，严禁虚构或编造链接
- 表情包与文字内容可以同时存在，用于增强表达效果
- 使用频率控制在约10-15%的回复中，保持自然
- sticker对象包含url和description两个必需字段

关键规则：
1. verified字段必须是布尔值(true/false)
1.5. timeOffset必须是负数，表示回复发布在推文之后多少分钟（如-2, -5, -15等）
2. replyTo字段必须是"${userComment.user.handle}"，表示回复用户的评论
3. ${
        boundCharacters.length > 0
          ? "生成角色回复时必须严格使用提供的角色X资料(xName、xHandle、xAvatar、xVerified)，不得使用默认值或自编信息"
          : "普通用户回复，自创用户名和句柄"
      }
4. sticker字段只能使用世界书中存在的真实链接，禁止虚构`;
      const formatSection = systemPrompt.substring(
        systemPrompt.lastIndexOf("【JSON返回格式】")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "统一AI回复生成器",
        "JSON格式要求",
        formatSection,
        tokenCount
      ); // 构建上下文信息
      let contextInfo = `【推文信息${
        pageType === "detail" ? "（详情页）" : "（主页）"
      }】
标题：${isOwnPost ? "【用户的帖子】" : ""}${tweetData.content}
推文作者：${tweetData.user.name} (${tweetData.user.handle})
${tweetData.location ? `位置：${tweetData.location}` : ""}
${tweetData.link ? `链接：${tweetData.link.title || tweetData.link.url}` : ""}
${
  tweetData.media && tweetData.media.length > 0
    ? `媒体：${tweetData.media[0].description}`
    : ""
}`; // 如果推文包含引用内容，添加引用信息
      if (tweetData.quotedTweet) {
        const quoted = tweetData.quotedTweet;
        const quotedType = quoted.type === "tweet" ? "推文" : "评论";
        contextInfo += `
【该推文引用了以下${quotedType}】
原作者：${quoted.user.name} (${quoted.user.handle})${
          quoted.user.verified ? " ✓已认证" : ""
        }
发布时间：${quoted.time}
原内容："${quoted.content}"`; // 如果引用内容包含图片，添加图片信息
        if (quoted.image) {
          if (quoted.image.type === "description") {
            contextInfo += `
原图片描述：${quoted.image.content}`;
          } else if (quoted.image.type === "upload") {
            contextInfo += `
原图片：包含上传的图片内容`;
          }
        }
        // 如果引用内容包含位置信息
        if (quoted.location) {
          contextInfo += `
原位置：${quoted.location}`;
        }
        contextInfo += `
注意：这是引用转发，用户的评论是对上述${quotedType}的回应/评论。回复时可以同时考虑用户的评论和被引用的原内容，可以讨论引用关系、原作者观点，或用户的转发评论等。`;
      }
      contextInfo += `
【用户发表的${commentType === "main_comment" ? "评论" : "回复"}】
用户名：${userComment.user.name}
用户句柄：${userComment.user.handle}
${commentType === "main_comment" ? "评论" : "回复"}内容：${
        userComment.content
      }`;
      if (commentType === "reply_comment" && parentComment) {
        contextInfo += `
【用户回复的对象（楼中楼场景）】
被回复者姓名：${parentComment.user.name}
被回复者句柄：${parentComment.user.handle}
被回复的评论：${parentComment.content}
⚠️ 重要说明：
- 用户 ${userComment.user.name} (${userComment.user.handle}) 刚刚回复了 ${parentComment.user.name} (${parentComment.user.handle}) 的评论
- 你生成的回复必须是对用户 ${userComment.user.name} (${userComment.user.handle}) 的回复
- 所有回复的 replyTo 字段必须是 "${userComment.user.handle}"`;
      }
      // 添加已有评论区内容到上下文
      if (tweetData.comments && tweetData.comments.length > 0) {
        contextInfo += `
【当前评论区内容】（共${tweetData.comments.length}条评论，帮助理解讨论主题和氛围）`; // 显示最多前10条评论，避免上下文过长
        const displayComments = tweetData.comments.slice(0, 10);
        displayComments.forEach((comment, index) => {
          contextInfo += `
${index + 1}. ${comment.user.name} (${comment.user.handle}): ${
            comment.content
          }`;
          if (comment.sticker) {
            contextInfo += ` [含表情包: ${comment.sticker.description}]`;
          }
          // 如果有回复，也显示前3条
          if (comment.replies && comment.replies.length > 0) {
            const displayReplies = comment.replies.slice(0, 3);
            displayReplies.forEach((reply, replyIndex) => {
              contextInfo += `
└─ ${reply.user.name} (${reply.user.handle}): ${reply.content}`;
              if (reply.sticker) {
                contextInfo += ` [含表情包: ${reply.sticker.description}]`;
              }
            });
            if (comment.replies.length > 3) {
              contextInfo += `
└─ ...还有${comment.replies.length - 3}条回复`;
            }
          }
        });
        if (tweetData.comments.length > 10) {
          contextInfo += `
...还有${tweetData.comments.length - 10}条评论未显示`;
        }
      }
      // 读取推文作者的完整资料（使用统一资料获取系统）
      if (tweetData.user && tweetData.user.handle) {
        try {
          console.log(
            `📝 [统一AI回复] 读取推文作者资料: ${tweetData.user.handle}`
          ); // 使用统一资料获取系统
          const tweetAuthorProfile = await StringBuilders.getUnifiedProfile(
            tweetData.user.handle,
            {
              userProfileInfo: userXProfileInfo,
            }
          );
          if (tweetAuthorProfile) {
            contextInfo += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📝 推文作者完整资料 📝
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`; // 格式化资料
            contextInfo += StringBuilders.formatProfileForPrompt(
              tweetAuthorProfile,
              {
                includeType: true,
                includeTweets: true,
                includeRelationships: true,
              }
            );
            contextInfo += `
⚠️ 推文作者资料使用说明：
- 如果推文作者是角色/NPC，回复时可能会来评论区互动
- 推文作者的关系NPC如果看到这条推文，可能会来评论
- 回复要符合推文作者的身份和背景
- 如果推文作者与用户有聊天记忆，可以自然体现在互动中
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
            tokenCount = TokenUtils.logTokenUsage(
              "统一AI回复生成器",
              "推文作者资料",
              contextInfo.substring(
                contextInfo.lastIndexOf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
              ),
              tokenCount
            );
          }
        } catch (error) {
          console.error(`❌ [统一AI回复] 读取推文作者资料失败:`, error);
        }
      }
      // 记录上下文信息token
      TokenUtils.logTokenUsage(
        "统一AI回复生成器",
        "上下文信息",
        contextInfo,
        tokenCount
      ); // 构建消息内容，支持图片识别
      const messageContent = [];
      messageContent.push({ type: "text", text: contextInfo }); // 如果用户评论包含上传的图片，添加图片内容
      if (
        userComment.image &&
        userComment.image.type === "upload" &&
        userComment.image.content
      ) {
        messageContent.push({
          type: "image_url",
          image_url: { url: userComment.image.content },
        });
      } else if (
        userComment.image &&
        userComment.image.type === "description"
      ) {
        messageContent.push({
          type: "text",
          text: `用户评论附带的图片描述：${userComment.image.content}`,
        });
      }
      const messages = [{ role: "user", content: messageContent }]; // 最终统计
      const contextText = messageContent
        .map((c) => c.text || "[图片]")
        .join(" ");
      TokenUtils.logFinalPrompt("统一AI回复生成器", systemPrompt, contextText); // 🔧 使用统一的API请求工具
      const aiResponseContent = await APIUtils.sendAIRequest({
        apiConfig,
        systemPrompt,
        messages,
        temperature: 0.8,
      });
      console.log("绑定角色数量:", boundCharacters.length);
      console.log(
        "评论区上下文:",
        tweetData.comments ? `${tweetData.comments.length}条评论` : "无评论"
      );
      if (tweetData.comments && tweetData.comments.length > 0) {
        console.log(
          "评论示例:",
          tweetData.comments
            .slice(0, 3)
            .map((c) => `${c.user.name}: ${c.content.substring(0, 50)}...`)
        );
      }
      // 🔧 使用统一的JSON解析工具
      let replyData = APIUtils.parseJSONResponse(aiResponseContent); // 🔧 使用统一的后处理工具
      replyData = await APIUtils.postProcessData(replyData, userXProfileInfo); // 统一数据处理
      const timestamp = Date.now();
      const repliesKey =
        commentType === "reply_comment" && pageType === "main"
          ? "replies"
          : "comments";
      const replies = replyData[repliesKey] || [];
      if (!Array.isArray(replies)) {
        throw new Error("AI返回的数据格式不正确");
      }
      // 根据页面类型和评论类型处理渲染
      if (pageType === "detail") {
        console.log(
          "🤖 [AI回复] 详情页模式 - 生成了",
          replies.length,
          "条回复"
        ); // 详情页面：先更新数据，再渲染到页面
        // 将AI回复添加到推文数据中
        let tweetTimestamp =
          tweetData.timestamp || tweetData.createdAt || Date.now(); // 确保时间戳是数字格式（处理可能的Date对象或字符串）
        if (typeof tweetTimestamp !== "number") {
          if (tweetTimestamp instanceof Date) {
            tweetTimestamp = tweetTimestamp.getTime();
          } else if (typeof tweetTimestamp === "string") {
            tweetTimestamp = new Date(tweetTimestamp).getTime();
          } else {
            tweetTimestamp = Date.now();
          }
        }
        // 验证推文时间戳有效性
        if (isNaN(tweetTimestamp) || tweetTimestamp <= 0) {
          console.warn("⚠️ [AI回复] 推文时间戳无效，使用当前时间");
          tweetTimestamp = Date.now();
        }
        if (commentType === "main_comment") {
          // 主评论回复
          replies.forEach((comment, index) => {
            comment.id = `ai_unified_${timestamp}_${index}`; // 转换timeOffset为实际时间戳
            if (
              comment.timeOffset !== undefined &&
              !isNaN(comment.timeOffset)
            ) {
              comment.timestamp =
                tweetTimestamp + Math.abs(comment.timeOffset) * 60 * 1000;
              delete comment.timeOffset;
            } else if (!comment.timestamp || isNaN(comment.timestamp)) {
              comment.timestamp =
                tweetTimestamp + (2 + Math.random() * 20) * 60 * 1000;
            }
            // 最终验证
            if (isNaN(comment.timestamp) || comment.timestamp <= 0) {
              console.warn("⚠️ [AI回复] 评论时间戳无效，使用推文时间");
              comment.timestamp = tweetTimestamp;
            }
            tweetData.comments.push(comment);
          });
          tweetData.stats.comments += replies.length;
          console.log(
            "🤖 [AI回复] AI回复已添加到推文数据，新评论总数:",
            tweetData.stats.comments
          );
        } else if (commentType === "reply_comment" && parentComment) {
          // 楼中楼回复
          const targetComment = tweetData.comments.find(
            (c) => c.id === parentComment.id
          );
          if (targetComment) {
            if (!targetComment.replies) targetComment.replies = [];
            replies.forEach((reply, index) => {
              reply.id = `ai_unified_${timestamp}_${index}`; // 转换timeOffset为实际时间戳
              if (reply.timeOffset !== undefined && !isNaN(reply.timeOffset)) {
                reply.timestamp =
                  tweetTimestamp + Math.abs(reply.timeOffset) * 60 * 1000;
                delete reply.timeOffset;
              } else if (!reply.timestamp || isNaN(reply.timestamp)) {
                // 回复时间应该比父评论晚
                let parentTimestamp =
                  targetComment.timestamp ||
                  targetComment.createdAt ||
                  tweetTimestamp; // 确保 parentTimestamp 是数字
                if (typeof parentTimestamp !== "number") {
                  parentTimestamp =
                    parentTimestamp instanceof Date
                      ? parentTimestamp.getTime()
                      : typeof parentTimestamp === "string"
                      ? new Date(parentTimestamp).getTime()
                      : tweetTimestamp;
                }
                reply.timestamp =
                  parentTimestamp + (1 + Math.random() * 10) * 60 * 1000;
              }
              // 最终验证
              if (isNaN(reply.timestamp) || reply.timestamp <= 0) {
                console.warn("⚠️ [AI回复] 楼中楼回复时间戳无效，使用推文时间");
                reply.timestamp = tweetTimestamp;
              }
              targetComment.replies.push(reply);
            });
            console.log(
              "🤖 [AI回复] 楼中楼回复已添加，目标评论:",
              parentComment.id,
              "，当前回复总数:",
              targetComment.replies.length
            );
          } else {
            console.error("❌ [AI回复] 未找到目标评论:", parentComment.id);
          }
        }
        // 保存到数据库
        try {
          const xDb = getXDB();
          const isUserTweet = tweetData.id.startsWith("user_");
          const isAccountTweet = tweetData._source === "account";
          const isRetweetMention = tweetData._source === "retweet_mention";
          const isNewTweetMention = tweetData._source === "newtweet_mention";
          if (isRetweetMention) {
            console.log("🤖 [AI回复] 保存到 Mentions 转帖通知数据");
            const mentionsId = `mentions_${currentAccountId || "main"}`;
            const mentionsData = await xDb.xAccountProfiles.get(mentionsId);
            if (mentionsData && mentionsData.data) {
              // 找到对应的转帖通知并更新其评论
              const retweetIndex = mentionsData.data.findIndex(
                (m) => m.id === tweetData.id && m.type === "retweet"
              );
              if (retweetIndex !== -1) {
                // 更新评论数据
                mentionsData.data[retweetIndex].comments = tweetData.comments; // 同步更新 stats
                if (!mentionsData.data[retweetIndex].stats) {
                  mentionsData.data[retweetIndex].stats = tweetData.stats;
                } else {
                  mentionsData.data[retweetIndex].stats.comments =
                    tweetData.stats.comments;
                }
                await xDb.xAccountProfiles.put(mentionsData);
                console.log(
                  "✅ [AI回复] Mentions 转帖通知已更新，评论总数:",
                  tweetData.comments.length
                );
              } else {
                console.warn(
                  "⚠️ [AI回复] 未在 Mentions 数据中找到对应的转帖通知:",
                  tweetData.id
                );
              }
            } else {
              console.warn("⚠️ [AI回复] 未找到 Mentions 数据:", mentionsId);
            }
          } else if (isNewTweetMention) {
            console.log("🤖 [AI回复] 保存到 Mentions New Tweet 通知数据");
            const mentionsId = `mentions_${currentAccountId || "main"}`;
            const mentionsData = await xDb.xAccountProfiles.get(mentionsId);
            if (mentionsData && mentionsData.data) {
              // 找到对应的 New Tweet 通知并更新其推文评论
              const newTweetIndex = mentionsData.data.findIndex(
                (m) => m.id === tweetData._mentionId && m.type === "newTweet"
              );
              if (newTweetIndex !== -1) {
                // 更新推文的评论数据
                if (!mentionsData.data[newTweetIndex].tweet) {
                  mentionsData.data[newTweetIndex].tweet = {};
                }
                mentionsData.data[newTweetIndex].tweet.comments =
                  tweetData.comments; // 同步更新 stats
                if (!mentionsData.data[newTweetIndex].tweet.stats) {
                  mentionsData.data[newTweetIndex].tweet.stats =
                    tweetData.stats;
                } else {
                  mentionsData.data[newTweetIndex].tweet.stats.comments =
                    tweetData.stats.comments;
                }
                await xDb.xAccountProfiles.put(mentionsData);
                console.log(
                  "✅ [AI回复] Mentions New Tweet 通知已更新，评论总数:",
                  tweetData.comments.length
                );
              } else {
                console.warn(
                  "⚠️ [AI回复] 未在 Mentions 数据中找到对应的 New Tweet 通知:",
                  tweetData._mentionId
                );
              }
            } else {
              console.warn("⚠️ [AI回复] 未找到 Mentions 数据:", mentionsId);
            }
          } else if (isAccountTweet) {
            console.log("🤖 [AI回复] 保存到账户推文数据");
            const accountHandle =
              tweetData._accountHandle ||
              (currentViewingAccount.accountInfo || currentViewingAccount)
                .handle;
            const cleanHandle = accountHandle.replace("@", "");
            if (currentViewingAccount && currentViewingAccount.tweets) {
              const tweetIndex = currentViewingAccount.tweets.findIndex(
                (t) => t.id === tweetData.id
              );
              if (tweetIndex !== -1) {
                currentViewingAccount.tweets[tweetIndex] = tweetData;
                await xDb.xAccountProfiles.put({
                  handle: cleanHandle,
                  name: (
                    currentViewingAccount.accountInfo || currentViewingAccount
                  ).name,
                  accountInfo:
                    currentViewingAccount.accountInfo || currentViewingAccount,
                  tweets: currentViewingAccount.tweets,
                  accountReplies: currentViewingAccount.accountReplies || [],
                  updatedAt: new Date().toISOString(),
                });
                console.log("✅ [AI回复] 账户推文已保存，账户:", cleanHandle);
              }
            }
          } else if (isUserTweet) {
            console.log("🤖 [AI回复] 保存到用户推文数据");
            const userTweetsId = `userTweets_${currentAccountId || "main"}`;
            const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
            if (userTweetsData && userTweetsData.tweets) {
              const tweetIndex = userTweetsData.tweets.findIndex(
                (t) => t.id === tweetData.id
              );
              if (tweetIndex !== -1) {
                userTweetsData.tweets[tweetIndex] = tweetData;
                await xDb.xUserTweets.put(userTweetsData);
                console.log(
                  "✅ [AI回复] 用户推文AI回复已保存，评论总数:",
                  tweetData.comments.length,
                  "，主评论",
                  tweetData.comments.length,
                  "条"
                );
              } else {
                console.error("❌ [AI回复] 未在数据库中找到目标推文");
              }
            }
          } else {
            console.log("🤖 [AI回复] 保存到主页推文数据");
            const tweetsData = await xDb.xTweetsData.get("tweets");
            if (tweetsData) {
              let updated = false;
              if (tweetsData.forYouTweets) {
                const index = tweetsData.forYouTweets.findIndex(
                  (t) => t.id === tweetData.id
                );
                if (index !== -1) {
                  tweetsData.forYouTweets[index] = tweetData;
                  updated = true;
                }
              }
              if (tweetsData.followingTweets && !updated) {
                const index = tweetsData.followingTweets.findIndex(
                  (t) => t.id === tweetData.id
                );
                if (index !== -1) {
                  tweetsData.followingTweets[index] = tweetData;
                  updated = true;
                }
              }
              if (updated) {
                await xDb.xTweetsData.put(tweetsData);
                console.log(
                  "✅ [AI回复] 主页推文AI回复已保存，评论总数:",
                  tweetData.comments.length,
                  "，主评论",
                  tweetData.comments.length,
                  "条"
                );
              } else {
                console.error("❌ [AI回复] 未在数据库中找到目标推文");
              }
            }
          }
          // 更新 sessionStorage
          sessionStorage.setItem("currentTweetData", JSON.stringify(tweetData));
          console.log("✅ [AI回复] sessionStorage 已更新");
        } catch (saveError) {
          console.error("❌ [AI回复] 保存AI回复到数据库失败:", saveError);
        }
        // 渲染到页面
        replies.forEach((comment, index) => {
          const commentElement = createCommentElement(
            comment,
            commentType === "reply_comment"
          );
          const commentsContainer = document.getElementById(
            "detail-comments-container"
          );
          if (commentType === "reply_comment" && parentComment) {
            // 对于楼中楼回复，找到被回复评论的位置，插入为平级
            const allComments =
              commentsContainer.querySelectorAll(".comment-item");
            let insertPosition = null;
            let insertAfter = null; // 找到被回复评论的位置
            allComments.forEach((commentEl) => {
              if (commentEl.dataset.commentId === parentComment.id) {
                insertPosition = commentEl; // 如果被回复的是楼中楼评论，找到这个评论组的最后一个评论
                if (commentEl.classList.contains("reply-item")) {
                  let nextSibling = commentEl.nextElementSibling;
                  insertAfter = commentEl; // 找到当前评论组的最后一条评论
                  while (
                    nextSibling &&
                    nextSibling.classList.contains("reply-item")
                  ) {
                    insertAfter = nextSibling;
                    nextSibling = nextSibling.nextElementSibling;
                  }
                } else {
                  // 如果被回复的是主评论，找到这个评论组的最后一条评论（包括所有楼中楼）
                  let nextSibling = commentEl.nextElementSibling;
                  insertAfter = commentEl;
                  while (
                    nextSibling &&
                    nextSibling.classList.contains("reply-item")
                  ) {
                    insertAfter = nextSibling;
                    nextSibling = nextSibling.nextElementSibling;
                  }
                }
              }
            });
            if (insertAfter) {
              // 插入到评论组的最后位置
              if (insertAfter.nextSibling) {
                insertAfter.parentNode.insertBefore(
                  commentElement,
                  insertAfter.nextSibling
                );
              } else {
                insertAfter.parentNode.appendChild(commentElement);
              }
            } else {
              // 如果没找到位置，就添加到末尾
              commentsContainer.appendChild(commentElement);
            }
          } else {
            // 主评论回复或找不到特定位置时，添加到末尾
            commentsContainer.appendChild(commentElement);
          }
        });
        console.log("✅ [AI回复] AI回复已渲染到页面"); // 更新回复输入框头像
        const replyUserAvatars =
          document.querySelectorAll(".reply-user-avatar");
        replyUserAvatars.forEach((avatar) => {
          avatar.src = userProfileData.avatar;
        });
      } else {
        // 主页：更新数据并重新渲染
        console.log("🤖 [AI回复] 主页模式 - 开始处理");
        let tweetTimestamp =
          tweetData.timestamp || tweetData.createdAt || Date.now(); // 确保时间戳是数字格式（处理可能的Date对象或字符串）
        if (typeof tweetTimestamp !== "number") {
          if (tweetTimestamp instanceof Date) {
            tweetTimestamp = tweetTimestamp.getTime();
          } else if (typeof tweetTimestamp === "string") {
            tweetTimestamp = new Date(tweetTimestamp).getTime();
          } else {
            tweetTimestamp = Date.now();
          }
        }
        // 验证推文时间戳有效性
        if (isNaN(tweetTimestamp) || tweetTimestamp <= 0) {
          console.warn("⚠️ [AI回复] 主页模式：推文时间戳无效，使用当前时间");
          tweetTimestamp = Date.now();
        }
        if (commentType === "main_comment") {
          // 主评论：添加到推文评论列表
          replies.forEach((comment, index) => {
            comment.id = `ai_main_unified_${timestamp}_${index}`; // 转换timeOffset为实际时间戳
            if (
              comment.timeOffset !== undefined &&
              !isNaN(comment.timeOffset)
            ) {
              comment.timestamp =
                tweetTimestamp + Math.abs(comment.timeOffset) * 60 * 1000;
              delete comment.timeOffset;
            } else if (!comment.timestamp || isNaN(comment.timestamp)) {
              comment.timestamp =
                tweetTimestamp + (2 + Math.random() * 20) * 60 * 1000;
            }
            // 最终验证
            if (isNaN(comment.timestamp) || comment.timestamp <= 0) {
              console.warn(
                "⚠️ [AI回复] 主页模式：评论时间戳无效，使用推文时间"
              );
              comment.timestamp = tweetTimestamp;
            }
            tweetData.comments.push(comment);
          });
          tweetData.stats.comments += replies.length;
          console.log(
            "🤖 [AI回复] 已添加主评论，新增:",
            replies.length,
            "条，总计:",
            tweetData.comments.length
          );
        } else {
          // 楼中楼回复：添加到主评论的replies（平级显示）
          const targetCommentId = mainCommentId || parentComment.id;
          const mainCommentObj = tweetData.comments.find(
            (c) => c.id === targetCommentId
          );
          if (mainCommentObj) {
            replies.forEach((reply, index) => {
              reply.id = `ai_main_sub_unified_${timestamp}_${index}`; // 转换timeOffset为实际时间戳
              if (reply.timeOffset !== undefined && !isNaN(reply.timeOffset)) {
                reply.timestamp =
                  tweetTimestamp + Math.abs(reply.timeOffset) * 60 * 1000;
                delete reply.timeOffset;
              } else if (!reply.timestamp || isNaN(reply.timestamp)) {
                let parentTimestamp =
                  mainCommentObj.timestamp ||
                  mainCommentObj.createdAt ||
                  tweetTimestamp; // 确保 parentTimestamp 是数字
                if (typeof parentTimestamp !== "number") {
                  parentTimestamp =
                    parentTimestamp instanceof Date
                      ? parentTimestamp.getTime()
                      : typeof parentTimestamp === "string"
                      ? new Date(parentTimestamp).getTime()
                      : tweetTimestamp;
                }
                reply.timestamp =
                  parentTimestamp + (1 + Math.random() * 10) * 60 * 1000;
              }
              // 最终验证
              if (isNaN(reply.timestamp) || reply.timestamp <= 0) {
                console.warn(
                  "⚠️ [AI回复] 主页模式：楼中楼回复时间戳无效，使用推文时间"
                );
                reply.timestamp = tweetTimestamp;
              }
              if (!mainCommentObj.replies) mainCommentObj.replies = [];
              mainCommentObj.replies.push(reply);
            });
            console.log(
              "🤖 [AI回复] 已添加楼中楼回复到主评论:",
              targetCommentId,
              "，新增:",
              replies.length,
              "条"
            );
          } else {
            console.warn(
              "⚠️ [AI回复] 无法找到主评论，mainCommentId:",
              targetCommentId
            );
          }
        }
        // 保存数据并重新渲染
        try {
          // 先更新全局数组中的推文数据
          let updated = false;
          const tweetIndex = forYouTweets.findIndex(
            (t) => t.id === tweetData.id
          );
          if (tweetIndex !== -1) {
            forYouTweets[tweetIndex] = tweetData;
            updated = true;
            console.log("🤖 [AI回复] 已更新forYouTweets中的推文");
          } else {
            const followingIndex = followingTweets.findIndex(
              (t) => t.id === tweetData.id
            );
            if (followingIndex !== -1) {
              followingTweets[followingIndex] = tweetData;
              updated = true;
              console.log("🤖 [AI回复] 已更新followingTweets中的推文");
            }
          }
          if (!updated) {
            console.warn("⚠️ [AI回复] 未在全局数组中找到推文:", tweetData.id);
          }
          // 保存到数据库
          const existingData = await xDb.xTweetsData.get("tweets");
          if (existingData) {
            existingData.forYouTweets = forYouTweets;
            existingData.followingTweets = followingTweets;
            existingData.lastUpdated = new Date().toISOString();
            await xDb.xTweetsData.put(existingData);
            console.log("✅ [AI回复] 数据已保存到数据库");
          } else {
            await xDb.xTweetsData.put({
              id: "tweets",
              forYouTweets: forYouTweets,
              followingTweets: followingTweets,
              lastUpdated: new Date().toISOString(),
            });
            console.log("✅ [AI回复] 数据已创建并保存");
          }
        } catch (saveError) {
          console.error("❌ [AI回复] 保存统一AI回复数据失败:", saveError);
        }
        // 重新渲染评论区
        console.log("🤖 [AI回复] 开始重新渲染评论区，推文ID:", currentTweetId);
        renderComments(currentTweetId); // 滚动到底部
        const commentsContainer = document.querySelector(".comments-container");
        setTimeout(() => {
          if (commentsContainer) {
            commentsContainer.scrollTop = commentsContainer.scrollHeight;
            console.log("✅ [AI回复] 评论区已滚动到底部");
          }
        }, 100);
      }
      // 显示手机样式通知
      const isEnglish = currentLanguage === "en";
      const userAvatar =
        window.userProfileData?.avatar ||
        "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg";
      showPhoneNotification({
        title: "X",
        message: isEnglish
          ? "Your comment received a reply!"
          : "你的评论已经收到回复！",
        avatar: userAvatar,
        leftIcon: "x",
      }); // 🔓 检测拉黑解除触发（如果用户评论了某人的推文）
      if (
        tweetData &&
        tweetData.user &&
        tweetData.user.handle &&
        userComment &&
        userComment.user &&
        userComment.user.handle
      ) {
        const userHandle = userComment.user.handle; // 用户的句柄
        const tweetAuthorHandle = tweetData.user.handle; // 推文作者的句柄
        const commentContent = userComment.content; // 评论内容
        // 异步检测拉黑解除
        checkUnblockTrigger(
          userHandle,
          tweetAuthorHandle,
          "comment",
          commentContent
        ).catch((err) => {
          console.error("拉黑解除检测失败（静默）:", err);
        });
      }
    } catch (error) {
      console.error("生成统一AI回复失败:", error);
      showXToast(`回复生成失败: ${error.message}`, "error");
    }
  }
  // 注意：已删除重复的API辅助函数定义，使用文件开头的健壮版本
  // ▲▲▲ 【主要！！！】第三个情景：统一AI回复生成器 ▲▲▲
  // ▲▲▲！！！三个情景综合如上！！！▲▲▲
  //▼▼▼ 引用转发功能JavaScript▼▼▼
  // 全局变量存储当前引用内容
  let currentQuoteData = null; // 处理账户主页推文的引用转发
  window.handleQuoteRetweetFromAccountTweet = async function (tweetId) {
    if (!currentViewingAccount || !currentViewingAccount.tweets) {
      showXToast("无法找到推文数据", "error");
      return;
    }
    // 从当前查看的账户数据中查找推文
    const tweet = currentViewingAccount.tweets.find((t) => t.id === tweetId);
    if (!tweet) {
      showXToast("未找到该推文", "error");
      return;
    }
    // 处理图片数据（从media字段转换为image格式）
    let imageData = null;
    if (tweet.media && tweet.media.length > 0) {
      if (tweet.media[0].type === "description") {
        imageData = {
          type: "description",
          content: tweet.media[0].description,
        };
      }
    } else if (tweet.image) {
      // 兼容已有的image字段格式
      imageData = tweet.image;
    }
    // 调用引用处理函数
    handleQuoteRetweet(
      "tweet",
      tweet.id,
      tweet.user.name,
      tweet.user.handle,
      tweet.user.avatar,
      tweet.user.verified,
      tweet.content || "",
      tweet.time,
      imageData,
      null, // 账户推文暂不支持链接
      null // 账户推文暂不支持位置
    );
  }; // 从数据源获取引用信息并处理转发
  async function handleQuoteRetweetFromData(type, id) {
    let sourceData = null;
    if (type === "tweet") {
      // 从主页推文数据中查找
      const allTweets = [...forYouTweets, ...followingTweets];
      sourceData = allTweets.find((tweet) => tweet.id === id); // 如果在主页没找到，查找用户推文
      if (!sourceData) {
        try {
          const db = getXDB(); // 🔧 多账户隔离：使用账户ID
          const userTweetsId = `userTweets_${currentAccountId || "main"}`;
          const userTweets = await db.xUserTweets.get(userTweetsId);
          if (userTweets && userTweets.tweets) {
            sourceData = userTweets.tweets.find((tweet) => tweet.id === id);
          }
        } catch (error) {
          console.error("查找用户推文失败:", error);
        }
      }
      // 如果还没找到，尝试从详情页当前推文中查找
      if (!sourceData) {
        const currentTweetData = sessionStorage.getItem("currentTweetData");
        if (currentTweetData) {
          try {
            const tweetData = JSON.parse(currentTweetData);
            if (tweetData.id === id) {
              sourceData = tweetData;
            }
          } catch (error) {
            console.error("解析详情页推文数据失败:", error);
          }
        }
      }
    } else if (type === "comment") {
      // 从评论数据中查找
      sourceData = await findCommentById(id);
    }
    if (!sourceData) {
      showXToast("无法找到要引用的内容", "error");
      return;
    }
    // 处理图片数据（从media字段转换为image格式）
    let imageData = null;
    if (sourceData.media && sourceData.media.length > 0) {
      // AI生成的推文使用media数组，第一个元素包含图片信息
      if (sourceData.media[0].type === "description") {
        // 图片描述类型（AI生成的文字描述）
        imageData = {
          type: "description",
          content: sourceData.media[0].description,
        };
      } else if (sourceData.media[0].type === "image") {
        // 实际图片类型（虽然目前不常用，但保持兼容）
        imageData = {
          type: "description",
          content: sourceData.media[0].description,
        };
      }
    } else if (sourceData.image) {
      // 兼容已有的image字段格式（用户上传的图片）
      imageData = sourceData.image;
    }
    // 调用引用处理函数
    handleQuoteRetweet(
      type,
      id,
      sourceData.user.name,
      sourceData.user.handle,
      sourceData.user.avatar,
      sourceData.user.verified,
      sourceData.content || "",
      sourceData.time,
      imageData, // 传递图片数据
      sourceData.link || null, // 传递链接数据
      sourceData.location || null // 传递位置数据
    );
  }
  // 根据ID查找评论 - 修复楼中楼查找逻辑
  async function findCommentById(commentId) {
    // 首先尝试直接从DOM中找到对应的评论元素并提取数据
    // 这样可以确保引用的是用户实际点击的评论，避免数据结构和DOM结构不匹配
    const commentElement = document.querySelector(
      `[data-comment-id="${commentId}"]`
    );
    if (commentElement) {
      try {
        const userName =
          commentElement.querySelector(".tweet-user-name").textContent;
        const userHandle =
          commentElement.querySelector(".tweet-user-handle").textContent;
        const userAvatar = commentElement.querySelector(".tweet-avatar").src;
        const verified =
          commentElement.querySelector(".tweet-verified") !== null;
        const contentElement = commentElement.querySelector(".comment-content"); // 获取评论内容，过滤掉回复标记
        let content = "";
        if (contentElement) {
          // 克隆节点以避免修改原DOM
          const contentClone = contentElement.cloneNode(true); // 移除回复标记
          const replyTo = contentClone.querySelector(".reply-to");
          if (replyTo) {
            replyTo.remove();
          }
          content = contentClone.textContent.trim();
        }
        const timeElement = commentElement.querySelector(".tweet-time");
        const time = timeElement
          ? timeElement.textContent.replace("·", "").trim()
          : "刚刚";
        return {
          id: commentId,
          user: {
            name: userName,
            handle: userHandle,
            avatar: userAvatar,
            verified: verified,
          },
          content: content,
          time: time,
        };
      } catch (error) {
        console.error("从DOM提取评论信息失败:", error);
      }
    }
    // 如果从DOM提取失败，回退到数据查找
    // 在主页推文中查找
    const allTweets = [...forYouTweets, ...followingTweets];
    for (const tweet of allTweets) {
      if (tweet.comments) {
        for (const comment of tweet.comments) {
          if (comment.id === commentId) {
            return comment;
          }
          // 检查回复
          if (comment.replies) {
            for (const reply of comment.replies) {
              if (reply.id === commentId) {
                return reply;
              }
            }
          }
        }
      }
    }
    // 在详情页面当前推文中查找
    const currentTweetData = sessionStorage.getItem("currentTweetData");
    if (currentTweetData) {
      const tweetData = ValidationUtils.safeParseJSON(currentTweetData);
      if (tweetData && tweetData.comments) {
        for (const comment of tweetData.comments) {
          if (comment.id === commentId) {
            return comment;
          }
          // 检查回复
          if (comment.replies) {
            for (const reply of comment.replies) {
              if (reply.id === commentId) {
                return reply;
              }
            }
          }
        }
      }
    }
    // 在用户推文中查找
    try {
      const db = getXDB();
      const userTweets = await db.xUserTweets.get("userTweets");
      if (userTweets && userTweets.tweets) {
        for (const tweet of userTweets.tweets) {
          if (tweet.comments) {
            for (const comment of tweet.comments) {
              if (comment.id === commentId) {
                return comment;
              }
              // 检查回复
              if (comment.replies) {
                for (const reply of comment.replies) {
                  if (reply.id === commentId) {
                    return reply;
                  }
                }
              }
            }
          }
        }
      }
    } catch (error) {
      ValidationUtils.handleError(error, "查找用户推文评论");
    }
    return null;
  }
  // 处理引用转发
  function handleQuoteRetweet(
    type,
    id,
    userName,
    userHandle,
    userAvatar,
    verified,
    content,
    time,
    imageData = null,
    linkData = null,
    location = null
  ) {
    // 打开发帖弹窗
    openComposeTweetModal(); // 存储引用数据
    currentQuoteData = {
      type: type, // 'tweet' 或 'comment'
      id: id,
      user: {
        name: userName,
        handle: userHandle,
        avatar: userAvatar,
        verified: verified,
      },
      content: content,
      time: time,
      image: imageData, // 图片数据
      link: linkData, // 链接数据
      location: location, // 位置数据
    }; // 显示引用内容预览
    showQuotePreview(); // 更新文本输入框占位符
    const textInput = document.getElementById("compose-text-input");
    if (textInput) {
      textInput.placeholder =
        type === "tweet"
          ? "添加你的评论来引用这条推文"
          : "添加你的评论来引用这条评论";
      textInput.focus();
    }
  }
  // 显示引用内容预览
  function showQuotePreview() {
    if (!currentQuoteData) return;
    const preview = document.getElementById("quote-content-preview");
    const typeText = document.getElementById("quote-type-text");
    const userAvatar = document.getElementById("quote-user-avatar");
    const userName = document.getElementById("quote-user-name");
    const userVerified = document.getElementById("quote-user-verified");
    const userHandle = document.getElementById("quote-user-handle");
    const userTime = document.getElementById("quote-user-time");
    const contentText = document.getElementById("quote-content-text");
    if (!preview) return; // 显示预览区域
    preview.style.display = "block"; // 设置引用类型
    if (typeText) {
      typeText.textContent =
        currentQuoteData.type === "tweet" ? "引用推文" : "引用评论";
    }
    // 设置用户信息
    if (userAvatar) userAvatar.src = currentQuoteData.user.avatar;
    if (userName) userName.textContent = currentQuoteData.user.name;
    if (userHandle) userHandle.textContent = currentQuoteData.user.handle;
    if (userTime) userTime.textContent = "·" + currentQuoteData.time; // 显示/隐藏认证图标
    if (userVerified) {
      userVerified.style.display = currentQuoteData.user.verified
        ? "inline"
        : "none";
    }
    // 设置内容
    if (contentText) {
      // 处理内容中的HTML转义
      const processedContent = currentQuoteData.content
        .replace(/&quot;/g, '"')
        .replace(/&#x27;/g, "'")
        .replace(/&amp;/g, "&");
      contentText.textContent = processedContent;
    }
    // 处理图片内容（支持多图）
    const imageContainer = document.getElementById("quote-image-container");
    if (imageContainer) {
      if (currentQuoteData.image) {
        imageContainer.style.display = "block"; // 文字描述类型
        if (currentQuoteData.image.type === "description") {
          imageContainer.innerHTML = `
 <div style="margin-top: 8px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 8px; box-sizing: border-box;">
 <div style="color:var(--x-text-primary); font-size: 13px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${currentQuoteData.image.content}</div>
 </div>
 `;
        }
        // 单图上传
        else if (currentQuoteData.image.type === "upload") {
          imageContainer.innerHTML = `
 <div style="margin-top: 8px; border-radius: 8px; overflow: hidden;">
 <img src="${currentQuoteData.image.content}" style="width: 100%; max-height: 120px; object-fit: cover; display: block;" alt="引用图片">
 </div>
 `;
        }
        // 多图上传
        else if (
          currentQuoteData.image.type === "uploads" &&
          currentQuoteData.image.images &&
          currentQuoteData.image.images.length > 0
        ) {
          const imageCount = currentQuoteData.image.images.length;
          let gridTemplate =
            imageCount <= 2
              ? "grid-template-columns: repeat(2, 1fr);"
              : "grid-template-columns: repeat(2, 1fr);";
          const imagesHtml = currentQuoteData.image.images
            .map((img, index) => {
              return `
 <div style="border-radius: 6px; overflow: hidden;">
 <img src="${
   img.content
 }" style="width: 100%; height: 80px; object-fit: cover; display: block;" alt="引用图片${
                index + 1
              }">
 </div>
 `;
            })
            .join("");
          imageContainer.innerHTML = `
 <div style="margin-top: 8px; display: grid; ${gridTemplate} gap: 4px;">
 ${imagesHtml}
 </div>
 `;
        }
      } else {
        imageContainer.style.display = "none";
        imageContainer.innerHTML = "";
      }
    }
  }
  // 移除引用内容
  function removeQuoteContent() {
    currentQuoteData = null;
    const preview = document.getElementById("quote-content-preview");
    if (preview) {
      preview.style.display = "none";
    }
    // 清理图片容器
    const imageContainer = document.getElementById("quote-image-container");
    if (imageContainer) {
      imageContainer.style.display = "none";
      imageContainer.innerHTML = "";
    }
    // 恢复原始占位符
    const textInput = document.getElementById("compose-text-input");
    if (textInput) {
      textInput.placeholder = "有什么新鲜事？";
    }
  }
  // ▲▲▲ 引用转发功能JavaScript ▲▲▲

  // ============================================
  // 推文详情页评论表情包功能
  // ============================================

  // 评论模式标识变量
  let isCommentStickerMode = false;
  let selectedCommentSticker = null;

  // 将变量暴露到全局以便其他模块访问
  window.isCommentStickerMode = isCommentStickerMode;

  // 暴露获取和设置isCommentStickerMode的函数
  window.getCommentStickerMode = () => isCommentStickerMode;
  window.setCommentStickerMode = (value) => {
    isCommentStickerMode = value;
    window.isCommentStickerMode = value;
  };

  // 暴露获取和设置selectedCommentSticker的函数
  window.getSelectedCommentSticker = () => selectedCommentSticker;
  window.setSelectedCommentSticker = (value) => {
    selectedCommentSticker = value;
  };

  // 重置选中的评论表情包
  window.resetSelectedCommentSticker = () => {
    selectedCommentSticker = null;
  };

  // 打开评论表情包选择器 (已移动到全局作用域)

  // 为评论选择表情包
  window.selectCommentSticker = function (sticker) {
    if (!window.getCommentStickerMode()) return;

    // 保存选中的表情包
    selectedCommentSticker = sticker;

    // 更新使用统计
    if (window.userStickers && Array.isArray(window.userStickers)) {
      const stickerIndex = window.userStickers.findIndex(
        (s) => s.url === sticker.url && s.description === sticker.description
      );

      if (stickerIndex !== -1) {
        window.userStickers[stickerIndex].useCount =
          (window.userStickers[stickerIndex].useCount || 0) + 1;
        window.userStickers[stickerIndex].lastUsedAt = new Date().toISOString();

        // 保存使用统计
        if (window.saveUserStickers) {
          window.saveUserStickers();
        }
      }
    }

    // 显示表情包预览
    showCommentStickerPreview(sticker);

    // 关闭选择器
    if (window.closeStickerPicker) {
      window.closeStickerPicker();
    }

    // 重置模式标识
    window.setCommentStickerMode(false);
  };

  // 显示评论表情包预览
  function showCommentStickerPreview(sticker) {
    const inputArea = document.querySelector(".detail-comment-input-area");
    if (!inputArea) return;

    // 移除现有预览
    removeCommentStickerPreview();

    // 创建预览容器
    const previewContainer = document.createElement("div");
    previewContainer.id = "comment-sticker-preview";
    previewContainer.style.cssText = `
      margin-top: 10px;
      padding: 12px;
      background-color: var(--x-bg-secondary);
      border: 1px solid var(--x-border-color);
      border-radius: 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      position: relative;
    `;

    // 表情包图片
    const stickerImg = document.createElement("img");
    stickerImg.src = sticker.url;
    stickerImg.alt = sticker.description;
    stickerImg.style.cssText = `
      width: 60px;
      height: 60px;
      object-fit: contain;
      border-radius: 8px;
    `;

    // 表情包描述
    const stickerInfo = document.createElement("div");
    stickerInfo.style.cssText = `
      flex: 1;
      color: var(--x-text-primary);
    `;
    stickerInfo.innerHTML = `
      <div style="font-size: 13px; font-weight: 600; margin-bottom: 2px;">选中的表情包</div>
      <div style="font-size: 12px; color: var(--x-text-secondary);">${
        sticker.description || "表情包"
      }</div>
    `;

    // 移除按钮
    const removeBtn = document.createElement("button");
    removeBtn.innerHTML = `
      <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;">
        <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
      </svg>
    `;
    removeBtn.style.cssText = `
      background: none;
      border: none;
      color: var(--x-text-secondary);
      cursor: pointer;
      padding: 4px;
      border-radius: 50%;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    `;
    removeBtn.onmouseover = () => {
      removeBtn.style.backgroundColor = "var(--x-bg-hover)";
      removeBtn.style.color = "var(--x-text-primary)";
    };
    removeBtn.onmouseout = () => {
      removeBtn.style.backgroundColor = "transparent";
      removeBtn.style.color = "var(--x-text-secondary)";
    };
    removeBtn.onclick = () => {
      // 用户手动删除表情包预览时，重置选择
      const preview = document.getElementById("comment-sticker-preview");
      if (preview) {
        preview.remove();
      }
      if (window.setSelectedCommentSticker) {
        window.setSelectedCommentSticker(null);
      } else {
        selectedCommentSticker = null;
      }
      updateDetailReplyButtonState();
    };

    // 组装预览
    previewContainer.appendChild(stickerImg);
    previewContainer.appendChild(stickerInfo);
    previewContainer.appendChild(removeBtn);

    // 插入到输入区域
    inputArea.appendChild(previewContainer);

    // 更新回复按钮状态
    updateDetailReplyButtonState();
  }

  // 移除评论表情包预览
  function removeCommentStickerPreview() {
    const preview = document.getElementById("comment-sticker-preview");
    if (preview) {
      preview.remove();
    }
    // 只在用户手动删除时重置表情包选择，不在自动清理时重置
    // selectedCommentSticker = null;  // 移除这行，由其他函数管理
    updateDetailReplyButtonState();
  }

  // 获取评论内容（包括表情包）
  window.getCommentContent = function () {
    const textInput = document.getElementById("detail-comment-input");
    const textContent = textInput ? textInput.value.trim() : "";

    return {
      text: textContent,
      sticker: window.getSelectedCommentSticker
        ? window.getSelectedCommentSticker()
        : selectedCommentSticker,
    };
  };

  // 清理评论输入（在发送评论后调用）
  window.clearCommentInput = function () {
    console.log("📝 [清理调试] 开始清理评论输入");

    const textInput = document.getElementById("detail-comment-input");
    if (textInput) {
      textInput.value = "";
      textInput.style.height = "20px";
    }

    // 清除表情包预览
    const preview = document.getElementById("comment-sticker-preview");
    if (preview) {
      preview.remove();
      console.log("📝 [清理调试] 表情包预览已移除");
    }

    // 重置表情包选择
    if (window.setSelectedCommentSticker) {
      window.setSelectedCommentSticker(null);
      console.log("📝 [清理调试] 表情包选择已重置（通过全局函数）");
    } else {
      selectedCommentSticker = null;
      console.log("📝 [清理调试] 表情包选择已重置（直接赋值）");
    }

    // 清除图片预览
    const imagePreview = document.getElementById(
      "detail-comment-image-preview"
    );
    if (imagePreview) {
      imagePreview.style.display = "none";
    }

    updateDetailReplyButtonState();
    console.log("📝 [清理调试] 评论输入清理完成");
  };

  // 暴露评论表情包函数到全局作用域
  window.openCommentStickers = openCommentStickers;

  // 修改现有的表情包选择逻辑（需要拦截点击事件）
  // 这将在 x-init.js 的表情包渲染代码中处理

  // ▲▲▲ 推文详情页评论表情包功能JavaScript ▲▲▲

  // ============================================
  // 审核页面跳转功能
  // ============================================
  window.openReviewPage = function () {
    // 检测当前语言
    const isEnglish = currentLanguage === "en";

    // 显示确认弹窗
    if (
      confirm(
        isEnglish
          ? "Are you ready to navigate to the Review page?"
          : "是否准备移动到审核页面？"
      )
    ) {
      // 用户确认，跳转到Discord审核页面
      window.open("https://discord.gg/KrVUCGykXp", "_blank");
      console.log("✅ 已打开审核页面");
    } else {
      console.log("❌ 用户取消跳转审核页面");
    }
  };

  // ============================================
  // 答疑页面跳转功能
  // ============================================
  window.openHelpPage = function () {
    // 检测当前语言
    const isEnglish = currentLanguage === "en";

    // 显示确认弹窗
    if (
      confirm(
        isEnglish
          ? "Are you ready to navigate to the Help & FAQ page?"
          : "是否准备移动到答疑页面？"
      )
    ) {
      // 用户确认，跳转到答疑页面
      window.open("https://docs.qq.com/smartsheet/DQkppaVN2enJVSHBq", "_blank");
      console.log("✅ 已打开答疑页面");
    } else {
      console.log("❌ 用户取消跳转答疑页面");
    }
  };

  // ??? ????X??app?JavaScript???? ???
  // ============================================


     /* ==================== 地图约会主题变量 ==================== */
      :root {
        /* 暗色主题（默认） */
        --map-bg-primary: #2a2a2a;
        --map-bg-secondary: #1a1a1a;
        --map-road-main: #3a3a3a;
        --map-road-secondary: #404040;
        --map-building: #353535;
        --map-building-alt: #2f2f2f;
        --map-park: rgba(100,150,100,0.2);
        --map-park-alt: rgba(100,150,100,0.15);
        --map-line: rgba(255,255,255,0.1);
        --map-shadow: rgba(0,0,0,0.3);
        /* 侧边栏主题 */
        --sidebar-bg: #1a1a1a;
        --sidebar-border: #2f3336;
        --sidebar-input-bg: #202327;
        --sidebar-text-primary: #fff;
        --sidebar-text-secondary: #71767b;
        --sidebar-hover: rgba(255,255,255,0.03);
      }
      /* 亮色主题支持 */
      #x-map-container.light-theme {
        --map-bg-primary: #e8e8e8;
        --map-bg-secondary: #f5f5f5;
        --map-road-main: #d0d0d0;
        --map-road-secondary: #e0e0e0;
        --map-building: #fff;
        --map-building-alt: #fafafa;
        --map-park: rgba(180,220,180,0.3);
        --map-park-alt: rgba(180,220,180,0.2);
        --map-line: rgba(255,255,255,0.4);
        --map-shadow: rgba(0,0,0,0.05);
        --sidebar-bg: #fff;
        --sidebar-border: #e0e0e0;
        --sidebar-input-bg: #f5f5f5;
        --sidebar-text-primary: #000;
        --sidebar-text-secondary: #666;
        --sidebar-hover: rgba(0,0,0,0.05);
      }
        
      /* ==================== 🚨 关键修复：主容器高度设置 ==================== */
      #map-dating-container {
        width: 100%;
        height: 100%;
        display: flex;
        position: relative;
        overflow: hidden;
      }
        
      /* ==================== 左侧边栏 ==================== */
      .map-sidebar {
        width: 85%;
        max-width: 360px;
        background: var(--sidebar-bg);
        display: flex;
        flex-direction: column;
        border-right: 1px solid var(--sidebar-border);
        position: fixed;
        top: 0;
        left: 0;
        height: 100%;
        z-index: 100;
        transform: translateX(-100%);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 2px 0 8px rgba(0,0,0,0.3);
      }

      .map-sidebar.show {
        transform: translateX(0);
      }

      .map-header {
        padding: 16px 20px;
        border-bottom: 1px solid var(--sidebar-border);
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .map-header h2 {
        font-size: 20px;
        font-weight: 700;
        color: var(--sidebar-text-primary);
        flex: 1;
      }

      .map-back-btn {
        background: none;
        border: none;
        padding: 8px;
        cursor: pointer;
        border-radius: 50%;
        transition: background-color 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .map-back-btn:hover {
        background-color: rgba(239,243,244,0.1);
      }

      .map-back-btn svg {
        width: 20px;
        height: 20px;
        fill: var(--sidebar-text-primary);
      }

      .map-search-box {
        padding: 12px 16px;
        background: var(--sidebar-bg);
      }

      .map-search-box input {
        width: 100%;
        background: var(--sidebar-input-bg);
        border: none;
        border-radius: 20px;
        padding: 10px 16px;
        color: var(--sidebar-text-primary);
        font-size: 15px;
        outline: none;
      }

      .map-search-box input::placeholder {
        color: var(--sidebar-text-secondary);
      }

      .map-filters {
        padding: 12px 16px;
        display: flex;
        gap: 8px;
        border-bottom: 1px solid var(--sidebar-border);
      }

      .filter-group {
        display: flex;
        gap: 8px;
        flex: 1;
      }

      .filter-select {
        flex: 1;
        background: var(--sidebar-input-bg);
        border: none;
        border-radius: 6px;
        padding: 8px 12px;
        color: var(--sidebar-text-primary);
        font-size: 13px;
        cursor: pointer;
        outline: none;
      }

      .filter-btn {
        background: #1d9bf0;
        border: none;
        border-radius: 6px;
        padding: 8px 16px;
        color: #fff;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .filter-btn:hover {
        background: #1a8cd8;
      }

      .map-user-list {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 8px 0;
        min-height: 0;
        -webkit-overflow-scrolling: touch;
      }

      .map-user-list::-webkit-scrollbar {
        width: 6px;
      }

      .map-user-list::-webkit-scrollbar-track {
        background: transparent;
      }

      .map-user-list::-webkit-scrollbar-thumb {
        background: #3a3a3a;
        border-radius: 3px;
      }

      .map-user-item {
        padding: 12px 16px;
        display: flex;
        align-items: center;
        gap: 12px;
        cursor: pointer;
        transition: background-color 0.2s;
        position: relative;
      }

      .map-user-item:hover {
        background: var(--sidebar-hover);
      }

      .map-user-item.active {
        background: rgba(29,155,240,0.1);
        border-left: 3px solid #1d9bf0;
      }

      .map-user-avatar-container {
        position: relative;
        flex-shrink: 0;
      }

      .map-user-avatar {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        object-fit: cover;
      }

      .map-online-indicator {
        position: absolute;
        bottom: 0;
        right: 0;
        width: 14px;
        height: 14px;
        background: #00ba7c;
        border: 2px solid var(--sidebar-bg);
        border-radius: 50%;
      }

      .map-user-info {
        flex: 1;
        min-width: 0;
      }

      .map-user-name {
        font-size: 15px;
        font-weight: 600;
        color: var(--sidebar-text-primary);
        margin-bottom: 2px;
      }

      .map-user-meta {
        font-size: 13px;
        color: var(--sidebar-text-secondary);
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .map-distance {
        display: flex;
        align-items: center;
        gap: 3px;
      }

      .map-distance svg {
        width: 12px;
        height: 12px;
        fill: var(--sidebar-text-secondary);
      }

      .map-view-icon {
        width: 20px;
        height: 20px;
        fill: var(--sidebar-text-secondary);
        transition: fill 0.2s;
      }

      .map-user-item:hover .map-view-icon {
        fill: #1d9bf0;
      }

      /* 侧边栏遮罩 */
      .map-sidebar-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 99;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s, visibility 0.3s;
      }

      .map-sidebar-overlay.show {
        opacity: 1;
        visibility: visible;
      }

      /* ==================== 右侧地图区域 ==================== */
      .map-area {
        width: 100%;
        height: 100%;
        position: relative;
        background: var(--map-bg-primary);
        overflow: hidden;
      }

      /* 羊图标按钮（咩三三报纸）- 在提醒按钮下方、设置按钮上方 */
      .map-newspaper-btn {
        position: absolute;
        top: 228px; /* 186 + 32 + 10 = 提醒按钮top + 提醒按钮高度 + 间距 */
        left: 20px;
        z-index: 10;
        width: 32px;
        height: 32px;
        background: none;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: opacity 0.15s ease, transform 0.2s ease;
        padding: 0;
      }

      .map-newspaper-btn:hover {
        opacity: 0.7;
      }

      .map-newspaper-btn:active {
        transform: scale(0.95);
      }

      .map-newspaper-btn svg {
        width: 24px;
        height: 24px;
        stroke: #fff;
        filter: drop-shadow(0 1px 3px rgba(0,0,0,0.4));
      }

      /* 关闭按钮 - ins风格简洁设计 */
      .map-close-btn {
        position: absolute;
        top: 60px;
        left: 20px;
        z-index: 10;
        width: 32px;
        height: 32px;
        background: none;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: opacity 0.2s;
        padding: 0;
      }

      .map-close-btn:hover {
        opacity: 0.6;
      }

      .map-close-btn svg {
        width: 24px;
        height: 24px;
        stroke: #fff;
        fill: none;
        stroke-width: 2;
        filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
      }

      /* 刷新按钮 - 在关闭按钮下方 */
      .map-refresh-btn {
        position: absolute;
        top: 102px; /* 60 + 32 + 10 = 关闭按钮top + 关闭按钮高度 + 间距 */
        left: 20px;
        z-index: 10;
        width: 32px;
        height: 32px;
        background: none;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: opacity 0.2s;
        padding: 0;
      }

      .map-refresh-btn:hover {
        opacity: 0.6;
      }

      .map-refresh-btn.refreshing {
        pointer-events: none;
        opacity: 0.5;
      }

      .map-refresh-btn.refreshing svg {
        animation: map-refresh-rotate 1s linear infinite;
      }

      @keyframes map-refresh-rotate {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      .map-refresh-btn svg {
        width: 24px;
        height: 24px;
        fill: #fff;
        filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
      }

      /* 聊天列表按钮样式 */
      .map-chats-btn {
        position: absolute;
        top: 144px; /* 102 + 32 + 10 = 刷新按钮top + 刷新按钮高度 + 间距 */
        left: 20px;
        z-index: 10;
        width: 32px;
        height: 32px;
        background: none;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: opacity 0.2s;
        padding: 0;
      }

      .map-chats-btn:hover {
        opacity: 0.6;
      }

      .map-chats-btn svg {
        width: 24px;
        height: 24px;
        stroke: #fff;
        filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
      }

      /* ==================== 提醒功能 - 黑白灰简约ins风格 ==================== */
      /* 提醒按钮 - 简约设计 */
      .map-notifications-btn {
        position: absolute;
        top: 186px;
        left: 20px;
        z-index: 10;
        width: 32px;
        height: 32px;
        background: none;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: opacity 0.15s ease;
        padding: 0;
      }

      .map-notifications-btn:hover {
        opacity: 0.7;
      }

      .map-notifications-btn:active {
        transform: scale(0.95);
      }

      .map-notifications-btn svg {
        width: 24px;
        height: 24px;
        stroke: #fff;
        fill: none;
        stroke-width: 2;
        filter: drop-shadow(0 1px 3px rgba(0,0,0,0.4));
      }

      /* 未读徽章 - 黑色圆点 */
      .map-notifications-badge {
        position: absolute;
        top: -2px;
        right: -2px;
        min-width: 18px;
        height: 18px;
        background: #000;
        border-radius: 9px;
        border: 2px solid rgba(42, 42, 42, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        font-weight: 700;
        color: #fff;
        padding: 0 4px;
        box-sizing: border-box;
      }

      .map-notifications-badge.hidden {
        display: none;
      }

      /* ==================== 城市乘车按钮 - 简约设计 ==================== */
      .map-ride-btn {
        position: absolute;
        top: 270px; /* 228 + 32 + 10 = 报纸按钮top + 报纸按钮高度 + 间距 */
        left: 20px;
        z-index: 10;
        width: 32px;
        height: 32px;
        background: none;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: opacity 0.15s ease, transform 0.2s ease;
        padding: 0;
      }

      .map-ride-btn:hover {
        opacity: 0.7;
      }

      .map-ride-btn:active {
        transform: scale(0.95);
      }

      .map-ride-btn svg {
        width: 24px;
        height: 24px;
        stroke: #fff;
        fill: none;
        stroke-width: 2;
        filter: drop-shadow(0 1px 3px rgba(0,0,0,0.4));
      }

      /* ==================== 应用设置按钮 - 简约设计 ==================== */
      .map-app-settings-btn {
        position: absolute;
        top: 312px; /* 270 + 32 + 10 = 乘车按钮top + 乘车按钮高度 + 间距 */
        left: 20px;
        z-index: 10;
        width: 32px;
        height: 32px;
        background: none;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: opacity 0.15s ease, transform 0.2s ease;
        padding: 0;
      }

      .map-app-settings-btn:hover {
        opacity: 0.7;
      }

      .map-app-settings-btn:active {
        transform: scale(0.95);
      }

      .map-app-settings-btn svg {
        width: 24px;
        height: 24px;
        stroke: #fff;
        fill: none;
        stroke-width: 2;
        filter: drop-shadow(0 1px 3px rgba(0,0,0,0.4));
      }

      /* 提醒列表弹窗 - Instagram风格 */
      .map-notifications-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.65);
        z-index: 299;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .map-notifications-overlay.show {
        opacity: 1;
        pointer-events: all;
      }

      .map-notifications-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: transparent;
        z-index: 300;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .map-notifications-modal.show {
        opacity: 1;
        pointer-events: all;
      }

      /* 提醒内容容器 - 全新设计 */
      .map-notifications-content {
        width: calc(100% - 40px);
        max-width: 480px;
        max-height: calc(100vh - 80px);
        background: #000;
        border-radius: 24px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        animation: modalSlideUp 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      @keyframes modalSlideUp {
        from {
          opacity: 0;
          transform: translateY(30px) scale(0.9);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      /* 弹窗头部 - 极简设计 */
      .map-notifications-header {
        padding: 24px 20px 16px;
        background: #000;
        border-bottom: none;
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        flex-shrink: 0;
        flex-direction: column;
        gap: 12px;
      }

      .map-notifications-header-top {
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .map-notifications-title {
        font-size: 28px;
        font-weight: 700;
        color: #fff;
        letter-spacing: -0.5px;
      }

      .map-notifications-close-btn {
        width: 36px;
        height: 36px;
        background: #1a1a1a;
        border: none;
        border-radius: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        padding: 0;
      }

      .map-notifications-close-btn:hover {
        background: #2a2a2a;
        transform: scale(1.05);
      }

      .map-notifications-close-btn:active {
        background: #1a1a1a;
        transform: scale(0.95);
      }

      .map-notifications-close-btn svg {
        width: 20px;
        height: 20px;
        stroke: #fff;
        fill: none;
        stroke-width: 2;
        stroke-linecap: round;
      }

      /* 统计卡片 */
      .map-notifications-stats {
        width: 100%;
        background: #1a1a1a;
        border-radius: 14px;
        padding: 14px 18px;
        display: flex;
        align-items: center;
        gap: 14px;
        box-sizing: border-box;
      }

      .map-notifications-stats-icon {
        width: 48px;
        height: 48px;
        background: #fff;
        border-radius: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }

      .map-notifications-stats-icon svg {
        width: 24px;
        height: 24px;
        stroke: #000;
        fill: none;
        stroke-width: 2;
      }

      .map-notifications-stats-info {
        flex: 1;
      }

      .map-notifications-stats-label {
        font-size: 13px;
        color: #8e8e8e;
        font-weight: 500;
        margin-bottom: 4px;
      }

      .map-notifications-stats-count {
        font-size: 24px;
        font-weight: 700;
        color: #fff;
        letter-spacing: -0.5px;
      }

      /* 分类Tab */
      .map-notifications-tabs {
        width: 100%;
        display: flex;
        gap: 8px;
        overflow-x: auto;
        scrollbar-width: none;
        -webkit-overflow-scrolling: touch;
      }

      .map-notifications-tabs::-webkit-scrollbar {
        display: none;
      }

      .map-notifications-tab {
        padding: 8px 16px;
        background: transparent;
        border: 1.5px solid #2a2a2a;
        border-radius: 20px;
        color: #8e8e8e;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
        flex-shrink: 0;
        box-sizing: border-box;
      }

      .map-notifications-tab:hover {
        border-color: #3a3a3a;
        color: #b0b0b0;
      }

      .map-notifications-tab.active {
        background: #fff;
        border-color: #fff;
        color: #000;
      }

      /* 提醒列表容器 - Toast风格 */
      .map-notifications-list-container {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        min-height: 0;
        background: #000;
        padding: 8px 16px 16px;
        -webkit-overflow-scrolling: touch;
      }

      .map-notifications-list-container::-webkit-scrollbar {
        width: 6px;
      }

      .map-notifications-list-container::-webkit-scrollbar-track {
        background: transparent;
      }

      .map-notifications-list-container::-webkit-scrollbar-thumb {
        background: #2a2a2a;
        border-radius: 3px;
      }

      .map-notifications-list-container::-webkit-scrollbar-thumb:hover {
        background: #3a3a3a;
      }

      /* 提醒卡片 - Toast简约风格 */
      .map-notification-item {
        margin-bottom: 8px;
        padding: 14px 16px;
        background: #0a0a0a;
        border: 1px solid #1a1a1a;
        border-radius: 12px;
        display: flex;
        align-items: center;
        gap: 14px;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        box-sizing: border-box;
      }

      .map-notification-item:hover {
        background: #141414;
        border-color: #2a2a2a;
      }

      .map-notification-item:active {
        background: #0a0a0a;
        transform: scale(0.98);
      }

      /* 未读标识 - 左侧色条 */
      .map-notification-item.unread {
        border-left: 3px solid #fff;
        padding-left: 13px;
      }

      /* 通知图标 */
      .map-notification-icon {
        width: 40px;
        height: 40px;
        background: #1a1a1a;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }

      .map-notification-icon svg {
        width: 20px;
        height: 20px;
        stroke: #fff;
        fill: none;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
      }

      /* 提醒信息区域 */
      .map-notification-info {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      /* 顶部：标题 + 时间 */
      .map-notification-header {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 12px;
      }

      .map-notification-title {
        font-size: 15px;
        font-weight: 600;
        color: #fff;
        letter-spacing: -0.2px;
      }

      .map-notification-time {
        font-size: 12px;
        color: #666;
        font-weight: 500;
        white-space: nowrap;
        flex-shrink: 0;
      }

      /* 内容文本 */
      .map-notification-content {
        font-size: 14px;
        color: #999;
        line-height: 1.4;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
        word-wrap: break-word;
      }

      /* 空状态 - 极简设计 */
      .map-notifications-empty {
        text-align: center;
        padding: 80px 32px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        background: #000;
      }

      .map-notifications-empty-icon {
        width: 64px;
        height: 64px;
        margin-bottom: 16px;
        background: #0a0a0a;
        border-radius: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .map-notifications-empty-icon svg {
        width: 32px;
        height: 32px;
        stroke: #333;
        fill: none;
        stroke-width: 2;
      }

      .map-notifications-empty-text {
        font-size: 14px;
        color: #666;
        line-height: 1.5;
        font-weight: 500;
      }

      /* ==================== 城市乘车面板 - 黑白灰简约ins风格 ==================== */
      /* 乘车面板遮罩 */
      .ride-panel-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 249;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .ride-panel-overlay.show {
        opacity: 1;
        pointer-events: all;
      }

      /* 乘车面板主容器 - 半屏抽屉 */
      .ride-panel {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 58vh;
        background: rgba(10, 10, 10, 0.75);
        backdrop-filter: blur(24px) saturate(180%);
        -webkit-backdrop-filter: blur(24px) saturate(180%);
        border-top: 1px solid #2a2a2a;
        box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.6);
        z-index: 250;
        overflow-y: auto;
        overflow-x: hidden;
        clip-path: polygon(0 3%, 3% 0, 97% 0, 100% 3%, 100% 100%, 0 100%);
        transform: translateY(100%);
        transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      .ride-panel.show {
        transform: translateY(0);
      }

      .ride-panel.hide {
        transform: translateY(100%);
      }

      /* 面板拖动手柄 */
      .ride-panel-handle {
        width: 48px;
        height: 5px;
        background: #404040;
        border-radius: 3px;
        margin: 12px auto 0;
      }

      /* 面板内容容器 */
      .ride-panel-content {
        padding: 24px 20px 40px;
        max-width: 640px;
        margin: 0 auto;
      }

      /* 路线信息横幅 */
      .ride-route-banner {
        background: linear-gradient(135deg, #2a2a2a 0%, #666 100%);
        color: #fff;
        padding: 14px 20px;
        border-radius: 10px;
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      }

      .ride-route-banner-left {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .ride-route-icon {
        width: 20px;
        height: 20px;
      }

      .ride-route-text {
        font-size: 13px;
        font-weight: 500;
        letter-spacing: 0.2px;
      }

      .ride-route-time {
        font-size: 18px;
        font-weight: 700;
        font-family: 'SF Mono', 'Monaco', Consolas, monospace;
      }

      /* 位置选择区域 */
      .ride-location-section {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-bottom: 24px;
      }

      .ride-location-box {
        background: #1a1a1a;
        border: 1px solid #2a2a2a;
        border-radius: 10px;
        padding: 14px 16px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        cursor: pointer;
      }

      .ride-location-box:hover {
        background: #252525;
        border-color: #3a3a3a;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .ride-location-box.selecting {
        border-color: #fff;
        background: #252525;
        animation: selectingPulse 1.5s ease-in-out infinite;
      }

      @keyframes selectingPulse {
        0%, 100% {
          border-color: #fff;
        }
        50% {
          border-color: #666;
        }
      }

      .ride-location-label {
        font-size: 10px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #707070;
        margin-bottom: 6px;
      }

      .ride-location-value {
        font-size: 13px;
        font-weight: 500;
        color: #fff;
        line-height: 1.4;
      }

      .ride-location-value.placeholder {
        color: #707070;
        font-style: italic;
      }

      /* 区域标题 */
      .ride-section-title {
        font-size: 17px;
        font-weight: 700;
        letter-spacing: -0.3px;
        color: #fff;
        margin-bottom: 16px;
      }

      /* 车辆选择网格 */
      .ride-vehicles-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 12px;
        margin-bottom: 24px;
      }

      /* 车辆卡片 */
      .ride-vehicle-card {
        background: #1a1a1a;
        border: 2px solid #2a2a2a;
        border-radius: 14px;
        padding: 18px 14px;
        cursor: pointer;
        transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
      }

      .ride-vehicle-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, transparent 0%, #252525 100%);
        opacity: 0;
        transition: opacity 0.35s ease;
      }

      .ride-vehicle-card:hover {
        border-color: #666;
        transform: translateY(-4px) scale(1.02);
        box-shadow: 0 8px 28px rgba(0, 0, 0, 0.5);
      }

      .ride-vehicle-card:hover::before {
        opacity: 1;
      }

      .ride-vehicle-card.selected {
        border-color: #fff;
        background: #252525;
        box-shadow: 0 0 0 1px #fff inset;
      }

      .ride-vehicle-card > * {
        position: relative;
        z-index: 1;
      }

      /* 车辆图片容器 */
      .ride-vehicle-image {
        width: 100%;
        height: 70px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 14px;
      }

      .ride-vehicle-image svg {
        max-width: 90%;
        max-height: 100%;
        filter: drop-shadow(2px 3px 5px rgba(0, 0, 0, 0.3));
        transition: transform 0.35s ease;
      }

      .ride-vehicle-card:hover .ride-vehicle-image svg {
        transform: scale(1.08);
      }

      /* 车辆信息 */
      .ride-vehicle-name {
        font-size: 15px;
        font-weight: 700;
        color: #fff;
        margin-bottom: 5px;
        letter-spacing: -0.2px;
      }

      .ride-vehicle-capacity {
        font-size: 11px;
        color: #a0a0a0;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .ride-capacity-icon {
        width: 14px;
        height: 14px;
      }

      /* 车辆价格 */
      .ride-vehicle-pricing {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
      }

      .ride-vehicle-price {
        font-size: 20px;
        font-weight: 800;
        color: #fff;
        font-family: 'SF Mono', 'Monaco', Consolas, monospace;
      }

      .ride-vehicle-eta {
        font-size: 10px;
        color: #707070;
        font-weight: 500;
      }

      /* 支付方式区域 */
      .ride-payment-section {
        margin-bottom: 20px;
      }

      .ride-payment-title {
        font-size: 14px;
        font-weight: 600;
        color: #fff;
        margin-bottom: 12px;
      }

      .ride-payment-options {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }

      .ride-payment-option {
        background: #1a1a1a;
        border: 2px solid #2a2a2a;
        border-radius: 10px;
        padding: 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        font-size: 13px;
        font-weight: 500;
        color: #fff;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .ride-payment-option:hover {
        border-color: #666;
        background: #252525;
      }

      .ride-payment-option.selected {
        border-color: #fff;
        background: #252525;
      }

      .ride-payment-icon {
        width: 18px;
        height: 18px;
      }

      /* 预订按钮 */
      .ride-book-btn {
        width: 100%;
        padding: 17px 24px;
        background: #fff;
        color: #000;
        border: none;
        border-radius: 12px;
        font-size: 15px;
        font-weight: 700;
        letter-spacing: 0.3px;
        text-transform: uppercase;
        cursor: pointer;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .ride-book-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 28px rgba(0, 0, 0, 0.6);
      }

      .ride-book-btn:active {
        transform: translateY(-1px);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      }

      .ride-book-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* 选择目的地提示 */
      .ride-selection-hint {
        position: fixed;
        top: 24px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(10, 10, 10, 0.75);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid #2a2a2a;
        padding: 12px 24px;
        border-radius: 24px;
        font-size: 13px;
        font-weight: 600;
        color: #fff;
        z-index: 260;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      .ride-selection-hint.show {
        opacity: 1;
      }

      /* 地图上的路线SVG容器 */
      .ride-route-svg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 5;
      }

      .ride-route-path {
        fill: none;
        stroke: #b0b0b0;
        stroke-width: 3;
        stroke-linecap: round;
        stroke-linejoin: round;
        stroke-dasharray: 12 6;
        animation: routeFlow 25s linear infinite;
      }

      @keyframes routeFlow {
        to {
          stroke-dashoffset: -180;
        }
      }

      /* 地图上的车辆标记 */
      .ride-vehicle-marker {
        position: absolute;
        width: 32px;
        height: 32px;
        z-index: 6;
        animation: vehicleFloat 3.5s ease-in-out infinite;
        filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.6));
        pointer-events: none;
      }

      .ride-vehicle-marker svg {
        width: 100%;
        height: 100%;
      }

      @keyframes vehicleFloat {
        0%, 100% {
          transform: translateY(0) rotate(0deg);
        }
        50% {
          transform: translateY(-5px) rotate(2deg);
        }
      }

      /* 选中的目的地地标发光效果 */
      .landmark-label.ride-destination-selected .landmark-label-icon {
        animation: destinationGlow 2s ease-in-out infinite;
      }

      @keyframes destinationGlow {
        0%, 100% {
          filter: drop-shadow(0 0 8px currentColor);
        }
        50% {
          filter: drop-shadow(0 0 16px currentColor);
        }
      }

      /* 滚动条样式 */
      .ride-panel::-webkit-scrollbar {
        width: 6px;
      }

      .ride-panel::-webkit-scrollbar-track {
        background: transparent;
      }

      .ride-panel::-webkit-scrollbar-thumb {
        background: #404040;
        border-radius: 3px;
      }

      .ride-panel::-webkit-scrollbar-thumb:hover {
        background: #707070;
      }

      /* ==================== 城市乘车面板 - 亮色主题适配 ==================== */
      #x-map-container.light-theme .ride-panel-overlay {
        background: rgba(0, 0, 0, 0.3);
      }

      #x-map-container.light-theme .ride-panel {
        background: rgba(255, 255, 255, 0.75);
        border-top: 1px solid #e5e5e5;
        box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.12);
      }

      #x-map-container.light-theme .ride-panel-handle {
        background: #cccccc;
      }

      #x-map-container.light-theme .ride-route-banner {
        background: linear-gradient(135deg, #2a2a2a 0%, #666 100%);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
      }

      #x-map-container.light-theme .ride-location-box {
        background: #f8f8f8;
        border: 1px solid #e5e5e5;
      }

      #x-map-container.light-theme .ride-location-box:hover {
        background: #f0f0f0;
        border-color: #d0d0d0;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      }

      #x-map-container.light-theme .ride-location-box.selecting {
        border-color: #000;
        background: #f0f0f0;
      }

      #x-map-container.light-theme .ride-location-label {
        color: #999;
      }

      #x-map-container.light-theme .ride-location-value {
        color: #000;
      }

      #x-map-container.light-theme .ride-location-value.placeholder {
        color: #999;
      }

      #x-map-container.light-theme .ride-section-title {
        color: #000;
      }

      #x-map-container.light-theme .ride-vehicle-card {
        background: #f8f8f8;
        border: 2px solid #e5e5e5;
      }

      #x-map-container.light-theme .ride-vehicle-card::before {
        background: linear-gradient(135deg, transparent 0%, #f0f0f0 100%);
      }

      #x-map-container.light-theme .ride-vehicle-card:hover {
        border-color: #666;
        box-shadow: 0 8px 28px rgba(0, 0, 0, 0.12);
      }

      #x-map-container.light-theme .ride-vehicle-card.selected {
        border-color: #000;
        background: #f0f0f0;
        box-shadow: 0 0 0 1px #000 inset;
      }

      #x-map-container.light-theme .ride-vehicle-name {
        color: #000;
      }

      #x-map-container.light-theme .ride-vehicle-capacity {
        color: #666;
      }

      #x-map-container.light-theme .ride-vehicle-price {
        color: #000;
      }

      #x-map-container.light-theme .ride-vehicle-eta {
        color: #999;
      }

      #x-map-container.light-theme .ride-payment-title {
        color: #000;
      }

      #x-map-container.light-theme .ride-payment-option {
        background: #f8f8f8;
        border: 2px solid #e5e5e5;
        color: #000;
      }

      #x-map-container.light-theme .ride-payment-option:hover {
        border-color: #666;
        background: #f0f0f0;
      }

      #x-map-container.light-theme .ride-payment-option.selected {
        border-color: #000;
        background: #f0f0f0;
      }

      #x-map-container.light-theme .ride-book-btn {
        background: #000;
        color: #fff;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
      }

      #x-map-container.light-theme .ride-book-btn:hover {
        box-shadow: 0 8px 28px rgba(0, 0, 0, 0.16);
      }

      #x-map-container.light-theme .ride-book-btn:active {
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
      }

      #x-map-container.light-theme .ride-selection-hint {
        background: rgba(255, 255, 255, 0.75);
        border: 1px solid #e5e5e5;
        color: #000;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
      }

      #x-map-container.light-theme .ride-route-path {
        stroke: #4a4a4a;
      }

      #x-map-container.light-theme .ride-panel::-webkit-scrollbar-thumb {
        background: #cccccc;
      }

      #x-map-container.light-theme .ride-panel::-webkit-scrollbar-thumb:hover {
        background: #a0a0a0;
      }

      /* ==================== 等待司机悬浮小球 ==================== */
      .waiting-driver-float-btn {
        position: fixed;
        bottom: 100px;
        right: 24px;
        width: 64px;
        height: 64px;
        background: rgba(10, 10, 10, 0.85);
        border: 2px solid #2a2a2a;
        border-radius: 50%;
        display: none;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 999;
        transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        backdrop-filter: blur(24px) saturate(180%);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }

      .waiting-driver-float-btn.active {
        display: flex;
      }

      .waiting-driver-float-btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.3);
        animation: driverPulse 2s ease-out infinite;
        z-index: -1;
      }

      @keyframes driverPulse {
        0% {
          transform: scale(1);
          opacity: 0.8;
        }
        100% {
          transform: scale(2);
          opacity: 0;
        }
      }

      .waiting-driver-float-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      }

      .waiting-driver-float-btn svg {
        width: 32px;
        height: 32px;
        stroke: #ffffff;
        stroke-width: 1.5;
        transition: stroke 0.3s ease;
      }

      /* 摇晃动画（车辆到达时） */
      .waiting-driver-float-btn.shake {
        animation: driverShake 0.5s cubic-bezier(0.36, 0.07, 0.19, 0.97) infinite;
      }

      @keyframes driverShake {
        0%, 100% { transform: translateX(0) rotate(0deg); }
        10%, 30%, 50%, 70%, 90% { transform: translateX(-4px) rotate(-5deg); }
        20%, 40%, 60%, 80% { transform: translateX(4px) rotate(5deg); }
      }

      /* 亮色主题适配 */
      #x-map-container.light-theme .waiting-driver-float-btn {
        background: rgba(255, 255, 255, 0.85);
        border-color: #e5e5e5;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
      }

      #x-map-container.light-theme .waiting-driver-float-btn::before {
        background: rgba(42, 42, 42, 0.3);
      }

      #x-map-container.light-theme .waiting-driver-float-btn svg {
        stroke: #000000;
      }

      #x-map-container.light-theme .waiting-driver-float-btn:hover {
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
      }

      /* ==================== 等待司机弹窗 ==================== */
      .waiting-driver-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(8px);
        z-index: 2500;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }

      .waiting-driver-modal-overlay.active {
        opacity: 1;
        visibility: visible;
      }

      .waiting-driver-modal {
        position: relative;
        width: 90%;
        max-width: 420px;
        background: rgba(10, 10, 10, 0.85);
        border: 1px solid #2a2a2a;
        backdrop-filter: blur(24px) saturate(180%);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        clip-path: polygon(
          16px 0,
          calc(100% - 16px) 0,
          100% 16px,
          100% calc(100% - 24px),
          calc(100% - 24px) 100%,
          24px 100%,
          0 calc(100% - 24px),
          0 16px
        );
        padding: 32px 24px 24px;
        transform: scale(0.8);
        opacity: 0;
        transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      .waiting-driver-modal-overlay.active .waiting-driver-modal {
        transform: scale(1);
        opacity: 1;
      }

      .waiting-driver-close {
        position: absolute;
        top: 12px;
        right: 12px;
        width: 32px;
        height: 32px;
        background: transparent;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s ease;
        z-index: 1;
      }

      .waiting-driver-close:hover {
        background: #252525;
        transform: rotate(90deg);
      }

      .waiting-driver-close svg {
        width: 20px;
        height: 20px;
        stroke: #a0a0a0;
        stroke-width: 2;
      }

      .waiting-driver-header {
        text-align: center;
        margin-bottom: 24px;
      }

      .waiting-driver-status {
        font-size: 13px;
        font-weight: 500;
        letter-spacing: 1.2px;
        text-transform: uppercase;
        color: #707070;
        margin-bottom: 8px;
      }

      .waiting-driver-eta {
        font-size: 32px;
        font-weight: 700;
        letter-spacing: -0.5px;
        color: #ffffff;
        font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
      }

      .waiting-driver-eta-label {
        font-size: 14px;
        font-weight: 400;
        color: #a0a0a0;
        margin-top: 4px;
      }

      .waiting-driver-card {
        background: #1a1a1a;
        border: 1px solid #2a2a2a;
        border-radius: 20px;
        padding: 20px;
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 16px;
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
      }

      .waiting-driver-card::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.05), transparent);
        transform: rotate(45deg);
        animation: driverCardShimmer 3s infinite;
      }

      @keyframes driverCardShimmer {
        0% { transform: translateX(-100%) rotate(45deg); }
        100% { transform: translateX(100%) rotate(45deg); }
      }

      .waiting-driver-avatar {
        position: relative;
        width: 64px;
        height: 64px;
        border-radius: 50%;
        overflow: hidden;
        flex-shrink: 0;
        z-index: 1;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .waiting-driver-avatar::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        border: 2px solid #d5d5d5;
        opacity: 0.3;
      }

      .waiting-driver-avatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .waiting-driver-info {
        flex: 1;
        z-index: 1;
      }

      .waiting-driver-name {
        font-size: 18px;
        font-weight: 700;
        color: #ffffff;
        margin-bottom: 4px;
        letter-spacing: -0.3px;
      }

      .waiting-driver-rating {
        display: flex;
        align-items: center;
        gap: 4px;
        margin-bottom: 6px;
      }

      .waiting-driver-rating svg {
        width: 14px;
        height: 14px;
        fill: #ffffff;
      }

      .waiting-driver-rating-value {
        font-size: 13px;
        font-weight: 600;
        color: #ffffff;
        margin-left: 2px;
      }

      .waiting-driver-vehicle {
        font-size: 13px;
        color: #a0a0a0;
        font-weight: 500;
      }

      .waiting-driver-plate {
        display: inline-block;
        background: #0a0a0a;
        border: 1px solid #2a2a2a;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 11px;
        font-weight: 700;
        letter-spacing: 0.5px;
        margin-left: 6px;
        font-family: 'Courier New', monospace;
        color: #ffffff;
      }

      .waiting-driver-route-map {
        position: relative;
        width: 100%;
        height: 200px;
        background: #151515;
        border-radius: 16px;
        overflow: hidden;
        margin-bottom: 20px;
        border: 1px solid #2a2a2a;
      }

      .waiting-driver-route-grid {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image:
          repeating-linear-gradient(0deg, transparent, transparent 19px, #2a2a2a 19px, #2a2a2a 20px),
          repeating-linear-gradient(90deg, transparent, transparent 19px, #2a2a2a 19px, #2a2a2a 20px);
        opacity: 0.3;
      }

      .waiting-driver-route-line {
        position: absolute;
        top: 50%;
        left: 20%;
        width: 60%;
        height: 2px;
        background: transparent;
        transform: translateY(-50%);
      }

      .waiting-driver-route-line::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
          to right,
          #b0b0b0 0px,
          #b0b0b0 8px,
          transparent 8px,
          transparent 16px
        );
        animation: driverRouteFlow 1.5s linear infinite;
      }

      @keyframes driverRouteFlow {
        0% { transform: translateX(0); }
        100% { transform: translateX(16px); }
      }

      .waiting-driver-user-marker {
        position: absolute;
        left: 80%;
        top: 50%;
        transform: translate(-50%, -50%);
        z-index: 2;
      }

      .waiting-driver-user-pin {
        width: 32px;
        height: 32px;
        background: #d5d5d5;
        border: 3px solid #0a0a0a;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .waiting-driver-user-pin svg {
        width: 16px;
        height: 16px;
        stroke: #0a0a0a;
        stroke-width: 2.5;
      }

      .waiting-driver-car-marker {
        position: absolute;
        left: 20%;
        top: 50%;
        transform: translate(-50%, -50%);
        z-index: 3;
      }

      .waiting-driver-car-icon {
        width: 40px;
        height: 40px;
        background: #0a0a0a;
        border: 2px solid #d5d5d5;
        border-radius: 50%;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
      }

      .waiting-driver-car-icon::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.3);
        animation: driverCarPulse 2s ease-out infinite;
        z-index: -1;
      }

      @keyframes driverCarPulse {
        0% {
          transform: scale(1);
          opacity: 0.6;
        }
        100% {
          transform: scale(2.5);
          opacity: 0;
        }
      }

      .waiting-driver-car-icon svg {
        width: 20px;
        height: 20px;
        stroke: #d5d5d5;
        stroke-width: 2;
      }

      .waiting-driver-car-label {
        position: absolute;
        bottom: -28px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(10, 10, 10, 0.85);
        border: 1px solid #2a2a2a;
        padding: 4px 10px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 600;
        color: #ffffff;
        white-space: nowrap;
        backdrop-filter: blur(8px);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      }

      .waiting-driver-distance-info {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px;
        background: #1a1a1a;
        border: 1px solid #2a2a2a;
        border-radius: 12px;
        margin-bottom: 20px;
      }

      .waiting-driver-distance-item {
        text-align: center;
        flex: 1;
      }

      .waiting-driver-distance-value {
        font-size: 20px;
        font-weight: 700;
        color: #ffffff;
        letter-spacing: -0.3px;
      }

      .waiting-driver-distance-label {
        font-size: 11px;
        color: #707070;
        margin-top: 2px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .waiting-driver-distance-divider {
        width: 1px;
        height: 32px;
        background: #2a2a2a;
      }

      .waiting-driver-actions {
        display: flex;
        gap: 12px;
      }

      .waiting-driver-action-btn {
        flex: 1;
        height: 48px;
        border: 1px solid #2a2a2a;
        border-radius: 12px;
        background: #1a1a1a;
        color: #ffffff;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        transition: all 0.2s ease;
      }

      .waiting-driver-action-btn:hover {
        background: #252525;
        transform: translateY(-2px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      .waiting-driver-action-btn svg {
        width: 18px;
        height: 18px;
        stroke: #ffffff;
        stroke-width: 2;
      }

      .waiting-driver-action-btn.cancel {
        background: transparent;
        border: 2px solid #d5d5d5;
      }

      .waiting-driver-action-btn.cancel:hover {
        background: #d5d5d5;
        color: #0a0a0a;
      }

      .waiting-driver-action-btn.cancel:hover svg {
        stroke: #0a0a0a;
      }

      /* 亮色主题适配 */
      #x-map-container.light-theme .waiting-driver-modal {
        background: rgba(255, 255, 255, 0.85);
        border-color: #e5e5e5;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
      }

      #x-map-container.light-theme .waiting-driver-close:hover {
        background: #f0f0f0;
      }

      #x-map-container.light-theme .waiting-driver-close svg {
        stroke: #666666;
      }

      #x-map-container.light-theme .waiting-driver-status {
        color: #999999;
      }

      #x-map-container.light-theme .waiting-driver-eta {
        color: #000000;
      }

      #x-map-container.light-theme .waiting-driver-eta-label {
        color: #666666;
      }

      #x-map-container.light-theme .waiting-driver-card {
        background: #f8f8f8;
        border-color: #e5e5e5;
      }

      #x-map-container.light-theme .waiting-driver-card::before {
        background: linear-gradient(45deg, transparent, rgba(0, 0, 0, 0.05), transparent);
      }

      #x-map-container.light-theme .waiting-driver-avatar::after {
        border-color: #2a2a2a;
      }

      #x-map-container.light-theme .waiting-driver-name {
        color: #000000;
      }

      #x-map-container.light-theme .waiting-driver-rating svg {
        fill: #000000;
      }

      #x-map-container.light-theme .waiting-driver-rating-value {
        color: #000000;
      }

      #x-map-container.light-theme .waiting-driver-vehicle {
        color: #666666;
      }

      #x-map-container.light-theme .waiting-driver-plate {
        background: #ffffff;
        border-color: #e5e5e5;
        color: #000000;
      }

      #x-map-container.light-theme .waiting-driver-route-map {
        background: #ebebeb;
        border-color: #e5e5e5;
      }

      #x-map-container.light-theme .waiting-driver-route-grid {
        background-image:
          repeating-linear-gradient(0deg, transparent, transparent 19px, #d5d5d5 19px, #d5d5d5 20px),
          repeating-linear-gradient(90deg, transparent, transparent 19px, #d5d5d5 19px, #d5d5d5 20px);
      }

      #x-map-container.light-theme .waiting-driver-route-line::before {
        background: repeating-linear-gradient(
          to right,
          #4a4a4a 0px,
          #4a4a4a 8px,
          transparent 8px,
          transparent 16px
        );
      }

      #x-map-container.light-theme .waiting-driver-user-pin {
        background: #2a2a2a;
        border-color: #ffffff;
      }

      #x-map-container.light-theme .waiting-driver-user-pin svg {
        stroke: #ffffff;
      }

      #x-map-container.light-theme .waiting-driver-car-icon {
        background: #ffffff;
        border-color: #2a2a2a;
      }

      #x-map-container.light-theme .waiting-driver-car-icon::before {
        background: rgba(42, 42, 42, 0.3);
      }

      #x-map-container.light-theme .waiting-driver-car-icon svg {
        stroke: #2a2a2a;
      }

      #x-map-container.light-theme .waiting-driver-car-label {
        background: rgba(255, 255, 255, 0.85);
        border-color: #e5e5e5;
        color: #000000;
      }

      #x-map-container.light-theme .waiting-driver-distance-info {
        background: #f8f8f8;
        border-color: #e5e5e5;
      }

      #x-map-container.light-theme .waiting-driver-distance-value {
        color: #000000;
      }

      #x-map-container.light-theme .waiting-driver-distance-label {
        color: #999999;
      }

      #x-map-container.light-theme .waiting-driver-distance-divider {
        background: #e5e5e5;
      }

      #x-map-container.light-theme .waiting-driver-action-btn {
        background: #f8f8f8;
        border-color: #e5e5e5;
        color: #000000;
      }

      #x-map-container.light-theme .waiting-driver-action-btn:hover {
        background: #f0f0f0;
      }

      #x-map-container.light-theme .waiting-driver-action-btn svg {
        stroke: #000000;
      }

      #x-map-container.light-theme .waiting-driver-action-btn.cancel {
        border-color: #2a2a2a;
      }

      #x-map-container.light-theme .waiting-driver-action-btn.cancel:hover {
        background: #2a2a2a;
        color: #ffffff;
      }

      #x-map-container.light-theme .waiting-driver-action-btn.cancel:hover svg {
        stroke: #ffffff;
      }

      /* 移动端适配 */
      @media (max-width: 480px) {
        .waiting-driver-modal {
          width: 95%;
          padding: 28px 20px 20px;
        }

        .waiting-driver-eta {
          font-size: 28px;
        }

        .waiting-driver-card {
          padding: 16px;
        }

        .waiting-driver-route-map {
          height: 180px;
        }
      }

      /* ==================== 移动端适配：提醒弹窗 ==================== */
      @media (max-width: 480px) {
        .map-notifications-content {
          width: calc(100% - 20px);
          max-width: 100%;
          border-radius: 20px;
        }

        .map-notifications-header {
          padding: 20px 16px 16px;
          gap: 12px;
        }

        .map-notifications-title {
          font-size: 24px;
        }

        .map-notifications-close-btn {
          width: 32px;
          height: 32px;
        }

        .map-notifications-stats {
          padding: 12px 16px;
          gap: 12px;
          border-radius: 12px;
        }

        .map-notifications-stats-icon {
          width: 40px;
          height: 40px;
          border-radius: 20px;
        }

        .map-notifications-stats-icon svg {
          width: 20px;
          height: 20px;
        }

        .map-notifications-stats-label {
          font-size: 12px;
        }

        .map-notifications-stats-count {
          font-size: 20px;
        }

        .map-notifications-tabs {
          gap: 6px;
        }

        .map-notifications-tab {
          padding: 6px 14px;
          font-size: 13px;
          border-radius: 16px;
        }

        .map-notifications-list-container {
          padding: 8px 12px 12px;
        }

        .map-notification-item {
          padding: 12px 14px;
          gap: 12px;
          border-radius: 10px;
        }

        .map-notification-icon {
          width: 36px;
          height: 36px;
          border-radius: 9px;
        }

        .map-notification-icon svg {
          width: 18px;
          height: 18px;
        }

        .map-notification-title {
          font-size: 14px;
        }

        .map-notification-content {
          font-size: 13px;
        }

        .map-notification-time {
          font-size: 11px;
        }

        .map-notifications-empty {
          padding: 60px 24px;
        }

        .map-notifications-empty-icon {
          width: 56px;
          height: 56px;
          border-radius: 14px;
        }

        .map-notifications-empty-icon svg {
          width: 28px;
          height: 28px;
        }

        .map-notifications-empty-text {
          font-size: 13px;
        }
      }

      /* ==================== 接收私信确认弹窗 - 极简黑白灰 ==================== */
      .map-accept-message-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 399;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .map-accept-message-overlay.show {
        opacity: 1;
        pointer-events: all;
      }

      .map-accept-message-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: transparent;
        z-index: 400;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .map-accept-message-modal.show {
        opacity: 1;
        pointer-events: all;
      }

      /* 确认弹窗内容容器 */
      .map-accept-message-content {
        width: calc(100% - 32px);
        max-width: 380px;
        background: #1a1a1a;
        border-radius: 20px;
        overflow: hidden;
        box-shadow: 0 12px 48px rgba(0, 0, 0, 0.6);
        animation: confirmModalZoom 0.3s cubic-bezier(0.32, 0.72, 0, 1);
      }

      @keyframes confirmModalZoom {
        from {
          opacity: 0;
          transform: scale(0.88);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      /* 确认弹窗内容区 */
      .map-accept-message-header {
        padding: 24px 20px;
        background: #1a1a1a;
      }

      .map-accept-message-user {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 16px;
      }

      .map-accept-message-avatar {
        width: 52px;
        height: 52px;
        border-radius: 50%;
        object-fit: cover;
        border: 1.5px solid #333333;
        flex-shrink: 0;
      }

      .map-accept-message-user-info h3 {
        font-size: 16px;
        font-weight: 600;
        color: #e5e5e5;
        margin: 0 0 4px 0;
        letter-spacing: -0.2px;
      }

      .map-accept-message-user-info p {
        font-size: 13px;
        color: #8e8e8e;
        margin: 0;
      }

      .map-accept-message-title {
        font-size: 13px;
        color: #8e8e8e;
        margin: 0 0 10px 0;
        font-weight: 500;
      }

      /* 私信内容预览框 */
      .map-accept-message-text {
        background: #262626;
        border-radius: 14px;
        padding: 14px 16px;
        font-size: 15px;
        color: #e5e5e5;
        line-height: 1.5;
        max-height: 180px;
        overflow-y: auto;
        border: 1px solid #333333;
      }

      .map-accept-message-text::-webkit-scrollbar {
        width: 6px;
      }

      .map-accept-message-text::-webkit-scrollbar-thumb {
        background: #444444;
        border-radius: 3px;
      }

      /* 确认弹窗按钮 */
      .map-accept-message-actions {
        padding: 20px;
        background: #1a1a1a;
        display: flex;
        gap: 12px;
        border-top: 1px solid #333333;
      }

      .map-accept-btn,
      .map-decline-btn {
        flex: 1;
        padding: 13px 20px;
        border: none;
        border-radius: 12px;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .map-accept-btn {
        background: #fff;
        color: #000;
      }

      .map-accept-btn:hover {
        background: #e5e5e5;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(255, 255, 255, 0.15);
      }

      .map-accept-btn:active {
        background: #d0d0d0;
        transform: translateY(0);
      }

      .map-decline-btn {
        background: #2a2a2a;
        color: #e5e5e5;
        border: 1.5px solid #444444;
      }

      .map-decline-btn:hover {
        background: #333333;
        border-color: #555555;
      }

      .map-decline-btn:active {
        background: #282828;
      }

      /* ==================== 🚨 举报弹窗 - 简约ins风格 ==================== */
      .map-report-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.75);
        z-index: 499;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .map-report-overlay.show {
        opacity: 1;
        pointer-events: all;
      }

      .map-report-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: transparent;
        z-index: 500;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        padding: 20px;
        box-sizing: border-box;
      }

      .map-report-modal.show {
        opacity: 1;
        pointer-events: all;
      }

      .map-report-content {
        width: 100%;
        max-width: 420px;
        max-height: 85vh;
        background: #1a1a1a;
        border-radius: 20px;
        overflow: hidden;
        box-shadow: 0 16px 56px rgba(0, 0, 0, 0.7);
        animation: reportModalSlide 0.3s cubic-bezier(0.32, 0.72, 0, 1);
        display: flex;
        flex-direction: column;
      }

      @keyframes reportModalSlide {
        from {
          opacity: 0;
          transform: scale(0.92) translateY(10px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      /* 举报弹窗头部 */
      .map-report-header {
        padding: 20px 20px 18px;
        background: #1a1a1a;
        border-bottom: 1px solid #2a2a2a;
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-shrink: 0;
      }

      .map-report-title {
        font-size: 18px;
        font-weight: 600;
        color: #e5e5e5;
        margin: 0;
        letter-spacing: -0.3px;
      }

      .map-report-close-btn {
        width: 32px;
        height: 32px;
        border: none;
        background: transparent;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: background 0.2s ease;
        padding: 0;
        flex-shrink: 0;
      }

      .map-report-close-btn svg {
        width: 20px;
        height: 20px;
        stroke: #8e8e8e;
        stroke-width: 2.5;
        stroke-linecap: round;
      }

      .map-report-close-btn:hover {
        background: rgba(255, 255, 255, 0.08);
      }

      .map-report-close-btn:hover svg {
        stroke: #e5e5e5;
      }

      .map-report-close-btn:active {
        background: rgba(255, 255, 255, 0.12);
      }

      /* 举报弹窗主体 */
      .map-report-body {
        padding: 20px;
        background: #1a1a1a;
        overflow-y: auto;
        overflow-x: hidden;
        flex: 1;
      }

      .map-report-body::-webkit-scrollbar {
        width: 6px;
      }

      .map-report-body::-webkit-scrollbar-track {
        background: transparent;
      }

      .map-report-body::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.15);
        border-radius: 3px;
      }

      .map-report-body::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.25);
      }

      /* 被举报用户信息 */
      .map-report-user-info {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 16px;
        background: #242424;
        border-radius: 14px;
        margin-bottom: 24px;
        border: 1px solid #2a2a2a;
      }

      .map-report-user-avatar {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        object-fit: cover;
        border: 1.5px solid #333333;
        flex-shrink: 0;
      }

      .map-report-user-details h4 {
        font-size: 15px;
        font-weight: 600;
        color: #e5e5e5;
        margin: 0 0 4px 0;
        letter-spacing: -0.2px;
      }

      .map-report-user-details p {
        font-size: 13px;
        color: #8e8e8e;
        margin: 0;
      }

      /* 举报表单区块 */
      .map-report-section {
        margin-bottom: 24px;
      }

      .map-report-section:last-child {
        margin-bottom: 0;
      }

      .map-report-section-label {
        display: block;
        font-size: 14px;
        font-weight: 600;
        color: #e5e5e5;
        margin-bottom: 12px;
        letter-spacing: -0.1px;
      }

      /* 举报理由列表 */
      .map-report-reasons {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .map-report-reason-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 14px 16px;
        background: #242424;
        border: 1.5px solid #2a2a2a;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        user-select: none;
      }

      .map-report-reason-item:hover {
        background: #2a2a2a;
        border-color: #3a3a3a;
      }

      .map-report-reason-item input[type="checkbox"] {
        width: 20px;
        height: 20px;
        cursor: pointer;
        margin: 0;
        flex-shrink: 0;
        appearance: none;
        -webkit-appearance: none;
        background: #1a1a1a;
        border: 2px solid #444444;
        border-radius: 6px;
        position: relative;
        transition: all 0.2s ease;
      }

      .map-report-reason-item input[type="checkbox"]:checked {
        background: #fff;
        border-color: #fff;
      }

      .map-report-reason-item input[type="checkbox"]:checked::after {
        content: '';
        position: absolute;
        left: 5px;
        top: 2px;
        width: 6px;
        height: 10px;
        border: solid #000;
        border-width: 0 2.5px 2.5px 0;
        transform: rotate(45deg);
      }

      .map-report-reason-item input[type="checkbox"]:hover {
        border-color: #666666;
      }

      .map-report-reason-text {
        font-size: 14px;
        color: #e5e5e5;
        font-weight: 500;
        letter-spacing: -0.1px;
      }

      /* 举报描述输入框 */
      .map-report-textarea {
        width: 100%;
        padding: 14px 16px;
        background: #242424;
        border: 1.5px solid #2a2a2a;
        border-radius: 12px;
        color: #e5e5e5;
        font-size: 14px;
        font-family: inherit;
        line-height: 1.5;
        resize: vertical;
        min-height: 100px;
        transition: all 0.2s ease;
        box-sizing: border-box;
      }

      .map-report-textarea::placeholder {
        color: #666666;
      }

      .map-report-textarea:focus {
        outline: none;
        border-color: #3a3a3a;
        background: #2a2a2a;
      }

      .map-report-textarea::-webkit-scrollbar {
        width: 6px;
      }

      .map-report-textarea::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.15);
        border-radius: 3px;
      }

      /* 举报弹窗底部按钮 */
      .map-report-actions {
        padding: 16px 20px;
        background: #1a1a1a;
        border-top: 1px solid #2a2a2a;
        display: flex;
        gap: 12px;
        flex-shrink: 0;
      }

      .map-report-cancel-btn,
      .map-report-submit-btn {
        flex: 1;
        padding: 13px 20px;
        border: none;
        border-radius: 12px;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .map-report-cancel-btn {
        background: #2a2a2a;
        color: #e5e5e5;
        border: 1.5px solid #3a3a3a;
      }

      .map-report-cancel-btn:hover {
        background: #333333;
        border-color: #444444;
      }

      .map-report-cancel-btn:active {
        background: #282828;
      }

      .map-report-submit-btn {
        background: #fff;
        color: #000;
      }

      .map-report-submit-btn:hover {
        background: #e5e5e5;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(255, 255, 255, 0.2);
      }

      .map-report-submit-btn:active {
        background: #d0d0d0;
        transform: translateY(0);
      }

      .map-report-submit-btn:disabled {
        background: #3a3a3a;
        color: #666666;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      /* ==================== 举报详情弹窗 - ins简约风格 ==================== */
      /* 举报详情遮罩 */
      .map-report-detail-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 499;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .map-report-detail-overlay.show {
        opacity: 1;
        pointer-events: all;
      }

      /* 举报详情弹窗容器 */
      .map-report-detail-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: transparent;
        z-index: 500;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        padding: 20px;
        box-sizing: border-box;
      }

      .map-report-detail-modal.show {
        opacity: 1;
        pointer-events: all;
      }

      /* 举报详情内容 */
      .map-report-detail-content {
        width: 100%;
        max-width: 480px;
        max-height: 90vh;
        background: #1a1a1a;
        border-radius: 24px;
        overflow: hidden;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        animation: reportDetailSlide 0.35s cubic-bezier(0.32, 0.72, 0, 1);
        display: flex;
        flex-direction: column;
      }

      @keyframes reportDetailSlide {
        from {
          opacity: 0;
          transform: scale(0.94) translateY(20px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      /* 举报详情头部 */
      .map-report-detail-header {
        padding: 24px 24px 20px;
        background: #1a1a1a;
        border-bottom: 1px solid #2a2a2a;
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-shrink: 0;
      }

      .map-report-detail-title {
        font-size: 20px;
        font-weight: 700;
        color: #e5e5e5;
        margin: 0;
        letter-spacing: -0.4px;
      }

      .map-report-detail-close-btn {
        width: 36px;
        height: 36px;
        border: none;
        background: transparent;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: background 0.2s ease;
        padding: 0;
        flex-shrink: 0;
      }

      .map-report-detail-close-btn svg {
        width: 22px;
        height: 22px;
        stroke: #8e8e8e;
        stroke-width: 2.5;
        stroke-linecap: round;
      }

      .map-report-detail-close-btn:hover {
        background: rgba(255, 255, 255, 0.08);
      }

      .map-report-detail-close-btn:hover svg {
        stroke: #e5e5e5;
      }

      .map-report-detail-close-btn:active {
        background: rgba(255, 255, 255, 0.12);
      }

      /* 判定结果徽章容器 */
      .map-report-detail-badge-container {
        padding: 24px 24px 20px;
        background: #1a1a1a;
        display: flex;
        justify-content: center;
      }

      .map-report-detail-badge {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 14px 24px;
        border-radius: 20px;
        border: 2px solid;
        animation: badgePulse 0.5s ease;
      }

      @keyframes badgePulse {
        0% { transform: scale(0.9); opacity: 0; }
        60% { transform: scale(1.05); }
        100% { transform: scale(1); opacity: 1; }
      }

      .map-report-detail-badge.approved {
        border-color: #4a4a4a;
        background: rgba(255, 255, 255, 0.03);
      }

      .map-report-detail-badge.declined {
        border-color: #4a4a4a;
        background: rgba(0, 0, 0, 0.1);
      }

      .map-report-detail-badge-icon {
        width: 22px;
        height: 22px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
      }

      .map-report-detail-badge.approved .map-report-detail-badge-icon::before {
        content: '';
        position: absolute;
        width: 8px;
        height: 14px;
        border: solid #e5e5e5;
        border-width: 0 2.5px 2.5px 0;
        transform: rotate(45deg);
        margin-top: -3px;
      }

      .map-report-detail-badge.declined .map-report-detail-badge-icon::before {
        content: '';
        position: absolute;
        width: 16px;
        height: 2.5px;
        background: #e5e5e5;
        transform: rotate(45deg);
      }

      .map-report-detail-badge.declined .map-report-detail-badge-icon::after {
        content: '';
        position: absolute;
        width: 16px;
        height: 2.5px;
        background: #e5e5e5;
        transform: rotate(-45deg);
      }

      .map-report-detail-badge-text {
        font-size: 16px;
        font-weight: 700;
        color: #e5e5e5;
        letter-spacing: -0.2px;
      }

      /* 举报详情主体 */
      .map-report-detail-body {
        padding: 20px 24px;
        background: #1a1a1a;
        overflow-y: auto;
        overflow-x: hidden;
        flex: 1;
      }

      .map-report-detail-body::-webkit-scrollbar {
        width: 6px;
      }

      .map-report-detail-body::-webkit-scrollbar-track {
        background: transparent;
      }

      .map-report-detail-body::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.15);
        border-radius: 3px;
      }

      .map-report-detail-body::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.25);
      }

      /* 详情区块 */
      .map-report-detail-section {
        margin-bottom: 24px;
      }

      .map-report-detail-section:last-child {
        margin-bottom: 0;
      }

      .map-report-detail-section-label {
        display: block;
        font-size: 12px;
        font-weight: 700;
        color: #8e8e8e;
        margin-bottom: 10px;
        letter-spacing: 0.5px;
        text-transform: uppercase;
      }

      /* 用户卡片 */
      .map-report-detail-user-card {
        display: flex;
        align-items: center;
        gap: 14px;
        padding: 16px;
        background: #242424;
        border-radius: 16px;
        border: 1px solid #2a2a2a;
      }

      .map-report-detail-user-avatar {
        width: 52px;
        height: 52px;
        border-radius: 50%;
        object-fit: cover;
        border: 2px solid #333333;
        flex-shrink: 0;
      }

      .map-report-detail-user-nickname {
        font-size: 16px;
        font-weight: 600;
        color: #e5e5e5;
        margin-bottom: 4px;
        letter-spacing: -0.2px;
      }

      .map-report-detail-user-handle {
        font-size: 14px;
        color: #8e8e8e;
      }

      /* 举报理由标签 */
      .map-report-detail-reasons {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .map-report-detail-reason-tag {
        display: inline-flex;
        align-items: center;
        padding: 8px 16px;
        background: #242424;
        border: 1px solid #3a3a3a;
        border-radius: 14px;
        font-size: 13px;
        font-weight: 500;
        color: #e5e5e5;
        letter-spacing: -0.1px;
      }

      /* 举报描述 */
      .map-report-detail-description {
        padding: 16px;
        background: #242424;
        border-radius: 16px;
        border: 1px solid #2a2a2a;
        font-size: 14px;
        line-height: 1.6;
        color: #c0c0c0;
        letter-spacing: -0.1px;
      }

      /* AI判定原因 */
      .map-report-detail-reason {
        padding: 18px;
        background: #242424;
        border-radius: 16px;
        border: 1px solid #2a2a2a;
        font-size: 14px;
        line-height: 1.7;
        color: #e5e5e5;
        letter-spacing: -0.1px;
      }

      /* 举报时间 */
      .map-report-detail-time {
        padding: 14px 16px;
        background: #242424;
        border-radius: 14px;
        border: 1px solid #2a2a2a;
        font-size: 14px;
        color: #8e8e8e;
        font-family: 'SF Mono', 'Menlo', 'Consolas', monospace;
      }

      /* 底部按钮 */
      .map-report-detail-actions {
        padding: 20px 24px;
        background: #1a1a1a;
        border-top: 1px solid #2a2a2a;
        flex-shrink: 0;
      }

      .map-report-detail-acknowledge-btn {
        width: 100%;
        padding: 15px 24px;
        border: none;
        border-radius: 16px;
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        background: #fff;
        color: #000;
        letter-spacing: -0.2px;
      }

      .map-report-detail-acknowledge-btn:hover {
        background: #e5e5e5;
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(255, 255, 255, 0.25);
      }

      .map-report-detail-acknowledge-btn:active {
        background: #d0d0d0;
        transform: translateY(0);
      }

      /* 亮色模式适配 */
      @media (prefers-color-scheme: light) {
        .map-report-detail-content,
        .map-report-detail-header,
        .map-report-detail-body {
          background: #ffffff;
        }

        .map-report-detail-header {
          border-bottom-color: #e5e5e5;
        }

        .map-report-detail-title,
        .map-report-detail-user-nickname,
        .map-report-detail-badge-text,
        .map-report-detail-reason {
          color: #1a1a1a;
        }

        .map-report-detail-close-btn svg {
          stroke: #666666;
        }

        .map-report-detail-close-btn:hover {
          background: rgba(0, 0, 0, 0.05);
        }

        .map-report-detail-close-btn:hover svg {
          stroke: #1a1a1a;
        }

        .map-report-detail-badge.approved,
        .map-report-detail-badge.declined {
          border-color: #d0d0d0;
          background: #f8f8f8;
        }

        .map-report-detail-badge.approved .map-report-detail-badge-icon::before {
          border-color: #1a1a1a;
        }

        .map-report-detail-badge.declined .map-report-detail-badge-icon::before,
        .map-report-detail-badge.declined .map-report-detail-badge-icon::after {
          background: #1a1a1a;
        }

        .map-report-detail-section-label {
          color: #666666;
        }

        .map-report-detail-user-card,
        .map-report-detail-description,
        .map-report-detail-reason,
        .map-report-detail-time {
          background: #f8f8f8;
          border-color: #e5e5e5;
        }

        .map-report-detail-user-avatar {
          border-color: #d0d0d0;
        }

        .map-report-detail-user-handle {
          color: #666666;
        }

        .map-report-detail-reason-tag {
          background: #f0f0f0;
          border-color: #d0d0d0;
          color: #1a1a1a;
        }

        .map-report-detail-description {
          color: #4a4a4a;
        }

        .map-report-detail-time {
          color: #666666;
        }

        .map-report-detail-actions {
          background: #ffffff;
          border-top-color: #e5e5e5;
        }

        .map-report-detail-acknowledge-btn {
          background: #1a1a1a;
          color: #ffffff;
        }

        .map-report-detail-acknowledge-btn:hover {
          background: #2a2a2a;
          box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        }

        .map-report-detail-acknowledge-btn:active {
          background: #1a1a1a;
        }
      }

      /* ==================== 应用设置弹窗 - 黑白灰简约ins风格 ==================== */
      /* 应用设置弹窗遮罩 */
      .map-app-settings-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 399;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .map-app-settings-overlay.show {
        opacity: 1;
        pointer-events: all;
      }

      /* 应用设置弹窗主容器 */
      .map-app-settings-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: transparent;
        z-index: 400;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .map-app-settings-modal.show {
        opacity: 1;
        pointer-events: all;
      }

      /* 应用设置内容卡片 - ins风格 */
      .map-app-settings-content {
        width: calc(100% - 40px);
        max-width: 380px;
        background: #1a1a1a;
        border-radius: 24px;
        overflow: hidden;
        box-shadow: 0 16px 64px rgba(0, 0, 0, 0.5);
        animation: appSettingsSlideIn 0.3s cubic-bezier(0.32, 0.72, 0, 1);
      }

      @keyframes appSettingsSlideIn {
        from {
          opacity: 0;
          transform: scale(0.92) translateY(10px);
        }
        to {
          opacity: 1;
          transform: scale(1) translateY(0);
        }
      }

      /* 应用设置弹窗头部 */
      .map-app-settings-header {
        padding: 20px 24px;
        background: #1a1a1a;
        border-bottom: 1px solid #2a2a2a;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .map-app-settings-title {
        font-size: 18px;
        font-weight: 700;
        color: #e5e5e5;
        letter-spacing: -0.3px;
      }

      .map-app-settings-close-btn {
        width: 32px;
        height: 32px;
        background: transparent;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.15s ease;
        padding: 0;
      }

      .map-app-settings-close-btn:hover {
        background: rgba(255, 255, 255, 0.08);
      }

      .map-app-settings-close-btn:active {
        background: rgba(255, 255, 255, 0.12);
      }

      .map-app-settings-close-btn svg {
        width: 20px;
        height: 20px;
        stroke: #e5e5e5;
        fill: none;
        stroke-width: 2.5;
        stroke-linecap: round;
      }

      /* 应用设置弹窗主体 */
      .map-app-settings-body {
        padding: 24px;
        background: #1a1a1a;
        max-height: 70vh;
        overflow-y: auto;
        overflow-x: hidden;
      }

      /* 滚动条样式 - 设置弹窗 */
      .map-app-settings-body::-webkit-scrollbar {
        width: 6px;
      }

      .map-app-settings-body::-webkit-scrollbar-track {
        background: transparent;
      }

      .map-app-settings-body::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
      }

      .map-app-settings-body::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.3);
      }

      /* 应用设置项 */
      .map-app-setting-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 0;
        border-bottom: 1px solid #2a2a2a;
      }

      .map-app-setting-item:last-child {
        border-bottom: none;
      }

      .map-app-setting-label {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .map-app-setting-label-text {
        font-size: 16px;
        font-weight: 600;
        color: #e5e5e5;
        letter-spacing: -0.2px;
      }

      .map-app-setting-label-desc {
        font-size: 13px;
        color: #8e8e8e;
        line-height: 1.4;
      }

      /* 主题切换开关 - 滑动开关设计 */
      .map-theme-toggle {
        position: relative;
        width: 64px;
        height: 32px;
        background: #2a2a2a;
        border-radius: 16px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border: 2px solid #3a3a3a;
        overflow: hidden;
      }

      .map-theme-toggle:hover {
        border-color: #4a4a4a;
      }

      .map-theme-toggle.light {
        background: #e5e5e5;
        border-color: #d0d0d0;
      }

      .map-theme-toggle.light:hover {
        border-color: #c0c0c0;
      }

      /* 滑动圆圈 */
      .map-theme-toggle-circle {
        position: absolute;
        top: 2px;
        left: 2px;
        width: 24px;
        height: 24px;
        background: #fff;
        border-radius: 50%;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      }

      .map-theme-toggle.light .map-theme-toggle-circle {
        left: 34px;
        background: #000;
      }

      /* 月亮/太阳图标 */
      .map-theme-toggle-icon {
        width: 16px;
        height: 16px;
        display: block;
        flex-shrink: 0;
      }

      /* 暗色模式：月亮图标（填充） */
      .map-theme-toggle-icon {
        fill: #000;
        stroke: none;
      }

      /* 亮色模式：太阳图标（描边） */
      .map-theme-toggle.light .map-theme-toggle-icon {
        fill: none;
        stroke: #fff;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
      }

      /* ==================== 自定义头像管理 ==================== */
      .map-app-setting-section {
        padding: 24px 0 0;
        border-top: 1px solid #2a2a2a;
        margin-top: 16px;
      }

      .map-app-setting-section-title {
        font-size: 16px;
        font-weight: 600;
        color: #e5e5e5;
        letter-spacing: -0.2px;
        margin-bottom: 4px;
      }

      .map-app-setting-section-desc {
        font-size: 13px;
        color: #8e8e8e;
        line-height: 1.4;
        margin-bottom: 16px;
      }

      .map-avatar-add-form {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .map-avatar-url-input {
        width: 100%;
        padding: 12px 16px;
        background: #0a0a0a;
        border: 1px solid #2a2a2a;
        border-radius: 10px;
        color: #e5e5e5;
        font-size: 14px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        transition: all 0.2s ease;
        box-sizing: border-box;
      }

      .map-avatar-url-input:focus {
        outline: none;
        border-color: #4a4a4a;
        background: #0f0f0f;
      }

      .map-avatar-url-input::placeholder {
        color: #666;
      }

      .map-avatar-category-selector {
        display: flex;
        gap: 8px;
      }

      .map-avatar-category-option {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 10px 16px;
        background: #0a0a0a;
        border: 1.5px solid #2a2a2a;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.2s ease;
        position: relative;
      }

      .map-avatar-category-option:hover {
        border-color: #3a3a3a;
        background: #0f0f0f;
      }

      .map-avatar-category-option input[type="radio"] {
        position: absolute;
        opacity: 0;
        pointer-events: none;
      }

      .map-avatar-category-option input[type="radio"]:checked + .map-avatar-category-label {
        color: #000;
      }

      .map-avatar-category-option:has(input[type="radio"]:checked) {
        background: #fff;
        border-color: #fff;
      }

      .map-avatar-category-label {
        font-size: 14px;
        font-weight: 600;
        color: #8e8e8e;
        transition: color 0.2s ease;
      }

      .map-avatar-add-btn {
        width: 100%;
        padding: 12px;
        background: #fff;
        border: none;
        border-radius: 10px;
        color: #000;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .map-avatar-add-btn:hover {
        background: #f0f0f0;
        transform: translateY(-1px);
      }

      .map-avatar-add-btn:active {
        background: #e0e0e0;
        transform: translateY(0);
      }

      .map-avatar-list {
        margin-top: 16px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-height: 300px;
        overflow-y: auto;
      }

      .map-avatar-list::-webkit-scrollbar {
        width: 6px;
      }

      .map-avatar-list::-webkit-scrollbar-track {
        background: transparent;
      }

      .map-avatar-list::-webkit-scrollbar-thumb {
        background: #2a2a2a;
        border-radius: 3px;
      }

      .map-avatar-list::-webkit-scrollbar-thumb:hover {
        background: #3a3a3a;
      }

      .map-avatar-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px 12px;
        background: #0a0a0a;
        border: 1px solid #1a1a1a;
        border-radius: 10px;
        transition: all 0.2s ease;
      }

      .map-avatar-item:hover {
        background: #0f0f0f;
        border-color: #2a2a2a;
      }

      .map-avatar-thumb {
        width: 40px;
        height: 40px;
        border-radius: 8px;
        object-fit: cover;
        border: 1px solid #2a2a2a;
        flex-shrink: 0;
      }

      .map-avatar-info {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .map-avatar-url {
        font-size: 13px;
        color: #8e8e8e;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .map-avatar-category-badge {
        display: inline-block;
        padding: 2px 8px;
        background: #1a1a1a;
        border: 1px solid #2a2a2a;
        border-radius: 6px;
        font-size: 11px;
        font-weight: 600;
        color: #8e8e8e;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        width: fit-content;
      }

      .map-avatar-delete-btn {
        width: 32px;
        height: 32px;
        background: transparent;
        border: 1px solid #2a2a2a;
        border-radius: 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        flex-shrink: 0;
      }

      .map-avatar-delete-btn:hover {
        background: #1a1a1a;
        border-color: #3a3a3a;
      }

      .map-avatar-delete-btn:active {
        background: #0a0a0a;
        transform: scale(0.95);
      }

      .map-avatar-delete-btn svg {
        width: 16px;
        height: 16px;
        stroke: #e5e5e5;
        fill: none;
        stroke-width: 2;
        stroke-linecap: round;
      }

      /* ==================== 地标管理 CSS ==================== */

      .map-landmark-section {
        margin-bottom: 32px;
      }

      .map-landmark-mode-toggle {
        display: flex;
        gap: 8px;
        margin-bottom: 16px;
      }

      .map-landmark-mode-btn {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 10px 16px;
        background: #0a0a0a;
        border: 1.5px solid #2a2a2a;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 14px;
        font-weight: 600;
        color: #8e8e8e;
      }

      .map-landmark-mode-btn:hover {
        border-color: #3a3a3a;
        background: #0f0f0f;
      }

      .map-landmark-mode-btn.active {
        background: #fff;
        border-color: #fff;
        color: #000;
      }

      .map-landmark-custom-form,
      .map-landmark-ai-form {
        display: none;
        flex-direction: column;
        gap: 12px;
      }

      .map-landmark-custom-form.active,
      .map-landmark-ai-form.active {
        display: flex;
      }

      .map-landmark-name-input,
      .map-landmark-desc-input,
      .map-landmark-ai-input {
        width: 100%;
        padding: 12px 16px;
        background: #0a0a0a;
        border: 1px solid #2a2a2a;
        border-radius: 10px;
        color: #e5e5e5;
        font-size: 14px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        transition: all 0.2s ease;
        box-sizing: border-box;
      }

      .map-landmark-desc-input,
      .map-landmark-ai-input {
        min-height: 80px;
        resize: vertical;
      }

      .map-landmark-name-input:focus,
      .map-landmark-desc-input:focus,
      .map-landmark-ai-input:focus {
        outline: none;
        border-color: #4a4a4a;
        background: #0f0f0f;
      }

      .map-landmark-name-input::placeholder,
      .map-landmark-desc-input::placeholder,
      .map-landmark-ai-input::placeholder {
        color: #666;
      }

      .map-landmark-icon-color-row {
        display: flex;
        gap: 12px;
      }

      .map-landmark-icon-selector {
        /* 平均分配空间，对称布局 */
        flex: 1;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .map-landmark-icon-preview {
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #0a0a0a;
        border: 1px solid #2a2a2a;
        border-radius: 8px;
        font-size: 20px;
      }

      .map-landmark-icon-input {
        /* emoji只需要1-2个字符，固定宽度即可 */
        width: 80px;
        padding: 10px 14px;
        background: #0a0a0a;
        border: 1px solid #2a2a2a;
        border-radius: 10px;
        color: #e5e5e5;
        font-size: 14px;
        text-align: center;
        transition: all 0.2s ease;
      }

      .map-landmark-icon-input:focus {
        outline: none;
        border-color: #4a4a4a;
        background: #0f0f0f;
      }

      .map-landmark-color-picker-wrapper {
        /* 平均分配空间，对称布局 */
        flex: 1;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .map-landmark-color-preview {
        width: 40px;
        height: 40px;
        border-radius: 8px;
        border: 1px solid #2a2a2a;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .map-landmark-color-preview:hover {
        transform: scale(1.05);
        border-color: #4a4a4a;
      }

      .map-landmark-color-input {
        /* 固定宽度100px，足够显示7个字符的颜色代码，不会溢出弹窗 */
        width: 100px;
        padding: 10px;
        background: #0a0a0a;
        border: 1px solid #2a2a2a;
        border-radius: 10px;
        color: #e5e5e5;
        font-size: 13px;
        transition: all 0.2s ease;
      }

      .map-landmark-color-input:focus {
        outline: none;
        border-color: #4a4a4a;
        background: #0f0f0f;
      }

      .map-landmark-pick-position {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .map-landmark-pick-btn {
        width: 100%;
        padding: 12px;
        background: #1a1a1a;
        border: 1px solid #2a2a2a;
        border-radius: 10px;
        color: #e5e5e5;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      .map-landmark-pick-btn:hover {
        background: #2a2a2a;
        border-color: #3a3a3a;
      }

      .map-landmark-pick-btn.active {
        background: #fff;
        color: #000;
        border-color: #fff;
      }

      .map-landmark-position-display {
        padding: 10px 14px;
        background: #0a0a0a;
        border: 1px solid #2a2a2a;
        border-radius: 10px;
        font-size: 13px;
        color: #8e8e8e;
        text-align: center;
      }

      .map-landmark-position-display.has-position {
        color: #e5e5e5;
      }

      .map-landmark-save-btn,
      .map-landmark-generate-btn {
        width: 100%;
        padding: 12px;
        background: #fff;
        border: none;
        border-radius: 10px;
        color: #000;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .map-landmark-save-btn:hover,
      .map-landmark-generate-btn:hover {
        background: #f0f0f0;
        transform: translateY(-1px);
      }

      .map-landmark-save-btn:active,
      .map-landmark-generate-btn:active {
        background: #e0e0e0;
        transform: translateY(0);
      }

      .map-landmark-save-btn:disabled,
      .map-landmark-generate-btn:disabled {
        background: #2a2a2a;
        color: #666;
        cursor: not-allowed;
        transform: none;
      }

      /* 地图选点模式提示条 */
      .map-landmark-pick-hint {
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        padding: 14px 28px;
        background: rgba(0, 0, 0, 0.92);
        backdrop-filter: blur(10px);
        border-radius: 16px;
        color: #fff;
        font-size: 15px;
        font-weight: 600;
        z-index: 9999;
        display: none;
        align-items: center;
        gap: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        pointer-events: none;
        animation: slideDown 0.3s ease;
        white-space: nowrap;
      }

      @keyframes slideDown {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(-20px);
        }
        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }

      .map-landmark-pick-hint.active {
        display: flex;
      }

      .map-landmark-cancel-btn {
        padding: 6px 14px;
        background: rgba(255, 255, 255, 0.12);
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 10px;
        color: #fff;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        pointer-events: auto;
        flex-shrink: 0;
      }

      .map-landmark-cancel-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.5);
      }

      .map-landmark-cancel-btn:active {
        transform: scale(0.95);
      }

      /* 地图选点模式：地图区域光标 */
      .map-area.picking-landmark {
        cursor: crosshair;
      }

      /* 地标列表 */
      .map-landmark-list {
        margin-top: 16px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-height: 400px;
        overflow-y: auto;
      }

      .map-landmark-list::-webkit-scrollbar {
        width: 6px;
      }

      .map-landmark-list::-webkit-scrollbar-track {
        background: transparent;
      }

      .map-landmark-list::-webkit-scrollbar-thumb {
        background: #2a2a2a;
        border-radius: 3px;
      }

      .map-landmark-list::-webkit-scrollbar-thumb:hover {
        background: #3a3a3a;
      }

      .map-landmark-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        background: #0a0a0a;
        border: 1px solid #1a1a1a;
        border-radius: 10px;
        transition: all 0.2s ease;
      }

      .map-landmark-item:hover {
        background: #0f0f0f;
        border-color: #2a2a2a;
      }

      .map-landmark-item.selected {
        background: #1a1a1a;
        border-color: #3a3a3a;
      }

      .map-landmark-checkbox {
        width: 20px;
        height: 20px;
        border: 2px solid #2a2a2a;
        border-radius: 6px;
        background: transparent;
        cursor: pointer;
        transition: all 0.2s ease;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .map-landmark-checkbox:hover {
        border-color: #4a4a4a;
      }

      .map-landmark-checkbox.checked {
        background: #fff;
        border-color: #fff;
      }

      .map-landmark-checkbox.checked::after {
        content: '✓';
        color: #000;
        font-size: 14px;
        font-weight: bold;
      }

      .map-landmark-icon-display {
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 10px;
        font-size: 24px;
        flex-shrink: 0;
        border: 1px solid #2a2a2a;
      }

      .map-landmark-info {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .map-landmark-name {
        font-size: 15px;
        font-weight: 600;
        color: #e5e5e5;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .map-landmark-desc {
        font-size: 13px;
        color: #8e8e8e;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        line-height: 1.3;
      }

      .map-landmark-position-badge {
        display: inline-block;
        padding: 2px 8px;
        background: #1a1a1a;
        border: 1px solid #2a2a2a;
        border-radius: 6px;
        font-size: 11px;
        font-weight: 600;
        color: #8e8e8e;
        letter-spacing: 0.3px;
        width: fit-content;
        margin-top: 2px;
      }

      .map-landmark-actions {
        display: flex;
        gap: 6px;
        flex-shrink: 0;
      }

      .map-landmark-edit-btn,
      .map-landmark-delete-btn {
        width: 32px;
        height: 32px;
        background: transparent;
        border: 1px solid #2a2a2a;
        border-radius: 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        flex-shrink: 0;
      }

      .map-landmark-edit-btn:hover {
        background: #1a1a1a;
        border-color: #3a3a3a;
      }

      .map-landmark-delete-btn:hover {
        background: #2a0000;
        border-color: #5a0000;
      }

      .map-landmark-edit-btn:active,
      .map-landmark-delete-btn:active {
        transform: scale(0.95);
      }

      .map-landmark-edit-btn svg,
      .map-landmark-delete-btn svg {
        width: 16px;
        height: 16px;
        stroke: #e5e5e5;
        fill: none;
        stroke-width: 2;
        stroke-linecap: round;
      }

      /* 批量操作栏 */
      .map-landmark-batch-actions {
        display: none;
        align-items: center;
        gap: 12px;
        padding: 12px;
        background: #0a0a0a;
        border: 1px solid #2a2a2a;
        border-radius: 10px;
        margin-bottom: 12px;
      }

      .map-landmark-batch-actions.active {
        display: flex;
      }

      .map-landmark-select-all-btn {
        padding: 8px 14px;
        background: #1a1a1a;
        border: 1px solid #2a2a2a;
        border-radius: 8px;
        color: #e5e5e5;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .map-landmark-select-all-btn:hover {
        background: #2a2a2a;
        border-color: #3a3a3a;
      }

      .map-landmark-selected-count {
        flex: 1;
        font-size: 13px;
        color: #8e8e8e;
      }

      .map-landmark-batch-delete-btn {
        padding: 8px 16px;
        background: #3a0000;
        border: 1px solid #5a0000;
        border-radius: 8px;
        color: #ff6b6b;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .map-landmark-batch-delete-btn:hover {
        background: #5a0000;
        border-color: #7a0000;
        color: #ff8888;
      }

      .map-landmark-batch-delete-btn:active {
        transform: scale(0.97);
      }

      .map-landmark-batch-delete-btn:disabled {
        background: #1a1a1a;
        border-color: #2a2a2a;
        color: #666;
        cursor: not-allowed;
      }

      /* 亮色主题覆盖 */
      #x-map-container.light-theme {
        /* CSS变量会自动切换 */
      }

      #x-map-container.light-theme .map-app-settings-content {
        background: #fff;
        box-shadow: 0 16px 64px rgba(0, 0, 0, 0.2);
      }

      #x-map-container.light-theme .map-app-settings-header {
        background: #fff;
        border-bottom-color: #efefef;
      }

      #x-map-container.light-theme .map-app-settings-title {
        color: #262626;
      }

      #x-map-container.light-theme .map-app-settings-close-btn svg {
        stroke: #262626;
      }

      #x-map-container.light-theme .map-app-settings-close-btn:hover {
        background: rgba(0, 0, 0, 0.05);
      }

      #x-map-container.light-theme .map-app-settings-close-btn:active {
        background: rgba(0, 0, 0, 0.08);
      }

      #x-map-container.light-theme .map-app-settings-body {
        background: #fff;
      }

      /* 滚动条样式 - 日间模式 */
      #x-map-container.light-theme .map-app-settings-body::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.15);
      }

      #x-map-container.light-theme .map-app-settings-body::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 0, 0, 0.25);
      }

      #x-map-container.light-theme .map-app-setting-item {
        border-bottom-color: #efefef;
      }

      #x-map-container.light-theme .map-app-setting-label-text {
        color: #262626;
      }

      #x-map-container.light-theme .map-app-setting-label-desc {
        color: #8e8e8e;
      }

      /* 亮色主题：自定义头像管理 */
      #x-map-container.light-theme .map-app-setting-section {
        border-top-color: #efefef;
      }

      #x-map-container.light-theme .map-app-setting-section-title {
        color: #262626;
      }

      #x-map-container.light-theme .map-avatar-url-input {
        background: #f5f5f5;
        border-color: #e0e0e0;
        color: #262626;
      }

      #x-map-container.light-theme .map-avatar-url-input:focus {
        border-color: #c0c0c0;
        background: #efefef;
      }

      #x-map-container.light-theme .map-avatar-category-option {
        background: #f5f5f5;
        border-color: #e0e0e0;
      }

      #x-map-container.light-theme .map-avatar-category-option:hover {
        border-color: #c0c0c0;
        background: #efefef;
      }

      #x-map-container.light-theme .map-avatar-category-option:has(input[type="radio"]:checked) {
        background: #000;
        border-color: #000;
      }

      #x-map-container.light-theme .map-avatar-category-option input[type="radio"]:checked + .map-avatar-category-label {
        color: #fff;
      }

      #x-map-container.light-theme .map-avatar-add-btn {
        background: #000;
        color: #fff;
      }

      #x-map-container.light-theme .map-avatar-add-btn:hover {
        background: #262626;
      }

      #x-map-container.light-theme .map-avatar-add-btn:active {
        background: #1a1a1a;
      }

      #x-map-container.light-theme .map-avatar-list::-webkit-scrollbar-thumb {
        background: #d0d0d0;
      }

      #x-map-container.light-theme .map-avatar-list::-webkit-scrollbar-thumb:hover {
        background: #b0b0b0;
      }

      #x-map-container.light-theme .map-avatar-item {
        background: #f5f5f5;
        border-color: #e8e8e8;
      }

      #x-map-container.light-theme .map-avatar-item:hover {
        background: #efefef;
        border-color: #d0d0d0;
      }

      #x-map-container.light-theme .map-avatar-thumb {
        border-color: #e0e0e0;
      }

      #x-map-container.light-theme .map-avatar-url {
        color: #666;
      }

      #x-map-container.light-theme .map-avatar-category-badge {
        background: #e8e8e8;
        border-color: #d0d0d0;
        color: #666;
      }

      #x-map-container.light-theme .map-avatar-delete-btn {
        border-color: #d0d0d0;
      }

      #x-map-container.light-theme .map-avatar-delete-btn:hover {
        background: #e8e8e8;
        border-color: #c0c0c0;
      }

      #x-map-container.light-theme .map-avatar-delete-btn:active {
        background: #d8d8d8;
      }

      #x-map-container.light-theme .map-avatar-delete-btn svg {
        stroke: #262626;
      }

      /* ==================== 亮色主题：地标管理 ==================== */

      #x-map-container.light-theme .map-landmark-mode-btn {
        background: #f5f5f5;
        border-color: #e0e0e0;
        color: #666;
      }

      #x-map-container.light-theme .map-landmark-mode-btn:hover {
        border-color: #c0c0c0;
        background: #efefef;
      }

      #x-map-container.light-theme .map-landmark-mode-btn.active {
        background: #000;
        border-color: #000;
        color: #fff;
      }

      #x-map-container.light-theme .map-landmark-name-input,
      #x-map-container.light-theme .map-landmark-desc-input,
      #x-map-container.light-theme .map-landmark-ai-input {
        background: #f5f5f5;
        border-color: #e0e0e0;
        color: #262626;
      }

      #x-map-container.light-theme .map-landmark-name-input:focus,
      #x-map-container.light-theme .map-landmark-desc-input:focus,
      #x-map-container.light-theme .map-landmark-ai-input:focus {
        border-color: #c0c0c0;
        background: #efefef;
      }

      #x-map-container.light-theme .map-landmark-name-input::placeholder,
      #x-map-container.light-theme .map-landmark-desc-input::placeholder,
      #x-map-container.light-theme .map-landmark-ai-input::placeholder {
        color: #999;
      }

      #x-map-container.light-theme .map-landmark-icon-preview {
        background: #f5f5f5;
        border-color: #e0e0e0;
      }

      #x-map-container.light-theme .map-landmark-icon-input,
      #x-map-container.light-theme .map-landmark-color-input {
        background: #f5f5f5;
        border-color: #e0e0e0;
        color: #262626;
      }

      #x-map-container.light-theme .map-landmark-icon-input:focus,
      #x-map-container.light-theme .map-landmark-color-input:focus {
        border-color: #c0c0c0;
        background: #efefef;
      }

      #x-map-container.light-theme .map-landmark-color-preview {
        border-color: #e0e0e0;
      }

      #x-map-container.light-theme .map-landmark-color-preview:hover {
        border-color: #c0c0c0;
      }

      #x-map-container.light-theme .map-landmark-pick-btn {
        background: #e8e8e8;
        border-color: #d0d0d0;
        color: #262626;
      }

      #x-map-container.light-theme .map-landmark-pick-btn:hover {
        background: #d8d8d8;
        border-color: #c0c0c0;
      }

      #x-map-container.light-theme .map-landmark-pick-btn.active {
        background: #000;
        color: #fff;
        border-color: #000;
      }

      #x-map-container.light-theme .map-landmark-position-display {
        background: #f5f5f5;
        border-color: #e0e0e0;
        color: #666;
      }

      #x-map-container.light-theme .map-landmark-position-display.has-position {
        color: #262626;
      }

      #x-map-container.light-theme .map-landmark-save-btn,
      #x-map-container.light-theme .map-landmark-generate-btn {
        background: #000;
        color: #fff;
      }

      #x-map-container.light-theme .map-landmark-save-btn:hover,
      #x-map-container.light-theme .map-landmark-generate-btn:hover {
        background: #262626;
      }

      #x-map-container.light-theme .map-landmark-save-btn:active,
      #x-map-container.light-theme .map-landmark-generate-btn:active {
        background: #1a1a1a;
      }

      #x-map-container.light-theme .map-landmark-save-btn:disabled,
      #x-map-container.light-theme .map-landmark-generate-btn:disabled {
        background: #d0d0d0;
        color: #999;
      }

      #x-map-container.light-theme .map-landmark-pick-overlay {
        background: rgba(255, 255, 255, 0.7);
      }

      #x-map-container.light-theme .map-landmark-pick-hint {
        background: rgba(0, 0, 0, 0.9);
        color: #fff;
      }

      #x-map-container.light-theme .map-landmark-list::-webkit-scrollbar-thumb {
        background: #d0d0d0;
      }

      #x-map-container.light-theme .map-landmark-list::-webkit-scrollbar-thumb:hover {
        background: #b0b0b0;
      }

      #x-map-container.light-theme .map-landmark-item {
        background: #f5f5f5;
        border-color: #e8e8e8;
      }

      #x-map-container.light-theme .map-landmark-item:hover {
        background: #efefef;
        border-color: #d0d0d0;
      }

      #x-map-container.light-theme .map-landmark-item.selected {
        background: #e8e8e8;
        border-color: #c0c0c0;
      }

      #x-map-container.light-theme .map-landmark-checkbox {
        border-color: #d0d0d0;
      }

      #x-map-container.light-theme .map-landmark-checkbox:hover {
        border-color: #b0b0b0;
      }

      #x-map-container.light-theme .map-landmark-checkbox.checked {
        background: #000;
        border-color: #000;
      }

      #x-map-container.light-theme .map-landmark-checkbox.checked::after {
        color: #fff;
      }

      #x-map-container.light-theme .map-landmark-icon-display {
        border-color: #e0e0e0;
      }

      #x-map-container.light-theme .map-landmark-name {
        color: #262626;
      }

      #x-map-container.light-theme .map-landmark-desc {
        color: #666;
      }

      #x-map-container.light-theme .map-landmark-position-badge {
        background: #e8e8e8;
        border-color: #d0d0d0;
        color: #666;
      }

      #x-map-container.light-theme .map-landmark-edit-btn,
      #x-map-container.light-theme .map-landmark-delete-btn {
        border-color: #d0d0d0;
      }

      #x-map-container.light-theme .map-landmark-edit-btn:hover {
        background: #e8e8e8;
        border-color: #c0c0c0;
      }

      #x-map-container.light-theme .map-landmark-delete-btn:hover {
        background: #ffe8e8;
        border-color: #ffb0b0;
      }

      #x-map-container.light-theme .map-landmark-edit-btn:active,
      #x-map-container.light-theme .map-landmark-delete-btn:active {
        background: #d8d8d8;
      }

      #x-map-container.light-theme .map-landmark-edit-btn svg,
      #x-map-container.light-theme .map-landmark-delete-btn svg {
        stroke: #262626;
      }

      #x-map-container.light-theme .map-landmark-batch-actions {
        background: #f5f5f5;
        border-color: #e0e0e0;
      }

      #x-map-container.light-theme .map-landmark-select-all-btn {
        background: #e8e8e8;
        border-color: #d0d0d0;
        color: #262626;
      }

      #x-map-container.light-theme .map-landmark-select-all-btn:hover {
        background: #d8d8d8;
        border-color: #c0c0c0;
      }

      #x-map-container.light-theme .map-landmark-selected-count {
        color: #666;
      }

      #x-map-container.light-theme .map-landmark-batch-delete-btn {
        background: #ffe8e8;
        border-color: #ffb0b0;
        color: #c00000;
      }

      #x-map-container.light-theme .map-landmark-batch-delete-btn:hover {
        background: #ffd0d0;
        border-color: #ff8888;
        color: #a00000;
      }

      #x-map-container.light-theme .map-landmark-batch-delete-btn:disabled {
        background: #e8e8e8;
        border-color: #d0d0d0;
        color: #999;
      }

      #x-map-container.light-theme .map-landmark-pick-hint {
        background: rgba(255, 255, 255, 0.95);
        color: #262626;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        border: 1px solid #e0e0e0;
      }

      #x-map-container.light-theme .map-landmark-cancel-btn {
        background: rgba(0, 0, 0, 0.05);
        border-color: rgba(0, 0, 0, 0.15);
        color: #262626;
      }

      #x-map-container.light-theme .map-landmark-cancel-btn:hover {
        background: rgba(0, 0, 0, 0.1);
        border-color: rgba(0, 0, 0, 0.25);
      }

      /* ==================== 咩三三城市报纸弹窗 - 电视机风格 ==================== */
      /* 报纸遮罩 */
      .map-newspaper-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 599;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .map-newspaper-overlay.show {
        opacity: 1;
        pointer-events: all;
      }

      /* 报纸弹窗主容器 */
      .map-newspaper-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: transparent;
        z-index: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        padding: 20px;
        box-sizing: border-box;
      }

      .map-newspaper-modal.show {
        opacity: 1;
        pointer-events: all;
      }

      /* 报纸容器 - 电视机风格异形设计 */
      .newspaper-container {
        width: 100%;
        max-width: 720px;
        background: #0a0a0a;
        position: relative;
        animation: tvTurnOn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        border-radius: 40px 40px 60px 60px;
        overflow: visible;
        box-shadow:
          0 0 0 3px #fff,
          0 0 0 8px #2a2a2a,
          0 0 0 10px #fff,
          0 20px 60px rgba(255, 255, 255, 0.15);
        padding: 12px;
      }

      #x-map-container.light-theme .newspaper-container {
        background: #fff;
        box-shadow:
          0 0 0 3px #000,
          0 0 0 8px #e0e0e0,
          0 0 0 10px #000,
          0 20px 60px rgba(0, 0, 0, 0.3);
      }

      @keyframes tvTurnOn {
        0% {
          opacity: 0;
          transform: scale(0.8, 0.001) translateY(-100px);
        }
        50% {
          opacity: 1;
          transform: scale(1.05, 0.02) translateY(0);
        }
        100% {
          opacity: 1;
          transform: scale(1, 1) translateY(0);
        }
      }

      /* 电视机扫描线效果 */
      .newspaper-scanline {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          to bottom,
          transparent 50%,
          rgba(255, 255, 255, 0.02) 50%
        );
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 999;
        animation: scanlineMove 8s linear infinite;
        border-radius: 40px 40px 60px 60px;
      }

      #x-map-container.light-theme .newspaper-scanline {
        background: linear-gradient(
          to bottom,
          transparent 50%,
          rgba(0, 0, 0, 0.03) 50%
        );
        background-size: 100% 4px;
      }

      @keyframes scanlineMove {
        0% { transform: translateY(0); }
        100% { transform: translateY(8px); }
      }

      /* 内容屏幕 */
      .newspaper-screen {
        background: #0a0a0a;
        border-radius: 32px 32px 52px 52px;
        overflow: hidden;
        position: relative;
      }

      #x-map-container.light-theme .newspaper-screen {
        background: #fff;
      }

      /* 浏览器风格顶栏 */
      .newspaper-browser-bar {
        background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
        border-bottom: 2px solid #fff;
        padding: 8px 12px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      #x-map-container.light-theme .newspaper-browser-bar {
        background: linear-gradient(180deg, #e8e8e8 0%, #d0d0d0 100%);
        border-bottom-color: #000;
      }

      .newspaper-browser-dots {
        display: flex;
        gap: 6px;
      }

      .newspaper-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        border: 2px solid #fff;
        transition: all 0.2s;
      }

      .newspaper-dot:hover {
        transform: scale(1.2);
      }

      #x-map-container.light-theme .newspaper-dot {
        border-color: #000;
      }

      .newspaper-dot:nth-child(1) { background: #3a3a3a; }
      .newspaper-dot:nth-child(2) { background: #666; }
      .newspaper-dot:nth-child(3) { background: #999; }

      #x-map-container.light-theme .newspaper-dot:nth-child(1) { background: #f5f5f5; }
      #x-map-container.light-theme .newspaper-dot:nth-child(2) { background: #b0b0b0; }
      #x-map-container.light-theme .newspaper-dot:nth-child(3) { background: #808080; }

      .newspaper-url-bar {
        flex: 1;
        background: #1a1a1a;
        border: 2px solid #fff;
        border-radius: 12px;
        padding: 4px 12px;
        font-family: "Courier New", monospace;
        font-size: 11px;
        font-weight: 700;
        color: #fff;
        box-shadow: inset 0 1px 3px rgba(255,255,255,0.1);
      }

      #x-map-container.light-theme .newspaper-url-bar {
        background: #fff;
        border-color: #000;
        color: #000;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
      }

      /* 关闭按钮 */
      .newspaper-close-btn {
        width: 28px;
        height: 28px;
        border: 2px solid #fff;
        background: #1a1a1a;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s;
        clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
      }

      .newspaper-close-btn:hover {
        transform: rotate(90deg);
        background: #fff;
        box-shadow: 0 0 0 2px #000;
      }

      .newspaper-close-btn:hover svg {
        stroke: #000;
      }

      #x-map-container.light-theme .newspaper-close-btn {
        background: #fff;
        border-color: #000;
      }

      #x-map-container.light-theme .newspaper-close-btn:hover {
        background: #000;
        box-shadow: 0 0 0 2px #fff;
      }

      #x-map-container.light-theme .newspaper-close-btn:hover svg {
        stroke: #fff;
      }

      .newspaper-close-btn svg {
        width: 14px;
        height: 14px;
        stroke: #fff;
        stroke-width: 2.5;
        transition: stroke 0.3s;
      }

      #x-map-container.light-theme .newspaper-close-btn svg {
        stroke: #000;
      }

      /* 主内容区 - 博客风格双栏布局 */
      .newspaper-content {
        display: grid;
        grid-template-columns: 1fr 200px;
        gap: 12px;
        padding: 12px;
        max-height: 70vh;
        overflow-y: auto;
        scrollbar-width: thin;
      }

      .newspaper-content::-webkit-scrollbar {
        width: 6px;
      }

      .newspaper-content::-webkit-scrollbar-track {
        background: transparent;
      }

      .newspaper-content::-webkit-scrollbar-thumb {
        background: #3a3a3a;
        border-radius: 3px;
      }

      #x-map-container.light-theme .newspaper-content::-webkit-scrollbar-thumb {
        background: #ccc;
      }

      /* 左侧主栏 */
      .newspaper-main-column {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      /* 右侧边栏 */
      .newspaper-sidebar {
        display: flex;
        flex-direction: column;
        gap: 10px;
        position: sticky;
        top: 0;
        align-self: start;
      }

      /* 头像名片 - 异形设计 */
      .newspaper-profile-card {
        background: linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%);
        border: 2px solid #fff;
        padding: 12px;
        position: relative;
        clip-path: polygon(0 0, 100% 0, 100% 85%, 85% 100%, 0 100%);
        box-shadow: 2px 2px 0 rgba(255,255,255,0.1);
      }

      #x-map-container.light-theme .newspaper-profile-card {
        background: linear-gradient(135deg, #fafafa 0%, #f0f0f0 100%);
        border-color: #000;
        box-shadow: 2px 2px 0 rgba(0,0,0,0.1);
      }

      .newspaper-avatar-box {
        position: relative;
        width: 64px;
        height: 64px;
        margin: 0 auto 8px;
      }

      .newspaper-avatar {
        width: 64px;
        height: 64px;
        border: 3px solid #fff;
        background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 32px;
        clip-path: polygon(20% 0%, 80% 0%, 100% 20%, 100% 80%, 80% 100%, 20% 100%, 0% 80%, 0% 20%);
        animation: avatarFloat 3s ease-in-out infinite;
        box-shadow: inset 0 2px 4px rgba(255,255,255,0.1);
      }

      #x-map-container.light-theme .newspaper-avatar {
        border-color: #000;
        background: linear-gradient(135deg, #e8e8e8 0%, #d0d0d0 100%);
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
      }

      @keyframes avatarFloat {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-6px); }
      }

      .newspaper-status-badge {
        position: absolute;
        bottom: -4px;
        right: -4px;
        background: #fff;
        color: #000;
        font-size: 9px;
        font-weight: 700;
        padding: 3px 7px;
        border-radius: 8px;
        border: 2px solid #0a0a0a;
        letter-spacing: 0.5px;
        box-shadow: 0 2px 4px rgba(255,255,255,0.3);
      }

      #x-map-container.light-theme .newspaper-status-badge {
        background: #000;
        color: #fff;
        border-color: #fff;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      }

      .newspaper-profile-name {
        font-family: "Courier New", monospace;
        font-size: 16px;
        font-weight: 900;
        color: #fff;
        text-align: center;
        margin-bottom: 4px;
        letter-spacing: 1px;
        text-shadow: 1px 1px 0 rgba(255,255,255,0.05);
      }

      #x-map-container.light-theme .newspaper-profile-name {
        color: #000;
        text-shadow: 1px 1px 0 rgba(0,0,0,0.05);
      }

      .newspaper-profile-role {
        font-size: 10px;
        color: #999;
        text-align: center;
        line-height: 1.5;
      }

      #x-map-container.light-theme .newspaper-profile-role {
        color: #666;
      }

      /* 像素风日期时钟 */
      .newspaper-pixel-clock {
        background: #fff;
        color: #000;
        padding: 10px;
        font-family: "Courier New", monospace;
        font-size: 11px;
        text-align: center;
        border: 2px solid #fff;
        position: relative;
        overflow: hidden;
        box-shadow: inset 0 0 10px rgba(255,255,255,0.5);
      }

      #x-map-container.light-theme .newspaper-pixel-clock {
        background: #000;
        color: #fff;
        border-color: #000;
        box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
      }

      .newspaper-pixel-clock::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(0,0,0,0.3), transparent);
        animation: pixelScan 3s infinite;
      }

      #x-map-container.light-theme .newspaper-pixel-clock::before {
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      }

      @keyframes pixelScan {
        0% { left: -100%; }
        100% { left: 100%; }
      }

      .newspaper-clock-date {
        font-weight: 700;
        margin-bottom: 2px;
        letter-spacing: 1px;
      }

      .newspaper-clock-time {
        font-size: 14px;
        font-weight: 900;
        letter-spacing: 2px;
      }

      /* 标签云 - 博客风格 */
      .newspaper-tags-widget {
        background: linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%);
        border: 2px dashed #fff;
        padding: 10px;
        clip-path: polygon(0 10px, 10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%);
      }

      #x-map-container.light-theme .newspaper-tags-widget {
        background: linear-gradient(135deg, #fafafa 0%, #f5f5f5 100%);
        border-color: #000;
      }

      .newspaper-widget-title {
        font-size: 11px;
        font-weight: 900;
        color: #fff;
        margin-bottom: 8px;
        letter-spacing: 1px;
        text-transform: uppercase;
      }

      #x-map-container.light-theme .newspaper-widget-title {
        color: #000;
      }

      .newspaper-tag-cloud {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
      }

      .newspaper-tag {
        font-size: 10px;
        color: #000;
        background: #fff;
        padding: 3px 9px;
        border-radius: 10px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s;
        transform: rotate(calc(var(--random) * 1deg));
        box-shadow: 1px 1px 2px rgba(255,255,255,0.2);
      }

      .newspaper-tag:hover {
        transform: scale(1.15) rotate(0deg);
        box-shadow: 2px 2px 4px rgba(255,255,255,0.3);
      }

      #x-map-container.light-theme .newspaper-tag {
        background: #000;
        color: #fff;
        box-shadow: 1px 1px 2px rgba(0,0,0,0.2);
      }

      #x-map-container.light-theme .newspaper-tag:hover {
        box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      }

      .newspaper-tag:nth-child(1) { --random: -3; }
      .newspaper-tag:nth-child(2) { --random: 2; }
      .newspaper-tag:nth-child(3) { --random: -1; }
      .newspaper-tag:nth-child(4) { --random: 3; }
      .newspaper-tag:nth-child(5) { --random: -2; }

      /* 迷你统计卡片 */
      .newspaper-stats-mini {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 4px;
      }

      .newspaper-stat-item {
        background: linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%);
        border: 2px solid #fff;
        padding: 8px;
        text-align: center;
        clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
        transition: all 0.3s;
        box-shadow: 1px 1px 0 rgba(255,255,255,0.1);
      }

      .newspaper-stat-item:hover {
        transform: scale(1.05) rotate(-2deg);
        box-shadow: 2px 2px 4px rgba(255,255,255,0.2);
      }

      #x-map-container.light-theme .newspaper-stat-item {
        background: linear-gradient(135deg, #fff 0%, #f5f5f5 100%);
        border-color: #000;
        box-shadow: 1px 1px 0 rgba(0,0,0,0.1);
      }

      #x-map-container.light-theme .newspaper-stat-item:hover {
        box-shadow: 2px 2px 4px rgba(0,0,0,0.2);
      }

      .newspaper-stat-value {
        font-family: "Courier New", monospace;
        font-size: 18px;
        font-weight: 900;
        color: #fff;
        text-shadow: 1px 1px 0 rgba(255,255,255,0.05);
      }

      #x-map-container.light-theme .newspaper-stat-value {
        color: #000;
        text-shadow: 1px 1px 0 rgba(0,0,0,0.05);
      }

      .newspaper-stat-label {
        font-size: 9px;
        color: #999;
        font-weight: 700;
        letter-spacing: 0.5px;
        text-transform: uppercase;
        margin-top: 2px;
      }

      #x-map-container.light-theme .newspaper-stat-label {
        color: #666;
      }

      /* 邮件通知 - 信封风格 */
      .newspaper-mail-notice {
        background: #1a1a1a;
        border: 2px solid #fff;
        padding: 10px;
        position: relative;
        transform: rotate(-2deg);
        margin: 4px;
        box-shadow: 3px 3px 0 rgba(255,255,255,0.15);
      }

      #x-map-container.light-theme .newspaper-mail-notice {
        background: #fff;
        border-color: #000;
        box-shadow: 3px 3px 0 rgba(0,0,0,0.15);
      }

      .newspaper-mail-stamp {
        position: absolute;
        top: 4px;
        right: 4px;
        width: 26px;
        height: 26px;
        border: 2px dashed #fff;
        border-radius: 4px;
        font-size: 13px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255,255,255,0.05);
      }

      #x-map-container.light-theme .newspaper-mail-stamp {
        border-color: #000;
        background: rgba(0,0,0,0.02);
      }

      .newspaper-mail-content {
        font-size: 10px;
        color: #fff;
        line-height: 1.6;
        font-family: "Courier New", monospace;
        font-weight: 600;
      }

      #x-map-container.light-theme .newspaper-mail-content {
        color: #000;
      }

      /* 天气预报 - 异形卡片 */
      .newspaper-weather-card {
        background: linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%);
        border: 2px solid #fff;
        padding: 14px;
        clip-path: polygon(0 0, 100% 0, 100% calc(100% - 16px), calc(100% - 16px) 100%, 0 100%);
        position: relative;
        box-shadow: 2px 2px 0 rgba(255,255,255,0.1);
      }

      #x-map-container.light-theme .newspaper-weather-card {
        background: linear-gradient(135deg, #f8f8f8 0%, #e8e8e8 100%);
        border-color: #000;
        box-shadow: 2px 2px 0 rgba(0,0,0,0.1);
      }

      .newspaper-weather-icon-big {
        font-size: 52px;
        text-align: center;
        margin-bottom: 10px;
        animation: weatherBounce 2s ease-in-out infinite;
        filter: drop-shadow(2px 2px 4px rgba(255,255,255,0.2));
      }

      #x-map-container.light-theme .newspaper-weather-icon-big {
        filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.2));
      }

      @keyframes weatherBounce {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.08); }
      }

      .newspaper-weather-temp-big {
        font-family: "Courier New", monospace;
        font-size: 36px;
        font-weight: 900;
        color: #fff;
        text-align: center;
        margin-bottom: 6px;
        text-shadow: 2px 2px 0 rgba(255,255,255,0.05);
      }

      #x-map-container.light-theme .newspaper-weather-temp-big {
        color: #000;
        text-shadow: 2px 2px 0 rgba(0,0,0,0.05);
      }

      .newspaper-weather-desc-big {
        font-size: 12px;
        color: #999;
        text-align: center;
        font-weight: 700;
        letter-spacing: 1px;
      }

      #x-map-container.light-theme .newspaper-weather-desc-big {
        color: #666;
      }

      /* 重大新闻 - 报纸风格 */
      .newspaper-news-card {
        background: #0a0a0a;
        border: 3px double #fff;
        padding: 16px;
        clip-path: polygon(0 8px, 8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%);
        position: relative;
        box-shadow: 3px 3px 0 rgba(255,255,255,0.1);
      }

      #x-map-container.light-theme .newspaper-news-card {
        background: #fff;
        border-color: #000;
        box-shadow: 3px 3px 0 rgba(0,0,0,0.1);
      }

      .newspaper-breaking-badge {
        position: absolute;
        top: -12px;
        left: 14px;
        background: #fff;
        color: #000;
        font-size: 10px;
        font-weight: 900;
        padding: 5px 14px;
        letter-spacing: 2px;
        clip-path: polygon(0 0, 100% 0, 95% 100%, 5% 100%);
        box-shadow: 0 2px 4px rgba(255,255,255,0.3);
      }

      #x-map-container.light-theme .newspaper-breaking-badge {
        background: #000;
        color: #fff;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      }

      .newspaper-news-headline {
        font-family: Georgia, "Times New Roman", serif;
        font-size: 20px;
        font-weight: 900;
        color: #fff;
        line-height: 1.3;
        margin-bottom: 10px;
      }

      #x-map-container.light-theme .newspaper-news-headline {
        color: #000;
      }

      .newspaper-news-meta {
        font-size: 11px;
        color: #666;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 8px;
        font-family: "Courier New", monospace;
      }

      #x-map-container.light-theme .newspaper-news-meta {
        color: #999;
      }

      .newspaper-news-body {
        font-size: 13px;
        line-height: 1.7;
        color: #ccc;
      }

      #x-map-container.light-theme .newspaper-news-body {
        color: #333;
      }

      .newspaper-emoticon-comment {
        font-family: "Courier New", monospace;
        font-size: 12px;
        color: #999;
        font-style: italic;
        margin-top: 10px;
        padding: 8px 10px;
        background: linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%);
        border-left: 3px solid #fff;
        box-shadow: inset 1px 1px 2px rgba(255,255,255,0.05);
      }

      #x-map-container.light-theme .newspaper-emoticon-comment {
        color: #666;
        background: linear-gradient(135deg, #f8f8f8 0%, #f0f0f0 100%);
        border-left-color: #000;
        box-shadow: inset 1px 1px 2px rgba(0,0,0,0.05);
      }

      /* 群众投稿 - 便签纸风格 */
      .newspaper-submission-sticky {
        border: none;
        padding: 12px;
        box-shadow: 4px 4px 10px rgba(0,0,0,0.5);
        transform: rotate(calc(var(--rotate) * 1deg));
        margin: 10px 4px;
        position: relative;
      }

      .newspaper-submission-sticky::before {
        content: '';
        position: absolute;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 45px;
        height: 14px;
        background: linear-gradient(180deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.08) 100%);
        border-radius: 0 0 8px 8px;
      }

      #x-map-container.light-theme .newspaper-submission-sticky::before {
        background: linear-gradient(180deg, rgba(0,0,0,0.15) 0%, rgba(0,0,0,0.05) 100%);
      }

      .newspaper-submission-sticky:nth-child(1) {
        --rotate: -2;
        background: linear-gradient(135deg, #1a1a1a 0%, #141414 100%);
      }
      .newspaper-submission-sticky:nth-child(2) {
        --rotate: 1;
        background: linear-gradient(135deg, #1f1f1f 0%, #181818 100%);
      }
      .newspaper-submission-sticky:nth-child(3) {
        --rotate: -1;
        background: linear-gradient(135deg, #252525 0%, #1c1c1c 100%);
      }
      .newspaper-submission-sticky:nth-child(4) {
        --rotate: 0.5;
        background: linear-gradient(135deg, #2a2a2a 0%, #1e1e1e 100%);
      }

      #x-map-container.light-theme .newspaper-submission-sticky:nth-child(1) {
        background: linear-gradient(135deg, #fff 0%, #fafafa 100%);
      }
      #x-map-container.light-theme .newspaper-submission-sticky:nth-child(2) {
        background: linear-gradient(135deg, #f8f8f8 0%, #f0f0f0 100%);
      }
      #x-map-container.light-theme .newspaper-submission-sticky:nth-child(3) {
        background: linear-gradient(135deg, #fafafa 0%, #f5f5f5 100%);
      }
      #x-map-container.light-theme .newspaper-submission-sticky:nth-child(4) {
        background: linear-gradient(135deg, #fcfcfc 0%, #f8f8f8 100%);
      }

      .newspaper-sticky-tag {
        font-size: 9px;
        font-weight: 900;
        color: #000;
        background: #fff;
        padding: 3px 10px;
        border-radius: 10px;
        display: inline-block;
        margin-bottom: 8px;
        letter-spacing: 1px;
        box-shadow: 1px 1px 2px rgba(255,255,255,0.2);
      }

      #x-map-container.light-theme .newspaper-sticky-tag {
        background: #000;
        color: #fff;
        box-shadow: 1px 1px 2px rgba(0,0,0,0.2);
      }

      .newspaper-sticky-title {
        font-weight: 700;
        font-size: 13px;
        color: #fff;
        margin-bottom: 8px;
      }

      #x-map-container.light-theme .newspaper-sticky-title {
        color: #000;
      }

      .newspaper-sticky-content {
        font-size: 11px;
        color: #999;
        line-height: 1.6;
      }

      #x-map-container.light-theme .newspaper-sticky-content {
        color: #666;
      }

      /* 广告横幅 - 异形 */
      .newspaper-ad-banner-special {
        background: linear-gradient(45deg, #1a1a1a 0%, #0f0f0f 100%);
        border: 2px solid #fff;
        padding: 14px;
        clip-path: polygon(0 0, calc(100% - 20px) 0, 100% 20px, 100% 100%, 20px 100%, 0 calc(100% - 20px));
        position: relative;
        overflow: hidden;
        margin: 10px 0;
        box-shadow: 2px 2px 0 rgba(255,255,255,0.1);
      }

      #x-map-container.light-theme .newspaper-ad-banner-special {
        background: linear-gradient(45deg, #f5f5f5 0%, #e8e8e8 100%);
        border-color: #000;
        box-shadow: 2px 2px 0 rgba(0,0,0,0.1);
      }

      .newspaper-ad-corner {
        position: absolute;
        top: 6px;
        right: 6px;
        font-size: 9px;
        font-weight: 900;
        color: #666;
        letter-spacing: 1px;
        transform: rotate(45deg);
        opacity: 0.5;
      }

      #x-map-container.light-theme .newspaper-ad-corner {
        color: #999;
      }

      .newspaper-ad-title {
        font-weight: 900;
        font-size: 15px;
        color: #fff;
        margin-bottom: 8px;
        font-family: Georgia, serif;
      }

      #x-map-container.light-theme .newspaper-ad-title {
        color: #000;
      }

      .newspaper-ad-text {
        font-size: 11px;
        color: #999;
        line-height: 1.6;
      }

      #x-map-container.light-theme .newspaper-ad-text {
        color: #666;
      }

      /* 联系方式 - 像素风 */
      .newspaper-contact-pixel {
        background: #fff;
        color: #000;
        padding: 12px;
        font-family: "Courier New", monospace;
        font-size: 10px;
        border: 2px solid #fff;
        image-rendering: pixelated;
        box-shadow: inset 0 0 10px rgba(255,255,255,0.5);
      }

      #x-map-container.light-theme .newspaper-contact-pixel {
        background: #000;
        color: #fff;
        border-color: #000;
        box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
      }

      .newspaper-contact-line {
        margin-bottom: 5px;
        letter-spacing: 1px;
        font-weight: 700;
      }

      .newspaper-contact-line:last-child {
        margin-bottom: 0;
      }

      /* 装饰星星 */
      .newspaper-star-deco {
        position: absolute;
        font-size: 14px;
        animation: starTwinkle 2s ease-in-out infinite;
        filter: drop-shadow(0 0 3px currentColor);
      }

      @keyframes starTwinkle {
        0%, 100% { opacity: 0.4; transform: scale(1) rotate(0deg); }
        50% { opacity: 1; transform: scale(1.3) rotate(180deg); }
      }

      .newspaper-star-deco:nth-child(1) { top: 5%; left: 5%; animation-delay: 0s; color: #fff; }
      .newspaper-star-deco:nth-child(2) { top: 15%; right: 8%; animation-delay: 0.5s; color: #fff; }
      .newspaper-star-deco:nth-child(3) { top: 60%; left: 3%; animation-delay: 1s; color: #fff; }
      .newspaper-star-deco:nth-child(4) { bottom: 20%; right: 5%; animation-delay: 1.5s; color: #fff; }

      #x-map-container.light-theme .newspaper-star-deco {
        color: #000;
      }

      /* 对话框装饰 */
      .newspaper-speech-bubble {
        position: relative;
        background: linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%);
        border: 2px solid #fff;
        padding: 10px;
        border-radius: 12px;
        margin: 10px 0;
        font-size: 11px;
        color: #fff;
        box-shadow: 2px 2px 0 rgba(255,255,255,0.1);
      }

      #x-map-container.light-theme .newspaper-speech-bubble {
        background: linear-gradient(135deg, #fff 0%, #f8f8f8 100%);
        border-color: #000;
        color: #000;
        box-shadow: 2px 2px 0 rgba(0,0,0,0.1);
      }

      .newspaper-speech-bubble::after {
        content: '';
        position: absolute;
        bottom: -12px;
        left: 22px;
        width: 0;
        height: 0;
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-top: 12px solid #fff;
      }

      #x-map-container.light-theme .newspaper-speech-bubble::after {
        border-top-color: #000;
      }

      /* 像素装饰点 */
      .newspaper-pixel-dots {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        pointer-events: none;
        z-index: 1;
      }

      .newspaper-pixel-dot {
        position: absolute;
        width: 3px;
        height: 3px;
        background: #fff;
        opacity: 0.15;
        image-rendering: pixelated;
      }

      #x-map-container.light-theme .newspaper-pixel-dot {
        background: #000;
        opacity: 0.1;
      }

      /* 底部签名 */
      .newspaper-footer-sig {
        text-align: center;
        font-size: 11px;
        color: #666;
        font-style: italic;
        padding: 14px;
        margin-top: 10px;
        border-top: 2px dashed #333;
        font-family: "Courier New", monospace;
      }

      #x-map-container.light-theme .newspaper-footer-sig {
        border-top-color: #e0e0e0;
        color: #999;
      }

      /* 移动端适配 */
      @media (max-width: 768px) {
        .newspaper-content {
          grid-template-columns: 1fr;
          gap: 10px;
          padding: 10px;
        }

        .newspaper-sidebar {
          position: static;
          order: -1;
        }

        .newspaper-profile-card,
        .newspaper-tags-widget,
        .newspaper-mail-notice {
          transform: rotate(0);
        }

        .newspaper-submission-sticky {
          transform: rotate(0);
          margin: 8px 0;
        }
      }

    /* ==================== 亮色主题：提醒功能 - Toast风格 ==================== */
      #x-map-container.light-theme .map-notifications-badge {
        background: #000;
      }
        
      #x-map-container.light-theme .map-notifications-content {
        background: #fff;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
      }

      #x-map-container.light-theme .map-notifications-header {
        background: #fff;
      }

      #x-map-container.light-theme .map-notifications-title {
        color: #000;
      }

      #x-map-container.light-theme .map-notifications-close-btn {
        background: #f5f5f5;
      }

      #x-map-container.light-theme .map-notifications-close-btn svg {
        stroke: #000;
      }

      #x-map-container.light-theme .map-notifications-close-btn:hover {
        background: #e8e8e8;
      }

      #x-map-container.light-theme .map-notifications-close-btn:active {
        background: #d8d8d8;
      }

      /* 统计卡片 - 亮色 */
      #x-map-container.light-theme .map-notifications-stats {
        background: #f5f5f5;
      }

      #x-map-container.light-theme .map-notifications-stats-icon {
        background: #000;
      }

      #x-map-container.light-theme .map-notifications-stats-icon svg {
        stroke: #fff;
      }

      #x-map-container.light-theme .map-notifications-stats-label {
        color: #666;
      }

      #x-map-container.light-theme .map-notifications-stats-count {
        color: #000;
      }

      /* 分类Tabs - 亮色 */
      #x-map-container.light-theme .map-notifications-tab {
        border-color: #e0e0e0;
        color: #999;
      }

      #x-map-container.light-theme .map-notifications-tab.active {
        background: #000;
        border-color: #000;
        color: #fff;
      }

      /* 列表容器 - 亮色 */
      #x-map-container.light-theme .map-notifications-list-container {
        background: #fff;
      }

      #x-map-container.light-theme .map-notifications-list-container::-webkit-scrollbar-thumb {
        background: #d0d0d0;
      }

      #x-map-container.light-theme .map-notifications-list-container::-webkit-scrollbar-thumb:hover {
        background: #b0b0b0;
      }

      /* 通知项 - 亮色 Toast风格 */
      #x-map-container.light-theme .map-notification-item {
        background: #fafafa;
        border-color: #e8e8e8;
      }

      #x-map-container.light-theme .map-notification-item:hover {
        background: #f5f5f5;
        border-color: #d0d0d0;
      }

      #x-map-container.light-theme .map-notification-item:active {
        background: #fafafa;
      }

      /* 未读标识 - 亮色 */
      #x-map-container.light-theme .map-notification-item.unread {
        border-left-color: #000;
      }

      /* 通知图标 - 亮色 */
      #x-map-container.light-theme .map-notification-icon {
        background: #f0f0f0;
      }

      #x-map-container.light-theme .map-notification-icon svg {
        stroke: #000;
      }

      /* 通知文本 - 亮色 */
      #x-map-container.light-theme .map-notification-title {
        color: #000;
      }

      #x-map-container.light-theme .map-notification-time {
        color: #999;
      }

      #x-map-container.light-theme .map-notification-content {
        color: #666;
      }

      /* 空状态 - 亮色 */
      #x-map-container.light-theme .map-notifications-empty {
        background: #fff;
      }

      #x-map-container.light-theme .map-notifications-empty-icon {
        background: #f5f5f5;
      }

      #x-map-container.light-theme .map-notifications-empty-icon svg {
        stroke: #ccc;
      }

      #x-map-container.light-theme .map-notifications-empty-text {
        color: #999;
      }

      /* ==================== 亮色主题：接收私信确认弹窗 ==================== */
      #x-map-container.light-theme .map-accept-message-content {
        background: #fff;
        box-shadow: 0 12px 48px rgba(0, 0, 0, 0.3);
      }

      #x-map-container.light-theme .map-accept-message-header {
        background: #fff;
      }

      #x-map-container.light-theme .map-accept-message-avatar {
        border-color: #dbdbdb;
      }

      #x-map-container.light-theme .map-accept-message-user-info h3 {
        color: #262626;
      }

      #x-map-container.light-theme .map-accept-message-text {
        background: #f5f5f5;
        color: #262626;
        border-color: #ebebeb;
      }

      #x-map-container.light-theme .map-accept-message-text::-webkit-scrollbar-thumb {
        background: #dbdbdb;
      }

      #x-map-container.light-theme .map-accept-message-actions {
        background: #fff;
        border-top-color: #efefef;
      }

      #x-map-container.light-theme .map-accept-btn {
        background: #000;
        color: #fff;
      }

      #x-map-container.light-theme .map-accept-btn:hover {
        background: #1a1a1a;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
      }

      #x-map-container.light-theme .map-accept-btn:active {
        background: #0a0a0a;
      }

      #x-map-container.light-theme .map-decline-btn {
        background: #fff;
        color: #262626;
        border-color: #dbdbdb;
      }

      #x-map-container.light-theme .map-decline-btn:hover {
        background: #f5f5f5;
        border-color: #c0c0c0;
      }

      #x-map-container.light-theme .map-decline-btn:active {
        background: #ebebeb;
      }

      /* ==================== 亮色主题：举报弹窗 ==================== */
      #x-map-container.light-theme .map-report-content {
        background: #fff;
        box-shadow: 0 16px 56px rgba(0, 0, 0, 0.25);
      }

      #x-map-container.light-theme .map-report-header {
        background: #fff;
        border-bottom-color: #efefef;
      }

      #x-map-container.light-theme .map-report-title {
        color: #262626;
      }

      #x-map-container.light-theme .map-report-close-btn:hover {
        background: rgba(0, 0, 0, 0.05);
      }

      #x-map-container.light-theme .map-report-close-btn:hover svg {
        stroke: #262626;
      }

      #x-map-container.light-theme .map-report-close-btn:active {
        background: rgba(0, 0, 0, 0.08);
      }

      #x-map-container.light-theme .map-report-body {
        background: #fff;
      }

      #x-map-container.light-theme .map-report-body::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.15);
      }

      #x-map-container.light-theme .map-report-body::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 0, 0, 0.25);
      }

      #x-map-container.light-theme .map-report-user-info {
        background: #f9f9f9;
        border-color: #efefef;
      }

      #x-map-container.light-theme .map-report-user-avatar {
        border-color: #dbdbdb;
      }

      #x-map-container.light-theme .map-report-user-details h4 {
        color: #262626;
      }

      #x-map-container.light-theme .map-report-section-label {
        color: #262626;
      }

      #x-map-container.light-theme .map-report-reason-item {
        background: #f9f9f9;
        border-color: #efefef;
      }

      #x-map-container.light-theme .map-report-reason-item:hover {
        background: #f5f5f5;
        border-color: #e0e0e0;
      }

      #x-map-container.light-theme .map-report-reason-item input[type="checkbox"] {
        background: #fff;
        border-color: #c0c0c0;
      }

      #x-map-container.light-theme .map-report-reason-item input[type="checkbox"]:checked {
        background: #000;
        border-color: #000;
      }

      #x-map-container.light-theme .map-report-reason-item input[type="checkbox"]:checked::after {
        border-color: #fff;
      }

      #x-map-container.light-theme .map-report-reason-item input[type="checkbox"]:hover {
        border-color: #8e8e8e;
      }

      #x-map-container.light-theme .map-report-reason-text {
        color: #262626;
      }

      #x-map-container.light-theme .map-report-textarea {
        background: #f9f9f9;
        border-color: #efefef;
        color: #262626;
      }

      #x-map-container.light-theme .map-report-textarea::placeholder {
        color: #8e8e8e;
      }

      #x-map-container.light-theme .map-report-textarea:focus {
        border-color: #e0e0e0;
        background: #f5f5f5;
      }

      #x-map-container.light-theme .map-report-textarea::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.15);
      }

      #x-map-container.light-theme .map-report-actions {
        background: #fff;
        border-top-color: #efefef;
      }

      #x-map-container.light-theme .map-report-cancel-btn {
        background: #fff;
        color: #262626;
        border-color: #dbdbdb;
      }

      #x-map-container.light-theme .map-report-cancel-btn:hover {
        background: #f5f5f5;
        border-color: #c0c0c0;
      }

      #x-map-container.light-theme .map-report-cancel-btn:active {
        background: #ebebeb;
      }

      #x-map-container.light-theme .map-report-submit-btn {
        background: #000;
        color: #fff;
      }

      #x-map-container.light-theme .map-report-submit-btn:hover {
        background: #1a1a1a;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      #x-map-container.light-theme .map-report-submit-btn:active {
        background: #0a0a0a;
      }

      #x-map-container.light-theme .map-report-submit-btn:disabled {
        background: #dbdbdb;
        color: #8e8e8e;
      }

      /* ==================== 亮色主题：侧边栏 ==================== */
      #x-map-container.light-theme .map-sidebar {
        box-shadow: 2px 0 8px rgba(0,0,0,0.15);
      }

      #x-map-container.light-theme .map-user-list::-webkit-scrollbar-thumb {
        background: #d0d0d0;
      }

      #x-map-container.light-theme .map-user-list::-webkit-scrollbar-thumb:hover {
        background: #b0b0b0;
      }

      /* 亮色主题下的按钮颜色调整 */
      #x-map-container.light-theme .map-app-settings-btn svg,
      #x-map-container.light-theme .map-notifications-btn svg,
      #x-map-container.light-theme .map-newspaper-btn svg,
      #x-map-container.light-theme .map-ride-btn svg,
      #x-map-container.light-theme .map-chats-btn svg,
      #x-map-container.light-theme .map-close-btn svg {
        stroke: #000;
        filter: drop-shadow(0 1px 3px rgba(255,255,255,0.6));
      }

      #x-map-container.light-theme .map-refresh-btn svg {
        fill: #000;
        filter: drop-shadow(0 1px 3px rgba(255,255,255,0.6));
      }

      #x-map-container.light-theme .map-notifications-badge {
        background: #fff;
        color: #000;
        border: 2px solid rgba(255, 255, 255, 0.8);
      }

      /* ==================== 亮色主题：地图控制和标记 ==================== */
      #x-map-container.light-theme .map-control-btn {
        background: #fff;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      }

      #x-map-container.light-theme .map-control-btn:active {
        background: #e8e8e8;
      }

      #x-map-container.light-theme .map-control-btn svg {
        fill: #000;
      }

      #x-map-container.light-theme .map-weather-info {
        background: #fff;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      }

      #x-map-container.light-theme .landmark-label {
        background: rgba(0, 0, 0, 0.15);
        color: #000;
        border: 1px solid rgba(0, 0, 0, 0.3);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15),
                    0 2px 8px rgba(0, 0, 0, 0.1),
                    inset 0 1px 0 rgba(0, 0, 0, 0.1),
                    inset 0 -1px 0 rgba(255, 255, 255, 0.3);
      }

      #x-map-container.light-theme .landmark-label::after {
        border-top: 5px solid rgba(0, 0, 0, 0.15);
      }

      #x-map-container.light-theme .marker-status-bubble {
        background: #fff;
        color: #000;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      }

      #x-map-container.light-theme .marker-status-bubble::after {
        border-top: 5px solid #fff;
      }

      #x-map-container.light-theme .map-swipe-hint {
        background: rgba(255,255,255,0.9);
        color: #000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      }

      #x-map-container.light-theme .marker-avatar {
        border: 3px solid #000;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15), inset 0 -2px 4px rgba(0,0,0,0.1);
      }

      #x-map-container.light-theme .map-marker:hover .marker-avatar {
        box-shadow: 0 6px 20px rgba(29,155,240,0.6), inset 0 -2px 4px rgba(0,0,0,0.1);
      }

      #x-map-container.light-theme .marker-container::after {
        background: radial-gradient(ellipse at center, rgba(0,0,0,0.15) 0%, transparent 70%);
      }

      /* ==================== 亮色主题：用户详情卡片 ==================== */
      #x-map-container.light-theme .map-user-detail-card {
        background: #fff;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      }

      #x-map-container.light-theme .card-header {
        background: #fff;
      }

      #x-map-container.light-theme .card-back-btn svg {
        stroke: #000;
      }

      #x-map-container.light-theme .card-header-nickname {
        color: #000;
      }

      #x-map-container.light-theme .card-action-btn svg {
        stroke: #000;
      }

      #x-map-container.light-theme .card-avatar-section {
        background: #fff;
      }

      #x-map-container.light-theme .card-avatar {
        border: 3px solid #e0e0e0;
      }

      #x-map-container.light-theme .card-avatar-bubble {
        background: #a0a0a0;
      }

      #x-map-container.light-theme .card-user-info {
        color: #000;
      }

      #x-map-container.light-theme .card-handle {
        color: #666;
      }

      #x-map-container.light-theme .card-stat-item::after {
        background: #e0e0e0;
      }

      #x-map-container.light-theme .card-stat-value {
        color: #000;
      }

      #x-map-container.light-theme .card-stat-label {
        color: #666;
      }

      #x-map-container.light-theme .card-btn-message {
        background: #f0f0f0;
        color: #000;
      }

      #x-map-container.light-theme .card-btn-message:hover {
        background: #e0e0e0;
      }

      #x-map-container.light-theme .card-btn-secondary {
        background: #f0f0f0;
        color: #000;
      }

      #x-map-container.light-theme .card-btn-secondary:hover {
        background: #e0e0e0;
      }

      #x-map-container.light-theme .card-bio-section {
        background: #fff;
      }

      #x-map-container.light-theme .card-bio {
        color: #000;
      }

      #x-map-container.light-theme .card-tag {
        background: #f0f0f0;
        color: #000;
        border: 1px solid #d0d0d0;
      }

      #x-map-container.light-theme .card-distance-info {
        color: #666;
      }

      #x-map-container.light-theme .card-distance-info svg {
        stroke: #666;
      }

      /* ==================== 亮色主题：评价/留言区 ==================== */
      #x-map-container.light-theme .card-reviews-section {
        background: #fff;
      }

      #x-map-container.light-theme .reviews-header {
        background: #fff;
      }

      #x-map-container.light-theme .reviews-back-btn svg {
        stroke: #000;
      }

      #x-map-container.light-theme .reviews-title {
        color: #000;
      }

      #x-map-container.light-theme .reviews-summary {
        background: #f5f5f5;
      }

      #x-map-container.light-theme .reviews-rating-number {
        color: #000;
      }

      #x-map-container.light-theme .reviews-rating-max {
        color: #999;
      }

      #x-map-container.light-theme .reviews-count {
        color: #666;
      }

      #x-map-container.light-theme .review-item {
        background: #f5f5f5;
      }

      #x-map-container.light-theme .review-name {
        color: #000;
      }

      #x-map-container.light-theme .review-rating {
        background: #e0e0e0;
      }

      #x-map-container.light-theme .review-time {
        color: #999;
      }

      #x-map-container.light-theme .review-content {
        color: #333;
      }

      #x-map-container.light-theme .review-reply-icon {
        color: #999;
      }

      #x-map-container.light-theme .review-reply-label {
        color: #000;
      }

      #x-map-container.light-theme .review-reply-content {
        color: #666;
      }

      #x-map-container.light-theme .review-action-btn {
        color: #999;
      }

      #x-map-container.light-theme .reviews-empty-text {
        color: #999;
      }

      /* ==================== 亮色主题：地图设置弹窗 ==================== */
      #x-map-container.light-theme .map-settings-modal {
        background: rgba(0, 0, 0, 0.4);
      }

      #x-map-container.light-theme .map-settings-content {
        background: #fff;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      #x-map-container.light-theme .map-settings-header {
        background: #fff;
        border-bottom: 1px solid #e0e0e0;
      }

      #x-map-container.light-theme .map-settings-back-btn:hover {
        background: rgba(0, 0, 0, 0.05);
      }

      #x-map-container.light-theme .map-settings-back-btn svg {
        stroke: #000;
      }

      #x-map-container.light-theme .map-settings-title {
        color: #000;
      }

      #x-map-container.light-theme .map-settings-body::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.2);
      }

      #x-map-container.light-theme .map-settings-section-title {
        color: rgba(0, 0, 0, 0.6);
      }

      #x-map-container.light-theme .map-settings-item {
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      }

      #x-map-container.light-theme .map-settings-item-label {
        color: #000;
      }

      #x-map-container.light-theme .map-settings-item-desc {
        color: rgba(0, 0, 0, 0.5);
      }

      #x-map-container.light-theme .map-settings-toggle-label {
        background: rgba(0, 0, 0, 0.15);
      }

      #x-map-container.light-theme .map-settings-toggle-label::after {
        background: #000;
      }

      #x-map-container.light-theme .map-settings-input {
        background: rgba(0, 0, 0, 0.05);
        border: 1px solid rgba(0, 0, 0, 0.15);
        color: #000;
      }

      #x-map-container.light-theme .map-settings-input::placeholder {
        color: rgba(0, 0, 0, 0.4);
      }

      #x-map-container.light-theme .map-settings-input:focus {
        background: rgba(0, 0, 0, 0.08);
      }

      #x-map-container.light-theme .map-settings-tags-container {
        background: rgba(0, 0, 0, 0.03);
      }

      #x-map-container.light-theme .map-settings-add-tag-btn {
        background: rgba(0, 0, 0, 0.05);
        border: 1px dashed rgba(0, 0, 0, 0.25);
        color: rgba(0, 0, 0, 0.7);
      }

      #x-map-container.light-theme .map-settings-add-tag-btn:hover {
        background: rgba(0, 0, 0, 0.08);
        border-color: rgba(0, 0, 0, 0.4);
        color: #000;
      }

      /* ==================== 亮色主题：社交圈弹窗 ==================== */
      #x-map-container.light-theme .map-social-circle-modal {
        background: rgba(0, 0, 0, 0.4);
      }

      #x-map-container.light-theme .map-social-circle-content {
        background: #fff;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      #x-map-container.light-theme .map-social-circle-header {
        border-bottom: 1px solid #e0e0e0;
      }

      #x-map-container.light-theme .map-social-circle-back-btn {
        background: rgba(0, 0, 0, 0.05);
      }

      #x-map-container.light-theme .map-social-circle-back-btn:hover {
        background: rgba(0, 0, 0, 0.1);
      }

      #x-map-container.light-theme .map-social-circle-back-btn svg {
        stroke: #000;
      }

      #x-map-container.light-theme .map-social-circle-title {
        color: #000;
      }

      #x-map-container.light-theme .map-social-circle-body::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.2);
      }

      #x-map-container.light-theme .map-social-circle-empty svg {
        color: rgba(0, 0, 0, 0.3);
      }

      #x-map-container.light-theme .map-social-circle-empty-text {
        color: rgba(0, 0, 0, 0.8);
      }

      #x-map-container.light-theme .map-social-circle-empty-desc {
        color: rgba(0, 0, 0, 0.5);
      }

      #x-map-container.light-theme .map-social-circle-friend-card {
        background: rgba(0, 0, 0, 0.03);
        border: 1px solid rgba(0, 0, 0, 0.1);
      }

      #x-map-container.light-theme .map-social-circle-friend-card:hover {
        background: rgba(0, 0, 0, 0.05);
        border-color: rgba(0, 0, 0, 0.15);
      }

      #x-map-container.light-theme .map-social-circle-friend-name {
        color: #000;
      }

      #x-map-container.light-theme .map-social-circle-friend-handle {
        color: rgba(0, 0, 0, 0.5);
      }

      #x-map-container.light-theme .map-social-circle-friend-relationship {
        background: rgba(0, 0, 0, 0.08);
        color: rgba(0, 0, 0, 0.8);
      }

      #x-map-container.light-theme .map-social-circle-friend-bio {
        color: rgba(0, 0, 0, 0.7);
      }

      #x-map-container.light-theme .map-social-circle-friend-stat {
        color: rgba(0, 0, 0, 0.5);
      }

      #x-map-container.light-theme .map-social-circle-friend-stat-value {
        color: rgba(0, 0, 0, 0.8);
      }

      /* ==================== 亮色主题：聊天弹窗 ==================== */
      #x-map-container.light-theme .map-chat-modal {
        background: #fff;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }

      #x-map-container.light-theme .map-chat-header {
        background: #fff;
        border-bottom: 1px solid #e0e0e0;
      }

      #x-map-container.light-theme .map-chat-back-btn svg {
        stroke: #000;
      }

      #x-map-container.light-theme .map-chat-user-name {
        color: #000;
      }

      #x-map-container.light-theme .map-chat-more-btn svg {
        fill: #000;
      }

      #x-map-container.light-theme .map-chat-more-menu {
        background: #fff;
        border: 1px solid #e0e0e0;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
      }

      #x-map-container.light-theme .map-chat-more-menu-item {
        color: #333;
      }

      #x-map-container.light-theme .map-chat-more-menu-item:hover {
        background: #f5f5f5;
      }

      #x-map-container.light-theme .map-chat-messages {
        background: #fff;
      }

      #x-map-container.light-theme .map-chat-messages::-webkit-scrollbar-thumb {
        background: #d0d0d0;
      }

      #x-map-container.light-theme .map-chat-timestamp {
        color: #999;
      }

      #x-map-container.light-theme .map-chat-message-row.received .map-chat-bubble {
        background: #fff;
        border: 1px solid #000;
        color: #000;
      }

      #x-map-container.light-theme .map-chat-message-row.sent .map-chat-bubble {
        background: #e0e0e0;
        color: #000;
      }

      /* 表情包样式 - light theme（保持一致，无需额外样式） */

      /* 🚨 系统消息 - light theme */
      #x-map-container.light-theme .map-chat-system-message {
        background: rgba(0, 0, 0, 0.03);
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-left-color: #000;
      }

      #x-map-container.light-theme .map-chat-system-message-icon {
        color: #000;
      }

      #x-map-container.light-theme .map-chat-system-message-text {
        color: #262626;
      }

      #x-map-container.light-theme .map-chat-footer {
        background: #fff;
        border-top: 1px solid #e0e0e0;
      }

      /* 删除模式工具栏 - 亮色主题适配 */
      #x-map-container.light-theme .map-chat-delete-toolbar {
        background: #fff;
        border-top: 1px solid #e0e0e0;
      }

      #x-map-container.light-theme .map-chat-delete-checkbox-wrapper span {
        color: #262626;
      }

      #x-map-container.light-theme .map-chat-delete-btn {
        background: #f5f5f5;
        color: #262626;
      }

      #x-map-container.light-theme .map-chat-delete-btn:hover:not(:disabled) {
        background: #e5e5e5;
        color: #000;
      }

      #x-map-container.light-theme .map-chat-delete-btn:disabled {
        opacity: 0.4;
      }

      #x-map-container.light-theme .map-chat-delete-btn.danger {
        background: #dc3545;
        color: #fff;
      }

      #x-map-container.light-theme .map-chat-delete-btn.danger:hover {
        background: #c82333;
      }

      #x-map-container.light-theme .map-chat-delete-btn.exit {
        background: #28a745;
        color: #fff;
      }

      #x-map-container.light-theme .map-chat-delete-btn.exit:hover {
        background: #218838;
      }

      /* 删除模式下消息气泡 - 亮色主题适配 */
      #x-map-container.light-theme .map-chat-bubble.delete-mode {
        cursor: pointer;
      }

      #x-map-container.light-theme .map-chat-bubble.delete-mode.selected {
        border: 2px solid #4a9eff;
        background: rgba(74, 158, 255, 0.12) !important;
        box-shadow: 0 0 0 4px rgba(74, 158, 255, 0.08);
      }

      #x-map-container.light-theme .map-chat-add-btn svg {
        stroke: #000;
      }

      #x-map-container.light-theme .map-chat-add-btn:hover {
        background: rgba(0, 0, 0, 0.05);
      }

      #x-map-container.light-theme .map-chat-input {
        background: #f5f5f5;
        border: 1px solid #d0d0d0;
        color: #000;
      }

      #x-map-container.light-theme .map-chat-input:focus {
        border-color: #aaa;
      }

      #x-map-container.light-theme .map-chat-input::placeholder {
        color: #999;
      }

      #x-map-container.light-theme .map-chat-like-btn svg {
        fill: #000;
      }

      #x-map-container.light-theme .map-chat-like-btn:hover {
        background: rgba(0, 0, 0, 0.05);
      }

      #x-map-container.light-theme .map-chat-overlay {
        background: rgba(0, 0, 0, 0.5);
      }

      #x-map-container.light-theme .map-chat-function-item {
        background: #f0f0f0;
        border: 1px solid #d0d0d0;
        color: #666;
      }

      #x-map-container.light-theme .map-chat-function-item:hover {
        background: #e0e0e0;
      }

      /* ==================== 亮色主题：笔记弹窗 ==================== */
      #x-map-container.light-theme .map-notes-overlay {
        background: rgba(0, 0, 0, 0.5);
      }

      #x-map-container.light-theme .map-notes-modal {
        background: #fff;
        border: 1px solid #d0d0d0;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      #x-map-container.light-theme .map-notes-header {
        border-bottom: 1px solid #e0e0e0;
      }

      #x-map-container.light-theme .map-notes-main-tabs {
        background: #f0f0f0;
      }

      #x-map-container.light-theme .map-notes-main-tab {
        color: #666;
      }

      #x-map-container.light-theme .map-notes-main-tab:hover {
        color: #333;
      }

      #x-map-container.light-theme .map-notes-main-tab.active {
        background: #fff;
        color: #000;
      }

      #x-map-container.light-theme .map-notes-close {
        color: #666;
      }

      #x-map-container.light-theme .map-notes-close:hover {
        background: #f0f0f0;
        color: #000;
      }

      #x-map-container.light-theme .map-notes-tabs {
        border-bottom: 1px solid #e0e0e0;
      }

      #x-map-container.light-theme .map-notes-tab {
        border: 1px solid #d0d0d0;
        color: #666;
      }

      #x-map-container.light-theme .map-notes-empty {
        color: #999;
      }

      #x-map-container.light-theme .map-notes-empty svg {
        color: #d0d0d0;
      }

      #x-map-container.light-theme .map-notes-empty p {
        color: #666;
      }

      #x-map-container.light-theme .map-notes-empty span {
        color: #999;
      }

      #x-map-container.light-theme .map-notes-item {
        border-bottom: 1px solid #e0e0e0;
      }

      #x-map-container.light-theme .map-notes-item-category {
        color: #000;
      }

      #x-map-container.light-theme .map-notes-item-time {
        color: #999;
      }

      #x-map-container.light-theme .map-notes-item-text {
        color: #333;
      }

      #x-map-container.light-theme .map-notes-item-action {
        border: 1px solid #d0d0d0;
        color: #666;
      }

      #x-map-container.light-theme .map-notes-picker-overlay {
        background: rgba(0, 0, 0, 0.3);
      }

      #x-map-container.light-theme .map-notes-picker {
        background: #fff;
        border: 1px solid #d0d0d0;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      }

      #x-map-container.light-theme .map-notes-picker-header {
        border-bottom: 1px solid #d0d0d0;
        color: #000;
      }

      #x-map-container.light-theme .map-notes-picker-item {
        border-bottom: 1px solid #e0e0e0;
        color: #333;
      }

      #x-map-container.light-theme .map-notes-picker-item:hover {
        background: #f5f5f5;
      }

      /* ==================== 亮色主题：聊天列表弹窗 ==================== */
      #x-map-container.light-theme .map-chats-list-overlay {
        background: rgba(0, 0, 0, 0.5);
      }

      #x-map-container.light-theme .map-chats-list-modal {
        background: #fff;
        border: 1px solid #d0d0d0;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      #x-map-container.light-theme .map-chats-list-header {
        border-bottom: 1px solid #e0e0e0;
      }

      #x-map-container.light-theme .map-chats-list-title {
        color: #000;
      }

      #x-map-container.light-theme .map-chats-list-close {
        color: #666;
      }

      #x-map-container.light-theme .map-chats-list-close:hover {
        background: #f0f0f0;
        color: #000;
      }

      #x-map-container.light-theme .map-chats-list-content::-webkit-scrollbar-thumb {
        background: #d0d0d0;
      }

      #x-map-container.light-theme .map-chats-list-empty {
        color: #999;
      }

      #x-map-container.light-theme .map-chats-list-empty svg {
        color: #d0d0d0;
      }

      #x-map-container.light-theme .map-chats-list-empty p {
        color: #666;
      }

      #x-map-container.light-theme .map-chats-list-empty span {
        color: #999;
      }

      #x-map-container.light-theme .map-chats-list-item {
        background: #f5f5f5;
        border: 1px solid #d0d0d0;
      }

      #x-map-container.light-theme .map-chats-list-item:hover {
        background: #ebebeb;
      }

      #x-map-container.light-theme .map-chats-list-item-avatar {
        background: #d0d0d0;
      }

      #x-map-container.light-theme .map-chats-list-item-name {
        color: #000;
      }

      #x-map-container.light-theme .map-chats-list-item-preview {
        color: #666;
      }

      #x-map-container.light-theme .map-chats-list-item-delete {
        color: #999;
      }

      /* ==================== 亮色主题：指定筛选弹窗 ==================== */
      #x-map-container.light-theme .map-advanced-filter-overlay {
        background: rgba(0, 0, 0, 0.4);
      }

      #x-map-container.light-theme .map-advanced-filter-modal {
        background: #fff;
        border: 1px solid #d0d0d0;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
      }

      #x-map-container.light-theme .map-advanced-filter-header {
        border-bottom: 1px solid #e0e0e0;
      }

      #x-map-container.light-theme .map-advanced-filter-title {
        color: #000;
      }

      #x-map-container.light-theme .map-advanced-filter-close {
        color: #666;
      }

      #x-map-container.light-theme .map-advanced-filter-close:hover {
        background: #f0f0f0;
        color: #000;
      }

      #x-map-container.light-theme .map-filter-label {
        color: #333;
      }

      #x-map-container.light-theme .map-filter-radio input[type="radio"] {
        border: 2px solid #d0d0d0;
      }

      #x-map-container.light-theme .map-filter-radio span {
        color: #000;
      }

      #x-map-container.light-theme .map-filter-input {
        background: #f5f5f5;
        border: 1px solid #d0d0d0;
        color: #000;
      }

      #x-map-container.light-theme .map-filter-input:focus {
        background: #fff;
      }

      #x-map-container.light-theme .map-filter-separator {
        color: #666;
      }

      #x-map-container.light-theme .map-filter-textarea {
        background: #f5f5f5;
        border: 1px solid #d0d0d0;
        color: #000;
      }

      #x-map-container.light-theme .map-filter-textarea:focus {
        background: #fff;
      }

      #x-map-container.light-theme .map-filter-textarea::placeholder,
      #x-map-container.light-theme .map-filter-input::placeholder {
        color: #999;
      }

      #x-map-container.light-theme .map-advanced-filter-footer {
        border-top: 1px solid #e0e0e0;
      }

      #x-map-container.light-theme .map-advanced-filter-btn-cancel {
        color: #666;
        border: 1px solid #d0d0d0;
      }

      #x-map-container.light-theme .map-advanced-filter-btn-cancel:hover {
        background: #f0f0f0;
        color: #333;
      }

      #x-map-container.light-theme .map-advanced-filter-btn-clear {
        background: #f0f0f0;
        color: #000;
      }

      #x-map-container.light-theme .map-advanced-filter-btn-clear:hover {
        background: #e0e0e0;
      }

      .map-controls {
        position: absolute;
        top: 80px;
        right: 20px;
        z-index: 10;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .map-control-btn {
        width: 40px;
        height: 40px;
        background: #1a1a1a;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        transition: all 0.2s;
        position: relative;
      }

      .map-control-btn:active {
        transform: scale(0.95);
        background: #2a2a2a;
      }

      .map-control-btn:hover::after {
        content: attr(title);
        position: absolute;
        right: calc(100% + 8px);
        background: rgba(0,0,0,0.8);
        color: #fff;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        pointer-events: none;
      }

      .map-control-btn svg {
        width: 20px;
        height: 20px;
        fill: #e5e5e5;
        transition: fill 0.2s;
      }

      .map-control-btn:active svg {
        fill: #1d9bf0;
      }

      .map-canvas {
        position: absolute;
        width: 300%;
        height: 300%;
        top: 0;
        left: 0;
        background: var(--map-bg-primary);
        cursor: grab;
        transition: none;
        will-change: transform;
        transform-origin: 0 0;
      }

      .map-canvas:active {
        cursor: grabbing;
      }

      #mapCanvasBg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }

      /* ==================== 地标标签 ==================== */
      .landmark-label {
        position: absolute;
        /* 液态玻璃磨砂效果 - ins风格 */
        background: rgba(255, 255, 255, 0.15);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        color: #ffffff;
        padding: 6px 14px;
        border-radius: 18px;
        font-size: 12px;
        font-weight: 600;
        white-space: nowrap;
        pointer-events: auto;
        cursor: default;
        transform: translate(-50%, -100%);
        margin-top: -10px;
        /* 玻璃质感阴影：外阴影 + 内阴影 */
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2),
                    0 2px 8px rgba(0, 0, 0, 0.15),
                    inset 0 1px 0 rgba(255, 255, 255, 0.3),
                    inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        display: flex;
        align-items: center;
        gap: 2px;
        opacity: 0;
        transform: translate(-50%, -100%) scale(0.85);
        transition: opacity 0.35s cubic-bezier(0.4, 0, 0.2, 1),
                    transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      .landmark-label.visible {
        opacity: 1;
        transform: translate(-50%, -100%) scale(1);
      }

      /* 有事件的地标显示手指光标 */
      .landmark-label.has-event {
        cursor: pointer;
      }

      .landmark-label-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
        margin-right: 6px;
        flex-shrink: 0;
      }

      .landmark-label-icon svg {
        width: 100%;
        height: 100%;
        display: block;
      }

      .landmark-label::after {
        content: '';
        position: absolute;
        bottom: -5px;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 5px solid transparent;
        border-right: 5px solid transparent;
        border-top: 5px solid rgba(255, 255, 255, 0.15);
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
      }

      .map-marker {
        position: absolute;
        cursor: pointer;
        transition: opacity 0.3s, transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 5;
        transform-origin: center center;
        pointer-events: auto;
      }

      .map-marker:active {
        transform: scale(0.95);
        z-index: 6;
      }

      .marker-container {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
      }

      .marker-avatar {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        border: 3px solid #fff;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3), inset 0 -2px 4px rgba(0,0,0,0.2);
        object-fit: cover;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        z-index: 2;
      }

      .map-marker:hover .marker-avatar {
        border-color: #1d9bf0;
        box-shadow: 0 6px 20px rgba(29,155,240,0.6), inset 0 -2px 4px rgba(0,0,0,0.2);
        transform: scale(1.05);
      }

      .marker-container::after {
        content: '';
        position: absolute;
        bottom: -6px;
        width: 50px;
        height: 12px;
        background: radial-gradient(ellipse at center, rgba(0,0,0,0.4) 0%, transparent 70%);
        border-radius: 50%;
        z-index: 1;
        transition: all 0.3s;
      }

      .map-marker:hover .marker-container::after {
        transform: scale(1.2);
        opacity: 0.6;
      }

      .marker-pulse {
        position: absolute;
        width: 44px;
        height: 44px;
        border-radius: 50%;
        background: rgba(29,155,240,0.3);
        animation: mapPulse 2s infinite;
        z-index: 1;
      }

      @keyframes mapPulse {
        0% { transform: scale(1); opacity: 0.6; }
        50% { transform: scale(1.5); opacity: 0.2; }
        100% { transform: scale(1); opacity: 0.6; }
      }

      /* 用户自己的标记 - 简洁设计 */
      .map-marker.current-user {
        z-index: 10;
      }

      .map-marker.current-user .marker-avatar {
        width: 44px;
        height: 44px;
        /* border颜色通过内联样式动态设置（使用主题色） */
        box-shadow: 0 2px 8px rgba(0,0,0,0.3), inset 0 -2px 4px rgba(0,0,0,0.2);
      }

      /* ==================== 气泡状态设计 ==================== */
      .marker-status-bubble {
        position: absolute;
        top: -35px;
        left: 50%;
        transform: translateX(-50%) scale(0);
        background: #1a1a1a;
        color: #e5e5e5;
        padding: 4px 10px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 600;
        white-space: nowrap;
        pointer-events: none;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        opacity: 0;
        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                    transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        z-index: 3;
      }

      .marker-status-bubble::after {
        content: '';
        position: absolute;
        bottom: -4px;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 5px solid transparent;
        border-right: 5px solid transparent;
        border-top: 5px solid #1a1a1a;
      }

      .marker-status-bubble.visible {
        opacity: 1;
        transform: translateX(-50%) scale(1);
      }

      /* ==================== 用户详情卡片 - TikTok风格 ==================== */
      .map-user-detail-card {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: calc(100% - 40px);
        max-width: 420px;
        max-height: calc(100% - 60px);
        background: #000;
        border-radius: 0;
        box-shadow: 0 8px 32px rgba(0,0,0,0.6);
        overflow-y: auto;
        z-index: 350; /* 修正：提高层级，在聊天弹窗(300)之上，确认弹窗(400)之下 */
        animation: mapCardZoomIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        -webkit-overflow-scrolling: touch;
        display: none;
      }

      .map-user-detail-card.active {
        display: block;
      }

      @keyframes mapCardZoomIn {
        from { transform: translate(-50%, -50%) scale(0.95); opacity: 0; }
        to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      }

      /* TikTok风格顶部Header区域 */
      .card-header {
        position: relative;
        padding: 12px 16px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: #000;
      }

      /* 返回按钮 - 左侧，有实际功能 */
      .card-back-btn {
        width: 72px;
        height: 32px;
        background: transparent;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        transition: opacity 0.2s;
        padding: 0;
      }

      .card-back-btn:hover {
        opacity: 0.6;
      }

      .card-back-btn svg {
        width: 24px;
        height: 24px;
        stroke: #fff;
        fill: none;
        stroke-width: 2;
      }

      /* 中间昵称区域 */
      .card-header-center {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }

      .card-header-nickname {
        font-size: 16px;
        font-weight: 700;
        color: #fff;
      }

      .card-header-verified {
        width: 16px;
        height: 16px;
        color: #0095f6;
        flex-shrink: 0;
      }

      /* 右侧装饰按钮组 */
      .card-header-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .card-action-btn {
        width: 32px;
        height: 32px;
        background: transparent;
        border: none;
        cursor: default;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
      }

      .card-action-btn svg {
        width: 22px;
        height: 22px;
        stroke: #fff;
        fill: none;
        stroke-width: 2;
      }

      /* 头像区域 - 简化padding */
      .card-avatar-section {
        padding: 12px 20px 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        background: #000;
      }

      .card-avatar-wrapper {
        position: relative;
        margin-bottom: 16px;
      }

      .card-avatar {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        object-fit: cover;
        border: 3px solid #262626;
      }

      /* 头像气泡 - 思考气泡风格（参考meme图，右上角，深灰色背景） */
      .card-avatar-bubble {
        position: absolute;
        top: -8px;
        right: -24px;
        min-width: 56px;
        height: 40px;
        padding: 0 12px;
        background: #6a6a6a;
        border: none;
        border-radius: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 22px;
        color: #fff;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        z-index: 1;
      }

      /* 思考气泡小尾巴 - 连接到头像左下方 */
      .card-avatar-bubble::before {
        content: '';
        position: absolute;
        bottom: -10px;
        left: 8px;
        width: 10px;
        height: 10px;
        background: #6a6a6a;
        border: none;
        border-radius: 50%;
      }

      .card-avatar-bubble::after {
        content: '';
        position: absolute;
        bottom: -18px;
        left: 4px;
        width: 6px;
        height: 6px;
        background: #6a6a6a;
        border: none;
        border-radius: 50%;
      }

      /* 用户信息 - 移除昵称（已移至header） */
      .card-user-info {
        text-align: center;
        color: #fff;
        margin-bottom: 16px;
      }

      .card-handle {
        font-size: 14px;
        color: #a8a8a8;
      }

      /* 统计数据 */
      .card-stats {
        display: flex;
        justify-content: center;
        gap: 0;
        padding: 12px 0 20px;
        margin-bottom: 0;
      }

      .card-stat-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
        padding: 0 24px;
        position: relative;
      }

      /* 竖线分隔符 - 在第2和第3项之间 */
      .card-stat-item:not(:last-child)::after {
        content: '';
        position: absolute;
        right: 0;
        top: 50%;
        transform: translateY(-50%);
        width: 1px;
        height: 20px;
        background: #262626;
      }

      .card-stat-value {
        font-size: 18px;
        font-weight: 600;
        color: #fff;
      }

      .card-stat-label {
        font-size: 13px;
        color: #a8a8a8;
      }

      /* 按钮组 */
      .card-buttons {
        display: flex;
        gap: 8px;
        padding: 0 16px 20px;
      }

      .card-btn {
        padding: 10px 16px;
        border: none;
        border-radius: 8px;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        transition: all 0.2s;
      }

      .card-btn-message {
        flex: 1;
        background: #363636;
        color: #fff;
      }

      .card-btn-message:hover {
        background: #404040;
      }

      .card-btn-secondary {
        background: #363636;
        color: #fff;
        padding: 10px 14px;
        flex: 0 0 auto;
        min-width: 44px;
      }

      .card-btn-secondary:hover {
        background: #404040;
      }

      .card-btn svg {
        width: 18px;
        height: 18px;
      }

      /* 下拉菜单容器 */
      .card-btn-dropdown-wrapper {
        position: relative;
        flex: 0 0 auto;
      }

      /* 下拉菜单 */
      .card-dropdown-menu {
        position: absolute;
        top: calc(100% + 8px);
        right: 0;
        min-width: 50px;
        background: #1a1a1a;
        border-radius: 12px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        padding: 8px 0;
        z-index: 1000;
        opacity: 0;
        transform: translateY(-10px);
        transition: opacity 0.2s ease, transform 0.2s ease;
        pointer-events: none;
      }

      .card-dropdown-menu.show {
        opacity: 1;
        transform: translateY(0);
        pointer-events: auto;
      }

      #x-map-container.light-theme .card-dropdown-menu {
        background: #fff;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
      }

      .card-dropdown-item {
        width: 100%;
        padding: 12px;
        background: transparent;
        border: none;
        color: #fff;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        transition: background 0.2s ease;
        text-align: center;
      }

      .card-dropdown-item:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      #x-map-container.light-theme .card-dropdown-item {
        color: #000;
      }

      #x-map-container.light-theme .card-dropdown-item:hover {
        background: rgba(0, 0, 0, 0.05);
      }

      .card-dropdown-item svg {
        width: 20px;
        height: 20px;
        flex-shrink: 0;
        stroke: currentColor;
      }

      .card-btn-message svg {
        width: 18px;
        height: 18px;
        stroke-width: 2;
        transform: rotate(-30deg);
      }

      /* 简介部分 */
      .card-bio-section {
        padding: 16px 20px;
        background: #000;
      }

      .card-bio {
        color: #fff;
        font-size: 14px;
        line-height: 1.6;
        text-align: center;
        margin-bottom: 16px;
        white-space: pre-line; /* 支持换行 */
      }

      /* 标签 */
      .card-tags {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 8px;
        margin-bottom: 16px;
      }

      .card-tag {
        background: #1a1a1a;
        color: #fff;
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 13px;
        font-weight: 500;
        border: 1px solid #262626;
      }

      /* 距离信息 */
      .card-distance-info {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        color: #a8a8a8;
        font-size: 14px;
      }

      .card-distance-info svg {
        width: 16px;
        height: 16px;
        stroke: #a8a8a8;
        fill: none;
      }

      /* ==================== 评价/留言弹窗 ==================== */
      .card-reviews-section {
        display: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        overflow-y: auto;
        z-index: 2;
      }

      .card-reviews-section.active {
        display: block;
      }

      /* 评价顶部header */
      .reviews-header {
        padding: 16px;
        background: #000;
        position: sticky;
        top: 0;
        z-index: 10;
      }

      .reviews-header-top {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 16px;
      }

      .reviews-back-btn {
        width: 32px;
        height: 32px;
        background: transparent;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
      }

      .reviews-back-btn svg {
        width: 24px;
        height: 24px;
        stroke: #fff;
        fill: none;
        stroke-width: 2;
      }

      .reviews-title {
        font-size: 16px;
        font-weight: 700;
        color: #fff;
        flex: 1;
        text-align: center;
      }

      .reviews-placeholder {
        width: 32px;
      }

      /* 总评分区域 */
      .reviews-summary {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 24px;
        padding: 16px;
        background: #1a1a1a;
        border-radius: 12px;
      }

      .reviews-rating-big {
        text-align: center;
      }

      .reviews-rating-number {
        font-size: 48px;
        font-weight: 700;
        color: #fff;
        line-height: 1;
      }

      .reviews-rating-max {
        font-size: 16px;
        color: #666;
      }

      .reviews-stars {
        display: flex;
        gap: 4px;
        margin-top: 8px;
        justify-content: center;
      }

      .reviews-stars svg {
        width: 16px;
        height: 16px;
        fill: #ffd700;
      }

      .reviews-count {
        font-size: 13px;
        color: #a8a8a8;
        margin-top: 4px;
      }

      /* 评价列表 */
      .reviews-list {
        padding: 16px;
      }

      .review-item {
        background: #1a1a1a;
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 12px;
      }

      .review-header {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        margin-bottom: 12px;
      }

      .review-avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        object-fit: cover;
        flex-shrink: 0;
      }

      .review-info {
        flex: 1;
        min-width: 0;
      }

      .review-name-line {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 4px;
      }

      .review-name {
        font-size: 14px;
        font-weight: 600;
        color: #fff;
      }

      .review-rating {
        display: flex;
        align-items: center;
        gap: 4px;
        background: #262626;
        padding: 2px 8px;
        border-radius: 12px;
      }

      .review-rating-number {
        font-size: 13px;
        font-weight: 600;
        color: #ffd700;
      }

      .review-rating svg {
        width: 12px;
        height: 12px;
        fill: #ffd700;
      }

      .review-time {
        font-size: 12px;
        color: #666;
      }

      .review-content {
        color: #e0e0e0;
        font-size: 14px;
        line-height: 1.6;
        margin-bottom: 12px;
      }

      .review-reply {
        display: flex;
        align-items: flex-start;
        gap: 8px;
        margin-top: 10px;
        padding-left: 8px;
      }

      .review-reply-icon {
        width: 14px;
        height: 14px;
        color: #666;
        flex-shrink: 0;
        margin-top: 2px;
      }

      .review-reply-body {
        flex: 1;
        line-height: 1.4;
      }

      .review-reply-label {
        font-size: 13px;
        color: #fff;
        font-weight: 600;
      }

      .review-reply-content {
        font-size: 13px;
        color: #a8a8a8;
        margin-left: 6px;
      }

      .review-actions {
        display: flex;
        align-items: center;
        gap: 16px;
      }

      .review-action-btn {
        background: none;
        border: none;
        color: #666;
        font-size: 13px;
        display: flex;
        align-items: center;
        gap: 6px;
        cursor: pointer;
        transition: color 0.2s;
        padding: 0;
      }

      .review-action-btn:hover {
        color: #1d9bf0;
      }

      .review-action-btn svg {
        width: 16px;
        height: 16px;
        fill: currentColor;
      }

      /* 空状态 */
      .reviews-empty {
        text-align: center;
        padding: 60px 20px;
      }

      .reviews-empty-icon {
        font-size: 48px;
        margin-bottom: 16px;
      }

      .reviews-empty-text {
        font-size: 15px;
        color: #666;
        line-height: 1.6;
      }

      /* ==================== 触摸滑动提示 ==================== */
      .map-swipe-hint {
        position: absolute;
        top: 50%;
        left: 20px;
        transform: translateY(-50%);
        background: rgba(26,26,26,0.9);
        color: #e5e5e5;
        padding: 12px 16px;
        border-radius: 12px;
        font-size: 14px;
        font-weight: 500;
        box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        animation: swipeHintAnim 2s infinite;
        z-index: 5;
        pointer-events: none;
      }

      .map-swipe-hint.hidden {
        display: none;
      }

      @keyframes swipeHintAnim {
        0%, 100% { transform: translateY(-50%) translateX(0); opacity: 1; }
        50% { transform: translateY(-50%) translateX(10px); opacity: 0.7; }
      }

      /* ==================== 天气特效系统 ==================== */
      .map-weather-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 3;
        overflow: hidden;
      }

      /* 晴天 - 阳光射线效果 */
      .weather-sunny {
        background: radial-gradient(circle at 15% 15%, rgba(255,200,50,0.15) 0%, transparent 50%);
      }

      .weather-sunny::before {
        content: '';
        position: absolute;
        top: 5%;
        left: 10%;
        width: 80px;
        height: 80px;
        background: radial-gradient(circle, rgba(255,220,100,0.6) 0%, rgba(255,180,50,0.3) 40%, transparent 70%);
        border-radius: 50%;
        animation: sunPulse 4s ease-in-out infinite;
      }

      @keyframes sunPulse {
        0%, 100% { transform: scale(1); opacity: 0.8; }
        50% { transform: scale(1.1); opacity: 1; }
      }

      /* 多云 - 全屏幕飘动的云层 */
      .weather-cloudy {
        background: linear-gradient(180deg, rgba(150,150,150,0.08) 0%, transparent 30%);
      }

      .weather-cloudy .cloud {
        position: absolute;
        background: rgba(200,200,200,0.25);
        border-radius: 50%;
        filter: blur(25px);
        animation: cloudFloat linear infinite;
        opacity: 0.8;
      }

      @keyframes cloudFloat {
        0% { transform: translateX(0); opacity: 0; }
        10% { opacity: 0.8; }
        90% { opacity: 0.8; }
        100% { transform: translateX(calc(100vw + 300px)); opacity: 0; }
      }

      /* 小雨 - 稀疏雨滴 */
      .weather-rain {
        background: linear-gradient(180deg, rgba(100,120,140,0.2) 0%, transparent 50%);
      }

      .weather-rain .rain-drop {
        position: absolute;
        width: 2px;
        height: 15px;
        background: linear-gradient(180deg, transparent, rgba(174,194,224,0.6));
        animation: rainFall 1s linear infinite;
      }

      @keyframes rainFall {
        0% { transform: translateY(-20px); opacity: 0; }
        10% { opacity: 1; }
        90% { opacity: 1; }
        100% { transform: translateY(100vh); opacity: 0; }
      }

      /* 大雨 - 密集雨滴 + 涟漪 */
      .weather-heavy-rain {
        background: linear-gradient(180deg, rgba(60,80,100,0.35) 0%, rgba(80,100,120,0.15) 50%, transparent 100%);
      }

      .weather-heavy-rain .rain-drop {
        position: absolute;
        width: 3px;
        height: 25px;
        background: linear-gradient(180deg, transparent, rgba(150,180,220,0.7));
        animation: heavyRainFall 0.6s linear infinite;
      }

      @keyframes heavyRainFall {
        0% { transform: translateY(-30px) rotate(15deg); opacity: 0; }
        10% { opacity: 1; }
        90% { opacity: 0.8; }
        100% { transform: translateY(100vh) rotate(15deg); opacity: 0; }
      }

      .weather-heavy-rain .ripple {
        position: absolute;
        bottom: 10%;
        width: 20px;
        height: 10px;
        border: 1px solid rgba(150,180,220,0.5);
        border-radius: 50%;
        animation: rippleExpand 1.5s ease-out infinite;
      }

      @keyframes rippleExpand {
        0% { transform: scale(0); opacity: 1; }
        100% { transform: scale(3); opacity: 0; }
      }

      /* 雷暴 - 闪电 + 大雨 */
      .weather-thunder {
        background: linear-gradient(180deg, rgba(40,50,70,0.4) 0%, rgba(60,70,90,0.2) 50%, transparent 100%);
      }

      .weather-thunder .rain-drop {
        position: absolute;
        width: 3px;
        height: 30px;
        background: linear-gradient(180deg, transparent, rgba(130,160,200,0.8));
        animation: heavyRainFall 0.5s linear infinite;
      }

      .weather-thunder .lightning {
        position: absolute;
        top: 0;
        left: 50%;
        width: 100%;
        height: 100%;
        background: rgba(255,255,255,0);
        animation: lightningFlash 8s ease-in-out infinite;
      }

      @keyframes lightningFlash {
        0%, 89%, 91%, 93%, 100% { background: rgba(255,255,255,0); }
        90% { background: rgba(255,255,255,0.3); }
        92% { background: rgba(255,255,255,0.5); }
      }

      /* 雪 - 飘落雪花 */
      .weather-snow {
        background: linear-gradient(180deg, rgba(200,210,230,0.15) 0%, transparent 40%);
      }

      .weather-snow .snowflake {
        position: absolute;
        color: rgba(255,255,255,0.9);
        font-size: 12px;
        animation: snowFall 8s linear infinite;
        text-shadow: 0 0 3px rgba(255,255,255,0.5);
      }

      @keyframes snowFall {
        0% { transform: translateY(-20px) rotate(0deg); opacity: 0; }
        10% { opacity: 1; }
        90% { opacity: 0.8; }
        100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
      }

      /* 雾 - 弥漫雾气 */
      .weather-fog {
        background: linear-gradient(180deg, rgba(180,180,190,0.4) 0%, rgba(160,160,170,0.3) 50%, rgba(150,150,160,0.2) 100%);
      }

      .weather-fog::before,
      .weather-fog::after {
        content: '';
        position: absolute;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(200,200,210,0.3), transparent);
        animation: fogDrift 20s ease-in-out infinite;
      }

      .weather-fog::after {
        animation-delay: -10s;
        animation-direction: reverse;
      }

      @keyframes fogDrift {
        0%, 100% { transform: translateX(-20%); opacity: 0.6; }
        50% { transform: translateX(20%); opacity: 0.8; }
      }

      /* 沙尘 - 黄沙飞舞 */
      .weather-dust {
        background: linear-gradient(180deg, rgba(180,150,100,0.35) 0%, rgba(160,130,80,0.2) 50%, transparent 100%);
      }

      .weather-dust .dust-particle {
        position: absolute;
        width: 4px;
        height: 4px;
        background: rgba(180,150,100,0.6);
        border-radius: 50%;
        animation: dustBlow 3s linear infinite;
      }

      @keyframes dustBlow {
        0% { transform: translate(0, 0) rotate(0deg); opacity: 0; }
        20% { opacity: 0.8; }
        80% { opacity: 0.6; }
        100% { transform: translate(100vw, 30vh) rotate(720deg); opacity: 0; }
      }

      /* 开发者测试按钮 */
      .map-weather-test-btn {
        position: absolute;
        bottom: 20px;
        left: 20px;
        z-index: 15;
        background: rgba(255,100,100,0.9);
        color: #fff;
        border: none;
        border-radius: 8px;
        padding: 8px 12px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        transition: all 0.2s;
      }

      .map-weather-test-btn:hover {
        background: rgba(255,80,80,1);
        transform: translateY(-2px);
      }

      .map-weather-test-btn::before {
        content: '🔧';
      }

      /* 天气信息显示 - 圆形按钮样式，垂直排列 */
      .map-weather-info {
        /* 移除position定位，作为flex子元素自动垂直排列 */
        width: 40px;
        height: 40px;
        background: #1a1a1a;
        border: none;
        border-radius: 8px;
        cursor: default;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        transition: all 0.2s;
        position: relative; /* 保留relative以支持::after定位 */
      }

      .map-weather-info:hover::after {
        content: attr(data-weather-name);
        position: absolute;
        right: calc(100% + 8px);
        background: rgba(0,0,0,0.8);
        color: #fff;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        pointer-events: none;
      }

      .map-weather-icon {
        font-size: 20px;
      }

      /* ==================== 动态(Moments)弹窗样式 ==================== */

      /* 动态弹窗容器 */
      .map-moments-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: transparent;
        z-index: 10000;
        display: none;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: none;
      }

      .map-moments-modal.active {
        display: block;
        opacity: 1;
        pointer-events: auto;
      }

      .map-moments-modal > * {
        pointer-events: auto;
      }

      #x-map-container.light-theme .map-moments-modal {
        background: transparent;
      }

      /* 关闭按钮 */
      .moments-close-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 44px;
        height: 44px;
        border-radius: 22px;
        background: rgba(255, 255, 255, 0.1);
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
        transition: all 0.2s ease;
      }

      .moments-close-btn:hover {
        background: rgba(255, 255, 255, 0.15);
      }

      .moments-close-btn:active {
        transform: scale(0.95);
      }

      .moments-close-btn svg {
        width: 20px;
        height: 20px;
        stroke: #fff;
        stroke-width: 2;
      }

      #x-map-container.light-theme .moments-close-btn {
        background: rgba(0, 0, 0, 0.05);
      }

      #x-map-container.light-theme .moments-close-btn:hover {
        background: rgba(0, 0, 0, 0.1);
      }

      #x-map-container.light-theme .moments-close-btn svg {
        stroke: #000;
      }

      /* 卡片堆叠容器 */
      .moments-cards-wrapper {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100%;
        max-width: 420px;
        height: 75vh;
        max-height: 700px;
        perspective: 1000px;
      }

      /* 单个动态卡片 */
      .moment-card {
        position: absolute;
        width: 100%;
        height: 100%;
        background: #1a1a1a;
        border-radius: 28px;
        overflow: hidden;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        cursor: grab;
        user-select: none;
        display: flex;
        flex-direction: column;
      }

      .moment-card:active {
        cursor: grabbing;
      }

      #x-map-container.light-theme .moment-card {
        background: #fff;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
      }

      /* 卡片层级和位置 */
      .moment-card[data-position="0"] {
        z-index: 5;
        transform: translate(0, 0) scale(1) rotateY(0deg);
        opacity: 1;
      }

      .moment-card[data-position="1"] {
        z-index: 4;
        transform: translate(0, 16px) scale(0.96) rotateY(0deg);
        opacity: 0.7;
        pointer-events: none;
      }

      .moment-card[data-position="2"] {
        z-index: 3;
        transform: translate(0, 32px) scale(0.92) rotateY(0deg);
        opacity: 0.4;
        pointer-events: none;
      }

      .moment-card.swiping-left {
        transform: translateX(var(--swipe-x, 0)) rotate(var(--swipe-rotate, 0deg));
      }

      .moment-card.swiping-right {
        transform: translateX(var(--swipe-x, 0)) rotate(var(--swipe-rotate, 0deg));
      }

      .moment-card.removed-left {
        transform: translateX(-150%) rotate(-30deg);
        opacity: 0;
      }

      .moment-card.removed-right {
        transform: translateX(150%) rotate(30deg);
        opacity: 0;
      }

      /* 卡片内容 */
      .moment-card-image {
        width: 100%;
        height: 45%;
        background: #0a0a0a;
        position: relative;
        overflow: hidden;
        flex-shrink: 0;
      }

      #x-map-container.light-theme .moment-card-image {
        background: #f5f5f5;
      }

      .moment-card-image img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .moment-card-image-placeholder {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #333;
        font-size: 14px;
        font-weight: 500;
        letter-spacing: 1px;
      }

      #x-map-container.light-theme .moment-card-image-placeholder {
        color: #ccc;
      }

      /* 文字配图渲染样式 - 黑白灰主题 */
      .moment-card-text-image {
        width: 100%;
        height: 100%;
        position: relative;
        background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
        overflow: hidden;
        padding: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .text-image-content {
        position: relative;
        width: 100%;
        max-height: 100%;
        z-index: 2;
        color: #e0e0e0;
        font-size: 15px;
        line-height: 1.7;
        text-align: center;
        font-weight: 500;
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        word-wrap: break-word;
        overflow-wrap: break-word;
        overflow-y: auto;
        overflow-x: hidden;
        padding-right: 8px;
        -webkit-overflow-scrolling: touch;
      }

      /* 文字配图滚动条样式 */
      .text-image-content::-webkit-scrollbar {
        width: 4px;
      }

      .text-image-content::-webkit-scrollbar-track {
        background: transparent;
      }

      .text-image-content::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 2px;
      }

      .text-image-content::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.5);
      }

      .text-image-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.05) 0%, rgba(0, 0, 0, 0.3) 100%);
        pointer-events: none;
        z-index: 1;
      }

      #x-map-container.light-theme .moment-card-text-image {
        background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
      }

      #x-map-container.light-theme .text-image-content {
        color: #333333;
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      #x-map-container.light-theme .text-image-content::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.2);
      }

      #x-map-container.light-theme .text-image-content::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 0, 0, 0.3);
      }

      .moment-card-content {
        flex: 1;
        padding: 24px;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .moment-card-header {
        display: flex;
        align-items: center;
        margin-bottom: 16px;
        flex-shrink: 0;
      }

      .moment-user-avatar {
        width: 40px;
        height: 40px;
        border-radius: 20px;
        background: #fff;
        color: #000;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: 600;
        margin-right: 12px;
        flex-shrink: 0;
        object-fit: cover;
      }

      #x-map-container.light-theme .moment-user-avatar {
        background: #000;
        color: #fff;
      }

      .moment-user-info {
        flex: 1;
        min-width: 0;
      }

      .moment-username {
        font-size: 15px;
        font-weight: 600;
        color: #fff;
        margin-bottom: 2px;
      }

      #x-map-container.light-theme .moment-username {
        color: #000;
      }

      .moment-time {
        font-size: 12px;
        color: #666;
      }

      #x-map-container.light-theme .moment-time {
        color: #999;
      }

      .moment-card-text {
        flex: 1;
        font-size: 15px;
        line-height: 1.6;
        color: #ccc;
        overflow-y: auto;
        margin-bottom: 16px;
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      #x-map-container.light-theme .moment-card-text {
        color: #333;
      }

      .moment-card-stats {
        display: flex;
        gap: 20px;
        padding: 16px 0;
        border-top: 1px solid #2a2a2a;
        border-bottom: 1px solid #2a2a2a;
        font-size: 13px;
        color: #999;
        flex-shrink: 0;
      }

      #x-map-container.light-theme .moment-card-stats {
        border-color: #f0f0f0;
        color: #666;
      }

      .moment-stat-item {
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .moment-stat-number {
        font-weight: 600;
        color: #fff;
      }

      #x-map-container.light-theme .moment-stat-number {
        color: #000;
      }

      .moment-card-actions {
        display: flex;
        gap: 8px;
        margin-top: 12px;
        flex-shrink: 0;
      }

      .moment-action-btn {
        flex: 1;
        height: 44px;
        border-radius: 22px;
        background: #2a2a2a;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        font-size: 13px;
        font-weight: 500;
        color: #999;
        transition: all 0.2s ease;
      }

      .moment-action-btn:active {
        transform: scale(0.95);
      }

      .moment-action-btn.active {
        background: #fff;
        color: #000;
      }

      #x-map-container.light-theme .moment-action-btn {
        background: #f5f5f5;
        color: #666;
      }

      #x-map-container.light-theme .moment-action-btn.active {
        background: #000;
        color: #fff;
      }

      .moment-action-btn svg {
        width: 18px;
        height: 18px;
        stroke: currentColor;
        stroke-width: 2;
      }

      /* 评论弹窗遮罩 */
      .moments-comments-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.6);
        z-index: 2001;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      .moments-comments-overlay.show {
        opacity: 1;
        pointer-events: auto;
      }

      /* 评论弹窗 */
      .moments-comments-drawer {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        max-height: 70vh;
        background: #1a1a1a;
        border-radius: 24px 24px 0 0;
        z-index: 2002;
        transform: translateY(100%);
        transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        flex-direction: column;
        box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.8);
      }

      .moments-comments-drawer.show {
        transform: translateY(0);
      }

      #x-map-container.light-theme .moments-comments-drawer {
        background: #fff;
        box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.2);
      }

      /* 评论抽屉顶部 */
      .moments-comments-drawer-header {
        padding: 16px 20px;
        border-bottom: 1px solid #2a2a2a;
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-shrink: 0;
      }

      #x-map-container.light-theme .moments-comments-drawer-header {
        border-bottom-color: #f0f0f0;
      }

      .moments-comments-drawer-handle {
        width: 40px;
        height: 4px;
        background: #333;
        border-radius: 2px;
        position: absolute;
        top: 8px;
        left: 50%;
        transform: translateX(-50%);
      }

      #x-map-container.light-theme .moments-comments-drawer-handle {
        background: #ddd;
      }

      .moments-comments-drawer-title {
        font-size: 16px;
        font-weight: 600;
        color: #fff;
      }

      #x-map-container.light-theme .moments-comments-drawer-title {
        color: #000;
      }

      .moments-comments-drawer-close {
        width: 32px;
        height: 32px;
        border-radius: 16px;
        background: #2a2a2a;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }

      .moments-comments-drawer-close:hover {
        background: #333;
      }

      .moments-comments-drawer-close:active {
        transform: scale(0.95);
      }

      #x-map-container.light-theme .moments-comments-drawer-close {
        background: #f5f5f5;
      }

      #x-map-container.light-theme .moments-comments-drawer-close:hover {
        background: #e8e8e8;
      }

      .moments-comments-drawer-close svg {
        width: 16px;
        height: 16px;
        stroke: #999;
        stroke-width: 2;
      }

      #x-map-container.light-theme .moments-comments-drawer-close svg {
        stroke: #666;
      }

      /* 评论列表 */
      .moments-comments-list {
        flex: 1;
        overflow-y: auto;
        padding: 16px 20px;
        min-height: 200px;
        max-height: 50vh;
        -webkit-overflow-scrolling: touch;
      }

      /* 评论列表滚动条样式 */
      .moments-comments-list::-webkit-scrollbar {
        width: 4px;
      }

      .moments-comments-list::-webkit-scrollbar-track {
        background: transparent;
      }

      .moments-comments-list::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 2px;
      }

      .moments-comments-list::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.3);
      }

      #x-map-container.light-theme .moments-comments-list::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.15);
      }

      #x-map-container.light-theme .moments-comments-list::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 0, 0, 0.25);
      }

      .moment-comment-item {
        display: flex;
        gap: 12px;
        margin-bottom: 16px;
      }

      .moment-comment-item:last-child {
        margin-bottom: 0;
      }

      .moment-comment-avatar {
        width: 32px;
        height: 32px;
        border-radius: 16px;
        background: #2a2a2a;
        color: #999;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: 600;
        flex-shrink: 0;
        object-fit: cover;
        overflow: hidden;
      }

      #x-map-container.light-theme .moment-comment-avatar {
        background: #ddd;
        color: #666;
      }

      .moment-comment-content {
        flex: 1;
        min-width: 0;
      }

      .moment-comment-user {
        font-size: 13px;
        font-weight: 600;
        color: #fff;
        margin-bottom: 4px;
      }

      #x-map-container.light-theme .moment-comment-user {
        color: #000;
      }

      .moment-comment-text {
        font-size: 13px;
        line-height: 1.5;
        color: #999;
        margin-bottom: 4px;
      }

      #x-map-container.light-theme .moment-comment-text {
        color: #666;
      }

      .moment-comment-time {
        font-size: 11px;
        color: #666;
      }

      #x-map-container.light-theme .moment-comment-time {
        color: #999;
      }

      /* 指示器 */
      .moments-indicator {
        position: absolute;
        bottom: 40px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;
        z-index: 6;
      }

      .moments-indicator-dot {
        width: 6px;
        height: 6px;
        border-radius: 3px;
        background: rgba(255, 255, 255, 0.3);
        transition: all 0.3s ease;
      }

      .moments-indicator-dot.active {
        width: 20px;
        background: rgba(255, 255, 255, 0.9);
      }

      #x-map-container.light-theme .moments-indicator-dot {
        background: rgba(0, 0, 0, 0.3);
      }

      #x-map-container.light-theme .moments-indicator-dot.active {
        background: rgba(0, 0, 0, 0.9);
      }

      /* 空状态 */
      .moments-empty-state {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 85%;
        max-width: 340px;
        height: auto;
        min-height: 240px;
        max-height: 320px;
        background: #1a1a1a;
        border-radius: 24px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        color: rgba(255, 255, 255, 0.5);
        font-size: 14px;
        padding: 32px 24px;
      }

      #x-map-container.light-theme .moments-empty-state {
        background: #fff;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12);
        color: rgba(0, 0, 0, 0.5);
      }

      .moments-empty-state svg {
        width: 48px;
        height: 48px;
        margin-bottom: 12px;
        stroke: rgba(255, 255, 255, 0.3);
      }

      #x-map-container.light-theme .moments-empty-state svg {
        stroke: rgba(0, 0, 0, 0.3);
      }

      /* 移动端适配 */
      @media (max-width: 768px) {
        .moments-cards-wrapper {
          max-width: 90%;
          height: 80vh;
        }

        .moment-card {
          border-radius: 24px;
        }

        .moment-card-content {
          padding: 20px;
        }

        .moments-close-btn {
          top: 16px;
          right: 16px;
        }

        .moments-indicator {
          bottom: 30px;
        }

        .moments-comments-drawer {
          max-height: 80vh;
          border-radius: 20px 20px 0 0;
        }

        .moments-comments-drawer-header {
          padding: 16px;
        }

        .moments-comments-list {
          padding: 12px 16px;
        }
      }

      /* ==================== 地图设置弹窗样式 - Instagram风格 ==================== */
      .map-settings-modal {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(10px);
        z-index: 1001;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: map-settings-fade-in 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      @keyframes map-settings-fade-in {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .map-settings-content {
        width: 90%;
        max-width: 500px;
        max-height: 65vh;
        background: #000;
        border-radius: 16px;
        overflow: hidden;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        animation: map-settings-slide-up 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        flex-direction: column;
      }

      @keyframes map-settings-slide-up {
        from {
          transform: translateY(50px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .map-settings-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 20px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        background: #000;
        flex-shrink: 0;
      }

      .map-settings-back-btn {
        background: none;
        border: none;
        cursor: pointer;
        padding: 8px;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s;
      }

      .map-settings-back-btn:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      .map-settings-back-btn svg {
        width: 24px;
        height: 24px;
        stroke: #fff;
        stroke-width: 2;
        fill: none;
      }

      .map-settings-title {
        font-size: 16px;
        font-weight: 600;
        color: #fff;
        flex: 1;
        text-align: center;
      }

      .map-settings-save-btn {
        background: none;
        border: none;
        cursor: pointer;
        padding: 8px 12px;
        color: #1d9bf0;
        font-size: 15px;
        font-weight: 600;
        border-radius: 8px;
        transition: all 0.2s;
      }

      .map-settings-save-btn:hover {
        background: rgba(29, 155, 240, 0.1);
      }

      .map-settings-body {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 20px;
        min-height: 0;
        -webkit-overflow-scrolling: touch;
      }

      .map-settings-body::-webkit-scrollbar {
        width: 6px;
      }

      .map-settings-body::-webkit-scrollbar-track {
        background: transparent;
      }

      .map-settings-body::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
      }

      .map-settings-section {
        margin-bottom: 32px;
      }

      .map-settings-section:last-child {
        margin-bottom: 0;
      }

      .map-settings-section-title {
        font-size: 13px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.6);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 16px;
      }

      .map-settings-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .map-settings-item:last-child {
        border-bottom: none;
      }

      .map-settings-item-left {
        flex: 1;
      }

      .map-settings-item-label {
        font-size: 15px;
        font-weight: 500;
        color: #fff;
        margin-bottom: 4px;
      }

      .map-settings-item-desc {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.5);
      }

      /* Instagram风格的Toggle开关 */
      .map-settings-toggle {
        position: relative;
      }

      .map-settings-toggle-input {
        display: none;
      }

      .map-settings-toggle-label {
        display: block;
        width: 50px;
        height: 30px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 15px;
        cursor: pointer;
        position: relative;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .map-settings-toggle-label::after {
        content: "";
        position: absolute;
        width: 26px;
        height: 26px;
        background: #fff;
        border-radius: 50%;
        top: 2px;
        left: 2px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .map-settings-toggle-input:checked + .map-settings-toggle-label {
        background: #1d9bf0;
      }

      .map-settings-toggle-input:checked + .map-settings-toggle-label::after {
        left: 22px;
      }

      /* 输入框样式 */
      .map-settings-input-wrapper {
        width: 180px;
      }

      .map-settings-input {
        width: 100%;
        padding: 10px 14px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        color: #fff;
        font-size: 14px;
        outline: none;
        transition: all 0.2s;
      }

      .map-settings-input::placeholder {
        color: rgba(255, 255, 255, 0.4);
      }

      .map-settings-input:focus {
        background: rgba(255, 255, 255, 0.15);
        border-color: #1d9bf0;
      }

      /* 标签管理样式 */
      .map-settings-tags-container {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 16px;
        min-height: 40px;
        padding: 12px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
      }

      .map-settings-tag {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 8px 12px;
        background: rgba(29, 155, 240, 0.15);
        border: 1px solid rgba(29, 155, 240, 0.3);
        border-radius: 20px;
        color: #1d9bf0;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }

      .map-settings-tag:hover {
        background: rgba(29, 155, 240, 0.25);
        border-color: rgba(29, 155, 240, 0.5);
      }

      .map-settings-tag-remove {
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
        transition: all 0.2s;
      }

      .map-settings-tag-remove:hover {
        background: rgba(255, 255, 255, 0.4);
      }

      .map-settings-tag-remove svg {
        width: 10px;
        height: 10px;
        stroke: currentColor;
        stroke-width: 2;
      }

      .map-settings-add-tag-btn {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 10px 16px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px dashed rgba(255, 255, 255, 0.3);
        border-radius: 10px;
        color: rgba(255, 255, 255, 0.7);
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }

      .map-settings-add-tag-btn:hover {
        background: rgba(255, 255, 255, 0.15);
        border-color: rgba(255, 255, 255, 0.5);
        color: #fff;
      }

      .map-settings-add-tag-btn svg {
        width: 18px;
        height: 18px;
      }

      /* ==================== 社交圈弹窗样式 - Instagram风格 ==================== */
      .map-social-circle-modal {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.6);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 105;
        animation: fadeIn 0.2s ease;
      }

      .map-social-circle-content {
        width: 90%;
        max-width: 500px;
        max-height: 80%;
        background: #1a1a1a;
        border-radius: 24px;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        animation: slideUp 0.3s ease;
      }

      .map-social-circle-header {
        display: flex;
        align-items: center;
        padding: 20px 24px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .map-social-circle-back-btn {
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.1);
        border: none;
        border-radius: 50%;
        color: #fff;
        cursor: pointer;
        transition: all 0.2s;
      }

      .map-social-circle-back-btn:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .map-social-circle-back-btn svg {
        width: 18px;
        height: 18px;
      }

      .map-social-circle-title {
        flex: 1;
        text-align: center;
        font-size: 18px;
        font-weight: 700;
        color: #fff;
        letter-spacing: -0.5px;
      }

      .map-social-circle-placeholder {
        width: 32px;
      }

      .map-social-circle-body {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
      }

      .map-social-circle-body::-webkit-scrollbar {
        width: 6px;
      }

      .map-social-circle-body::-webkit-scrollbar-track {
        background: transparent;
      }

      .map-social-circle-body::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
      }

      /* Empty State */
      .map-social-circle-empty {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 60px 32px;
        text-align: center;
      }

      .map-social-circle-empty svg {
        width: 64px;
        height: 64px;
        color: rgba(255, 255, 255, 0.3);
        margin-bottom: 20px;
      }

      .map-social-circle-empty-text {
        font-size: 18px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.8);
        margin-bottom: 8px;
      }

      .map-social-circle-empty-desc {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.5);
        line-height: 1.5;
      }

      /* 社交圈好友列表 */
      .map-social-circle-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      /* 好友卡片 */
      .map-social-circle-friend-card {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 16px;
        cursor: pointer;
        transition: all 0.2s;
      }

      .map-social-circle-friend-card:hover {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
      }

      .map-social-circle-friend-header {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 12px;
      }

      .map-social-circle-friend-avatar {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        object-fit: cover;
      }

      .map-social-circle-friend-info {
        flex: 1;
        min-width: 0;
      }

      .map-social-circle-friend-name {
        font-size: 16px;
        font-weight: 600;
        color: #fff;
        margin-bottom: 4px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .map-social-circle-friend-handle {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.5);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .map-social-circle-friend-relationship {
        padding: 4px 12px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        font-size: 12px;
        font-weight: 500;
        color: rgba(255, 255, 255, 0.8);
        white-space: nowrap;
      }

      .map-social-circle-friend-bio {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.7);
        line-height: 1.5;
        margin-bottom: 12px;
        overflow: hidden;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
      }

      .map-social-circle-friend-stats {
        display: flex;
        gap: 16px;
      }

      .map-social-circle-friend-stat {
        display: flex;
        align-items: center;
        gap: 4px;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.5);
      }

      .map-social-circle-friend-stat-value {
        font-weight: 600;
        color: rgba(255, 255, 255, 0.8);
      }

      /* ==================== 聊天弹窗样式 ==================== */
      .map-chat-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 480px;
        height: 80%;
        max-height: 700px;
        background: #000;
        border-radius: 20px;
        z-index: 300;
        display: none;
        flex-direction: column;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        overflow: hidden;
      }

      .map-chat-modal.show {
        display: flex;
      }

      /* 聊天顶栏 */
      .map-chat-header {
        display: flex;
        align-items: center;
        padding: 16px 20px;
        border-bottom: 1px solid #2f2f2f;
        background: #000;
      }

      .map-chat-back-btn {
        background: none;
        border: none;
        padding: 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 12px;
      }

      .map-chat-back-btn svg {
        width: 24px;
        height: 24px;
        stroke: #fff;
        stroke-width: 2;
        fill: none;
      }

      .map-chat-user-info {
        display: flex;
        align-items: center;
        gap: 12px;
        flex: 1;
      }

      .map-chat-user-avatar {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        object-fit: cover;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .map-chat-user-avatar:hover {
        transform: scale(1.08);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }

      .map-chat-user-avatar:active {
        transform: scale(0.98);
      }

      .map-chat-user-name {
        font-size: 16px;
        font-weight: 600;
        color: #fff;
      }

      .map-chat-more-btn {
        background: none;
        border: none;
        padding: 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .map-chat-more-btn svg {
        width: 20px;
        height: 20px;
        fill: #fff;
      }

      /* More options下拉菜单 */
      .map-chat-more-menu {
        position: absolute;
        top: 56px;
        right: 12px;
        background: #2a2a2a;
        border: 1px solid #3a3a3a;
        border-radius: 8px;
        min-width: 180px;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
        opacity: 0;
        pointer-events: none;
        transform: translateY(-10px);
        transition: all 0.2s ease;
        z-index: 50;
      }

      .map-chat-more-menu.show {
        opacity: 1;
        pointer-events: all;
        transform: translateY(0);
      }

      .map-chat-more-menu-item {
        width: 100%;
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 16px;
        background: transparent;
        border: none;
        color: #e0e0e0;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: left;
      }

      .map-chat-more-menu-item:hover {
        background: #333;
      }

      .map-chat-more-menu-item svg {
        stroke: #4a9eff;
        flex-shrink: 0;
      }

      /* 消息列表区域 */
      .map-chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 4px;
        background: #000;
      }

      .map-chat-messages::-webkit-scrollbar {
        width: 6px;
      }

      .map-chat-messages::-webkit-scrollbar-track {
        background: transparent;
      }

      .map-chat-messages::-webkit-scrollbar-thumb {
        background: #3a3a3a;
        border-radius: 3px;
      }

      /* 时间戳 */
      .map-chat-timestamp {
        text-align: center;
        font-size: 12px;
        color: #71767b;
        margin: 12px 0;
      }

      /* 消息组（同一发送者的连续消息） */
      .map-chat-message-group {
        display: flex;
        flex-direction: column;
        gap: 4px;
        margin-bottom: 12px;
      }

      .map-chat-message-group.sent {
        align-items: flex-end;
      }

      .map-chat-message-group.received {
        align-items: flex-start;
      }

      /* 消息行（包含头像和气泡） */
      .map-chat-message-row {
        display: flex;
        align-items: flex-end;
        gap: 8px;
        max-width: 80%;
      }

      .map-chat-message-row.sent {
        flex-direction: row-reverse;
        margin-left: auto;
      }

      .map-chat-message-row.received {
        flex-direction: row;
        margin-right: auto;
      }

      /* 头像占位（隐藏时保持布局） */
      .map-chat-message-avatar-placeholder {
        width: 36px;
        height: 36px;
        flex-shrink: 0;
        visibility: hidden;
      }

      .map-chat-message-avatar {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        object-fit: cover;
        flex-shrink: 0;
      }

      /* 消息气泡 */
      .map-chat-bubble {
        padding: 12px 16px;
        font-size: 15px;
        line-height: 1.4;
        word-wrap: break-word;
        position: relative;
      }

      /* 接收的消息（左侧，黑色边框气泡） */
      .map-chat-message-row.received .map-chat-bubble {
        background: #000;
        border: 1px solid #3a3a3a;
        border-radius: 18px;
        border-top-left-radius: 4px;
        color: #fff;
      }

      /* 接收消息组中非最后一条的圆角 */
      .map-chat-message-group.received .map-chat-message-row:not(:last-child) .map-chat-bubble {
        border-radius: 18px;
      }

      /* 发送的消息（右侧，灰色气泡） */
      .map-chat-message-row.sent .map-chat-bubble {
        background: #3a3a3a;
        border-radius: 18px;
        border-top-right-radius: 4px;
        color: #fff;
      }

      /* 发送消息组中非最后一条的圆角 */
      .map-chat-message-group.sent .map-chat-message-row:not(:last-child) .map-chat-bubble {
        border-radius: 18px;
      }

      /* 表情包样式 - 不要气泡，直接显示图片 */
      .map-chat-sticker {
        max-width: 120px;
        max-height: 120px;
        width: auto;
        height: auto;
        border-radius: 8px;
        object-fit: contain;
        user-select: none;
        cursor: default;
        display: block;
      }

      /* 🚨 系统消息样式 */
      .map-chat-system-message {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        padding: 16px;
        margin: 16px 0;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 14px;
        border-left: 3px solid #fff;
      }

      .map-chat-system-message-icon {
        width: 20px;
        height: 20px;
        flex-shrink: 0;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .map-chat-system-message-icon svg {
        width: 100%;
        height: 100%;
      }

      .map-chat-system-message-text {
        flex: 1;
        font-size: 14px;
        line-height: 1.5;
        color: #e5e5e5;
        font-weight: 500;
      }

      /* ==================== 🗑️ 删除模式样式 ==================== */
      /* 删除模式工具栏 */
      .map-chat-delete-toolbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 16px;
        background: #1a1a1a;
        border-top: 1px solid #2f2f2f;
        gap: 12px;
      }

      .map-chat-delete-left {
        display: flex;
        align-items: center;
      }

      .map-chat-delete-checkbox-wrapper {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        user-select: none;
      }

      .map-chat-delete-checkbox-wrapper input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
      }

      .map-chat-delete-checkbox-wrapper span {
        font-size: 14px;
        color: #d0d0d0;
        font-weight: 500;
      }

      .map-chat-delete-actions {
        display: flex;
        gap: 8px;
      }

      .map-chat-delete-btn {
        padding: 8px 12px;
        border: none;
        border-radius: 6px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
        transition: all 0.2s ease;
        background: #2a2a2a;
        color: #d0d0d0;
      }

      .map-chat-delete-btn:hover:not(:disabled) {
        background: #3a3a3a;
        color: #fff;
      }

      .map-chat-delete-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .map-chat-delete-btn.danger {
        background: #dc3545;
        color: #fff;
      }

      .map-chat-delete-btn.danger:hover {
        background: #c82333;
      }

      .map-chat-delete-btn.exit {
        background: #28a745;
        color: #fff;
      }

      .map-chat-delete-btn.exit:hover {
        background: #218838;
      }

      .map-chat-delete-btn svg {
        flex-shrink: 0;
      }

      /* 删除模式下消息气泡的选中状态 */
      .map-chat-bubble.delete-mode {
        cursor: pointer;
        user-select: none;
        transition: all 0.2s ease;
      }

      .map-chat-bubble.delete-mode:hover {
        transform: scale(0.98);
        opacity: 0.9;
      }

      .map-chat-bubble.delete-mode.selected {
        border: 2px solid #4a9eff;
        background: rgba(74, 158, 255, 0.15) !important;
        box-shadow: 0 0 0 4px rgba(74, 158, 255, 0.1);
      }

      .map-chat-bubble.delete-mode.selected .map-chat-bubble-content {
        opacity: 0.9;
      }

      /* 聊天底栏 */
      .map-chat-footer {
        display: flex;
        align-items: center;
        padding: 12px 16px;
        border-top: 1px solid #2f2f2f;
        background: #000;
        gap: 12px;
      }

      .map-chat-add-btn {
        background: none;
        border: none;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        flex-shrink: 0;
        transition: background 0.2s;
      }

      .map-chat-add-btn:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      .map-chat-add-btn svg {
        width: 24px;
        height: 24px;
        stroke: #fff;
        stroke-width: 2;
        fill: none;
      }

      .map-chat-input-wrapper {
        flex: 1;
        position: relative;
      }

      .map-chat-input {
        width: 100%;
        background: #1a1a1a;
        border: 1px solid #3a3a3a;
        border-radius: 20px;
        padding: 10px 16px;
        color: #fff;
        font-size: 15px;
        outline: none;
        transition: border-color 0.2s;
      }

      .map-chat-input:focus {
        border-color: #555;
      }

      .map-chat-input::placeholder {
        color: #71767b;
      }

      .map-chat-like-btn {
        background: none;
        border: none;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        flex-shrink: 0;
        transition: background 0.2s;
      }

      .map-chat-like-btn:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      .map-chat-like-btn svg {
        width: 24px;
        height: 24px;
        fill: #fff;
      }

      /* 聊天遮罩 */
      .map-chat-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 299;
        display: none;
      }

      .map-chat-overlay.show {
        display: block;
      }

      /* ==================== 📌 功能收纳菜单样式（简约暗色） ==================== */
      .map-chat-function-menu-wrapper {
        position: relative;
      }

      .map-chat-function-menu {
        position: absolute;
        bottom: 100%;
        left: 0;
        margin-bottom: 10px;
        opacity: 0;
        transform: translateY(10px);
        transition: all 0.2s ease;
        pointer-events: none;
      }

      .map-chat-function-menu.show {
        opacity: 1;
        transform: translateY(0);
        pointer-events: all;
      }

      .map-chat-function-item {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 40px;
        height: 40px;
        background: #2a2a2a;
        border: 1px solid #3a3a3a;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        color: #888;
      }

      .map-chat-function-item:hover {
        background: #333;
        color: #4a9eff;
        border-color: #4a9eff;
      }

      .map-chat-function-item svg {
        width: 20px;
        height: 20px;
      }

      /* ==================== 📌 笔记弹窗样式（简约暗色） ==================== */
      .map-notes-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 399;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
      }

      .map-notes-overlay.show {
        opacity: 1;
        pointer-events: all;
      }

      .map-notes-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.95);
        width: min(480px, 90vw);
        max-height: 70vh;
        background: #1a1a1a;
        border: 1px solid #3a3a3a;
        border-radius: 12px;
        z-index: 400;
        opacity: 0;
        pointer-events: none;
        transition: all 0.2s ease;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .map-notes-modal.show {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        pointer-events: all;
      }

      .map-notes-container {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
        overflow: hidden;
      }

      /* 头部 */
      .map-notes-header {
        padding: 16px 20px;
        border-bottom: 1px solid #2a2a2a;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .map-notes-main-tabs {
        display: flex;
        gap: 4px;
        background: #2a2a2a;
        padding: 3px;
        border-radius: 8px;
      }

      .map-notes-main-tab {
        padding: 6px 16px;
        background: transparent;
        border: none;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        color: #888;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
      }

      .map-notes-main-tab:hover {
        color: #b0b0b0;
      }

      .map-notes-main-tab.active {
        background: #1a1a1a;
        color: #e0e0e0;
      }

      .map-notes-close {
        width: 32px;
        height: 32px;
        background: transparent;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #888;
        transition: all 0.2s ease;
      }

      .map-notes-close:hover {
        background: #2a2a2a;
        color: #e0e0e0;
      }

      /* Tabs过滤 */
      .map-notes-tabs {
        padding: 12px 20px;
        border-bottom: 1px solid #2a2a2a;
        display: flex;
        gap: 8px;
        overflow-x: auto;
        scrollbar-width: none;
        flex-wrap: nowrap;
        flex-shrink: 0;
        align-items: center;
      }

      .map-notes-tabs::-webkit-scrollbar {
        display: none;
      }

      .map-notes-tab {
        padding: 6px 14px;
        background: transparent;
        border: 1px solid #3a3a3a;
        border-radius: 6px;
        color: #888;
        font-size: 13px;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
        flex-shrink: 0;
      }

      .map-notes-tab:hover {
        border-color: #4a9eff;
        color: #4a9eff;
      }

      .map-notes-tab.active {
        background: #4a9eff;
        border-color: #4a9eff;
        color: #fff;
      }

      /* 笔记列表（时间线式） */
      .map-notes-list {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        min-height: 0;
        -webkit-overflow-scrolling: touch;
      }

      .map-notes-list::-webkit-scrollbar {
        width: 6px;
      }

      .map-notes-list::-webkit-scrollbar-track {
        background: transparent;
      }

      .map-notes-list::-webkit-scrollbar-thumb {
        background: #3a3a3a;
        border-radius: 3px;
      }

      .map-notes-list::-webkit-scrollbar-thumb:hover {
        background: #4a4a4a;
      }

      /* 空状态 */
      .map-notes-empty {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 40px 20px;
        text-align: center;
        color: #666;
      }

      .map-notes-empty svg {
        color: #3a3a3a;
        margin-bottom: 16px;
      }

      .map-notes-empty p {
        font-size: 15px;
        font-weight: 500;
        color: #888;
        margin: 0 0 8px 0;
      }

      .map-notes-empty span {
        font-size: 13px;
        color: #666;
      }

      /* 笔记项（时间线式） */
      .map-notes-item {
        display: flex;
        gap: 12px;
        padding: 16px 0;
        border-bottom: 1px solid #2a2a2a;
        animation: noteItemIn 0.3s ease;
      }

      .map-notes-item:last-child {
        border-bottom: none;
      }

      .map-notes-item-icon {
        width: 36px;
        height: 36px;
        flex-shrink: 0;
        background: #4a9eff;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #fff;
      }

      .map-notes-item-icon svg {
        width: 18px;
        height: 18px;
      }

      .map-notes-item-content {
        flex: 1;
        min-width: 0;
      }

      .map-notes-item-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 6px;
      }

      .map-notes-item-category {
        font-size: 13px;
        font-weight: 500;
        color: #e0e0e0;
      }

      .map-notes-item-time {
        font-size: 12px;
        color: #666;
      }

      .map-notes-item-text {
        font-size: 14px;
        line-height: 1.5;
        color: #b0b0b0;
        word-break: break-word;
      }

      .map-notes-item-actions {
        display: flex;
        gap: 8px;
        margin-top: 10px;
      }

      .map-notes-item-action {
        padding: 5px 12px;
        background: transparent;
        border: 1px solid #3a3a3a;
        border-radius: 5px;
        color: #888;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 4px;
      }

      .map-notes-item-action:hover {
        border-color: #4a9eff;
        color: #4a9eff;
      }

      .map-notes-item-action svg {
        width: 14px;
        height: 14px;
      }

      @keyframes noteItemIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* ==================== 📌 分类选择菜单（简洁列表） ==================== */
      .map-notes-picker-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 498;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
      }

      .map-notes-picker-overlay.show {
        opacity: 1;
        pointer-events: all;
      }

      .map-notes-picker {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.95);
        width: min(280px, 85vw);
        background: #2a2a2a;
        border: 1px solid #3a3a3a;
        border-radius: 8px;
        z-index: 499;
        opacity: 0;
        pointer-events: none;
        transition: all 0.2s ease;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      }

      .map-notes-picker.show {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        pointer-events: all;
      }

      .map-notes-picker-header {
        padding: 14px 16px;
        border-bottom: 1px solid #3a3a3a;
        font-size: 14px;
        font-weight: 600;
        color: #e0e0e0;
      }

      .map-notes-picker-list {
        max-height: 400px;
        overflow-y: auto;
      }

      .map-notes-picker-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 16px;
        cursor: pointer;
        transition: all 0.2s ease;
        border-bottom: 1px solid #2a2a2a;
        color: #b0b0b0;
      }

      .map-notes-picker-item:last-child {
        border-bottom: none;
      }

      .map-notes-picker-item:hover {
        background: #333;
      }

      .map-notes-picker-item svg {
        width: 18px;
        height: 18px;
        color: #4a9eff;
      }

      /* 消息标记高亮效果（简约灰色边框） */
      .map-chat-bubble.marking {
        border: 2px solid #4a9eff !important;
        background: rgba(74, 158, 255, 0.1) !important;
      }


      /* 聊天列表弹窗样式 */
      .map-chats-list-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 399;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
      }

      .map-chats-list-overlay.show {
        opacity: 1;
        pointer-events: all;
      }

      .map-chats-list-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.95);
        width: min(420px, 90vw);
        max-height: 70vh;
        background: #1a1a1a;
        border: 1px solid #3a3a3a;
        border-radius: 12px;
        z-index: 400;
        opacity: 0;
        pointer-events: none;
        transition: all 0.2s ease;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      }

      .map-chats-list-modal.show {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        pointer-events: all;
      }

      .map-chats-list-container {
        display: flex;
        flex-direction: column;
        max-height: 70vh;
        height: 100%;
      }

      /* 头部 */
      .map-chats-list-header {
        padding: 16px 20px;
        border-bottom: 1px solid #2a2a2a;
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-shrink: 0;
      }

      .map-chats-list-title {
        font-size: 16px;
        font-weight: 600;
        color: #e0e0e0;
        margin: 0;
      }

      .map-chats-list-close {
        width: 32px;
        height: 32px;
        background: transparent;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #888;
        transition: all 0.2s ease;
      }

      .map-chats-list-close:hover {
        background: #2a2a2a;
        color: #e0e0e0;
      }

      /* 聊天列表内容 */
      .map-chats-list-content {
        flex: 1;
        overflow-y: auto;
        padding: 12px;
        min-height: 0;
      }

      .map-chats-list-content::-webkit-scrollbar {
        width: 6px;
      }

      .map-chats-list-content::-webkit-scrollbar-track {
        background: transparent;
      }

      .map-chats-list-content::-webkit-scrollbar-thumb {
        background: #3a3a3a;
        border-radius: 3px;
      }

      .map-chats-list-content::-webkit-scrollbar-thumb:hover {
        background: #4a4a4a;
      }

      /* 空状态 */
      .map-chats-list-empty {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 40px 20px;
        text-align: center;
        color: #666;
      }

      .map-chats-list-empty svg {
        color: #3a3a3a;
        margin-bottom: 16px;
      }

      .map-chats-list-empty p {
        font-size: 15px;
        font-weight: 500;
        color: #888;
        margin: 0 0 8px 0;
      }

      .map-chats-list-empty span {
        font-size: 13px;
        color: #666;
      }

      /* 聊天项 */
      .map-chats-list-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        background: #2a2a2a;
        border: 1px solid #3a3a3a;
        border-radius: 10px;
        margin-bottom: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        animation: chatItemIn 0.3s ease;
      }

      .map-chats-list-item:hover {
        background: #333;
        border-color: #4a9eff;
      }

      .map-chats-list-item:last-child {
        margin-bottom: 0;
      }

      @keyframes chatItemIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .map-chats-list-item-avatar {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        flex-shrink: 0;
        object-fit: cover;
        background: #3a3a3a;
      }

      .map-chats-list-item-info {
        flex: 1;
        min-width: 0;
      }

      .map-chats-list-item-name {
        font-size: 14px;
        font-weight: 500;
        color: #e0e0e0;
        margin: 0 0 4px 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .map-chats-list-item-preview {
        font-size: 13px;
        color: #888;
        margin: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .map-chats-list-item-delete {
        width: 32px;
        height: 32px;
        background: transparent;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #666;
        transition: all 0.2s ease;
        flex-shrink: 0;
      }

      .map-chats-list-item-delete:hover {
        background: #ff4444;
        color: #fff;
      }

      .map-chats-list-item-delete svg {
        width: 18px;
        height: 18px;
      }

      /* 🎯 指定筛选弹窗样式（简约暗色风格） */
      .map-advanced-filter-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        z-index: 498;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
      }

      .map-advanced-filter-overlay.show {
        opacity: 1;
        visibility: visible;
      }

      .map-advanced-filter-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.95);
        width: min(420px, 90vw);
        max-height: 80vh;
        background: #1a1a1a;
        border: 1px solid #3a3a3a;
        border-radius: 12px;
        z-index: 499;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
      }

      .map-advanced-filter-modal.show {
        opacity: 1;
        visibility: visible;
        transform: translate(-50%, -50%) scale(1);
      }

      .map-advanced-filter-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        overflow: hidden;
      }

      .map-advanced-filter-header {
        padding: 16px 20px;
        border-bottom: 1px solid #2a2a2a;
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-shrink: 0;
      }

      .map-advanced-filter-title {
        font-size: 16px;
        font-weight: 600;
        color: #e0e0e0;
        margin: 0;
      }

      .map-advanced-filter-close {
        width: 32px;
        height: 32px;
        background: transparent;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #888;
        transition: all 0.2s ease;
      }

      .map-advanced-filter-close:hover {
        background: #2a2a2a;
        color: #e0e0e0;
      }

      .map-advanced-filter-form {
        padding: 20px;
        overflow-y: auto;
        flex: 1;
      }

      .map-filter-field {
        margin-bottom: 20px;
      }

      .map-filter-field:last-child {
        margin-bottom: 0;
      }

      .map-filter-label {
        display: block;
        font-size: 13px;
        font-weight: 500;
        color: #b0b0b0;
        margin-bottom: 8px;
      }

      .map-filter-radio-group {
        display: flex;
        gap: 12px;
      }

      .map-filter-radio {
        display: flex;
        align-items: center;
        cursor: pointer;
        user-select: none;
      }

      .map-filter-radio input[type="radio"] {
        appearance: none;
        width: 18px;
        height: 18px;
        border: 2px solid #3a3a3a;
        border-radius: 50%;
        margin-right: 8px;
        position: relative;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .map-filter-radio input[type="radio"]:checked {
        border-color: #4a9eff;
      }

      .map-filter-radio input[type="radio"]:checked::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 8px;
        height: 8px;
        background: #4a9eff;
        border-radius: 50%;
      }

      .map-filter-radio span {
        font-size: 14px;
        color: #e0e0e0;
      }

      .map-filter-range {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .map-filter-input {
        flex: 1;
        background: #2a2a2a;
        border: 1px solid #3a3a3a;
        border-radius: 6px;
        padding: 10px 12px;
        color: #e0e0e0;
        font-size: 14px;
        outline: none;
        transition: all 0.2s ease;
      }

      .map-filter-input:focus {
        border-color: #4a9eff;
        background: #252525;
      }

      .map-filter-separator {
        color: #888;
        font-size: 14px;
      }

      .map-filter-textarea {
        width: 100%;
        background: #2a2a2a;
        border: 1px solid #3a3a3a;
        border-radius: 6px;
        padding: 10px 12px;
        color: #e0e0e0;
        font-size: 14px;
        outline: none;
        resize: none;
        transition: all 0.2s ease;
      }

      .map-filter-textarea:focus {
        border-color: #4a9eff;
        background: #252525;
      }

      .map-filter-textarea-multi {
        resize: vertical;
      }

      .map-filter-textarea::placeholder,
      .map-filter-input::placeholder {
        color: #666;
      }

      .map-advanced-filter-footer {
        padding: 16px 20px;
        border-top: 1px solid #2a2a2a;
        display: flex;
        gap: 12px;
        flex-shrink: 0;
      }

      .map-advanced-filter-btn {
        flex: 1;
        padding: 10px 16px;
        border: none;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .map-advanced-filter-btn-cancel {
        background: transparent;
        color: #888;
        border: 1px solid #3a3a3a;
      }

      .map-advanced-filter-btn-cancel:hover {
        background: #2a2a2a;
        color: #b0b0b0;
      }

      .map-advanced-filter-btn-clear {
        background: #2a2a2a;
        color: #e0e0e0;
      }

      .map-advanced-filter-btn-clear:hover {
        background: #333;
      }

      .map-advanced-filter-btn-apply {
        background: #4a9eff;
        color: #fff;
      }

      .map-advanced-filter-btn-apply:hover {
        background: #3a8eef;
      }

      /* 指定筛选按钮样式 */
      .filter-btn-advanced {
        margin-left: 4px;
      }

      .filter-btn-advanced svg {
        width: 18px;
        height: 18px;
      }

      /* ==================== 地标事件系统样式 ==================== */

      /* 有事件的地标样式 */
      .map-landmark.has-event {
        position: relative;
        animation: landmarkPulse 2s ease-in-out infinite;
      }

      @keyframes landmarkPulse {
        0%, 100% {
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5), 0 0 0 0 rgba(201, 48, 44, 0.7);
        }
        50% {
          box-shadow: 0 6px 20px rgba(0, 0, 0, 0.7), 0 0 0 10px rgba(201, 48, 44, 0);
        }
      }

      /* 事件徽章（右上角红点）*/
      .map-landmark.has-event::after {
        content: '';
        position: absolute;
        top: -2px;
        right: -2px;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #ff3b30;
        border: 2px solid var(--map-bg-primary, #1a1a1a);
        animation: badgePulse 1.5s ease-in-out infinite;
        z-index: 1;
      }

      @keyframes badgePulse {
        0%, 100% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.2);
          opacity: 0.8;
        }
      }

      /* 光晕效果 */
      .map-landmark.has-event::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 70px;
        height: 70px;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(201, 48, 44, 0.3) 0%, transparent 70%);
        transform: translate(-50%, -50%);
        animation: landmarkGlow 2s ease-in-out infinite;
        pointer-events: none;
        z-index: -1;
      }

      @keyframes landmarkGlow {
        0%, 100% {
          opacity: 0.5;
          transform: translate(-50%, -50%) scale(1);
        }
        50% {
          opacity: 0.8;
          transform: translate(-50%, -50%) scale(1.2);
        }
      }

      /* ==================== 事件弹窗样式 ==================== */

      /* CSS变量扩展 - 事件系统专用 */
      :root {
        --event-bg-primary: #1a1a1a;
        --event-bg-secondary: #252525;
        --event-bg-tertiary: #2f2f2f;
        --event-bg-paper: #1e1e1e;
        --event-text-primary: #f5f5f5;
        --event-text-secondary: #d0d0d0;
        --event-text-muted: #909090;
        --event-border-light: #3a3a3a;
        --event-border-medium: #4a4a4a;
        --event-border-dark: #2a2a2a;
        --event-accent: #c9302c;
        --event-accent-hover: #ac2925;
        --event-overlay: rgba(0, 0, 0, 0.92);
        --event-shadow-sm: rgba(0, 0, 0, 0.3);
        --event-shadow-md: rgba(0, 0, 0, 0.5);
        --event-shadow-lg: rgba(0, 0, 0, 0.7);
        --event-image-filter: grayscale(0.3) contrast(1.1);
      }

      /* 浅色主题 - 事件系统变量 */
      #x-map-container.light-theme {
        --event-bg-primary: #fefefe;
        --event-bg-secondary: #f8f8f8;
        --event-bg-tertiary: #f0f0f0;
        --event-bg-paper: #ffffff;
        --event-text-primary: #1a1a1a;
        --event-text-secondary: #3a3a3a;
        --event-text-muted: #707070;
        --event-border-light: #e0e0e0;
        --event-border-medium: #c0c0c0;
        --event-border-dark: #a0a0a0;
        --event-accent: #c9302c;
        --event-accent-hover: #ac2925;
        --event-overlay: rgba(0, 0, 0, 0.7);
        --event-shadow-sm: rgba(0, 0, 0, 0.08);
        --event-shadow-md: rgba(0, 0, 0, 0.12);
        --event-shadow-lg: rgba(0, 0, 0, 0.16);
        --event-image-filter: grayscale(0.2) contrast(1.05);
      }

      /* Modal 结构 */
      .event-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--event-overlay);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 100000;
        padding: 20px;
        animation: eventFadeIn 0.25s ease;
        overflow-y: auto;
        backdrop-filter: blur(8px);
      }

      .event-modal-overlay.active {
        display: flex;
      }

      @keyframes eventFadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      .event-modal-container {
        background: var(--event-bg-paper);
        width: 100%;
        max-width: 720px;
        max-height: 90vh;
        border-radius: 4px;
        box-shadow:
          0 0 0 1px var(--event-border-medium),
          0 20px 60px var(--event-shadow-lg);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        animation: eventSlideUp 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        position: relative;
      }

      @keyframes eventSlideUp {
        from {
          opacity: 0;
          transform: translateY(40px) scale(0.96);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      .event-controls {
        position: absolute;
        top: 20px;
        right: 20px;
        display: flex;
        gap: 10px;
        z-index: 10;
      }

      .event-btn {
        width: 40px;
        height: 40px;
        border: 1px solid var(--event-border-medium);
        background: var(--event-bg-primary);
        color: var(--event-text-primary);
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        transition: all 0.2s ease;
        backdrop-filter: blur(10px);
        box-shadow: 0 2px 12px var(--event-shadow-md);
      }

      .event-btn:hover {
        background: var(--event-accent);
        border-color: var(--event-accent);
        color: white;
        transform: scale(1.08);
      }

      .event-btn:active {
        transform: scale(0.92);
      }

      .event-content {
        padding: 0;
        overflow-y: auto;
        flex: 1;
      }

      /* 报纸头部 */
      .event-paper-header {
        border-bottom: 3px double var(--event-border-dark);
        padding: 24px 32px 16px;
        background: var(--event-bg-secondary);
        position: relative;
      }

      .event-paper-header::before,
      .event-paper-header::after {
        content: '';
        position: absolute;
        left: 0;
        right: 0;
        height: 1px;
        background: var(--event-border-light);
      }

      .event-paper-header::before { top: 0; }
      .event-paper-header::after { bottom: 0; }

      .event-masthead {
        font-family: "Playfair Display", serif;
        font-size: 36px;
        font-weight: 900;
        text-align: center;
        letter-spacing: 2px;
        color: var(--event-text-primary);
        margin-bottom: 8px;
        text-transform: uppercase;
      }

      .event-tagline {
        font-family: "Courier New", monospace;
        font-size: 11px;
        text-align: center;
        color: var(--event-text-muted);
        letter-spacing: 1.5px;
        text-transform: uppercase;
      }

      .event-header-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px solid var(--event-border-light);
        font-size: 11px;
        color: var(--event-text-muted);
        font-family: "Courier New", monospace;
      }

      /* 文章内容区 */
      .event-article {
        padding: 32px 40px 40px;
      }

      .event-tags {
        margin-bottom: 20px;
      }

      .event-tag {
        display: inline-block;
        background: var(--event-accent);
        color: white;
        font-size: 10px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        padding: 5px 12px;
        border-radius: 2px;
        margin-right: 6px;
        margin-bottom: 8px;
      }

      .event-tag.secondary {
        background: var(--event-bg-tertiary);
        color: var(--event-text-primary);
        border: 1px solid var(--event-border-medium);
      }

      .event-headline {
        font-family: "Playfair Display", serif;
        font-size: 42px;
        font-weight: 900;
        line-height: 1.15;
        color: var(--event-text-primary);
        margin-bottom: 16px;
        letter-spacing: -0.8px;
      }

      .event-subheadline {
        font-family: "Merriweather", serif;
        font-size: 26px;
        font-weight: 700;
        line-height: 1.3;
        color: var(--event-text-primary);
        margin-top: 32px;
        margin-bottom: 14px;
      }

      .event-title {
        font-family: "Merriweather", serif;
        font-size: 20px;
        font-weight: 700;
        color: var(--event-text-primary);
        margin-top: 24px;
        margin-bottom: 12px;
      }

      .event-lead {
        font-family: "Libre Baskerville", serif;
        font-size: 20px;
        line-height: 1.7;
        color: var(--event-text-secondary);
        margin-bottom: 24px;
        font-weight: 400;
      }

      .event-body {
        font-family: "Crimson Text", serif;
        font-size: 19px;
        line-height: 1.8;
        color: var(--event-text-secondary);
        margin-bottom: 18px;
      }

      .event-body-sans {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        font-size: 16px;
        line-height: 1.7;
        color: var(--event-text-secondary);
        margin-bottom: 16px;
      }

      .event-caption {
        font-size: 14px;
        line-height: 1.6;
        color: var(--event-text-muted);
        font-style: italic;
      }

      .event-drop-cap::first-letter {
        font-family: "Playfair Display", serif;
        font-size: 80px;
        font-weight: 900;
        line-height: 0.85;
        float: left;
        margin: 8px 12px 0 0;
        color: var(--event-accent);
      }

      .event-quote {
        font-family: "Libre Baskerville", serif;
        font-size: 22px;
        font-style: italic;
        line-height: 1.65;
        color: var(--event-text-primary);
        border-left: 3px solid var(--event-accent);
        padding-left: 24px;
        margin: 32px 0;
        position: relative;
      }

      .event-quote::before {
        content: '"';
        font-family: "Playfair Display", serif;
        font-size: 60px;
        position: absolute;
        left: -10px;
        top: -15px;
        color: var(--event-accent);
        opacity: 0.3;
      }

      .event-quote-author {
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        font-size: 14px;
        font-style: normal;
        font-weight: 600;
        color: var(--event-text-muted);
        margin-top: 10px;
        text-transform: uppercase;
        letter-spacing: 0.8px;
      }

      .event-byline {
        font-size: 13px;
        color: var(--event-text-muted);
        margin-bottom: 20px;
        padding-bottom: 20px;
        border-bottom: 1px solid var(--event-border-light);
      }

      .event-byline strong {
        color: var(--event-text-primary);
        font-weight: 600;
      }

      .event-divider {
        border: none;
        border-top: 1px solid var(--event-border-light);
        margin: 28px 0;
      }

      .event-divider-thick {
        border: none;
        border-top: 3px solid var(--event-text-primary);
        margin: 32px 0;
      }

      .event-divider-double {
        border: none;
        border-top: 3px double var(--event-border-dark);
        margin: 28px 0;
      }

      .event-list {
        margin: 20px 0;
        padding-left: 28px;
      }

      .event-list li {
        font-family: "Crimson Text", serif;
        font-size: 19px;
        line-height: 1.8;
        color: var(--event-text-secondary);
        margin-bottom: 10px;
      }

      .event-list-clean {
        list-style: none;
        padding-left: 0;
      }

      .event-list-clean li {
        padding-left: 24px;
        position: relative;
      }

      .event-list-clean li::before {
        content: '•';
        position: absolute;
        left: 8px;
        color: var(--event-accent);
        font-weight: bold;
      }

      .event-box {
        background: var(--event-bg-secondary);
        border: 1px solid var(--event-border-medium);
        padding: 20px 24px;
        border-radius: 3px;
        margin: 28px 0;
      }

      .event-box-highlight {
        background: var(--event-bg-tertiary);
        border-left: 4px solid var(--event-accent);
        padding: 20px 24px;
        margin: 28px 0;
      }

      .event-box-alert {
        background: var(--event-accent);
        color: white;
        padding: 20px 24px;
        border-radius: 3px;
        margin: 28px 0;
        font-weight: 600;
      }

      .event-box-alert * {
        color: white !important;
      }

      .event-table {
        width: 100%;
        border-collapse: collapse;
        margin: 28px 0;
        font-size: 15px;
        border: 1px solid var(--event-border-medium);
      }

      .event-table th {
        background: var(--event-bg-secondary);
        color: var(--event-text-primary);
        font-weight: 700;
        text-align: left;
        padding: 14px 16px;
        border-bottom: 2px solid var(--event-border-dark);
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .event-table td {
        padding: 14px 16px;
        border-bottom: 1px solid var(--event-border-light);
        color: var(--event-text-secondary);
        font-family: "Crimson Text", serif;
        font-size: 17px;
      }

      .event-table tr:last-child td {
        border-bottom: none;
      }

      .event-columns-2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 24px;
        margin: 28px 0;
      }

      .event-sidebar-box {
        background: var(--event-bg-secondary);
        border: 1px solid var(--event-border-medium);
        padding: 20px;
        margin-bottom: 20px;
      }

      .event-sidebar-box h3 {
        font-family: "Merriweather", serif;
        font-size: 16px;
        font-weight: 700;
        margin-bottom: 12px;
        color: var(--event-text-primary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .event-emphasis {
        color: var(--event-accent);
        font-weight: 600;
      }

      .event-bold {
        font-weight: 700;
        color: var(--event-text-primary);
      }

      .event-footer {
        border-top: 3px double var(--event-border-dark);
        padding: 20px 40px;
        background: var(--event-bg-secondary);
        text-align: center;
        font-size: 11px;
        color: var(--event-text-muted);
        font-family: "Courier New", monospace;
        letter-spacing: 1px;
      }

      /* 响应式 */
      @media (max-width: 768px) {
        .event-modal-overlay {
          padding: 0;
          align-items: flex-end;
        }

        .event-modal-container {
          max-width: 100%;
          max-height: 95vh;
          border-radius: 12px 12px 0 0;
        }

        .event-paper-header {
          padding: 20px 20px 14px;
        }

        .event-masthead {
          font-size: 28px;
        }

        .event-article {
          padding: 24px 20px 32px;
        }

        .event-headline {
          font-size: 32px;
        }

        .event-subheadline {
          font-size: 22px;
        }

        .event-lead {
          font-size: 18px;
        }

        .event-body {
          font-size: 17px;
        }

        .event-quote {
          font-size: 19px;
          padding-left: 20px;
        }

        .event-columns-2 {
          grid-template-columns: 1fr;
          gap: 16px;
        }

        .event-controls {
          top: 16px;
          right: 16px;
        }

        .event-btn {
          width: 36px;
          height: 36px;
          font-size: 18px;
        }

        .event-footer {
          padding: 16px 20px;
        }
      }
    `;

    document.head.appendChild(styleEl);
  }

  // ==========================================
  // 第二部分：HTML动态生成
  // ==========================================

  // SVG图标集合，别问老王为什么要集中管理，因为DRY原则
  const MapIcons = {
    back: '<svg viewBox="0 0 24 24"><g><path d="M7.414 13l5.043 5.04-1.414 1.42L3.586 12l7.457-7.46 1.414 1.42L7.414 11H21v2H7.414z"></path></g></svg>',
    close:
      '<svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>',
    refresh:
      '<svg viewBox="0 0 24 24"><g><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></g></svg>',
    location:
      '<svg viewBox="0 0 24 24"><g><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></g></svg>',
    center:
      '<svg viewBox="0 0 24 24"><g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"></path></g></svg>',
    zoomIn: '<svg viewBox="0 0 24 24"><g><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></g></svg>',
    zoomOut: '<svg viewBox="0 0 24 24"><g><path d="M19 13H5v-2h14v2z"></path></g></svg>',
    filter:
      '<svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: currentColor;"><g><path d="M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"></path></g></svg>',
    message:
      '<svg viewBox="0 0 24 24" style="fill: currentColor;"><g><path d="M1.998 5.5c0-1.381 1.119-2.5 2.5-2.5h15c1.381 0 2.5 1.119 2.5 2.5v13c0 1.381-1.119 2.5-2.5 2.5h-15c-1.381 0-2.5-1.119-2.5-2.5v-13zm2.5-.5c-.276 0-.5.224-.5.5v.511l8 3.999 8-3.999V5.5c0-.276-.224-.5-.5-.5h-15zm15.5 5.097l-8 3.999-8-3.999V18.5c0 .276.224.5.5.5h15c.276 0 .5-.224.5-.5v-8.403z"></path></g></svg>',
    profile:
      '<svg viewBox="0 0 24 24" style="fill: currentColor;"><g><path d="M12 11.816c1.355 0 2.872-.15 3.84-1.256.814-.93 1.078-2.368.806-4.392-.38-2.825-2.117-4.512-4.646-4.512S7.734 3.343 7.354 6.17c-.272 2.022-.008 3.46.806 4.39.968 1.107 2.485 1.256 3.84 1.256zM8.84 6.368c.162-1.2.787-3.212 3.16-3.212s2.998 2.013 3.16 3.212c.207 1.55.057 2.627-.45 3.205-.455.52-1.266.743-2.71.743s-2.255-.223-2.71-.743c-.507-.578-.657-1.656-.45-3.205zm11.44 12.868c-.877-3.526-4.282-5.99-8.28-5.99s-7.403 2.464-8.28 5.99c-.172.692-.028 1.4.395 1.94.408.52 1.04.82 1.733.82h12.304c.693 0 1.325-.3 1.733-.82.424-.54.567-1.247.394-1.94zm-1.576 1.016c-.126.16-.316.246-.552.246H5.848c-.235 0-.426-.085-.552-.246-.137-.174-.18-.412-.12-.654.71-2.855 3.517-4.85 6.824-4.85s6.114 1.994 6.824 4.85c.06.242.017.48-.12.654z"></path></g></svg>',
    chart:
      '<svg viewBox="0 0 24 24"><g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10h2L6 21H4zm9.248 0v-7h2v7h-2z"></path></g></svg>',
    plus: '<svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>',
    heart:
      '<svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>',
    moreVertical:
      '<svg viewBox="0 0 24 24"><circle cx="12" cy="5" r="2"></circle><circle cx="12" cy="12" r="2"></circle><circle cx="12" cy="19" r="2"></circle></svg>',
    arrowLeft:
      '<svg viewBox="0 0 24 24"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>',
    newspaper:
      '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M16 6h3a1 1 0 0 1 1 1v11a2 2 0 0 1 -4 0v-13a1 1 0 0 0 -1 -1h-10a1 1 0 0 0 -1 1v12a3 3 0 0 0 3 3h11"/><path d="M8 8l4 0"/><path d="M8 12l4 0"/><path d="M8 16l4 0"/></svg>',
  };

  // 生成地图约会页面的HTML结构
  function generateMapHTML() {
    return `
      <div id="map-dating-container">
        <!-- 侧边栏遮罩 -->
        <div class="map-sidebar-overlay" id="mapSidebarOverlay"></div>

        <!-- 左侧边栏 -->
        <div class="map-sidebar" id="mapSidebar">
          <div class="map-header">
            <button class="map-back-btn" id="mapBackBtn">
              ${MapIcons.back}
            </button>
            <h2>附近的人</h2>
          </div>

          <div class="map-search-box">
            <input type="text" placeholder="搜索..." id="mapSearchInput">
          </div>

          <div class="map-filters">
            <div class="filter-group">
              <select class="filter-select" id="mapDistanceFilter">
                <option value="all">全部距离</option>
                <option value="1">1km内</option>
                <option value="3">3km内</option>
                <option value="5">5km内</option>
              </select>
              <select class="filter-select" id="mapGenderFilter">
                <option value="all">不限性别</option>
                <option value="male">男性</option>
                <option value="female">女性</option>
              </select>
            </div>
            <button class="filter-btn" id="mapApplyFilterBtn">
              ${MapIcons.filter}
            </button>
            <button class="filter-btn filter-btn-advanced" id="mapAdvancedFilterBtn" title="指定筛选">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="4" y1="21" x2="4" y2="14"></line>
                <line x1="4" y1="10" x2="4" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="12"></line>
                <line x1="12" y1="8" x2="12" y2="3"></line>
                <line x1="20" y1="21" x2="20" y2="16"></line>
                <line x1="20" y1="12" x2="20" y2="3"></line>
                <line x1="1" y1="14" x2="7" y2="14"></line>
                <line x1="9" y1="8" x2="15" y2="8"></line>
                <line x1="17" y1="16" x2="23" y2="16"></line>
              </svg>
            </button>
          </div>

          <div class="map-user-list" id="mapUserList">
            <!-- 动态生成用户列表 -->
          </div>
        </div>

        <!-- 右侧地图区域 -->
        <div class="map-area" id="mapArea">
          <!-- 关闭按钮 -->
          <button class="map-close-btn" id="mapCloseBtn">
            ${MapIcons.close}
          </button>

          <!-- 刷新按钮 -->
          <button class="map-refresh-btn" id="mapRefreshBtn" title="刷新附近的人">
            ${MapIcons.refresh}
          </button>

          <!-- 聊天列表按钮 -->
          <button class="map-chats-btn" id="mapChatsBtn" title="Saved Chats">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
          </button>

          <!-- 提醒按钮 -->
          <button class="map-notifications-btn" id="mapNotificationsBtn" title="Notifications">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
              <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
            </svg>
            <div class="map-notifications-badge hidden" id="mapNotificationsBadge">0</div>
          </button>

          <!-- 咩三三报纸按钮 -->
          <button class="map-newspaper-btn" id="mapNewspaperBtn" title="咩三三的城市报纸">
            ${MapIcons.newspaper}
          </button>

          <!-- 城市乘车按钮 -->
          <button class="map-ride-btn" id="mapRideBtn" title="城市乘车">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" />
              <path d="M12 17l-1 -4l-4 -1l9 -4z" />
            </svg>
          </button>

          <!-- 应用设置按钮 -->
          <button class="map-app-settings-btn" id="mapAppSettingsBtn" title="Settings">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="3"></circle>
              <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
          </button>

          <!-- 滑动提示 -->
          <div class="map-swipe-hint" id="mapSwipeHint">
            👈 向右滑动查看附近的人
          </div>

          <div class="map-controls">
            <!-- 天气信息显示 - 放在我的位置上方 -->
            <div class="map-weather-info map-control-btn" id="mapWeatherInfo" style="display: none;" data-weather-name="晴天">
              <span class="map-weather-icon" id="mapWeatherIcon">☀️</span>
            </div>

            <button class="map-control-btn" title="我的位置" id="mapCenterBtn">
              ${MapIcons.center}
            </button>
            <button class="map-control-btn" title="放大" id="mapZoomInBtn">
              ${MapIcons.zoomIn}
            </button>
            <button class="map-control-btn" title="缩小" id="mapZoomOutBtn">
              ${MapIcons.zoomOut}
            </button>
          </div>

          <!-- 天气特效容器 -->
          <div class="map-weather-container" id="mapWeatherContainer"></div>

          <div class="map-canvas" id="mapCanvas">
            <!-- Canvas地图背景 -->
            <canvas id="mapCanvasBg"></canvas>
            <!-- 动态生成地图标记 -->
          </div>

          <!-- 地图选点提示条 -->
          <div class="map-landmark-pick-hint" id="mapLandmarkPickHint" style="display: none;">
            <span style="font-size: 18px;">📍</span>
            <span>Click on the map to place your landmark</span>
            <button class="map-landmark-cancel-btn" onclick="MapDatingController.cancelLandmarkPick()">
              <span>✕</span>
            </button>
          </div>

          <!-- 用户详情卡片 - TikTok风格 -->
          <div class="map-user-detail-card" id="mapUserDetailCard" style="display: none;">
            <!-- TikTok风格顶部Header -->
            <div class="card-header">
              <!-- 左侧返回按钮（有功能） -->
              <button class="card-back-btn" id="mapCardCloseBtn">
                <svg viewBox="0 0 24 24">
                  <line x1="19" y1="12" x2="5" y2="12"></line>
                  <polyline points="12 19 5 12 12 5"></polyline>
                </svg>
              </button>

              <!-- 中间昵称（居中显示，无认证标志） -->
              <div class="card-header-center">
                <span class="card-header-nickname" id="mapCardNickname">昵称</span>
              </div>

              <!-- 右侧装饰按钮（铃铛和分享） -->
              <div class="card-header-actions">
                <button class="card-action-btn" id="mapCardReviewsBtn">
                  <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.89 2 2 2zm6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z"/>
                  </svg>
                </button>
                <button class="card-action-btn" id="mapCardSettingsBtn">
                  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polygon points="5 3 19 12 5 21 5 3"></polygon>
                  </svg>
                </button>
              </div>
            </div>

            <!-- 头像区域 -->
            <div class="card-avatar-section">
              <div class="card-avatar-wrapper">
                <img class="card-avatar" id="mapCardAvatar" src="" alt="">
                <div class="card-avatar-bubble" id="mapCardAvatarBubble">😊</div>
              </div>

              <div class="card-user-info">
                <div class="card-handle">
                  <span id="mapCardHandle">@handle</span>
                  <svg class="card-header-verified" viewBox="0 0 24 24" fill="currentColor" style="display: inline-block; vertical-align: middle; margin-left: 4px;">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                  </svg>
                </div>
              </div>

              <!-- 统计数据 -->
              <div class="card-stats">
                <div class="card-stat-item">
                  <span class="card-stat-value">0</span>
                  <span class="card-stat-label">Following</span>
                </div>
                <div class="card-stat-item">
                  <span class="card-stat-value" id="mapCardFollowers">0</span>
                  <span class="card-stat-label">Followers</span>
                </div>
                <div class="card-stat-item">
                  <span class="card-stat-value" id="mapCardLikes">0</span>
                  <span class="card-stat-label">Likes</span>
                </div>
              </div>
            </div>

            <!-- 按钮组 - TikTok风格3个按钮 -->
            <div class="card-buttons">
              <button class="card-btn card-btn-message" id="mapSendMsgBtn">
                <svg viewBox="0 0 24 24" fill="currentColor">
                  <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                </svg>
                Message
              </button>
              <button class="card-btn card-btn-secondary" id="mapSocialCircleBtn">
                <svg viewBox="0 0 24 24" fill="currentColor">
                  <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
                </svg>
              </button>
              <div class="card-btn-dropdown-wrapper" id="mapViewProfileDropdownWrapper">
                <button class="card-btn card-btn-secondary" id="mapViewProfileBtn">
                  <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M7 10l5 5 5-5z"/>
                  </svg>
                </button>
                <!-- 下拉菜单 -->
                <div class="card-dropdown-menu" id="mapProfileDropdownMenu">
                  <button class="card-dropdown-item" id="mapViewMomentsBtn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                      <path d="M7 3m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" />
                      <path d="M4.012 7.26a2.005 2.005 0 0 0 -1.012 1.737v10c0 1.1 .9 2 2 2h10c.75 0 1.158 -.385 1.5 -1" />
                      <path d="M17 7h.01" />
                      <path d="M7 13l3.644 -3.644a1.21 1.21 0 0 1 1.712 0l3.644 3.644" />
                      <path d="M15 12l1.644 -1.644a1.21 1.21 0 0 1 1.712 0l2.644 2.644" />
                    </svg>
                  </button>
                </div>
              </div>
            </div>

            <!-- 简介部分 -->
            <div class="card-bio-section">
              <div class="card-bio" id="mapCardBio">个人简介...</div>

              <div class="card-tags" id="mapCardTags">
                <!-- 动态生成标签 -->
              </div>

              <div class="card-distance-info" id="mapCardDistanceInfo">
                <svg viewBox="0 0 24 24"><path d="M10 9l-3 3l3 3"/><path d="M14 9l3 3l-3 3"/></svg>
                <span id="mapCardDistance">1.2km</span>
              </div>
            </div>

            <!-- 评价/留言弹窗 -->
            <div class="card-reviews-section" id="mapCardReviewsSection">
              <div class="reviews-header">
                <div class="reviews-header-top">
                  <button class="reviews-back-btn" id="mapReviewsBackBtn">
                    <svg viewBox="0 0 24 24">
                      <line x1="19" y1="12" x2="5" y2="12"></line>
                      <polyline points="12 19 5 12 12 5"></polyline>
                    </svg>
                  </button>
                  <div class="reviews-title">评价</div>
                  <div class="reviews-placeholder"></div>
                </div>

                <div class="reviews-summary" id="mapReviewsSummary">
                  <div class="reviews-rating-big">
                    <div>
                      <span class="reviews-rating-number" id="mapReviewsAvgRating">4.8</span>
                      <span class="reviews-rating-max">/5</span>
                    </div>
                    <div class="reviews-stars" id="mapReviewsStars">
                      <!-- 动态生成星星 -->
                    </div>
                    <div class="reviews-count" id="mapReviewsCount">0条评价</div>
                  </div>
                </div>
              </div>

              <div class="reviews-list" id="mapReviewsList">
                <!-- 动态生成评价列表 -->
              </div>
            </div>

            <!-- 地图设置弹窗 - Instagram风格 -->
            <div class="map-settings-modal" id="mapSettingsModal" style="display: none;">
              <div class="map-settings-content">
                <!-- 顶部Header -->
                <div class="map-settings-header">
                  <button class="map-settings-back-btn" id="mapSettingsBackBtn">
                    <svg viewBox="0 0 24 24">
                      <line x1="19" y1="12" x2="5" y2="12"></line>
                      <polyline points="12 19 5 12 12 5"></polyline>
                    </svg>
                  </button>
                  <div class="map-settings-title">地图资料设置</div>
                  <button class="map-settings-save-btn" id="mapSettingsSaveBtn">完成</button>
                </div>

                <!-- 设置表单内容 -->
                <div class="map-settings-body">
                  <!-- 基本资料编辑 -->
                  <div class="map-settings-section">
                    <div class="map-settings-section-title">基本资料</div>

                    <div class="map-settings-item">
                      <div class="map-settings-item-left">
                        <div class="map-settings-item-label">昵称</div>
                        <div class="map-settings-item-desc">你的显示名称</div>
                      </div>
                      <div class="map-settings-input-wrapper">
                        <input type="text" id="mapSettingsNickname" class="map-settings-input" placeholder="输入昵称" maxlength="20">
                      </div>
                    </div>

                    <div class="map-settings-item">
                      <div class="map-settings-item-left">
                        <div class="map-settings-item-label">句柄</div>
                        <div class="map-settings-item-desc">@用户名（纯英文小写+数字+下划线）</div>
                      </div>
                      <div class="map-settings-input-wrapper">
                        <input type="text" id="mapSettingsHandle" class="map-settings-input" placeholder="username_123" maxlength="15">
                      </div>
                    </div>

                    <div class="map-settings-item">
                      <div class="map-settings-item-left">
                        <div class="map-settings-item-label">粉丝数</div>
                        <div class="map-settings-item-desc">followers数量（100-50000）</div>
                      </div>
                      <div class="map-settings-input-wrapper">
                        <input type="number" id="mapSettingsFollowers" class="map-settings-input" placeholder="1000" min="100" max="50000">
                      </div>
                    </div>

                    <div class="map-settings-item">
                      <div class="map-settings-item-left">
                        <div class="map-settings-item-label">获赞数</div>
                        <div class="map-settings-item-desc">likes数量（粉丝数的10-50倍）</div>
                      </div>
                      <div class="map-settings-input-wrapper">
                        <input type="number" id="mapSettingsLikes" class="map-settings-input" placeholder="15000" min="1000" max="2500000">
                      </div>
                    </div>
                  </div>

                  <!-- 头像气泡设置 -->
                  <div class="map-settings-section">
                    <div class="map-settings-section-title">头像气泡</div>

                    <div class="map-settings-item">
                      <div class="map-settings-item-left">
                        <div class="map-settings-item-label">启用头像气泡</div>
                        <div class="map-settings-item-desc">在地图标记上显示气泡</div>
                      </div>
                      <div class="map-settings-toggle">
                        <input type="checkbox" id="mapSettingsAvatarBubbleEnabled" class="map-settings-toggle-input">
                        <label for="mapSettingsAvatarBubbleEnabled" class="map-settings-toggle-label"></label>
                      </div>
                    </div>

                    <div class="map-settings-item" id="mapSettingsAvatarBubbleTextSection">
                      <div class="map-settings-item-left">
                        <div class="map-settings-item-label">气泡内容</div>
                        <div class="map-settings-item-desc">单个emoji或1-2个颜文字</div>
                      </div>
                      <div class="map-settings-input-wrapper">
                        <input type="text" id="mapSettingsAvatarBubbleText" class="map-settings-input" placeholder="👋" maxlength="4">
                      </div>
                    </div>
                  </div>

                  <!-- 状态气泡设置 -->
                  <div class="map-settings-section">
                    <div class="map-settings-section-title">状态气泡</div>

                    <div class="map-settings-item">
                      <div class="map-settings-item-left">
                        <div class="map-settings-item-label">启用状态气泡</div>
                        <div class="map-settings-item-desc">在地图标记上显示状态</div>
                      </div>
                      <div class="map-settings-toggle">
                        <input type="checkbox" id="mapSettingsStatusEnabled" class="map-settings-toggle-input">
                        <label for="mapSettingsStatusEnabled" class="map-settings-toggle-label"></label>
                      </div>
                    </div>

                    <div class="map-settings-item" id="mapSettingsStatusTextSection">
                      <div class="map-settings-item-left">
                        <div class="map-settings-item-label">状态内容</div>
                        <div class="map-settings-item-desc">显示你的当前状态</div>
                      </div>
                      <div class="map-settings-input-wrapper">
                        <input type="text" id="mapSettingsStatusText" class="map-settings-input" placeholder="探索中..." maxlength="20">
                      </div>
                    </div>
                  </div>

                  <!-- 标签管理 -->
                  <div class="map-settings-section">
                    <div class="map-settings-section-title">个人标签</div>
                    <div class="map-settings-tags-container" id="mapSettingsTagsContainer">
                      <!-- 动态生成标签 -->
                    </div>
                    <button class="map-settings-add-tag-btn" id="mapSettingsAddTagBtn">
                      <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                      </svg>
                      添加标签
                    </button>
                  </div>
                </div>
              </div>
            </div>

            <!-- 社交圈弹窗 - Instagram风格 -->
            <div class="map-social-circle-modal" id="mapSocialCircleModal" style="display: none;">
              <div class="map-social-circle-content">
                <!-- 顶部Header -->
                <div class="map-social-circle-header">
                  <button class="map-social-circle-back-btn" id="mapSocialCircleBackBtn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <line x1="19" y1="12" x2="5" y2="12"></line>
                      <polyline points="12 19 5 12 12 5"></polyline>
                    </svg>
                  </button>
                  <div class="map-social-circle-title">Social Circle</div>
                  <div class="map-social-circle-placeholder"></div>
                </div>

                <!-- 社交圈好友列表 -->
                <div class="map-social-circle-body" id="mapSocialCircleBody">
                  <!-- Empty state -->
                  <div class="map-social-circle-empty" id="mapSocialCircleEmpty">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                      <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
                    </svg>
                    <div class="map-social-circle-empty-text">No friends in social circle yet</div>
                    <div class="map-social-circle-empty-desc">Friends will appear here as you chat</div>
                  </div>

                  <!-- 社交圈列表 -->
                  <div class="map-social-circle-list" id="mapSocialCircleList">
                    <!-- 动态生成好友卡片 -->
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- 动态(Moments)弹窗 -->
      <div class="map-moments-modal" id="mapMomentsModal" style="display: none;">
        <button class="moments-close-btn" id="mapMomentsCloseBtn">
          <svg viewBox="0 0 24 24" fill="none">
            <line x1="18" y1="6" x2="6" y2="18"/>
            <line x1="6" y1="6" x2="18" y2="18"/>
          </svg>
        </button>

        <div class="moments-cards-wrapper" id="mapMomentsCardsWrapper"></div>

        <div class="moments-indicator" id="mapMomentsIndicator"></div>

        <!-- 空状态 -->
        <div class="moments-empty-state" id="mapMomentsEmptyState" style="display: none;">
          <svg viewBox="0 0 24 24" fill="none">
            <path d="M7 3m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" />
            <path d="M4.012 7.26a2.005 2.005 0 0 0 -1.012 1.737v10c0 1.1 .9 2 2 2h10c.75 0 1.158 -.385 1.5 -1" />
            <path d="M17 7h.01" />
            <path d="M7 13l3.644 -3.644a1.21 1.21 0 0 1 1.712 0l3.644 3.644" />
            <path d="M15 12l1.644 -1.644a1.21 1.21 0 0 1 1.712 0l2.644 2.644" />
          </svg>
          <div>No moments yet</div>
        </div>

        <!-- 动态评论弹窗 -->
        <div class="moments-comments-overlay" id="mapMomentsCommentsOverlay"></div>
        <div class="moments-comments-drawer" id="mapMomentsCommentsDrawer">
          <div class="moments-comments-drawer-handle"></div>
          <div class="moments-comments-drawer-header">
            <div class="moments-comments-drawer-title" id="mapMomentsCommentsTitle">Comments</div>
            <button class="moments-comments-drawer-close" id="mapMomentsCommentsClose">
              <svg viewBox="0 0 24 24" fill="none">
                <line x1="18" y1="6" x2="6" y2="18"/>
                <line x1="6" y1="6" x2="18" y2="18"/>
              </svg>
            </button>
          </div>
          <div class="moments-comments-list" id="mapMomentsCommentsList"></div>
        </div>
      </div>

      <!-- 聊天弹窗遮罩 -->
      <div class="map-chat-overlay" id="mapChatOverlay"></div>

      <!-- 聊天弹窗 -->
      <div class="map-chat-modal" id="mapChatModal">
        <!-- 聊天顶栏 -->
        <div class="map-chat-header">
          <button class="map-chat-back-btn" id="mapChatBackBtn">
            ${MapIcons.arrowLeft}
          </button>
          <div class="map-chat-user-info">
            <img class="map-chat-user-avatar" id="mapChatUserAvatar" src="" alt="Avatar">
            <span class="map-chat-user-name" id="mapChatUserName">User Name</span>
          </div>
          <button class="map-chat-more-btn" id="mapChatMoreBtn">
            ${MapIcons.moreVertical}
          </button>
          <!-- More options下拉菜单 -->
          <div class="map-chat-more-menu" id="mapChatMoreMenu">
            <button class="map-chat-more-menu-item" id="mapChatAddToListBtn">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
              </svg>
              <span>Add to Chats</span>
            </button>
            <button class="map-chat-more-menu-item" id="mapChatReportBtn">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                <line x1="12" y1="9" x2="12" y2="13"></line>
                <line x1="12" y1="17" x2="12.01" y2="17"></line>
              </svg>
              <span>Report User</span>
            </button>
            <button class="map-chat-more-menu-item" id="mapChatManageBtn">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
              </svg>
              <span>Manage Messages</span>
            </button>
          </div>
        </div>

        <!-- 消息列表 -->
        <div class="map-chat-messages" id="mapChatMessages">
          <!-- 消息将动态生成 -->
        </div>

        <!-- 删除模式工具栏（默认隐藏） -->
        <div class="map-chat-delete-toolbar" id="mapChatDeleteToolbar" style="display: none;">
          <div class="map-chat-delete-left">
            <label class="map-chat-delete-checkbox-wrapper">
              <input type="checkbox" id="mapChatDeleteSelectAll">
              <span>Select All</span>
            </label>
          </div>
          <div class="map-chat-delete-actions">
            <button class="map-chat-delete-btn" id="mapChatDeleteSelected" disabled>
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
              </svg>
              Delete
            </button>
            <button class="map-chat-delete-btn danger" id="mapChatClearAll">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="15" y1="9" x2="9" y2="15"></line>
                <line x1="9" y1="9" x2="15" y2="15"></line>
              </svg>
              Clear All
            </button>
            <button class="map-chat-delete-btn exit" id="mapChatDeleteExit">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
              Exit
            </button>
          </div>
        </div>

        <!-- 聊天底栏 -->
        <div class="map-chat-footer">
          <!-- 功能收纳按钮（原加号） -->
          <div class="map-chat-function-menu-wrapper">
            <button class="map-chat-add-btn" id="mapChatAddBtn">
              ${MapIcons.plus}
            </button>
            <!-- 功能菜单（圆形放射状） -->
            <div class="map-chat-function-menu" id="mapChatFunctionMenu">
              <button class="map-chat-function-item" id="mapChatNotesBtn" data-function="notes">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M6 4h12a2 2 0 0 1 2 2v7h-5a2 2 0 0 0 -2 2v5h-7a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2z" />
                  <path d="M20 13v.172a2 2 0 0 1 -.586 1.414l-4.828 4.828a2 2 0 0 1 -1.414 .586h-.172" />
                </svg>
              </button>
            </div>
          </div>

          <div class="map-chat-input-wrapper">
            <input
              type="text"
              class="map-chat-input"
              id="mapChatInput"
              placeholder="Type a message..."
            >
          </div>
          <button class="map-chat-like-btn" id="mapChatLikeBtn">
            ${MapIcons.heart}
          </button>
        </div>
      </div>

      <!-- 📌 用户笔记弹窗（简约暗色风格） -->
      <div class="map-notes-overlay" id="mapNotesOverlay"></div>
      <div class="map-notes-modal" id="mapNotesModal">
        <div class="map-notes-container">
          <!-- 头部 -->
          <div class="map-notes-header">
            <div class="map-notes-main-tabs">
              <button class="map-notes-main-tab active" id="mapNotesMainTabMine" data-tab="mine">我的笔记</button>
              <button class="map-notes-main-tab" id="mapNotesMainTabTheirs" data-tab="theirs">TA的笔记</button>
            </div>
            <button class="map-notes-close" id="mapNotesCloseBtn">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>

          <!-- 分类过滤tabs -->
          <div class="map-notes-tabs" id="mapNotesTabs">
            <button class="map-notes-tab active" data-category="all">All</button>
          </div>

          <!-- 笔记列表（时间线式） -->
          <div class="map-notes-list" id="mapNotesList">
            <!-- 空状态 -->
            <div class="map-notes-empty" id="mapNotesEmpty">
              <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="12" y1="11" x2="12" y2="17"></line>
                <line x1="9" y1="14" x2="15" y2="14"></line>
              </svg>
              <p>No notes yet</p>
              <span>Double-tap messages to add notes</span>
            </div>
          </div>
        </div>
      </div>

      <!-- 📌 分类选择菜单（简洁列表） -->
      <div class="map-notes-picker-overlay" id="mapNotesPickerOverlay"></div>
      <div class="map-notes-picker" id="mapNotesPicker">
        <div class="map-notes-picker-header">Select Category</div>
        <div class="map-notes-picker-list" id="mapNotesPickerList"></div>
      </div>

      <!-- 📌 聊天列表弹窗 -->
      <div class="map-chats-list-overlay" id="mapChatsListOverlay"></div>
      <div class="map-chats-list-modal" id="mapChatsListModal">
        <div class="map-chats-list-container">
          <!-- 头部 -->
          <div class="map-chats-list-header">
            <h3 class="map-chats-list-title">Saved Chats</h3>
            <button class="map-chats-list-close" id="mapChatsListCloseBtn">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>

          <!-- 聊天列表 -->
          <div class="map-chats-list-content" id="mapChatsListContent">
            <!-- 空状态 -->
            <div class="map-chats-list-empty" id="mapChatsListEmpty">
              <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
              </svg>
              <p>No saved chats</p>
              <span>Add chats via More options in chat window</span>
            </div>
          </div>
        </div>
      </div>

      <!-- 🎯 指定筛选弹窗（简约暗色风格） -->
      <div class="map-advanced-filter-overlay" id="mapAdvancedFilterOverlay"></div>
      <div class="map-advanced-filter-modal" id="mapAdvancedFilterModal">
        <div class="map-advanced-filter-container">
          <!-- 头部 -->
          <div class="map-advanced-filter-header">
            <h3 class="map-advanced-filter-title">Advanced Filter</h3>
            <button class="map-advanced-filter-close" id="mapAdvancedFilterCloseBtn">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>

          <!-- 筛选表单 -->
          <div class="map-advanced-filter-form">
            <!-- 性别 -->
            <div class="map-filter-field">
              <label class="map-filter-label">Gender</label>
              <div class="map-filter-radio-group">
                <label class="map-filter-radio">
                  <input type="radio" name="advGender" value="all" checked>
                  <span>All</span>
                </label>
                <label class="map-filter-radio">
                  <input type="radio" name="advGender" value="male">
                  <span>Male</span>
                </label>
                <label class="map-filter-radio">
                  <input type="radio" name="advGender" value="female">
                  <span>Female</span>
                </label>
              </div>
            </div>

            <!-- 年龄区间 -->
            <div class="map-filter-field">
              <label class="map-filter-label">Age Range</label>
              <div class="map-filter-range">
                <input type="number" class="map-filter-input" id="advAgeMin" placeholder="Min" min="18" max="99" value="18">
                <span class="map-filter-separator">-</span>
                <input type="number" class="map-filter-input" id="advAgeMax" placeholder="Max" min="18" max="99" value="50">
              </div>
            </div>

            <!-- 性格 -->
            <div class="map-filter-field">
              <label class="map-filter-label">Personality</label>
              <input type="text" class="map-filter-textarea" id="advPersonality" placeholder="e.g., outgoing, shy, funny...">
            </div>

            <!-- 标签 -->
            <div class="map-filter-field">
              <label class="map-filter-label">Tags</label>
              <input type="text" class="map-filter-textarea" id="advTags" placeholder="e.g., music, sports, travel...">
            </div>

            <!-- 类型（自由输入） -->
            <div class="map-filter-field">
              <label class="map-filter-label">Type / Other</label>
              <textarea class="map-filter-textarea map-filter-textarea-multi" id="advType" placeholder="Any other requirements..." rows="3"></textarea>
            </div>
          </div>

          <!-- 底部按钮 -->
          <div class="map-advanced-filter-footer">
            <button class="map-advanced-filter-btn map-advanced-filter-btn-cancel" id="mapAdvancedFilterCancelBtn">Cancel</button>
            <button class="map-advanced-filter-btn map-advanced-filter-btn-clear" id="mapAdvancedFilterClearBtn">Clear</button>
            <button class="map-advanced-filter-btn map-advanced-filter-btn-apply" id="mapAdvancedFilterApplyBtn">Apply</button>
          </div>
        </div>
      </div>

      <!-- 🔔 提醒弹窗 - Toast风格极简设计 -->
      <div class="map-notifications-overlay" id="mapNotificationsOverlay"></div>
      <div class="map-notifications-modal" id="mapNotificationsModal">
        <div class="map-notifications-content">
          <!-- 头部 -->
          <div class="map-notifications-header">
            <!-- 顶部：标题 + 关闭按钮 -->
            <div class="map-notifications-header-top">
              <h3 class="map-notifications-title">Notifications</h3>
              <button class="map-notifications-close-btn" id="mapNotificationsCloseBtn">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <line x1="18" y1="6" x2="6" y2="18"></line>
                  <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
              </button>
            </div>

            <!-- 统计卡片 -->
            <div class="map-notifications-stats">
              <div class="map-notifications-stats-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
                  <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
                </svg>
              </div>
              <div class="map-notifications-stats-info">
                <div class="map-notifications-stats-label">Unread</div>
                <div class="map-notifications-stats-count" id="mapNotificationsUnreadCount">0</div>
              </div>
            </div>

            <!-- 分类Tabs -->
            <div class="map-notifications-tabs" id="mapNotificationsTabs">
              <button class="map-notifications-tab active" data-filter="all">All</button>
              <button class="map-notifications-tab" data-filter="likes">Likes</button>
              <button class="map-notifications-tab" data-filter="messages">Messages</button>
              <button class="map-notifications-tab" data-filter="follows">Follows</button>
              <button class="map-notifications-tab" data-filter="reports">Reports</button>
            </div>
          </div>

          <!-- 提醒列表 -->
          <div class="map-notifications-list-container" id="mapNotificationsListContainer">
            <!-- 空状态 -->
            <div class="map-notifications-empty" id="mapNotificationsEmpty">
              <div class="map-notifications-empty-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
                  <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
                </svg>
              </div>
              <p class="map-notifications-empty-text">No notifications yet</p>
            </div>

            <!-- 提醒列表（动态生成） -->
            <div id="mapNotificationsList"></div>
          </div>
        </div>
      </div>

      <!-- 💬 接收私信确认弹窗 - 简约设计 -->
      <div class="map-accept-message-overlay" id="mapAcceptMessageOverlay"></div>
      <div class="map-accept-message-modal" id="mapAcceptMessageModal">
        <div class="map-accept-message-content">
          <!-- 头部 -->
          <div class="map-accept-message-header">
            <div class="map-accept-message-user">
              <img class="map-accept-message-avatar" id="mapAcceptMsgAvatar" src="" alt="">
              <div class="map-accept-message-user-info">
                <h3 id="mapAcceptMsgNickname">User</h3>
                <p id="mapAcceptMsgHandle">@handle</p>
              </div>
            </div>
            <p class="map-accept-message-title">Sent you a message:</p>
            <div class="map-accept-message-text" id="mapAcceptMsgText">
              Message content...
            </div>
          </div>

          <!-- 按钮 -->
          <div class="map-accept-message-actions">
            <button class="map-decline-btn" id="mapDeclineMessageBtn">Decline</button>
            <button class="map-accept-btn" id="mapAcceptMessageBtn">Accept</button>
          </div>
        </div>
      </div>

      <!-- 🚨 举报用户弹窗 - 简约设计 -->
      <div class="map-report-overlay" id="mapReportOverlay"></div>
      <div class="map-report-modal" id="mapReportModal">
        <div class="map-report-content">
          <!-- 头部 -->
          <div class="map-report-header">
            <h3 class="map-report-title">Report User</h3>
            <button class="map-report-close-btn" id="mapReportCloseBtn">
              <svg viewBox="0 0 24 24">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>

          <!-- 举报表单 -->
          <div class="map-report-body">
            <!-- 被举报用户信息 -->
            <div class="map-report-user-info">
              <img class="map-report-user-avatar" id="mapReportUserAvatar" src="" alt="">
              <div class="map-report-user-details">
                <h4 id="mapReportUserNickname">User</h4>
                <p id="mapReportUserHandle">@handle</p>
              </div>
            </div>

            <!-- 举报理由 -->
            <div class="map-report-section">
              <label class="map-report-section-label">Reason for report</label>
              <div class="map-report-reasons">
                <label class="map-report-reason-item">
                  <input type="checkbox" name="reportReason" value="inappropriate_content" />
                  <span class="map-report-reason-text">Inappropriate Content</span>
                </label>
                <label class="map-report-reason-item">
                  <input type="checkbox" name="reportReason" value="harassment" />
                  <span class="map-report-reason-text">Harassment</span>
                </label>
                <label class="map-report-reason-item">
                  <input type="checkbox" name="reportReason" value="abuse" />
                  <span class="map-report-reason-text">Verbal Abuse</span>
                </label>
                <label class="map-report-reason-item">
                  <input type="checkbox" name="reportReason" value="spam" />
                  <span class="map-report-reason-text">Spam</span>
                </label>
                <label class="map-report-reason-item">
                  <input type="checkbox" name="reportReason" value="other" />
                  <span class="map-report-reason-text">Other</span>
                </label>
              </div>
            </div>

            <!-- 举报描述 -->
            <div class="map-report-section">
              <label class="map-report-section-label" for="mapReportDescription">Additional details (optional)</label>
              <textarea
                class="map-report-textarea"
                id="mapReportDescription"
                placeholder="Provide more information about the issue..."
                rows="4"
              ></textarea>
            </div>
          </div>

          <!-- 底部按钮 -->
          <div class="map-report-actions">
            <button class="map-report-cancel-btn" id="mapReportCancelBtn">Cancel</button>
            <button class="map-report-submit-btn" id="mapReportSubmitBtn">Submit Report</button>
          </div>
        </div>
      </div>

      <!-- 📋 举报详情弹窗 - ins简约风格 -->
      <div class="map-report-detail-overlay" id="mapReportDetailOverlay"></div>
      <div class="map-report-detail-modal" id="mapReportDetailModal">
        <div class="map-report-detail-content">
          <!-- 头部 -->
          <div class="map-report-detail-header">
            <h3 class="map-report-detail-title">Report Result</h3>
            <button class="map-report-detail-close-btn" id="mapReportDetailCloseBtn">
              <svg viewBox="0 0 24 24">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>

          <!-- 判定结果徽章 -->
          <div class="map-report-detail-badge-container">
            <div class="map-report-detail-badge" id="mapReportDetailBadge">
              <div class="map-report-detail-badge-icon" id="mapReportDetailBadgeIcon"></div>
              <div class="map-report-detail-badge-text" id="mapReportDetailBadgeText"></div>
            </div>
          </div>

          <!-- 详情主体 -->
          <div class="map-report-detail-body">
            <!-- 被举报用户 -->
            <div class="map-report-detail-section">
              <div class="map-report-detail-section-label">Reported User</div>
              <div class="map-report-detail-user-card">
                <img class="map-report-detail-user-avatar" id="mapReportDetailUserAvatar" src="" alt="">
                <div class="map-report-detail-user-info">
                  <div class="map-report-detail-user-nickname" id="mapReportDetailUserNickname"></div>
                  <div class="map-report-detail-user-handle" id="mapReportDetailUserHandle"></div>
                </div>
              </div>
            </div>

            <!-- 举报理由 -->
            <div class="map-report-detail-section">
              <div class="map-report-detail-section-label">Report Reasons</div>
              <div class="map-report-detail-reasons" id="mapReportDetailReasons"></div>
            </div>

            <!-- 举报描述 -->
            <div class="map-report-detail-section" id="mapReportDetailDescSection">
              <div class="map-report-detail-section-label">Additional Details</div>
              <div class="map-report-detail-description" id="mapReportDetailDescription"></div>
            </div>

            <!-- AI判定原因 -->
            <div class="map-report-detail-section">
              <div class="map-report-detail-section-label">Review Result</div>
              <div class="map-report-detail-reason" id="mapReportDetailReason"></div>
            </div>

            <!-- 举报时间 -->
            <div class="map-report-detail-section">
              <div class="map-report-detail-section-label">Report Time</div>
              <div class="map-report-detail-time" id="mapReportDetailTime"></div>
            </div>
          </div>

          <!-- 底部按钮 -->
          <div class="map-report-detail-actions">
            <button class="map-report-detail-acknowledge-btn" id="mapReportDetailAcknowledgeBtn">Acknowledge</button>
          </div>
        </div>
      </div>

      <!-- 🚗 城市乘车面板 - ins风格 -->
      <!-- 选择目的地提示 -->
      <div class="ride-selection-hint" id="rideSelectionHint">
        点击地图上的地标选择目的地
      </div>

      <!-- 乘车面板遮罩 -->
      <div class="ride-panel-overlay" id="ridePanelOverlay"></div>

      <!-- 乘车面板 - 半屏抽屉 -->
      <div class="ride-panel" id="ridePanel">
        <!-- 面板拖动手柄 -->
        <div class="ride-panel-handle"></div>

        <!-- 面板内容 -->
        <div class="ride-panel-content">
          <!-- 路线信息横幅 -->
          <div class="ride-route-banner">
            <div class="ride-route-banner-left">
              <svg class="ride-route-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"/>
                <polyline points="12 6 12 12 16 14"/>
              </svg>
              <span class="ride-route-text">预计到达</span>
            </div>
            <span class="ride-route-time" id="rideEstimatedTime">--</span>
          </div>

          <!-- 位置选择 -->
          <div class="ride-location-section">
            <div class="ride-location-box">
              <div class="ride-location-label">Start</div>
              <div class="ride-location-value">当前位置</div>
            </div>
            <div class="ride-location-box" id="rideDestinationBox">
              <div class="ride-location-label">Finish</div>
              <div class="ride-location-value placeholder" id="rideDestinationValue">点击选择目的地</div>
            </div>
          </div>

          <!-- 车辆选择标题 -->
          <h2 class="ride-section-title">选择车型</h2>

          <!-- 车辆选择网格 -->
          <div class="ride-vehicles-grid" id="rideVehiclesGrid">
            <!-- 经济型 -->
            <div class="ride-vehicle-card selected" data-type="economy" data-base-price="18" data-rate="1.2">
              <div class="ride-vehicle-image">
                <svg viewBox="0 0 120 80" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <ellipse cx="60" cy="68" rx="32" ry="6" fill="currentColor" opacity="0.1"/>
                  <path d="M 24,58 L 18,50 L 18,32 L 30,24 L 90,24 L 102,32 L 102,50 L 96,58 Z" fill="currentColor" opacity="0.25"/>
                  <ellipse cx="35" cy="58" rx="11" ry="11" fill="currentColor" opacity="0.5"/>
                  <ellipse cx="85" cy="58" rx="11" ry="11" fill="currentColor" opacity="0.5"/>
                  <rect x="28" y="18" width="64" height="22" rx="4" fill="currentColor" opacity="0.35"/>
                  <rect x="42" y="12" width="36" height="10" rx="2.5" fill="currentColor" opacity="0.45"/>
                </svg>
              </div>
              <div class="ride-vehicle-name">经济型</div>
              <div class="ride-vehicle-capacity">
                <svg class="ride-capacity-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                  <circle cx="12" cy="7" r="4"/>
                </svg>
                <span>1-3</span>
              </div>
              <div class="ride-vehicle-pricing">
                <span class="ride-vehicle-price">¥<span class="ride-price-value">18</span></span>
                <span class="ride-vehicle-eta">5 min</span>
              </div>
            </div>

            <!-- 舒适型 -->
            <div class="ride-vehicle-card" data-type="comfort" data-base-price="32" data-rate="2.0">
              <div class="ride-vehicle-image">
                <svg viewBox="0 0 120 80" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <ellipse cx="60" cy="68" rx="34" ry="6" fill="currentColor" opacity="0.12"/>
                  <path d="M 22,58 L 16,49 L 16,30 L 28,21 L 92,21 L 104,30 L 104,49 L 98,58 Z" fill="currentColor" opacity="0.3"/>
                  <ellipse cx="34" cy="58" rx="12" ry="12" fill="currentColor" opacity="0.6"/>
                  <ellipse cx="86" cy="58" rx="12" ry="12" fill="currentColor" opacity="0.6"/>
                  <rect x="26" y="16" width="68" height="24" rx="5" fill="currentColor" opacity="0.4"/>
                  <rect x="40" y="10" width="40" height="11" rx="3" fill="currentColor" opacity="0.5"/>
                </svg>
              </div>
              <div class="ride-vehicle-name">舒适型</div>
              <div class="ride-vehicle-capacity">
                <svg class="ride-capacity-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                  <circle cx="9" cy="7" r="4"/>
                  <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                  <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                </svg>
                <span>1-4</span>
              </div>
              <div class="ride-vehicle-pricing">
                <span class="ride-vehicle-price">¥<span class="ride-price-value">32</span></span>
                <span class="ride-vehicle-eta">8 min</span>
              </div>
            </div>

            <!-- 商务型 -->
            <div class="ride-vehicle-card" data-type="business" data-base-price="56" data-rate="3.5">
              <div class="ride-vehicle-image">
                <svg viewBox="0 0 120 80" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <ellipse cx="60" cy="68" rx="36" ry="6" fill="currentColor" opacity="0.14"/>
                  <path d="M 20,58 L 14,48 L 14,28 L 26,18 L 94,18 L 106,28 L 106,48 L 100,58 Z" fill="currentColor" opacity="0.35"/>
                  <ellipse cx="33" cy="58" rx="13" ry="13" fill="currentColor" opacity="0.7"/>
                  <ellipse cx="87" cy="58" rx="13" ry="13" fill="currentColor" opacity="0.7"/>
                  <rect x="24" y="14" width="72" height="26" rx="6" fill="currentColor" opacity="0.45"/>
                  <rect x="38" y="8" width="44" height="12" rx="3.5" fill="currentColor" opacity="0.55"/>
                </svg>
              </div>
              <div class="ride-vehicle-name">商务型</div>
              <div class="ride-vehicle-capacity">
                <svg class="ride-capacity-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <rect x="2" y="7" width="20" height="14" rx="2" ry="2"/>
                  <path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"/>
                </svg>
                <span>1-4</span>
              </div>
              <div class="ride-vehicle-pricing">
                <span class="ride-vehicle-price">¥<span class="ride-price-value">56</span></span>
                <span class="ride-vehicle-eta">10 min</span>
              </div>
            </div>

            <!-- 豪华型 -->
            <div class="ride-vehicle-card" data-type="luxury" data-base-price="128" data-rate="6.0">
              <div class="ride-vehicle-image">
                <svg viewBox="0 0 120 80" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <ellipse cx="60" cy="68" rx="38" ry="6" fill="currentColor" opacity="0.16"/>
                  <path d="M 18,58 L 12,47 L 12,26 L 24,15 L 96,15 L 108,26 L 108,47 L 102,58 Z" fill="currentColor" opacity="0.4"/>
                  <ellipse cx="32" cy="58" rx="14" ry="14" fill="currentColor" opacity="0.8"/>
                  <ellipse cx="88" cy="58" rx="14" ry="14" fill="currentColor" opacity="0.8"/>
                  <rect x="22" y="11" width="76" height="28" rx="7" fill="currentColor" opacity="0.5"/>
                  <rect x="36" y="5" width="48" height="13" rx="4" fill="currentColor" opacity="0.6"/>
                </svg>
              </div>
              <div class="ride-vehicle-name">豪华型</div>
              <div class="ride-vehicle-capacity">
                <svg class="ride-capacity-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
                </svg>
                <span>1-4</span>
              </div>
              <div class="ride-vehicle-pricing">
                <span class="ride-vehicle-price">¥<span class="ride-price-value">128</span></span>
                <span class="ride-vehicle-eta">15 min</span>
              </div>
            </div>
          </div>

          <!-- 支付方式 -->
          <div class="ride-payment-section">
            <h3 class="ride-payment-title">支付方式</h3>
            <div class="ride-payment-options">
              <button class="ride-payment-option selected" data-payment="cash">
                <svg class="ride-payment-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <line x1="12" y1="1" x2="12" y2="23"/>
                  <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/>
                </svg>
                <span>现金</span>
              </button>
              <button class="ride-payment-option" data-payment="online">
                <svg class="ride-payment-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <rect x="1" y="4" width="22" height="16" rx="2" ry="2"/>
                  <line x1="1" y1="10" x2="23" y2="10"/>
                </svg>
                <span>在线支付</span>
              </button>
            </div>
          </div>

          <!-- 预订按钮 -->
          <button class="ride-book-btn" id="rideBookBtn" disabled>请先选择目的地</button>
        </div>
      </div>

      <!-- 等待司机悬浮小球 -->
      <button class="waiting-driver-float-btn" id="waitingDriverFloatBtn">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path d="M7 17m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" />
          <path d="M17 17m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" />
          <path d="M5 17h-2v-6l2 -5h9l4 5h1a2 2 0 0 1 2 2v4h-2m-4 0h-6m-6 -6h15m-6 0v-5" />
        </svg>
      </button>

      <!-- 等待司机弹窗 -->
      <div class="waiting-driver-modal-overlay" id="waitingDriverModalOverlay">
        <div class="waiting-driver-modal">
          <!-- 关闭按钮 -->
          <button class="waiting-driver-close" id="waitingDriverCloseBtn">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke-linecap="round" stroke-linejoin="round">
              <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
          </button>

          <!-- Header -->
          <div class="waiting-driver-header">
            <div class="waiting-driver-status">Driver on the way</div>
            <div class="waiting-driver-eta" id="waitingDriverEta">0:00</div>
            <div class="waiting-driver-eta-label">Estimated Arrival</div>
          </div>

          <!-- 司机卡片 -->
          <div class="waiting-driver-card">
            <div class="waiting-driver-avatar">
              <img id="waitingDriverAvatar" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64'%3E%3Crect fill='%23d5d5d5' width='64' height='64'/%3E%3Ctext x='50%25' y='50%25' fill='%23666' text-anchor='middle' dy='.3em' font-size='24' font-family='Arial'%3ED%3C/text%3E%3C/svg%3E" alt="Driver">
            </div>
            <div class="waiting-driver-info">
              <div class="waiting-driver-name" id="waitingDriverName">Driver</div>
              <div class="waiting-driver-rating">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
                <span class="waiting-driver-rating-value" id="waitingDriverRating">5.0</span>
              </div>
              <div class="waiting-driver-vehicle">
                <span id="waitingDriverVehicle">Vehicle</span>
                <span class="waiting-driver-plate" id="waitingDriverPlate">XXXXXXXX</span>
              </div>
            </div>
          </div>

          <!-- 路线图 -->
          <div class="waiting-driver-route-map">
            <div class="waiting-driver-route-grid"></div>
            <div class="waiting-driver-route-line"></div>

            <!-- 用户标记 -->
            <div class="waiting-driver-user-marker">
              <div class="waiting-driver-user-pin">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                  <circle cx="12" cy="7" r="4"/>
                </svg>
              </div>
            </div>

            <!-- 司机标记 -->
            <div class="waiting-driver-car-marker" id="waitingDriverCarMarker">
              <div class="waiting-driver-car-icon">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M7 17m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" />
                  <path d="M17 17m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" />
                  <path d="M5 17h-2v-6l2 -5h9l4 5h1a2 2 0 0 1 2 2v4h-2m-4 0h-6m-6 -6h15m-6 0v-5" />
                </svg>
              </div>
              <div class="waiting-driver-car-label" id="waitingDriverDistance">0.0 km</div>
            </div>
          </div>

          <!-- 距离信息 -->
          <div class="waiting-driver-distance-info">
            <div class="waiting-driver-distance-item">
              <div class="waiting-driver-distance-value" id="waitingDriverDistanceKm">0.0</div>
              <div class="waiting-driver-distance-label">Distance (km)</div>
            </div>
            <div class="waiting-driver-distance-divider"></div>
            <div class="waiting-driver-distance-item">
              <div class="waiting-driver-distance-value" id="waitingDriverSpeed">0</div>
              <div class="waiting-driver-distance-label">Speed (km/h)</div>
            </div>
          </div>

          <!-- 操作按钮 -->
          <div class="waiting-driver-actions">
            <button class="waiting-driver-action-btn" id="waitingDriverContactBtn">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/>
              </svg>
              <span id="waitingDriverContactText">Contact</span>
            </button>
            <button class="waiting-driver-action-btn cancel" id="waitingDriverCancelBtn">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"/>
                <path d="M15 9l-6 6M9 9l6 6"/>
              </svg>
              Cancel Ride
            </button>
          </div>
        </div>
      </div>

      <!-- ⚙️ 应用设置弹窗 - ins风格 -->
      <div class="map-app-settings-overlay" id="mapAppSettingsOverlay"></div>
      <div class="map-app-settings-modal" id="mapAppSettingsModal">
        <div class="map-app-settings-content">
          <!-- 头部 -->
          <div class="map-app-settings-header">
            <h3 class="map-app-settings-title">Settings</h3>
            <button class="map-app-settings-close-btn" id="mapAppSettingsCloseBtn">
              <svg viewBox="0 0 24 24">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>

          <!-- 设置主体 -->
          <div class="map-app-settings-body">
            <!-- 主题切换 -->
            <div class="map-app-setting-item">
              <div class="map-app-setting-label">
                <div class="map-app-setting-label-text">Appearance</div>
                <div class="map-app-setting-label-desc">Switch between light and dark theme</div>
              </div>
              <div class="map-theme-toggle" id="mapThemeToggle">
                <div class="map-theme-toggle-circle">
                  <svg class="map-theme-toggle-icon" viewBox="0 0 24 24">
                    <!-- 月亮图标（暗色模式） -->
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                  </svg>
                </div>
              </div>
            </div>

            <!-- 地标管理 -->
            <div class="map-app-setting-section map-landmark-section">
              <div class="map-app-setting-section-title">Landmark Management</div>
              <div class="map-app-setting-section-desc">Add custom landmarks or generate them with AI</div>

              <!-- 模式切换 -->
              <div class="map-landmark-mode-toggle">
                <button class="map-landmark-mode-btn active" data-mode="custom">
                  Custom Landmark
                </button>
                <button class="map-landmark-mode-btn" data-mode="ai">
                  AI Generate
                </button>
              </div>

              <!-- 自定义地标表单 -->
              <div class="map-landmark-custom-form active">
                <input
                  type="text"
                  class="map-landmark-name-input"
                  id="mapLandmarkNameInput"
                  placeholder="Landmark name (e.g., Starbucks, Central Park)"
                  maxlength="50"
                />

                <textarea
                  class="map-landmark-desc-input"
                  id="mapLandmarkDescInput"
                  placeholder="Landmark description (optional)"
                  maxlength="200"
                ></textarea>

                <div class="map-landmark-icon-color-row">
                  <!-- 图标选择 -->
                  <div class="map-landmark-icon-selector">
                    <div class="map-landmark-icon-preview" id="mapLandmarkIconPreview">📍</div>
                    <input
                      type="text"
                      class="map-landmark-icon-input"
                      id="mapLandmarkIconInput"
                      placeholder="Icon emoji"
                      maxlength="2"
                      value="📍"
                    />
                  </div>

                  <!-- 颜色选择 -->
                  <div class="map-landmark-color-picker-wrapper">
                    <div class="map-landmark-color-preview" id="mapLandmarkColorPreview" style="background-color: #ff6b6b;"></div>
                    <input
                      type="text"
                      class="map-landmark-color-input"
                      id="mapLandmarkColorInput"
                      placeholder="Color (e.g., #ff6b6b)"
                      maxlength="7"
                      value="#ff6b6b"
                    />
                  </div>
                </div>

                <!-- 地图选点 -->
                <div class="map-landmark-pick-position">
                  <button class="map-landmark-pick-btn" id="mapLandmarkPickBtn">
                    <span>📍</span>
                    <span>Click to pick position on map</span>
                  </button>
                  <div class="map-landmark-position-display" id="mapLandmarkPositionDisplay">
                    No position selected
                  </div>
                </div>

                <button class="map-landmark-save-btn" id="mapLandmarkSaveBtn" disabled>
                  Save Landmark
                </button>
              </div>

              <!-- AI生成地标表单 -->
              <div class="map-landmark-ai-form">
                <textarea
                  class="map-landmark-ai-input"
                  id="mapLandmarkAiInput"
                  placeholder="Describe what landmarks you want AI to generate (e.g., 'Generate 5-10 restaurants and cafes in downtown area')"
                ></textarea>

                <button class="map-landmark-generate-btn" id="mapLandmarkGenerateBtn">
                  Generate Landmarks with AI
                </button>
              </div>

              <!-- 批量操作栏 -->
              <div class="map-landmark-batch-actions" id="mapLandmarkBatchActions">
                <button class="map-landmark-select-all-btn" id="mapLandmarkSelectAllBtn">
                  Select All
                </button>
                <span class="map-landmark-selected-count" id="mapLandmarkSelectedCount">
                  0 selected
                </span>
                <button class="map-landmark-batch-delete-btn" id="mapLandmarkBatchDeleteBtn" disabled>
                  Delete Selected
                </button>
              </div>

              <!-- 地标列表 -->
              <div class="map-landmark-list" id="mapLandmarkList">
                <!-- 动态生成 -->
              </div>
            </div>

            <!-- 自定义头像管理 -->
            <div class="map-app-setting-section">
              <div class="map-app-setting-section-title">Custom Avatars</div>
              <div class="map-app-setting-section-desc">Add your own avatar URLs to the library</div>

              <!-- 添加头像表单 -->
              <div class="map-avatar-add-form">
                <input
                  type="text"
                  class="map-avatar-url-input"
                  id="mapAvatarUrlInput"
                  placeholder="Enter URL(s), separate with commas for batch upload"
                />

                <div class="map-avatar-category-selector">
                  <label class="map-avatar-category-option">
                    <input type="radio" name="avatarCategory" value="unisex" checked />
                    <span class="map-avatar-category-label">Unisex</span>
                  </label>
                  <label class="map-avatar-category-option">
                    <input type="radio" name="avatarCategory" value="male" />
                    <span class="map-avatar-category-label">Male</span>
                  </label>
                  <label class="map-avatar-category-option">
                    <input type="radio" name="avatarCategory" value="female" />
                    <span class="map-avatar-category-label">Female</span>
                  </label>
                </div>

                <button class="map-avatar-add-btn" id="mapAvatarAddBtn">Add Avatar</button>
              </div>

              <!-- 已添加头像列表 -->
              <div class="map-avatar-list" id="mapCustomAvatarList">
                <!-- 动态生成 -->
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- 地标事件弹窗 -->
      <div class="event-modal-overlay" id="eventModalOverlay">
        <div class="event-modal-container">
          <div class="event-controls">
            <button class="event-btn" id="eventModalCloseBtn" title="关闭">×</button>
          </div>
          <div class="event-content" id="eventModalContent">
            <!-- AI生成的事件HTML将动态注入这里 -->
          </div>
        </div>
      </div>

      <!-- 咩三三城市报纸弹窗 -->
      <div class="map-newspaper-overlay" id="newspaperOverlay"></div>
      <div class="map-newspaper-modal" id="newspaperModal">
        <div class="newspaper-container">
          <!-- 扫描线效果 -->
          <div class="newspaper-scanline"></div>

          <!-- 装饰星星 -->
          <span class="newspaper-star-deco">✦</span>
          <span class="newspaper-star-deco">✧</span>
          <span class="newspaper-star-deco">✦</span>
          <span class="newspaper-star-deco">✧</span>

          <!-- 像素装饰点 -->
          <div class="newspaper-pixel-dots">
            <span class="newspaper-pixel-dot" style="top: 10%; left: 15%;"></span>
            <span class="newspaper-pixel-dot" style="top: 25%; right: 20%;"></span>
            <span class="newspaper-pixel-dot" style="top: 45%; left: 8%;"></span>
            <span class="newspaper-pixel-dot" style="top: 70%; right: 12%;"></span>
            <span class="newspaper-pixel-dot" style="bottom: 15%; left: 25%;"></span>
          </div>

          <div class="newspaper-screen">
            <!-- 浏览器风格顶栏 -->
            <div class="newspaper-browser-bar">
              <div class="newspaper-browser-dots">
                <div class="newspaper-dot"></div>
                <div class="newspaper-dot"></div>
                <div class="newspaper-dot"></div>
              </div>
              <div class="newspaper-url-bar">mie333://city-news.daily</div>
              <button class="newspaper-close-btn" id="newspaperCloseBtn">
                <svg viewBox="0 0 24 24" fill="none">
                  <path d="M18 6L6 18M6 6L18 18" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </button>
            </div>

            <!-- 主内容区 - 双栏布局 -->
            <div class="newspaper-content">
              <!-- 右侧边栏 -->
              <div class="newspaper-sidebar">
                <!-- 头像名片 -->
                <div class="newspaper-profile-card">
                  <div class="newspaper-avatar-box">
                    <div class="newspaper-avatar">🐑</div>
                    <div class="newspaper-status-badge">ONLINE</div>
                  </div>
                  <div class="newspaper-profile-name">MIE333</div>
                  <div class="newspaper-profile-role">News Reporter<br>Weather Reporter<br>Merchant</div>
                </div>

                <!-- 像素时钟 -->
                <div class="newspaper-pixel-clock">
                  <div class="newspaper-clock-date" id="newspaperClockDate">2024-01-15</div>
                  <div class="newspaper-clock-time" id="newspaperClockTime">10:23 PM</div>
                </div>

                <!-- 标签云 -->
                <div class="newspaper-tags-widget">
                  <div class="newspaper-widget-title">TAGS</div>
                  <div class="newspaper-tag-cloud">
                    <span class="newspaper-tag">NEWS</span>
                    <span class="newspaper-tag">WEATHER</span>
                    <span class="newspaper-tag">TIPS</span>
                    <span class="newspaper-tag">ADS</span>
                    <span class="newspaper-tag">STORY</span>
                  </div>
                </div>

                <!-- 迷你统计 -->
                <div class="newspaper-stats-mini">
                  <div class="newspaper-stat-item">
                    <div class="newspaper-stat-value" id="newspaperViewsCount">0</div>
                    <div class="newspaper-stat-label">Views</div>
                  </div>
                  <div class="newspaper-stat-item">
                    <div class="newspaper-stat-value" id="newspaperTipsCount">0</div>
                    <div class="newspaper-stat-label">Tips</div>
                  </div>
                </div>

                <!-- 邮件通知 -->
                <div class="newspaper-mail-notice">
                  <div class="newspaper-mail-stamp">📮</div>
                  <div class="newspaper-mail-content">
                    Contact via<br>
                    mie333@city-news.com
                  </div>
                </div>
              </div>

              <!-- 左侧主栏 -->
              <div class="newspaper-main-column" id="newspaperMainContent">
                <!-- AI生成的报纸内容将动态注入这里 -->
                <div style="padding: 40px; text-align: center; color: var(--map-text-secondary);">
                  Loading...
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  // ==========================================
  // 第三部分：程序化地图生成器
  // ==========================================

  const MapGenerator = {
    // 暗色主题颜色（默认）
    darkColors: {
      background: '#1a1a1a',
      water: '#1a2a3a',
      waterLight: '#243444',
      land: '#252525',
      park: '#1e3025',
      parkLight: '#253530',
      building: '#2a2a2a',
      buildingLight: '#303030',
      buildingDark: '#222222',
      roadMain: '#3a3a3a',
      roadSecondary: '#333333',
      roadLine: 'rgba(255,255,255,0.08)',
      roadCenter: 'rgba(255,200,50,0.15)',
    },

    // 亮色主题颜色
    lightColors: {
      background: '#f5f5f5',
      water: '#a8d8ea',
      waterLight: '#c1e7f4',
      land: '#e8e8e8',
      park: '#b8e6b8',
      parkLight: '#d0f0d0',
      building: '#fff',
      buildingLight: '#fafafa',
      buildingDark: '#f0f0f0',
      roadMain: '#d0d0d0',
      roadSecondary: '#e0e0e0',
      roadLine: 'rgba(0,0,0,0.08)',
      roadCenter: 'rgba(255,200,50,0.3)',
    },

    // 当前使用的颜色（默认暗色）
    colors: null,

    landmarkTypes: [
      {
        type: 'restaurant',
        color: '#ff6b6b',
        names: ['海底捞火锅', '必胜客', '肯德基', '星巴克咖啡', '麦当劳', '外婆家', '绿茶餐厅', '西贝莜面村'],
        icon: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M8.1 13.34l2.83-2.83L3.91 3.5c-1.56 1.56-1.56 4.09 0 5.66l4.19 4.18zm6.78-1.81c1.53.71 3.68.21 5.27-1.38 1.91-1.91 2.28-4.65.81-6.12-1.46-1.46-4.2-1.1-6.12.81-1.59 1.59-2.09 3.74-1.38 5.27L3.7 19.87l1.41 1.41L12 14.41l6.88 6.88 1.41-1.41L13.41 13l1.47-1.47z"/></svg>',
      },
      {
        type: 'cafe',
        color: '#8b6f47',
        names: ['星巴克', 'Costa咖啡', '瑞幸咖啡', 'Manner咖啡', '太平洋咖啡', '猫的天空之城'],
        icon: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M2 21h18v-2H2v2zm15.5-6c1.38 0 2.5-1.12 2.5-2.5V4H3v8.5c0 1.38 1.12 2.5 2.5 2.5h12zM5 6h12v6.5c0 .28-.22.5-.5.5h-11c-.28 0-.5-.22-.5-.5V6zm15-.5c.28 0 .5.22.5.5v3c0 .28-.22.5-.5.5s-.5-.22-.5-.5V6c0-.28.22-.5.5-.5z"/></svg>',
      },
      {
        type: 'park',
        color: '#51cf66',
        names: ['中央公园', '人民公园', '森林公园', '滨江公园', '城市绿地', '儿童乐园'],
        icon: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M17 8C17 5.24 14.76 3 12 3S7 5.24 7 8c0 2.85 2.92 7.21 5 9.88 2.11-2.69 5-7 5-9.88zM12 11c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm-7 9c0-3.87 3.13-7 7-7s7 3.13 7 7H5z"/></svg>',
      },
      {
        type: 'mall',
        color: '#cc5de8',
        names: ['万达广场', '银泰百货', '大悦城', '龙湖天街', '万象城', '来福士广场'],
        icon: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zM1 2v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1H5.21l-.94-2H1zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2z"/></svg>',
      },
      {
        type: 'hospital',
        color: '#ff6b6b',
        names: ['人民医院', '中医院', '第一医院', '儿童医院', '口腔医院', '社区诊所'],
        icon: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5c-1.1 0-1.99.9-1.99 2L3 19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-1 11h-4v4h-4v-4H6v-4h4V6h4v4h4v4z"/></svg>',
      },
      {
        type: 'school',
        color: '#339af0',
        names: ['实验小学', '第一中学', '外国语学校', '职业学院', '大学城', '幼儿园'],
        icon: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M5 13.18v4L12 21l7-3.82v-4L12 17l-7-3.82zM12 3L1 9l11 6 9-4.91V17h2V9L12 3z"/></svg>',
      },
      {
        type: 'metro',
        color: '#748ffc',
        names: ['地铁站', '火车站', '公交总站', '客运中心'],
        icon: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2c-4 0-8 .5-8 4v9.5C4 17.43 5.57 19 7.5 19L6 20.5v.5h2l2-2h4l2 2h2v-.5L16.5 19c1.93 0 3.5-1.57 3.5-3.5V6c0-3.5-4-4-8-4zm0 2c3.51 0 4.96.48 5.57 1H6.43c.61-.52 2.06-1 5.57-1zM6 7h5v3H6V7zm12 8.5c0 .83-.67 1.5-1.5 1.5h-9c-.83 0-1.5-.67-1.5-1.5V12h12v3.5zm0-5.5h-5V7h5v3zM7.5 16c.83 0 1.5.67 1.5 1.5S8.33 19 7.5 19 6 18.33 6 17.5 6.67 16 7.5 16zm9 0c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5-1.5-.67-1.5-1.5.67-1.5 1.5-1.5z"/></svg>',
      },
      {
        type: 'scenic',
        color: '#ffd43b',
        names: ['博物馆', '图书馆', '剧院', '体育馆', '美术馆', '科技馆', '音乐厅'],
        icon: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>',
      },
    ],

    landmarks: [],
    seed: 12345,

    // 地图配置（可由AI动态调整）
    config: {
      waterRatio: 0.15, // 湖水比例（默认15%）
      buildingDensity: 0.6, // 建筑密度（默认60%）
      parkCount: 4, // 公园数量（默认4个）
      roadWidth: 18, // 道路宽度（默认18px）
    },

    random() {
      this.seed = (this.seed * 9301 + 49297) % 233280;
      return this.seed / 233280;
    },

    randomRange(min, max) {
      return min + this.random() * (max - min);
    },

    randomInt(min, max) {
      return Math.floor(this.randomRange(min, max + 1));
    },

    // 设置主题颜色
    setTheme(isLight) {
      this.colors = isLight ? this.lightColors : this.darkColors;
      console.log(`🎨 [地图主题] 已切换到${isLight ? '亮色' : '暗色'}主题`);
    },

    // 重新绘制地图
    redraw() {
      if (!this.ctx || !this.width || !this.height) {
        console.warn('⚠️ [地图重绘] 地图未初始化，跳过重绘');
        return;
      }

      // 清空画布
      this.ctx.clearRect(0, 0, this.width, this.height);

      // 重置随机种子以保持地图一致
      this.seed = 12345;

      // 重新绘制所有图层
      this.drawBackground();
      this.drawWaterAreas();
      this.drawParks();
      this.drawBlocks();
      this.drawMainRoads();
      this.drawSecondaryRoads();
      this.drawBuildings();
      this.drawRoadDetails();
      this.drawLandmarks();

      console.log('✅ [地图重绘] 地图已重新绘制');
    },

    init(canvasId) {
      console.log('🗺️ [MapGenerator.init] 开始初始化地图, canvasId:', canvasId);
      console.log('🗺️ [MapGenerator.init] 当前landmarks数量:', this.landmarks?.length || 0);
      const canvas = document.getElementById(canvasId);
      if (!canvas) {
        console.error('❌ [MapGenerator.init] 找不到canvas元素:', canvasId);
        return;
      }

      const mapCanvas = document.getElementById('mapCanvas');
      const width = mapCanvas.offsetWidth;
      const height = mapCanvas.offsetHeight;

      canvas.width = width;
      canvas.height = height;

      const ctx = canvas.getContext('2d');
      this.ctx = ctx;
      this.width = width;
      this.height = height;

      this.seed = 12345;

      // 根据当前主题设置颜色
      const container = document.getElementById('x-map-container');
      const isLight = container?.classList.contains('light-theme') || false;
      this.setTheme(isLight);

      this.drawBackground();
      this.drawWaterAreas();
      this.drawParks();
      this.drawBlocks();
      this.drawMainRoads();
      this.drawSecondaryRoads();
      this.drawBuildings();
      this.drawRoadDetails();
      this.generateLandmarks();
      this.drawLandmarks();
      console.log('✅ [MapGenerator.init] 地图初始化完成');
    },

    generateLandmarks() {
      // 如果已经有AI生成的地标数据，不再重新生成
      if (this.landmarks && this.landmarks.length > 0) {
        console.log('📍 [地图生成] 使用AI生成的地标数据，共', this.landmarks.length, '个');
        return;
      }

      // 使用默认随机生成
      this.landmarks = [];
      const { width, height } = this;
      const landmarkCount = this.randomInt(30, 50);

      for (let i = 0; i < landmarkCount; i++) {
        const typeIndex = this.randomInt(0, this.landmarkTypes.length - 1);
        const landmarkType = this.landmarkTypes[typeIndex];
        const nameIndex = this.randomInt(0, landmarkType.names.length - 1);
        const name = landmarkType.names[nameIndex];
        const x = this.randomRange(50, width - 50);
        const y = this.randomRange(50, height - 50);

        this.landmarks.push({
          id: `landmark-${i}`,
          x,
          y,
          name,
          type: landmarkType.type,
          icon: landmarkType.icon,
          color: landmarkType.color,
        });
      }
      console.log('📍 [地图生成] 使用默认随机地标数据，共', this.landmarks.length, '个');
    },

    drawLandmarks() {
      const { ctx, landmarks, colors } = this;

      const landmarksWithEvents = landmarks.filter(l => l.event);
      if (landmarksWithEvents.length > 0) {
        console.log(`🗺️ [地图绘制] 总共${landmarks.length}个地标，其中${landmarksWithEvents.length}个有事件:`, landmarksWithEvents.map(l => l.name));
      }

      // 根据主题选择描边颜色
      const strokeColor = colors === this.lightColors ? '#000' : '#fff';
      const highlightColor = colors === this.lightColors ? 'rgba(0,0,0,0.3)' : 'rgba(255,255,255,0.5)';

      landmarks.forEach(landmark => {
        // 外圈光晕
        ctx.beginPath();
        ctx.arc(landmark.x, landmark.y, 8, 0, Math.PI * 2);
        ctx.fillStyle = landmark.color + '20';
        ctx.fill();

        // 主圆点
        ctx.beginPath();
        ctx.arc(landmark.x, landmark.y, 5, 0, Math.PI * 2);
        ctx.fillStyle = landmark.color;
        ctx.fill();

        // 边框（有事件的地标使用红色边框）
        ctx.strokeStyle = landmark.event ? '#ff3b30' : strokeColor;
        ctx.lineWidth = landmark.event ? 3 : 2;
        ctx.stroke();

        // 高光
        ctx.beginPath();
        ctx.arc(landmark.x - 1, landmark.y - 1, 2, 0, Math.PI * 2);
        ctx.fillStyle = highlightColor;
        ctx.fill();

        // 如果有事件，绘制右上角红点徽章
        if (landmark.event) {
          ctx.beginPath();
          ctx.arc(landmark.x + 4, landmark.y - 4, 3, 0, Math.PI * 2);
          ctx.fillStyle = '#ff3b30';
          ctx.fill();
          ctx.strokeStyle = colors === this.lightColors ? '#fff' : '#1a1a1a';
          ctx.lineWidth = 1.5;
          ctx.stroke();
        }
      });
    },

    drawBackground() {
      const { ctx, width, height, colors } = this;
      ctx.fillStyle = colors.background;
      ctx.fillRect(0, 0, width, height);
    },

    drawWaterAreas() {
      const { ctx, width, height, colors } = this;

      ctx.beginPath();
      ctx.moveTo(0, height * 0.3);

      const riverWidth = this.randomRange(80, 150);
      let y = height * 0.3;

      for (let x = 0; x < width; x += 100) {
        y += this.randomRange(-50, 50);
        y = Math.max(height * 0.1, Math.min(height * 0.5, y));
        ctx.lineTo(x, y);
      }

      ctx.lineTo(width, y);
      ctx.lineTo(width, y + riverWidth);

      y = y + riverWidth;
      for (let x = width; x >= 0; x -= 100) {
        y += this.randomRange(-30, 30);
        ctx.lineTo(x, y);
      }

      ctx.closePath();

      const gradient = ctx.createLinearGradient(0, 0, width, 0);
      gradient.addColorStop(0, colors.water);
      gradient.addColorStop(0.5, colors.waterLight);
      gradient.addColorStop(1, colors.water);
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.beginPath();
      const lakeX = width * 0.7;
      const lakeY = height * 0.75;
      const lakeRx = this.randomRange(100, 180);
      const lakeRy = this.randomRange(60, 100);
      ctx.ellipse(lakeX, lakeY, lakeRx, lakeRy, 0.2, 0, Math.PI * 2);
      ctx.fillStyle = colors.water;
      ctx.fill();
    },

    drawParks() {
      const { ctx, width, height, colors } = this;
      const parkCount = this.randomInt(4, 8);

      for (let i = 0; i < parkCount; i++) {
        const x = this.randomRange(50, width - 50);
        const y = this.randomRange(50, height - 50);
        const w = this.randomRange(80, 200);
        const h = this.randomRange(60, 150);

        ctx.beginPath();
        ctx.moveTo(x, y);

        const points = this.randomInt(5, 8);
        for (let j = 0; j < points; j++) {
          const angle = (j / points) * Math.PI * 2;
          const radius = (j % 2 === 0 ? w : h) * this.randomRange(0.3, 0.6);
          const px = x + Math.cos(angle) * radius;
          const py = y + Math.sin(angle) * radius;
          ctx.lineTo(px, py);
        }

        ctx.closePath();
        ctx.fillStyle = i % 2 === 0 ? colors.park : colors.parkLight;
        ctx.fill();
      }
    },

    drawBlocks() {
      const { ctx, width, height, colors } = this;
      const blockSize = 200;
      const cols = Math.ceil(width / blockSize);
      const rows = Math.ceil(height / blockSize);

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const x = col * blockSize + this.randomRange(5, 15);
          const y = row * blockSize + this.randomRange(5, 15);
          const w = blockSize - this.randomRange(20, 40);
          const h = blockSize - this.randomRange(20, 40);

          const colorChoice = this.random();
          if (colorChoice < 0.6) {
            ctx.fillStyle = colors.land;
          } else if (colorChoice < 0.8) {
            ctx.fillStyle = colors.building;
          } else {
            ctx.fillStyle = colors.buildingLight;
          }

          this.roundRect(x, y, w, h, 5);
          ctx.fill();
        }
      }
    },

    drawMainRoads() {
      const { ctx, width, height, colors } = this;
      const roadWidth = 24;

      ctx.strokeStyle = colors.roadMain;
      ctx.lineWidth = roadWidth;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      const hRoadCount = this.randomInt(3, 5);
      for (let i = 0; i < hRoadCount; i++) {
        const y = (height / (hRoadCount + 1)) * (i + 1) + this.randomRange(-30, 30);

        ctx.beginPath();
        ctx.moveTo(0, y);

        for (let x = 0; x <= width; x += width / 4) {
          const offsetY = this.randomRange(-20, 20);
          ctx.lineTo(x, y + offsetY);
        }

        ctx.stroke();
      }

      const vRoadCount = this.randomInt(3, 5);
      for (let i = 0; i < vRoadCount; i++) {
        const x = (width / (vRoadCount + 1)) * (i + 1) + this.randomRange(-30, 30);

        ctx.beginPath();
        ctx.moveTo(x, 0);

        for (let y = 0; y <= height; y += height / 4) {
          const offsetX = this.randomRange(-20, 20);
          ctx.lineTo(x + offsetX, y);
        }

        ctx.stroke();
      }
    },

    drawSecondaryRoads() {
      const { ctx, width, height, colors } = this;
      const roadWidth = 12;

      ctx.strokeStyle = colors.roadSecondary;
      ctx.lineWidth = roadWidth;

      const roadCount = this.randomInt(15, 25);

      for (let i = 0; i < roadCount; i++) {
        const isHorizontal = this.random() > 0.5;

        ctx.beginPath();

        if (isHorizontal) {
          const y = this.randomRange(50, height - 50);
          const startX = this.randomRange(0, width * 0.3);
          const endX = this.randomRange(width * 0.7, width);

          ctx.moveTo(startX, y);
          ctx.lineTo(endX, y + this.randomRange(-30, 30));
        } else {
          const x = this.randomRange(50, width - 50);
          const startY = this.randomRange(0, height * 0.3);
          const endY = this.randomRange(height * 0.7, height);

          ctx.moveTo(x, startY);
          ctx.lineTo(x + this.randomRange(-30, 30), endY);
        }

        ctx.stroke();
      }
    },

    drawBuildings() {
      const { ctx, width, height, colors } = this;
      const buildingCount = this.randomInt(200, 350);

      for (let i = 0; i < buildingCount; i++) {
        const x = this.randomRange(0, width);
        const y = this.randomRange(0, height);
        const w = this.randomRange(15, 50);
        const h = this.randomRange(15, 50);

        const colorChoice = this.random();
        if (colorChoice < 0.4) {
          ctx.fillStyle = colors.building;
        } else if (colorChoice < 0.7) {
          ctx.fillStyle = colors.buildingLight;
        } else {
          ctx.fillStyle = colors.buildingDark;
        }

        ctx.fillRect(x, y, w, h);

        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, w, h);
      }
    },

    drawRoadDetails() {
      const { ctx, width, height, colors } = this;

      ctx.setLineDash([15, 10]);
      ctx.strokeStyle = colors.roadLine;
      ctx.lineWidth = 1;

      for (let y = 100; y < height; y += 150 + this.randomRange(-20, 20)) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }

      for (let x = 100; x < width; x += 150 + this.randomRange(-20, 20)) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }

      ctx.setLineDash([]);

      ctx.setLineDash([20, 15]);
      ctx.strokeStyle = colors.roadCenter;
      ctx.lineWidth = 2;

      for (let y = 200; y < height; y += 300) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }

      for (let x = 200; x < width; x += 300) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }

      ctx.setLineDash([]);
    },

    roundRect(x, y, w, h, r) {
      const { ctx } = this;
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    },
  };

  // ==========================================
  // 第四部分：地图约会控制器
  // ==========================================

  const MapDatingController = {
    // ==================== 头像库 ====================
    avatarLibrary: {
      // 共用头像 - 无论男女
      unisex: [
        'https://i.postimg.cc/nzYhv1dF/25f610139f457dbb334fa669033e710d.jpg',
        'https://i.postimg.cc/rFpwrxxB/8a0c2ef08661efe92a45bdac2522e0e5.jpg',
        'https://i.postimg.cc/Sx2QZ4ZB/d3e487bf5b4dcb930aa4710bddace460.jpg',
        'https://i.postimg.cc/kGgqWP6S/47625239f04329daf2f0a5cb857fab17.jpg',
        'https://i.postimg.cc/WbKTqK2b/3597240784be5b8a5e20c48444522ac0.jpg',
        'https://i.postimg.cc/TwR6Xv9G/𝐴𝑣𝑎𝑡𝑎𝑟.jpg',
        'https://i.postimg.cc/yYJzKPFR/0906e30095fe9c7d755f9878c6e9b231.jpg',
      ],
      // 女用头像
      female: [
        'https://i.postimg.cc/CK0yjp9Z/2a8ebd43a59bbb20d1d8b8e058b2d8f8.jpg',
        'https://i.postimg.cc/vTkkTJWV/68f698a3ec805053ecc57d4ccb24bb88.jpg',
        'https://i.postimg.cc/ZYM1wd1n/dca1d391113e16471670428ff246a797.jpg',
      ],
      // 男用头像
      male: [
        'https://i.postimg.cc/K8nwcs4Z/2b5d7cc132d92c7539f72a271d3bb2bb.jpg',
        'https://i.postimg.cc/wBgP1cs2/2f3ad4ca3491f004f0985f7f94987e63.jpg',
        'https://i.postimg.cc/wx16xgzd/8a371ffd7747316ca6a20a73e9213d83.jpg',
        'https://i.postimg.cc/vZsMvnVy/16602df49663ddff9f7affe386ca828d.jpg',
        'https://e3f49eaa46b57.cdn.sohucs.com/2025/11/23/19/53/MTAwMTE0XzE3NjM4OTg4MDMxNjA=.jpg',
      ],
    },

    // 自定义头像库（用户添加的）
    customAvatars: {
      unisex: [],
      male: [],
      female: [],
    },

    // 从头像库中随机选择头像（包含自定义头像）
    getRandomAvatar(gender = 'unisex') {
      // 合并内置头像和自定义头像
      const builtInAvatars =
        gender === 'male'
          ? [...this.avatarLibrary.male, ...this.avatarLibrary.unisex]
          : gender === 'female'
          ? [...this.avatarLibrary.female, ...this.avatarLibrary.unisex]
          : this.avatarLibrary.unisex;

      const customAvatarsForGender =
        gender === 'male'
          ? [...this.customAvatars.male, ...this.customAvatars.unisex]
          : gender === 'female'
          ? [...this.customAvatars.female, ...this.customAvatars.unisex]
          : this.customAvatars.unisex;

      const pool = [...builtInAvatars, ...customAvatarsForGender];

      return pool[Math.floor(Math.random() * pool.length)];
    },

    // ==================== 聊天系统数据 ====================
    chatMessages: {}, // 存储每个用户的聊天记录 { userId: [{type: 'sent'|'received', text: '...', timestamp: '...'}] }
    chatAffectionData: {}, // 存储好感度数据 { userId: {affection: 0, threshold: 50, growthRate: 1.0} }
    chatNotes: {}, // 📝 AI自动记录的人设笔记（不可见） { userId: {work: '...', hobbies: [], ...} }
    userMarkedNotes: {}, // 📌 用户手动标记的笔记（可视化展示） { userId: [{id, category, content, messageIndex, timestamp}] }
    npcNotesAboutUser: {}, // 💭 NPC对用户的笔记记录（每个NPC独立） { userId: [{id, category, content, timestamp}] }
    chatContext: {}, // 🎯 聊天发起上下文 { userId: 'normal'|'interested_then_message'|'message_accepted' }
    detailCardOpenSource: 'map', // 🔧 记录资料卡打开来源 'map'|'interested' (用于区分聊天上下文)
    currentChatUser: null, // 当前聊天对象
    userMessageQueue: [], // 用户发送的消息队列（等待AI回复）

    // ==================== 真实度系统 ====================
    // 真实度：隐藏分数，初始100，范围0-200
    // 举报成功增加，举报失败（恶意举报）扣除
    // AI会根据真实度决定是否拒绝聊天
    authenticityScore: 100,

    // 当前打开的举报详情notification（用于"已知晓"按钮结算）
    currentReportNotification: null,

    // ==================== 被举报计数和封禁系统 ====================
    // 被举报次数（累计）
    userReportedCount: 0,
    // 封禁开始时间（null表示未封禁）
    mapBanStartTime: null,
    // 封禁时长（毫秒）12小时
    mapBanDuration: 12 * 60 * 60 * 1000,

    // 初始化真实度
    initAuthenticityScore() {
      const saved = localStorage.getItem('xUserAuthenticityScore');
      if (saved !== null) {
        this.authenticityScore = parseFloat(saved);
        console.log(`🎯 [真实度系统] 加载真实度: ${this.authenticityScore}`);
      } else {
        this.authenticityScore = 100;
        localStorage.setItem('xUserAuthenticityScore', '100');
        console.log(`🎯 [真实度系统] 初始化真实度: 100`);
      }
    },

    // 获取当前真实度
    getAuthenticityScore() {
      return this.authenticityScore;
    },

    // 增加真实度
    addAuthenticityScore(amount, reason = '') {
      const oldScore = this.authenticityScore;
      this.authenticityScore = Math.min(200, this.authenticityScore + amount);
      localStorage.setItem('xUserAuthenticityScore', this.authenticityScore.toString());
      console.log(
        `✅ [真实度系统] ${reason || '增加真实度'}: ${oldScore.toFixed(1)} → ${this.authenticityScore.toFixed(
          1,
        )} (+${amount})`,
      );
      return this.authenticityScore;
    },

    // 扣除真实度
    subtractAuthenticityScore(amount, reason = '') {
      const oldScore = this.authenticityScore;
      this.authenticityScore = Math.max(0, this.authenticityScore - amount);
      localStorage.setItem('xUserAuthenticityScore', this.authenticityScore.toString());
      console.log(
        `⚠️ [真实度系统] ${reason || '扣除真实度'}: ${oldScore.toFixed(1)} → ${this.authenticityScore.toFixed(
          1,
        )} (-${amount})`,
      );
      return this.authenticityScore;
    },

    // 初始化被举报计数系统
    initReportedCountSystem() {
      // 加载被举报次数
      const savedCount = localStorage.getItem('xUserReportedCount');
      if (savedCount !== null) {
        this.userReportedCount = parseInt(savedCount);
        console.log(`🚨 [被举报计数] 加载被举报次数: ${this.userReportedCount}`);
      } else {
        this.userReportedCount = 0;
        localStorage.setItem('xUserReportedCount', '0');
        console.log(`🚨 [被举报计数] 初始化被举报次数: 0`);
      }

      // 加载封禁状态
      const savedBanTime = localStorage.getItem('xMapBanStartTime');
      if (savedBanTime) {
        this.mapBanStartTime = parseInt(savedBanTime);
        console.log(`🚫 [封禁系统] 加载封禁时间: ${new Date(this.mapBanStartTime).toLocaleString()}`);
      } else {
        this.mapBanStartTime = null;
      }
    },

    // 增加被举报次数
    incrementReportedCount() {
      this.userReportedCount++;
      localStorage.setItem('xUserReportedCount', this.userReportedCount.toString());
      console.log(`🚨 [被举报计数] 被举报次数增加: ${this.userReportedCount}`);

      // 如果达到5次，触发封禁
      if (this.userReportedCount >= 5) {
        this.banMapAccess();
      }

      return this.userReportedCount;
    },

    // 封禁地图访问
    banMapAccess() {
      this.mapBanStartTime = Date.now();
      localStorage.setItem('xMapBanStartTime', this.mapBanStartTime.toString());
      console.log(`🚫 [封禁系统] 地图功能已被封禁12小时，开始时间: ${new Date(this.mapBanStartTime).toLocaleString()}`);

      // 重置被举报次数
      this.userReportedCount = 0;
      localStorage.setItem('xUserReportedCount', '0');
    },

    // 检查是否被封禁
    checkMapBanStatus() {
      if (!this.mapBanStartTime) {
        return { isBanned: false };
      }

      const now = Date.now();
      const elapsed = now - this.mapBanStartTime;

      if (elapsed >= this.mapBanDuration) {
        // 封禁时间已过，解除封禁
        this.mapBanStartTime = null;
        localStorage.removeItem('xMapBanStartTime');
        console.log(`✅ [封禁系统] 封禁时间已过，已自动解除`);
        return { isBanned: false };
      } else {
        // 仍在封禁中
        const remaining = this.mapBanDuration - elapsed;
        const remainingHours = Math.floor(remaining / (60 * 60 * 1000));
        const remainingMinutes = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
        console.log(`🚫 [封禁系统] 仍在封禁中，剩余时间: ${remainingHours}小时${remainingMinutes}分钟`);
        return {
          isBanned: true,
          remainingTime: remaining,
          remainingHours: remainingHours,
          remainingMinutes: remainingMinutes,
        };
      }
    },

    // 显示封禁提示UI
    showMapBanNotice(banStatus) {
      const container = document.getElementById('x-map-container');
      if (!container) return;

      // 清空容器
      container.innerHTML = '';

      // 创建封禁提示UI（纯黑白灰ins风格）
      const banNotice = document.createElement('div');
      banNotice.style.cssText = `
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
        padding: 24px;
      `;

      banNotice.innerHTML = `
        <div style="
          max-width: 400px;
          background: #1a1a1a;
          border-radius: 24px;
          padding: 40px 32px;
          text-align: center;
          border: 1px solid #2a2a2a;
          box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        ">
          <!-- 警告图标 -->
          <div style="
            width: 80px;
            height: 80px;
            margin: 0 auto 28px;
            background: #2a2a2a;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #3a3a3a;
          ">
            <svg viewBox="0 0 24 24" style="width: 36px; height: 36px; fill: #9ca3af;">
              <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
            </svg>
          </div>

          <!-- 标题 -->
          <h2 style="
            color: #fff;
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 12px;
            letter-spacing: -0.5px;
          ">Account Suspended</h2>

          <!-- 副标题 -->
          <div style="
            color: #6b7280;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 1.2px;
          ">Temporary Restriction</div>

          <!-- 描述 -->
          <p style="
            color: #9ca3af;
            font-size: 15px;
            line-height: 1.6;
            margin-bottom: 28px;
          ">Your access to Map Dating has been temporarily suspended due to multiple community guideline violations.</p>

          <!-- 违规次数指示器 -->
          <div style="
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
          ">
            <div style="width: 12px; height: 12px; border-radius: 50%; background: #fff; border: 2px solid #fff;"></div>
            <div style="width: 12px; height: 12px; border-radius: 50%; background: #fff; border: 2px solid #fff;"></div>
            <div style="width: 12px; height: 12px; border-radius: 50%; background: #fff; border: 2px solid #fff;"></div>
            <div style="width: 12px; height: 12px; border-radius: 50%; background: #fff; border: 2px solid #fff;"></div>
            <div style="width: 12px; height: 12px; border-radius: 50%; background: #fff; border: 2px solid #fff;"></div>
          </div>

          <!-- 分隔线 -->
          <div style="
            height: 1px;
            background: #2a2a2a;
            margin: 24px 0;
          "></div>

          <!-- 剩余时间卡片 -->
          <div style="
            background: #0a0a0a;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 28px;
            border: 1px solid #2a2a2a;
          ">
            <div style="
              color: #6b7280;
              font-size: 12px;
              margin-bottom: 10px;
              text-transform: uppercase;
              letter-spacing: 1.5px;
              font-weight: 600;
            ">Time Remaining</div>
            <div style="
              color: #fff;
              font-size: 32px;
              font-weight: 700;
              font-family: 'Courier New', monospace;
              letter-spacing: 2px;
            ">${banStatus.remainingHours}h ${banStatus.remainingMinutes}m</div>
          </div>

          <!-- 提示文本 -->
          <p style="
            color: #6b7280;
            font-size: 13px;
            line-height: 1.6;
            margin-bottom: 28px;
            padding: 0 8px;
          ">Access will be automatically restored after the suspension period. Please review our community guidelines to avoid future violations.</p>

          <!-- 关闭按钮 -->
          <button onclick="document.getElementById('x-map-container').style.display='none'" style="
            width: 100%;
            background: #fff;
            color: #000;
            border: none;
            border-radius: 16px;
            padding: 16px 24px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            letter-spacing: -0.2px;
          " onmouseover="this.style.background='#e5e5e5'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(255, 255, 255, 0.15)'" onmouseout="this.style.background='#fff'; this.style.transform='translateY(0)'; this.style.boxShadow='none'">
            Close
          </button>
        </div>
      `;

      container.appendChild(banNotice);

      console.log(`🚫 [封禁系统] 已显示封禁提示UI`);
    },

    // 📌 用户笔记分类定义（简约暗色风格）
    noteCategories: [
      { id: 'work', name: '工作', iconType: 'briefcase' },
      { id: 'hobby', name: '兴趣', iconType: 'heart' },
      { id: 'family', name: '家庭', iconType: 'users' },
      { id: 'personality', name: '性格', iconType: 'user' },
      { id: 'appearance', name: '外貌', iconType: 'eye' },
      { id: 'food', name: '饮食', iconType: 'coffee' },
      { id: 'location', name: '地点', iconType: 'map-pin' },
      { id: 'dream', name: '梦想', iconType: 'star' },
      { id: 'habit', name: '习惯', iconType: 'repeat' },
      { id: 'friend', name: '朋友', iconType: 'user-plus' },
      { id: 'other', name: '其他', iconType: 'file-text' },
    ],

    // ==================== 天气系统方法 ====================

    // 从天气描述文本中解析天气类型
    parseWeatherFromText(weatherText) {
      if (!weatherText) return 'sunny'; // 默认晴天

      const text = weatherText.toLowerCase();

      // 按优先级匹配天气关键词（雷暴 > 大雨 > 小雨等）
      const priorityOrder = ['thunder', 'heavy-rain', 'snow', 'dust', 'fog', 'rain', 'cloudy', 'sunny'];

      for (const weatherType of priorityOrder) {
        const keywords = this.weatherKeywords[weatherType];
        if (keywords && keywords.some(kw => text.includes(kw))) {
          return weatherType;
        }
      }

      return 'sunny'; // 匹配不到默认晴天
    },

    // 随机选择天气（如果没有全局大事件）
    getRandomWeather() {
      const weatherList = Object.keys(this.weatherTypes);
      // 🌤️ 平均几率：每个天气类型都有相同的出现概率
      return weatherList[Math.floor(Math.random() * weatherList.length)];
    },

    // 渲染天气特效
    renderWeatherEffect(weatherType) {
      const container = document.getElementById('mapWeatherContainer');
      const weatherInfo = document.getElementById('mapWeatherInfo');
      const weatherIcon = document.getElementById('mapWeatherIcon');

      if (!container) {
        console.warn('⚠️ [天气系统] 找不到天气容器');
        return;
      }

      // 清空容器
      container.innerHTML = '';
      container.className = 'map-weather-container';

      const weather = this.weatherTypes[weatherType];
      if (!weather) {
        console.warn(`⚠️ [天气系统] 未知天气类型: ${weatherType}`);
        return;
      }

      // 添加天气CSS类
      container.classList.add(weather.cssClass);

      // 更新天气信息显示（只显示图标，悬停显示名称）
      if (weatherInfo && weatherIcon) {
        weatherInfo.style.display = 'flex';
        weatherInfo.setAttribute('data-weather-name', weather.name);
        weatherIcon.textContent = weather.icon;
      }

      // 添加粒子效果（雨滴、雪花、沙尘等）
      const particleCount = weather.particles;
      if (particleCount > 0) {
        this.createWeatherParticles(container, weatherType, particleCount);
      }

      // 多云特效：全屏幕随机云层
      if (weatherType === 'cloudy') {
        // 生成8-12个云层，全屏幕随机分布
        const cloudCount = 8 + Math.floor(Math.random() * 5);
        for (let i = 0; i < cloudCount; i++) {
          const cloud = document.createElement('div');
          cloud.className = 'cloud';

          // 随机大小 (100-250px宽，30-80px高)
          const width = 100 + Math.random() * 150;
          const height = 30 + Math.random() * 50;
          cloud.style.width = `${width}px`;
          cloud.style.height = `${height}px`;

          // 随机起始位置（在屏幕左侧外）
          cloud.style.left = `-${width}px`;

          // 随机垂直位置（5%-95%）
          cloud.style.top = `${5 + Math.random() * 90}%`;

          // 随机动画时长 (20-50秒)
          cloud.style.animationDuration = `${20 + Math.random() * 30}s`;

          // 随机延迟启动 (0-30秒)
          cloud.style.animationDelay = `${Math.random() * 30}s`;

          container.appendChild(cloud);
        }
      }

      // 雷暴特效额外添加闪电层
      if (weatherType === 'thunder') {
        const lightning = document.createElement('div');
        lightning.className = 'lightning';
        container.appendChild(lightning);
      }

      // 大雨特效额外添加涟漪
      if (weatherType === 'heavy-rain') {
        for (let i = 0; i < 8; i++) {
          const ripple = document.createElement('div');
          ripple.className = 'ripple';
          ripple.style.left = `${Math.random() * 90 + 5}%`;
          ripple.style.animationDelay = `${Math.random() * 1.5}s`;
          container.appendChild(ripple);
        }
      }

      this.currentWeather = weatherType;
      console.log(`🌤️ [天气系统] 已应用天气特效: ${weather.name}`);
    },

    // 创建天气粒子效果
    createWeatherParticles(container, weatherType, count) {
      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');

        switch (weatherType) {
          case 'rain':
          case 'heavy-rain':
          case 'thunder':
            particle.className = 'rain-drop';
            particle.style.left = `${Math.random() * 100}%`;
            particle.style.animationDelay = `${Math.random() * 2}s`;
            particle.style.animationDuration = `${0.5 + Math.random() * 0.5}s`;
            break;

          case 'snow':
            particle.className = 'snowflake';
            particle.textContent = ['❄', '❅', '❆', '✻', '✼'][Math.floor(Math.random() * 5)];
            particle.style.left = `${Math.random() * 100}%`;
            particle.style.animationDelay = `${Math.random() * 8}s`;
            particle.style.animationDuration = `${6 + Math.random() * 4}s`;
            particle.style.fontSize = `${8 + Math.random() * 10}px`;
            break;

          case 'dust':
            particle.className = 'dust-particle';
            particle.style.left = `${Math.random() * 30}%`;
            particle.style.top = `${Math.random() * 80}%`;
            particle.style.animationDelay = `${Math.random() * 3}s`;
            particle.style.animationDuration = `${2 + Math.random() * 2}s`;
            particle.style.width = `${2 + Math.random() * 4}px`;
            particle.style.height = particle.style.width;
            break;
        }

        container.appendChild(particle);
      }
    },

    // 开发者测试：循环切换天气
    cycleWeatherTest() {
      const weatherList = Object.keys(this.weatherTypes);
      this.weatherTestIndex = (this.weatherTestIndex + 1) % weatherList.length;
      const nextWeather = weatherList[this.weatherTestIndex];

      this.renderWeatherEffect(nextWeather);

      // 在控制台显示当前天气
      const weather = this.weatherTypes[nextWeather];
      console.log(
        `🔧 [开发者测试] 切换到天气: ${weather.icon} ${weather.name} (${this.weatherTestIndex + 1}/${
          weatherList.length
        })`,
      );
    },

    // 模拟用户数据，后续可以从数据库或AI获取
    mockUsers: [
      {
        id: 1,
        nickname: '艾莉娅',
        handle: 'ailiyadev',
        avatarBubble: '📷',
        distance: 0.8,
        online: true,
        status: '📷 拍照中',
        avatar: 'https://i.postimg.cc/CK0yjp9Z/2a8ebd43a59bbb20d1d8b8e058b2d8f8.jpg', // 女用头像1
        bio: '24岁 | 单身\n热爱旅行和摄影\n喜欢探索城市的每个角落\n周末常去咖啡馆看书写字',
        tags: ['摄影', '旅行', '咖啡', '阅读'],
        followers: 1024,
        likes: 46900,
        position: { top: '25%', left: '65%' },
        moments: [
          {
            id: 1,
            userName: '艾莉娅',
            userAvatar: 'https://i.postimg.cc/CK0yjp9Z/2a8ebd43a59bbb20d1d8b8e058b2d8f8.jpg',
            time: '2h ago',
            text: 'Morning coffee and city views. Taking time to appreciate the simple moments before the day gets busy.',
            image: null,
            likes: 234,
            comments: 18,
            shares: 5,
            commentsList: [
              { user: 'Alex', avatar: 'A', text: 'Beautiful shot!', time: '1h ago' },
              { user: 'Emma', avatar: 'E', text: 'Need this energy', time: '30m ago' }
            ]
          },
          {
            id: 2,
            userName: '艾莉娅',
            userAvatar: 'https://i.postimg.cc/CK0yjp9Z/2a8ebd43a59bbb20d1d8b8e058b2d8f8.jpg',
            time: '1d ago',
            text: 'Sunset at the beach. Nature always knows how to paint the perfect picture.',
            image: null,
            likes: 567,
            comments: 42,
            shares: 12,
            commentsList: [
              { user: 'David', avatar: 'D', text: 'Amazing colors!', time: '1d ago' }
            ]
          },
          {
            id: 3,
            userName: '艾莉娅',
            userAvatar: 'https://i.postimg.cc/CK0yjp9Z/2a8ebd43a59bbb20d1d8b8e058b2d8f8.jpg',
            time: '3d ago',
            text: 'New camera lens arrived. Time to explore the city with fresh eyes.',
            image: null,
            likes: 892,
            comments: 67,
            shares: 23,
            commentsList: []
          }
        ]
      },
      {
        id: 2,
        nickname: '林晓',
        handle: 'linxiao_fit',
        avatarBubble: '💪',
        distance: 1.2,
        online: true,
        status: '💪 健身中',
        avatar: 'https://i.postimg.cc/K8nwcs4Z/2b5d7cc132d92c7539f72a271d3bb2bb.jpg', // 男用头像1
        bio: '27岁 | 健身教练\n相信运动改变生活\n喜欢户外运动和健康饮食',
        tags: ['健身', '户外', '美食'],
        followers: 5420,
        likes: 128000,
        position: { top: '45%', left: '40%' },
      },
      {
        id: 3,
        nickname: 'Sophie',
        handle: 'sophiedesign',
        avatarBubble: '🎨',
        distance: 1.5,
        online: false,
        status: '🎨 创作中',
        avatar: 'https://i.postimg.cc/vTkkTJWV/68f698a3ec805053ecc57d4ccb24bb88.jpg', // 女用头像2
        bio: '23岁 | 设计师\n热衷于创造美好的事物\n喜欢艺术展览和独立音乐',
        tags: ['设计', '艺术', '音乐', '猫咪'],
        followers: 2340,
        likes: 78500,
        position: { top: '60%', left: '70%' },
      },
      {
        id: 4,
        nickname: '陈墨',
        handle: 'chenmo_dev',
        avatarBubble: '💻',
        distance: 2.1,
        online: true,
        status: '💻 写代码',
        avatar: 'https://i.postimg.cc/wBgP1cs2/2f3ad4ca3491f004f0985f7f94987e63.jpg', // 男用头像2
        bio: '29岁 | 软件工程师\n技术宅\n业余时间喜欢玩游戏和做饭',
        tags: ['编程', '游戏', '烹饪'],
        followers: 892,
        likes: 34200,
        position: { top: '35%', left: '50%' },
      },
      {
        id: 5,
        nickname: 'Emma',
        handle: 'emma_yoga',
        avatarBubble: '🧘',
        distance: 2.8,
        online: true,
        status: '🧘 冥想中',
        avatar: 'https://i.postimg.cc/ZYM1wd1n/dca1d391113e16471670428ff246a797.jpg', // 女用头像3
        bio: '26岁 | 瑜伽老师\n追求身心平衡\n喜欢冥想、手工和素食',
        tags: ['瑜伽', '冥想', '手工', '素食'],
        followers: 6780,
        likes: 215000,
        position: { top: '20%', left: '30%' },
      },
      {
        id: 6,
        nickname: '王浩',
        handle: 'wanghao_arch',
        avatarBubble: '🚴',
        distance: 3.2,
        online: false,
        status: '🚴 骑行中',
        avatar: 'https://i.postimg.cc/wx16xgzd/8a371ffd7747316ca6a20a73e9213d83.jpg', // 男用头像3
        bio: '31岁 | 建筑师\n对城市规划和空间设计充满热情\n爱好骑行和摄影',
        tags: ['建筑', '设计', '骑行'],
        followers: 3210,
        likes: 96300,
        position: { top: '55%', left: '25%' },
      },
      {
        id: 7,
        nickname: '米娅',
        handle: 'miya_illust',
        avatarBubble: '✏️',
        distance: 3.5,
        online: true,
        status: '✏️ 画画',
        avatar: 'https://i.postimg.cc/nzYhv1dF/25f610139f457dbb334fa669033e710d.jpg', // 共用头像1
        bio: '25岁 | 插画师\n喜欢用画笔记录生活\n热爱动漫和手账',
        tags: ['插画', '动漫', '手账', '猫咪'],
        followers: 15600,
        likes: 452000,
        position: { top: '70%', left: '55%' },
      },
      {
        id: 8,
        nickname: '李思远',
        handle: 'lisiyuan_fin',
        avatarBubble: '🏀',
        distance: 4.1,
        online: false,
        status: '🏀 打球',
        avatar: 'https://i.postimg.cc/vZsMvnVy/16602df49663ddff9f7affe386ca828d.jpg', // 男用头像4
        bio: '28岁 | 金融分析师 | 单身\n工作之余喜欢打篮球和看电影',
        tags: ['篮球', '电影', '投资'],
        followers: 1890,
        likes: 67800,
        position: { top: '40%', left: '80%' },
      },
      {
        id: 9,
        nickname: '张悦',
        handle: 'zhangyue_music',
        avatarBubble: '🎸',
        distance: 4.5,
        online: true,
        status: '🎸 弹吉他',
        avatar: 'https://i.postimg.cc/rFpwrxxB/8a0c2ef08661efe92a45bdac2522e0e5.jpg', // 共用头像2
        bio: '22岁 | 音乐人\n热爱独立音乐和现场表演',
        tags: ['音乐', '吉他', '创作'],
        followers: 8920,
        likes: 286000,
        position: { top: '15%', left: '45%' },
      },
      {
        id: 10,
        nickname: '刘洋',
        handle: 'liuyang_photo',
        avatarBubble: '📸',
        distance: 5.0,
        online: true,
        status: '📸 街拍',
        avatar: 'https://i.postimg.cc/Sx2QZ4ZB/d3e487bf5b4dcb930aa4710bddace460.jpg', // 共用头像3
        bio: '30岁 | 摄影师\n专注街拍和人像',
        tags: ['摄影', '街拍', '后期'],
        followers: 12400,
        likes: 398000,
        position: { top: '65%', left: '35%' },
      },
      {
        id: 11,
        nickname: 'Anna',
        handle: 'anna_coffee',
        avatarBubble: '☕',
        distance: 5.3,
        online: false,
        status: '☕ 冲咖啡',
        avatar: 'https://i.postimg.cc/kGgqWP6S/47625239f04329daf2f0a5cb857fab17.jpg', // 共用头像4
        bio: '24岁 | 咖啡师\n喜欢研究咖啡和烘焙',
        tags: ['咖啡', '烘焙', '手冲'],
        followers: 4560,
        likes: 143000,
        position: { top: '50%', left: '60%' },
      },
      {
        id: 12,
        nickname: '赵明',
        handle: 'zhaoming_gamedev',
        avatarBubble: '🎮',
        distance: 5.8,
        online: true,
        status: '🎮 开发游戏',
        avatar: 'https://i.postimg.cc/WbKTqK2b/3597240784be5b8a5e20c48444522ac0.jpg', // 共用头像5
        bio: '27岁 | 游戏开发者\n独立游戏爱好者',
        tags: ['游戏', '开发', '独立游戏'],
        followers: 7320,
        likes: 234000,
        position: { top: '30%', left: '75%' },
      },
    ],

    allUsers: [], // 完整的用户数据源（AI生成或默认）
    currentUsers: [], // 当前显示的用户列表（可能被筛选过）

    // 🎯 指定筛选条件
    advancedFilter: {
      enabled: false, // 是否启用指定筛选
      gender: 'all', // 性别：all/male/female
      ageMin: 18, // 最小年龄
      ageMax: 50, // 最大年龄
      personality: '', // 性格要求（自由输入）
      tags: '', // 标签要求（自由输入）
      type: '', // 其他类型要求（自由输入）
    },

    // ==================== 天气系统 ====================
    // 天气类型定义：关联全局大事件中的天气描述
    weatherTypes: {
      sunny: { icon: '☀️', name: '晴天', cssClass: 'weather-sunny', particles: 0 },
      cloudy: { icon: '⛅', name: '多云', cssClass: 'weather-cloudy', particles: 0 },
      rain: { icon: '🌧️', name: '小雨', cssClass: 'weather-rain', particles: 30 },
      'heavy-rain': { icon: '⛈️', name: '大雨', cssClass: 'weather-heavy-rain', particles: 60 },
      thunder: { icon: '🌩️', name: '雷暴', cssClass: 'weather-thunder', particles: 50 },
      snow: { icon: '🌨️', name: '下雪', cssClass: 'weather-snow', particles: 40 },
      fog: { icon: '🌫️', name: '大雾', cssClass: 'weather-fog', particles: 0 },
      dust: { icon: '🌪️', name: '沙尘', cssClass: 'weather-dust', particles: 35 },
    },
    // 天气关键词映射：用于从全局大事件的天气描述中识别天气类型
    weatherKeywords: {
      sunny: ['晴', '晴天', '晴朗', '阳光', '万里无云', '艳阳'],
      cloudy: ['多云', '阴', '阴天', '云', '转阴'],
      rain: ['小雨', '阵雨', '零星小雨', '毛毛雨', '细雨'],
      'heavy-rain': ['大雨', '暴雨', '中雨', '大到暴雨', '倾盆大雨'],
      thunder: ['雷', '雷暴', '雷阵雨', '雷电', '打雷'],
      snow: ['雪', '小雪', '中雪', '大雪', '暴雪', '雨夹雪'],
      fog: ['雾', '大雾', '浓雾', '雾霾', '霾'],
      dust: ['沙尘', '扬沙', '浮尘', '沙尘暴', '尘'],
    },
    currentWeather: 'sunny', // 当前天气类型
    weatherTestIndex: 0, // 开发者测试用的天气索引

    selectedUserId: null,
    isSidebarOpen: false,

    // 用户自己的位置（地图中心）
    currentUserPosition: { top: '50%', left: '50%' },

    // 触摸状态
    touchStartX: 0,
    touchStartY: 0,
    touchEndX: 0,
    touchEndY: 0,

    // 地图状态
    mapState: {
      scale: 1,
      translateX: 0,
      translateY: 0,
      isDragging: false,
      startX: 0,
      startY: 0,
      lastTranslateX: 0,
      lastTranslateY: 0,
    },

    MIN_ZOOM: 0.5,
    MAX_ZOOM: 2.5,
    ZOOM_STEP: 0.3,
    MAP_SIZE_MULTIPLIER: 3,

    // ▼▼▼ 【第十五个情景】地图约会数据AI生成器 ▼▼▼
    async generateMapDatingData(onlyUsers = false, onlyLandmarks = false, customRequirements = '') {
      try {
        console.log(
          onlyUsers
            ? '🔄 [第十五个情景] 刷新附近的人...'
            : onlyLandmarks
            ? '📍 [第十五个情景] AI生成地标...'
            : '🗺️ [第十五个情景] 地图约会数据生成器启动...',
        );

        // 🔧 1. 使用统一的API配置加载工具
        // 合并后所有模块都在同一个IIFE作用域内，可以直接访问 APIUtils、StringBuilders、TokenUtils
        const { db, xDb, apiConfig, xSettings } = await APIUtils.loadConfigAndSettings();
        const { userPrompt, worldSetting, boundCharacters } = xSettings;

        // 🔧 1.5. 如果只刷新用户，从数据库读取原有数据
        let existingMapConfig = null;
        let existingLandmarks = null;
        let existingWeather = null;
        let shouldAIDecideWeather = false; // 是否让AI根据上次天气决定新天气
        let hoursSinceWeatherRefresh = 0; // 距离天气刷新基准时间的小时数
        let firstMapEnterTime = null; // 首次进入地图的时间
        let lastWeatherRefreshTime = null; // 上次天气刷新的时间
        let weatherWasRefreshed = false; // 天气是否被刷新（需要更新lastWeatherRefreshTime）
        let mapWeatherType = null; // 天气类型（只在非landmark-only模式使用）
        let mapWeatherInfo = null; // 天气信息对象（只在非landmark-only模式使用）

        if (onlyUsers) {
          const dataId = `mapDatingData_${currentAccountId || 'main'}`;
          const savedData = await xDb.xMapDatingData.get(dataId);

          if (savedData && savedData.data) {
            existingMapConfig = savedData.data.mapConfig;
            existingLandmarks = savedData.data.landmarks;
            existingWeather = savedData.data.weather;
            firstMapEnterTime = savedData.firstMapEnterTime || null;
            lastWeatherRefreshTime = savedData.lastWeatherRefreshTime || null;

            // 🌤️ 新逻辑：根据天气刷新时间基准判断是否需要AI决定新天气
            const now = new Date();
            let weatherRefreshBaseTime = null; // 天气刷新的基准时间

            if (lastWeatherRefreshTime) {
              // 有上次天气刷新时间，以它为基准
              weatherRefreshBaseTime = new Date(lastWeatherRefreshTime);
              console.log(`🌤️ [天气判断] 使用上次天气刷新时间为基准: ${weatherRefreshBaseTime.toLocaleString('zh-CN')}`);
            } else if (firstMapEnterTime) {
              // 没有天气刷新时间但有首次进入时间，以首次进入时间为基准
              weatherRefreshBaseTime = new Date(firstMapEnterTime);
              console.log(`🌤️ [天气判断] 使用首次进入地图时间为基准: ${weatherRefreshBaseTime.toLocaleString('zh-CN')}`);
            } else {
              // 都没有，说明是第一次进入地图，记录当前时间为首次进入时间
              firstMapEnterTime = now.toISOString();
              console.log(`🌤️ [天气判断] 首次进入地图，记录进入时间: ${now.toLocaleString('zh-CN')}`);
            }

            // 如果有基准时间，计算距离现在过了多少小时
            if (weatherRefreshBaseTime) {
              hoursSinceWeatherRefresh = (now - weatherRefreshBaseTime) / (1000 * 60 * 60);

              if (hoursSinceWeatherRefresh >= 12 && existingWeather) {
                shouldAIDecideWeather = true;
                console.log(
                  `🌤️ [天气刷新] 距离基准时间已超过${hoursSinceWeatherRefresh.toFixed(1)}小时（≥12h），将让AI根据上次天气【${existingWeather}】决定新天气`,
                );
                // 保留 existingWeather，让AI在提示词中根据上次天气和时间推移决定
              } else {
                console.log(
                  `🌤️ [天气保留] 距离基准时间仅${hoursSinceWeatherRefresh.toFixed(1)}小时（<12h），保留天气: ${existingWeather}`,
                );
              }
            }

            console.log('📖 [第十五个情景] 已加载原有地图配置和地标数据');
            console.log(`  |- 地图配置: ${JSON.stringify(existingMapConfig)}`);
            console.log(`  |- 地标数量: ${existingLandmarks?.length || 0}`);
            console.log(`  |- 当前天气: ${existingWeather || '将重新生成'}`);
            console.log(`  |- 首次进入时间: ${firstMapEnterTime ? new Date(firstMapEnterTime).toLocaleString('zh-CN') : '无'}`);
            console.log(
              `  |- 上次天气刷新: ${lastWeatherRefreshTime ? new Date(lastWeatherRefreshTime).toLocaleString('zh-CN') : '无'}`,
            );
          } else {
            console.warn('⚠️ [第十五个情景] 未找到原有数据，将进行完整生成');
            onlyUsers = false; // 降级为完整生成
          }
        }

        // 🔧 2. 构建用户X个人资料信息（只在需要时）
        const userXProfileInfo = onlyLandmarks ? null : StringBuilders.buildUserXProfileInfo(window.userProfileData);

        // 🔧 3. Token计数器初始化
        let tokenCount = 0;

        // 🔧 5. 时间感知（北京时间）- 只在生成附近的人时需要
        let systemPrompt = '';

        if (!onlyLandmarks) {
          // 只在生成附近的人时才添加时间感知
          const now = new Date();
          const timeInfo = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⏰ 时间感知
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
当前北京时间：${now.toLocaleString('zh-CN', {
            timeZone: 'Asia/Shanghai',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            weekday: 'long',
          })}
【时间相关提示】：
- 生成的附近的人状态应该符合当前时间段（早晨、中午、下午、晚上、深夜）
- 例如：早晨可能在"晨跑中"，中午可能在"吃午饭"，晚上可能在"看电影"等
- 在线状态也应该考虑时间因素（深夜在线率较低）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          systemPrompt = timeInfo;
          tokenCount = TokenUtils.logTokenUsage('地图约会生成器', '时间感知', timeInfo, tokenCount);
        }

        // 🔧 6. 基础系统提示词
        systemPrompt +=
          StringBuilders.buildBaseSystemPrompt({
            userPrompt,
            worldSetting,
          });
        tokenCount = TokenUtils.logTokenUsage('地图约会生成器', '基础系统提示词', systemPrompt, tokenCount);

        // 🔧 7. 获取适用的世界书内容
        const worldBooksContent = await StringBuilders.getApplicableWorldBooks('mapDating', {
          boundCharacters,
        });
        if (worldBooksContent) {
          systemPrompt += worldBooksContent;
          tokenCount = TokenUtils.logTokenUsage('地图约会生成器', '世界书内容', worldBooksContent, tokenCount);
        }

        // 🔧 8. 读取世界运转大事件（如果启用）- 只在生成附近的人时需要
        if (!onlyLandmarks) {
          // 只在生成附近的人时才读取世界运转大事件和天气规则
          const worldEventsDataId = `worldEvents_${window.currentAccountId || 'main'}`;
          const worldEventsRecord = await xDb.xWorldEvents.get(worldEventsDataId);

          // 🌤️ 解析天气类型（从全局大事件或随机生成，或使用已有天气）
          mapWeatherType = existingWeather || this.getRandomWeather(); // 如果是刷新用户且有原天气，使用原天气
          mapWeatherInfo = null;

        if (
          worldEventsRecord &&
          worldEventsRecord.enabled &&
          worldEventsRecord.events &&
          worldEventsRecord.events.length > 0
        ) {
          // 从全局大事件的天气描述中解析天气类型（但如果是刷新用户且有原天气，不覆盖）
          if (!existingWeather) {
            const weatherCondition = worldEventsRecord.weather?.condition || '';
            mapWeatherType = this.parseWeatherFromText(weatherCondition);
          }
          mapWeatherInfo = this.weatherTypes[mapWeatherType];
          console.log(
            `🌤️ [地图约会生成器] ${existingWeather ? '保持原有天气' : '从全局大事件解析天气'}: ${mapWeatherInfo.icon} ${
              mapWeatherInfo.name
            }`,
          );

          const worldEventsPrompt = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🌍 世界运转状态（地图约会生成必读）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【当前世界设定】：
📍 所在地点：${worldEventsRecord.location}
🌤️ 天气状况：${worldEventsRecord.weather?.condition || '--'} ${worldEventsRecord.weather?.temp || '--'}
💡 穿衣建议：${worldEventsRecord.weather?.tip || '--'}

【近期大事件】（${worldEventsRecord.events.length}个热门事件）：
${worldEventsRecord.events
  .map(
    (event, index) => `
${index + 1}. [${event.category}] ${event.title}
   详情：${event.detail}
   影响：${event.impact}
`,
  )
  .join('')}

【大事件融入规则】：
🎯 核心原则：地图约会中的附近的人状态、个人简介应该受这些事件影响
1. **状态影响**：某些人的状态可能与大事件相关（如"讨论XX新闻中"）
2. **简介影响**：个人简介可能提及对某个事件的态度或兴趣
3. **标签影响**：标签可能包含与事件相关的关键词
4. **自然融入**：不要强行在每个人身上体现，保持多样性（建议10-30%的人受影响）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🌤️ 天气影响状态气泡规则（重要！）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
当前天气：${mapWeatherInfo.icon} ${mapWeatherInfo.name}

**天气会影响附近的人的状态气泡（status字段）**，请根据当前天气生成符合逻辑的状态：

${
  mapWeatherType === 'rain' || mapWeatherType === 'heavy-rain' || mapWeatherType === 'thunder'
    ? `
🌧️ 【雨天/暴风雨状态建议】（20-40%的人可能受影响）：
- "躲雨中"、"没带伞😭"、"等雨停"、"听雨"
- "宅家追剧"、"窝被窝"、"在家办公"
- "雨天咖啡☕"、"适合发呆"
- 大雨/雷暴时更可能宅在室内
`
    : ''
}
${
  mapWeatherType === 'snow'
    ? `
❄️ 【雪天状态建议】（20-40%的人可能受影响）：
- "赏雪中"、"堆雪人⛄"、"打雪仗"
- "窝被窝"、"喝热可可"、"烤火取暖"
- "拍雪景📷"、"雪地散步"
`
    : ''
}
${
  mapWeatherType === 'fog'
    ? `
🌫️ 【大雾状态建议】（10-20%的人可能受影响）：
- "雾太大等会出门"、"能见度低"
- "宅家"、"晚点再约"
`
    : ''
}
${
  mapWeatherType === 'dust'
    ? `
🌪️ 【沙尘状态建议】（20-30%的人可能受影响）：
- "戴口罩出门"、"沙尘天待室内"
- "等沙尘过去"、"空气太差"
`
    : ''
}
${
  mapWeatherType === 'sunny' || mapWeatherType === 'cloudy'
    ? `
☀️ 【晴天/多云状态建议】（正常活动）：
- 户外活动较多：跑步、逛街、拍照、约会
- 可以出现各种正常状态，天气影响较小
`
    : ''
}

**注意**：不要所有人都提天气，保持状态多样性。大部分人应该是正常状态，只有部分人的状态会受天气影响。
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          systemPrompt += worldEventsPrompt;
          tokenCount = TokenUtils.logTokenUsage(
            '地图约会生成器',
            '世界运转大事件+天气规则',
            worldEventsPrompt,
            tokenCount,
          );
          console.log(`🌍 [地图约会生成器] 已注入 ${worldEventsRecord.events.length} 个世界大事件`);
        } else {
          // 没有全局大事件，但仍然要注入天气影响规则
          mapWeatherInfo = this.weatherTypes[mapWeatherType];
          console.log(`🌤️ [地图约会生成器] 随机生成天气: ${mapWeatherInfo.icon} ${mapWeatherInfo.name}`);

          const weatherOnlyPrompt = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🌤️ 天气影响状态气泡规则
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
当前天气：${mapWeatherInfo.icon} ${mapWeatherInfo.name}

**天气会影响附近的人的状态气泡（status字段）**，请根据当前天气生成符合逻辑的状态：

${
  mapWeatherType === 'rain' || mapWeatherType === 'heavy-rain' || mapWeatherType === 'thunder'
    ? `
🌧️ 【雨天/暴风雨状态建议】（20-40%的人可能受影响）：
- "躲雨中"、"没带伞😭"、"等雨停"、"听雨"
- "宅家追剧"、"窝被窝"、"在家办公"
- "雨天咖啡☕"、"适合发呆"
`
    : ''
}
${
  mapWeatherType === 'snow'
    ? `
❄️ 【雪天状态建议】（20-40%的人可能受影响）：
- "赏雪中"、"堆雪人⛄"、"打雪仗"
- "窝被窝"、"喝热可可"、"烤火取暖"
`
    : ''
}
${
  mapWeatherType === 'fog'
    ? `
🌫️ 【大雾状态建议】（10-20%的人可能受影响）：
- "雾太大等会出门"、"能见度低"
- "宅家"、"晚点再约"
`
    : ''
}
${
  mapWeatherType === 'dust'
    ? `
🌪️ 【沙尘状态建议】（20-30%的人可能受影响）：
- "戴口罩出门"、"沙尘天待室内"
`
    : ''
}
${
  mapWeatherType === 'sunny' || mapWeatherType === 'cloudy'
    ? `
☀️ 【晴天/多云状态建议】（正常活动）：
- 户外活动较多：跑步、逛街、拍照、约会
- 可以出现各种正常状态
`
    : ''
}

**注意**：不要所有人都提天气，保持状态多样性。
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          systemPrompt += weatherOnlyPrompt;
          tokenCount = TokenUtils.logTokenUsage(
            '地图约会生成器',
            '天气规则（无大事件）',
            weatherOnlyPrompt,
            tokenCount,
          );
          console.log('ℹ️ [地图约会生成器] 世界大事件未启用或无数据，仅注入天气规则');
        }
        } // 结束 if (!onlyLandmarks) - 天气和世界运转大事件部分

        // 🔧 9. 核心任务说明 - 根据是否只刷新用户选择不同的提示词
        if (onlyUsers) {
          // 只刷新附近的人
          systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务说明 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是地图约会数据生成器。请根据世界观、世界书和大事件生成新的附近的人数据。

🚨 **重要：你必须只返回有效的JSON格式数据，任何语法错误都会导致系统崩溃！** 🚨
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【生成要求】：

## 附近的人（nearbyUsers）- Instagram风格资料卡
- 生成8-15个附近的人`;

          // 🎯 添加指定筛选条件（如果启用）
          if (this.advancedFilter && this.advancedFilter.enabled) {
            systemPrompt += `

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 用户指定筛选条件（重要！）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ **用户设置了指定筛选条件，请尽量按以下要求生成附近的人：**

【筛选条件】：
${
  this.advancedFilter.gender !== 'all'
    ? `- 性别偏好：${this.advancedFilter.gender === 'male' ? '男性为主' : '女性为主'}`
    : ''
}
${
  this.advancedFilter.ageMin && this.advancedFilter.ageMax
    ? `- 年龄区间：${this.advancedFilter.ageMin}-${this.advancedFilter.ageMax}岁`
    : ''
}
${this.advancedFilter.personality ? `- 性格要求：${this.advancedFilter.personality}` : ''}
${this.advancedFilter.tags ? `- 标签/兴趣要求：${this.advancedFilter.tags}` : ''}
${this.advancedFilter.type ? `- 其他要求：${this.advancedFilter.type}` : ''}

【筛选规则】：
⚠️ **重要：不需要每个人都完全符合条件，可以灵活匹配！**

1. **性别筛选**（如果指定）：
   - 如果用户选择了特定性别，生成的人物中**60-80%应该是该性别**
   - 保留20-40%其他性别的人物，保持真实性和多样性

2. **年龄区间**（如果指定）：
   - **70-90%的人物年龄应该在指定区间内**
   - 允许10-30%的人物年龄稍微超出范围（±3岁左右）

3. **性格要求**（如果指定）：
   - 生成时，**50-70%的人物性格标签应包含相关关键词**
   - 例如用户要求"outgoing"，可以生成：开朗、外向、活泼、社交达人等
   - 不是所有人都要完全匹配，保持性格多样性

4. **标签/兴趣要求**（如果指定）：
   - **40-60%的人物应该有相关的标签或兴趣**
   - 例如用户要求"music, sports"，生成的人物中部分有音乐相关标签，部分有运动标签
   - 可以是直接匹配（"音乐"、"运动"）或相关词（"吉他"、"健身"、"篮球"）

5. **其他要求**（如果指定）：
   - 根据用户自由输入的要求，**灵活理解并应用到30-50%的人物中**
   - 不要生硬地强制匹配，保持自然和真实性

🎯 **核心原则**：
- 筛选是"倾向性"而非"强制性"：大部分人符合条件即可
- 保持多样性：不要所有人都一模一样
- 真实感优先：即使有筛选条件，生成的人物也要符合世界观和逻辑
- 可以有惊喜：偶尔生成一些不完全符合但很有特色的人物

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          }
        } else if (onlyLandmarks) {
          // 只生成地标模式
          systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务说明 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是地标数据生成器。请根据世界观、世界书和用户要求生成独一无二的地标数据。

🚨 **重要：你必须只返回有效的JSON格式数据，任何语法错误都会导致系统崩溃！** 🚨
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【用户自定义要求】：
${customRequirements || '无特殊要求，根据世界观自由生成即可。'}
${
  this.customLandmarks && this.customLandmarks.length > 0
    ? `

【现有自定义地标】：
系统中已存在 ${this.customLandmarks.length} 个自定义地标，请注意：
1. **为这些地标生成事件**：约20%的现有地标应该生成事件（如果它们还没有event字段）
2. **深度结合description字段**：如果地标有description字段，必须深度结合其内容生成事件
3. **避免重复**：不要生成与现有地标名称相同的新地标
4. **返回时必须包含所有现有地标**（无论是否添加事件），并与新生成的地标一起返回

现有地标数据：
\`\`\`json
${JSON.stringify(this.customLandmarks, null, 2)}
\`\`\`
`
    : ''
}

【生成要求】：

## 地标数据（landmarks）
- 根据世界观和用户要求生成**新的**地标
- 如果用户指定了地标类型或数量，优先满足用户要求
- 如果用户没有指定，根据世界观关键词随机生成，类型分布合理：
  * 教育类（🎓）：15-25%
  * 餐饮类（☕🍜🍕）：20-30%
  * 娱乐类（🎮🎬🎪）：15-25%
  * 商业类（🛒💼🏢）：15-25%
  * 公共类（🏥⛪🏛️）：10-20%
- **严禁生成重复的地标**，每个地标名称必须唯一
- 地标数量：根据用户要求，默认5-15个
- 每个地标包含：
  * id: 唯一标识（字符串）
  * name: 地标名称（字符串）
  * icon: emoji图标（字符串）
  * color: 颜色（#十六进制字符串）
  * **注意：x, y坐标由系统自动分配，不需要生成**

【输出JSON格式】：
\`\`\`json
{
  "landmarks": [
    {
      "id": "landmark_001",
      "name": "星巴克咖啡（市中心店）",
      "icon": "☕",
      "color": "#00a862"
      // 无事件的地标不需要event字段
    },
    {
      "id": "landmark_002",
      "name": "中央公园",
      "icon": "🌳",
      "color": "#4caf50",
      "event": {
        "eventType": "alert",
        "accentColor": "#c9302c",
        "eventHTML": "<div class=\\"event-paper-header\\" style=\\"background: #c9302c;\\">...</div><div class=\\"event-article\\">...</div><div class=\\"event-footer\\">...</div>"
      }
    },
    {
      "id": "landmark_003",
      "name": "好莱坞工厂",
      "icon": "🏭",
      "color": "#9e9e9e",
      "event": {
        "eventType": "news",
        "accentColor": "#2c5aa0",
        "eventHTML": "<div class=\\"event-paper-header\\"><div class=\\"event-masthead\\">City Daily</div>...</div>..."
      }
    }
    // ... 更多地标（约20%有event，80%无event）
  ],
  "newspaper": {
    "weather": { "icon": "☀", "temp": "18°C", "desc": "TODAY · SUNNY" },
    "news": [ { "headline": "...", "location": "...", "time": "...", "body": "...", "comment": "..." } ],
    "bubble": "✧ ...",
    "submissions": [ { "tag": "MISSING", "title": "...", "content": "..." } ],
    "ads": [ { "title": "...", "text": "..." } ]
  }
}
\`\`\`

🚨 **重要**：
- 必须返回 **landmarks数组** 和 **newspaper对象**
- newspaper字段是必须的，包含结构化的报纸数据（非HTML字符串）
- JSON必须合法，不能有语法错误
- 所有字段名必须用双引号
- 最后一个对象后面不能有逗号
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        } else {
          // 完整生成
          systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务说明 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是地图约会数据生成器。请根据世界观、世界书和大事件生成独一无二的地图约会数据。

🚨 **重要：你必须只返回有效的JSON格式数据，任何语法错误都会导致系统崩溃！** 🚨
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【生成要求】：
${
  this.customLandmarks && this.customLandmarks.length > 0
    ? `

【现有自定义地标】：
系统中已存在 ${this.customLandmarks.length} 个自定义地标，请注意：
1. **为这些地标生成事件**：约20%的现有地标应该生成事件（如果它们还没有event字段）
2. **深度结合description字段**：如果地标有description字段，必须深度结合其内容生成事件
3. **避免重复**：不要生成与现有地标名称相同的新地标
4. **返回时必须包含所有现有地标**（无论是否添加事件），并与新生成的地标一起返回

现有地标数据：
\`\`\`json
${JSON.stringify(this.customLandmarks, null, 2)}
\`\`\`
`
    : ''
}

## 1. 地图配置（mapConfig）
根据世界观描述动态调整地图元素比例：
- waterRatio: 湖水比例（0-1小数）。如果世界观描述"靠海"、"临江"、"水城"等，应增加此值（0.3-0.5）；如果是"内陆"、"沙漠"等，应减少（0-0.1）
- buildingDensity: 建筑密度（0-1小数）。先进城市0.6-0.8，普通城市0.4-0.6，农村0.1-0.3
- parkCount: 公园数量（2-8整数）。根据城市大小和环境意识调整
- roadWidth: 道路宽度（10-25整数）。发达地区用更宽的道路

## 2. 地标数据（landmarks）
- **必须包含世界观和世界书中提到的所有重要地标**（学校、公司、商场等关键地点）
- 其他地标根据世界观关键词随机生成，类型分布合理：
  * 教育类（🎓）：15-25%
  * 餐饮类（☕🍜🍕）：20-30%
  * 娱乐类（🎮🎬🎪）：15-25%
  * 商业类（🛒💼🏢）：15-25%
  * 公共类（🏥⛪🏛️）：10-20%
- **严禁生成重复的地标**，每个地标名称必须唯一
- 地标数量：10-30个
- 每个地标包含：
  * id: 唯一标识（字符串）
  * name: 地标名称（字符串）
  * icon: emoji图标（字符串）
  * color: 颜色（#十六进制字符串）
  * **注意：x, y坐标由系统自动分配，不需要生成**
  * event: 地标事件对象（可选，**约20%的地标应该有事件**）
    - eventType: 事件类型字符串（"news"新闻/"alert"警报/"scandal"丑闻/"wanted"通缉/"business"商业/"government"政府/"incident"事件等）
    - eventHTML: 事件HTML内容（字符串，**必须严格遵循下方的HTML生成规范**）
    - accentColor: 强调色（#十六进制字符串，**可以自由选择任何深色系颜色，根据事件性质和氛围选择最合适的颜色，禁止使用荧光色和emoji**）

### 2.1 地标事件生成规则（仅适用于约20%的地标）

**事件分配原则**：
- 随机选择约20%的地标赋予事件
- 事件类型必须与地标性质高度相关（如：工厂→火灾新闻、公园→可疑物品警报、商场→开业活动、酒吧→斗殴事件）
- 事件内容必须符合世界观设定、当前时间、天气状况
- **如果地标有description字段（自定义地标），必须深度结合description内容生成事件**

**事件类型示例**（颜色可自由选择，以下仅为参考）：
1. **报纸新闻** (news)：火灾、事故、重大发现、历史建筑、名人事件
2. **紧急警报** (alert)：可疑物品、治安事件、自然灾害预警、交通管制
3. **娱乐丑闻** (scandal)：名人绯闻、商业内幕、隐私泄露、争议事件
4. **通缉令** (wanted)：在逃人员、悬赏通缉、协查通报、犯罪预警
5. **商业活动** (business)：新店开业、促销活动、品牌发布、商场庆典
6. **政府公告** (government)：工程施工、政策通知、公共服务、市政改造
7. **血腥事件** (incident)：暴力事件、重大伤亡、犯罪现场、恐怖袭击
8. **抓马事件** (drama)：情感纠纷、八卦爆料、社区冲突、邻里矛盾
9. **其他创意类型**：根据地标性质和世界观自由发挥，不限于以上分类

### 2.2 事件HTML生成规范（极其重要！）

**生成的eventHTML必须严格遵守以下规范**：

#### 设计要求（强制）：
1. **色彩系统**：
   - 主色调：只能使用黑色、白色、各级灰色
   - 强调色：accentColor字段用于指定强调色（深蓝/深红/深绿/紫色/深灰，**绝对禁止荧光色**）
   - **绝对禁止**：Emoji表情符号、荧光色、彩虹色、粉色、亮绿色
   - **颜色使用规则（极其重要）**：
     * 只在JSON的accentColor字段中指定颜色值（如 "#8E44AD"）
     * HTML中绝对不要写任何颜色代码（不要用style="color: xxx"之类）
     * HTML中只使用提供的CSS类（如 event-tag, event-emphasis 等）
     * 系统会自动将accentColor设置为CSS变量 --event-accent
     * CSS类会自动应用这个变量，你不需要手动指定颜色

2. **排版类库（必须使用提供的CSS类）**：
   - **报纸头部**：
     * event-paper-header（头部容器）
     * event-masthead（报社名称，大标题）
     * event-tagline（标语口号）
     * event-header-meta（元信息：期数、日期等）

   - **标题类**：
     * event-headline（主标题，42px，粗体衬线）
     * event-subheadline（副标题，26px）
     * event-title（小标题，20px）

   - **正文类**：
     * event-lead（导语，20px，加粗）
     * event-body（正文，19px，衬线字体）
     * event-body-sans（无衬线正文，16px）
     * event-byline（署名行）

   - **装饰类**：
     * event-drop-cap（首字母下沉，用于正文第一段）
     * event-quote（引用块，灰色背景+主题色左边框）
     * event-quote-author（引用来源）
     * event-emphasis（强调文字，主题色文字颜色）
     * event-bold（加粗）
     * event-caption（说明文字，小字号灰色）

   - **容器类（注意区分用途）**：
     * event-box（基础信息框，灰色背景）
     * event-box-highlight（高亮信息框，灰色背景+主题色左边框）
     * event-box-alert（警告框，**主题色背景+白色文字**）

   - **标签类**：
     * event-tag（主标签，**主题色背景+白色文字**）
     * event-tag secondary（次要标签，灰色背景+普通文字）

   - **分隔线**：
     * event-divider（细线）
     * event-divider-thick（粗线）
     * event-divider-double（双线）

   - **列表和表格**：
     * event-list（有序/无序列表）
     * event-list-clean（无样式列表）
     * event-table（表格）

   - **布局**：
     * event-columns-2（双栏布局）
     * event-footer（页脚）

3. **内容质量标准**：
   - 长度：300-1000字，根据事件重要性调整
   - 深度：必须有具体细节、人物对话、数据支持、时间线
   - 真实感：符合地标性质、世界观设定、时间线逻辑、天气状况
   - **自定义地标**：如果landmark有description字段，必须深度结合其内容生成事件
   - 避免空洞、模板化的描述

4. **HTML结构模板**：
\`\`\`html
<div class="event-paper-header">
  <div class="event-masthead">报社名称</div>
  <div class="event-tagline">标语口号</div>
  <div class="event-header-meta">
    <span>期数/编号</span>
    <span>日期</span>
    <span>其他信息</span>
  </div>
</div>

<div class="event-article">
  <div class="event-tags">
    <span class="event-tag">标签1</span>
    <span class="event-tag secondary">标签2</span>
  </div>

  <h1 class="event-headline">主标题<br>可以换行</h1>

  <div class="event-byline">
    <strong>记者/来源</strong> · 时间/地点
  </div>

  <p class="event-lead">导语：简明扼要概括事件核心，吸引读者注意...</p>

  <hr class="event-divider-thick">

  <p class="event-body event-drop-cap">正文第一段使用首字母下沉效果。内容要具体生动，包含时间、地点、人物、经过、结果等要素...</p>

  <div class="event-quote">
    引用的话语内容，可以是目击者证词、专家评论等...
    <div class="event-quote-author">— 引用来源</div>
  </div>

  <h2 class="event-subheadline">副标题</h2>

  <p class="event-body">继续叙述...</p>

  <div class="event-box">
    <strong class="event-bold">相关信息</strong><br>
    <span class="event-caption">补充说明...</span>
  </div>
</div>

<div class="event-footer">
  版权信息或其他页脚内容
</div>
\`\`\`

5. **事件类型特定要求**：
   - **报纸新闻**：使用报纸头部、首字母下沉、引用块、相关报道框
   - **紧急警报**：红色警告框、时间线表格、受影响区域列表、公众提醒
   - **政府公告**：邮件头部样式、阶段表格、联系方式框、正式语气
   - **娱乐丑闻**：双栏证词框、爆料风格、免责声明、阅读量统计
   - **通缉令**：人物信息表、悬赏公告、举报方式、案情描述
   - **商业活动**：优惠信息、活动详情、营业时间、联系方式
   - **血腥事件**：严肃措辞、警方通报格式、深色调、避免过度描写

**重要提醒**：
- eventHTML只输出HTML片段，不要包含 <html>, <head>, <body> 等外层标签
- 不要添加额外的 <style> 或 <script>
- **所有样式必须且只能使用提供的CSS类，绝对禁止任何内联style样式！**
- **强调色必须且只能通过CSS类实现，系统会自动设置CSS变量值，绝对不要在HTML中写任何颜色代码！**
- **CSS类使用规则（极其重要，避免颜色混淆）**：
  * 需要"主题色背景+白字"效果时：使用 event-tag 或 event-box-alert
  * 需要"灰色背景+主题色边框"效果时：使用 event-box-highlight 或 event-quote
  * 需要"主题色文字"效果时：使用 event-emphasis 或在span/strong上添加event-emphasis类
  * 需要普通信息框时：使用 event-box（灰色背景，无主题色）
  * **绝对不要混淆背景和文字的颜色使用场景！**
  * **绝对不要把主题色背景用在应该用灰色背景的地方，反之亦然！**
- 必须适配深色和浅色主题（使用CSS变量）
- 必须在移动端（竖屏）完美显示

## 3. 附近的人（nearbyUsers）- Instagram风格资料卡
- 生成10-30个附近的人`;
        }

        // 🔧 继续添加附近的人和提醒的详细说明 - 只在生成附近的人时需要
        if (!onlyLandmarks) {
          systemPrompt += `
- 人物应符合世界观背景和大事件影响
- **地域限制**：如果有绑定角色，检查角色的居住地/活动地点。外国角色、异地角色不能出现在附近的人中！只能生成与当前地点相符的本地人。
- 每个人包含：
  * nickname: 昵称（2-8个字符，可以是真名、网名或艺名，符合世界观背景）
  * handle: 句柄（类似Instagram的@username，5-15个字符，纯英文小写+数字+下划线，如"lihua_dev"、"xiaoming2024"）
  * avatarBubble: 头像气泡（单个emoji或1-2个颜文字，表达心情或个性，如"😊"、"📷"、"💤"、"🎮"、"✨"）
  * gender: 性别（"male"、"female"或"unisex"字符串）
  * distance: 距离（0.5-6.0小数，保留1位）
  * online: 是否在线（true/false布尔值）
  * status: 状态文本（**格式自由，可以有emoji也可以没有**）
    - 可以是个人状态：如"健身中"、"📷 拍照中"、"工作ing"
    - 可以是社交宣告：如"cpdd"、"已婚勿扰"、"找饭搭子"、"交友"
    - 状态应该符合时间段和人物性格
  * bio: 个人简介（**多行格式，用\n分隔行**）
    - **第一行格式**：年龄（18-35）+ " | " + 感情状态（单身/恋爱中/已婚/保密等）
    - **后续行**：兴趣爱好、职业、生活态度等（1-3句话）
    - **示例**："24岁 | 单身\n热爱旅行和摄影\n喜欢探索城市的每个角落\n周末常去咖啡馆看书写字"
  * publicPersonality: 表现性格（数组，10-15个关键词，描述在网络/社交媒体上表现出来的性格特征）
    - 关键词示例："开朗"、"热情"、"幽默"、"温柔"、"活泼"、"乐观"、"健谈"等
    - 这是TA给外界的印象，可能与真实性格一致，也可能表里不一
  * realPersonality: 真实性格（数组，10-15个关键词，描述真实的内在性格特征）
    - 关键词示例："内向"、"敏感"、"闷骚"、"阴暗"、"受虐狂"、"控制欲"、"阴险"、"孤僻"等
    - 这是TA的真实性格，可能与表现性格完全不同（双面性），也可能一致（表里如一）
    - **重要**：真实性格可以是负面的、复杂的、矛盾的，要真实反映人性的多面性
  * appearance: 外貌及身材（数组，10-15个关键词，描述外貌和身体特征）
    - 关键词示例："黑发"、"猫眼"、"182cm/60kg"、"三围90/60/88"、"蝴蝶耳钉"、"纹身"、"肌肉线条"、"瓜子脸"、"单眼皮"、"痣"等
    - 包括：发色、眼睛、身高体重、三围、配饰、特殊标记、体型、脸型、五官特征等
  * tags: 标签数组（2-4个字符串）
  * followers: 粉丝数（100-50000整数，符合普通用户水平，不要太夸张）
  * likes: 获赞数（1000-100000整数，一般是粉丝数的10-50倍）
  * avgRating: 平均评分（0-5小数，保留1位，约会评分系统。如4.8、3.2、0表示无评价）
  * reviews: 评价/留言数组（可选，0-8条评价，这是地图约会app的核心功能！）
    - reviewerName: 评价者昵称（2-8字符，或"匿名用户"）
    - rating: 评分（1-5小数，保留1位，如4.9、3.5）
    - content: 评价内容（20-100字，可以是：赞美外貌/身材、警告骚扰行为、分享约会体验、投诉不守时等，真实自然）
    - reply: 作者回复（可选，10-50字，该地图用户对评价的回复）
    - likes: 点赞数（0-500整数）
    - comments: 评论数（0-50整数）
    - timestamp: 时间戳（ISO格式字符串，如"2024-01-15T10:30:00Z"，最近1-30天内）
    - isAnonymous: 是否匿名（布尔值，约30%匿名）
  * **注意：不需要生成avatar、id、position、reviewerAvatar字段，由系统自动处理**

## 4. 提醒功能（notifications）- 跨地域互动系统
- 生成0-3条提醒（30-50%概率生成，可以不生成）
- 提醒来自"其他用户"对"用户X"的行为（感兴趣或发私信）

### 提醒类型说明：

**第一类：interested（对你的资料感兴趣）**
- 含义：某个用户浏览了你的资料后，对你产生了兴趣
- 数据结构：
  * type: "interested"
  * fromUser: 完整的用户对象（结构与nearbyUsers相同）
  * content: 简短的兴趣表达（10-30字），如"觉得你挺有趣的"、"你的照片很好看"、"想认识一下"等
  * 不需要生成id、timestamp、isRead字段

**第二类：message（发来私信）**
- 含义：某个用户给你发送了1-3条私信
- 数据结构：
  * type: "message"
  * fromUser: 完整的用户对象（结构与nearbyUsers相同）
  * messages: 字符串数组（1-3条私信内容）
    - 第1条：开场白/打招呼（15-40字），如"Hi，可以认识一下吗？"、"你好，看到你的资料觉得很有趣"
    - 第2条（可选）：兴趣点/共同话题（15-50字），如"我也喜欢旅行"、"看到你去过日本，我也很想去"
    - 第3条（可选）：进一步表达/邀约（15-50字），如"有空可以一起喝杯咖啡吗？"、"很想和你聊聊摄影"
  * **重要**：message类型不需要content字段，只需要messages数组
  * 不需要生成id、timestamp、isRead字段

### fromUser用户特征：
- fromUser是完整的用户对象，包含所有nearbyUsers的字段（nickname, handle, avatarBubble, gender, distance, online, status, bio, publicPersonality, realPersonality, appearance, tags, followers, likes, avgRating, reviews等）
- **重要**：fromUser可以是距离较远的用户（5-50km），或者来自其他城市/国家，**不受地图约会地域限制**
- 这些用户可以是异地的、外国的，因为App允许跨地域浏览资料和发私信
- fromUser应该符合世界观背景和大事件影响
- fromUser的性格、外貌、标签应该多样化，不要千篇一律

### 生成概率和分布：
- 30-50%概率生成提醒（即有50-70%概率返回空数组[]）
- 如果生成提醒，70%概率生成1条，20%概率生成2条，10%概率生成3条
- interested和message类型比例大约1:1
- message类型中，60%生成1条消息，30%生成2条消息，10%生成3条消息
`;
        } // 结束 if (!onlyLandmarks) - 附近的人和提醒详细说明部分

        const coreTaskSection = systemPrompt.substring(
          tokenCount > 0 ? systemPrompt.lastIndexOf('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━') : 0,
        );
        tokenCount = TokenUtils.logTokenUsage('地图约会生成器', '核心任务说明', coreTaskSection, tokenCount);

        // 🔧 10-13. 角色资料、关系网络、用户约束、天气决策 - 只在生成附近的人时需要
        if (!onlyLandmarks) {
          // 🔧 10. 角色资料（如果有绑定角色）+ 地域判断提示
          const charactersInfo = await StringBuilders.buildCompleteCharacterInfo(
          boundCharacters,
          userXProfileInfo,
          'mapDating',
        );
        if (charactersInfo) {
          systemPrompt += charactersInfo;

          // 添加地域判断提示
          systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🌏 地域限制规则（重要！）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
**在生成附近的人时，必须严格遵守地域限制：**

1. **检查角色居住地/活动地点**：
   - 如果角色卡明确标注居住在外国（如美国、日本、韩国等）→ 该角色不能出现在附近的人中
   - 如果角色卡标注在国内其他城市（异地）→ 该角色不能出现在附近的人中
   - 只有明确在当前地点或未标注居住地的角色，才可能出现

2. **生成本地人物**：
   - 附近的人应该是符合当前地点（世界观中的城市/地区）的本地人
   - 姓名、身份、生活方式应符合当前地点的文化背景
   - 避免生成明显的异地/异国人物

3. **特殊情况**：
   - 如果角色卡中提到"经常往返"、"双城生活"等，可以酌情考虑
   - 如果世界观本身设定在国外，则按照该国的本地标准判断

**记住：地图约会是基于地理位置的，异地/异国的人不可能出现在附近！**
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

          tokenCount = TokenUtils.logTokenUsage('地图约会生成器', '角色资料+地域判断', charactersInfo, tokenCount);
        }

        // 🔧 11. 角色关系网络（如果有）
        const relationshipsInfo = await StringBuilders.buildCharacterRelationships(
          boundCharacters,
          currentAccountId || 'main',
        );
        if (relationshipsInfo) {
          systemPrompt += relationshipsInfo;
          tokenCount = TokenUtils.logTokenUsage('地图约会生成器', '角色关系网络', relationshipsInfo, tokenCount);
          console.log('💞 已加载角色关系网络信息');
        }

        // 🔧 12. 用户资料约束（通用约束）
        const userConstraintsStart = systemPrompt.length;
        systemPrompt += StringBuilders.buildUniversalConstraints(userXProfileInfo);
        const userConstraints = systemPrompt.substring(userConstraintsStart);
        tokenCount = TokenUtils.logTokenUsage('地图约会生成器', '用户资料约束', userConstraints, tokenCount);

        // 🔧 13. 天气决策提示（如果需要AI决定天气）
        if (shouldAIDecideWeather && existingWeather) {
          const weatherInfo = this.weatherTypes[existingWeather];
          systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🌤️ 天气更新决策（重要！）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ **系统检测到距离天气刷新基准时间已过去${hoursSinceWeatherRefresh.toFixed(1)}小时（≥12小时），需要你根据天气规律决定当前天气**

【上次天气状态】：
- 天气类型：${weatherInfo.icon} ${weatherInfo.name}（${existingWeather}）
- 经过时间：${hoursSinceWeatherRefresh.toFixed(1)}小时

【天气决策规则】：
⏰ **根据时间推移和天气规律，合理决定新天气**

1. **天气连续性原则**（优先考虑）：
   - 晴天 → 12小时后：60%继续晴天，30%转多云，10%转其他
   - 多云 → 12小时后：40%继续多云，30%转晴，20%转雨，10%转其他
   - 小雨 → 12小时后：30%继续下雨，40%雨停转多云，20%转晴，10%转其他
   - 暴雨 → 12小时后：20%继续暴雨，50%转小雨，20%转多云，10%转晴
   - 雷暴 → 12小时后：10%继续雷暴，40%转小雨，30%转多云，20%转晴
   - 下雪 → 12小时后：40%继续下雪，30%雪停转多云，20%转晴，10%转雨
   - 雾霾 → 12小时后：50%继续雾霾，30%散去转多云，20%转晴
   - 沙尘 → 12小时后：40%继续沙尘，40%散去转多云，20%转晴

2. **时间因素**：
   - 如果经过时间较短（12-18小时），天气变化应该较小，倾向保持或微变
   - 如果经过时间较长（18-24小时以上），天气变化可以较大

3. **季节常识**（如果世界观有季节设定）：
   - 夏季：更容易出现雷暴、暴雨
   - 冬季：更容易出现雨雪、雾霾
   - 春秋：天气变化较频繁

4. **可用天气类型**（你必须从以下类型中选择）：
   - "sunny"（晴天）- ☀️
   - "cloudy"（多云）- ☁️
   - "rain"（小雨）- 🌧️
   - "heavy-rain"（暴雨）- ⛈️
   - "thunder"（雷暴）- ⚡
   - "snow"（下雪）- ❄️
   - "fog"（雾霾）- 🌫️
   - "dust"（沙尘）- 🌪️

【返回格式要求】：
${
  onlyUsers
    ? `- 在JSON的nearbyUsers同级添加 "weather" 字段
- 格式：{
    "nearbyUsers": [...],
    "weather": "你决定的天气类型字符串（从上面8个类型中选择）"
  }`
    : `- 在JSON的mapConfig同级添加 "weather" 字段
- 格式：{
    "mapConfig": {...},
    "weather": "你决定的天气类型字符串（从上面8个类型中选择）",
    "landmarks": [...],
    "nearbyUsers": [...]
  }`
}

⚠️ **重要**：你必须决定新天气，不能省略weather字段！请根据上述规则，考虑天气连续性和时间推移，做出合理决策！
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        }
        } // 结束 if (!onlyLandmarks) - 角色资料、关系网络、用户约束、天气决策部分

        // 🔧 13.5. 咩三三城市报纸生成提示词（只在非onlyUsers模式）
        let shouldGenerateNewspaper = false;
        if (!onlyUsers) {
          // 检查12小时内的生成次数限制
          const now = Date.now();
          const twelveHoursMs = 12 * 60 * 60 * 1000; // 12小时的毫秒数

          // 读取生成历史
          let generateHistory = [];
          try {
            const historyStr = localStorage.getItem('newspaperGenerateHistory');
            if (historyStr) {
              generateHistory = JSON.parse(historyStr);
            }
          } catch (error) {
            console.error('❌ [咩三三报纸] 读取生成历史失败:', error);
            generateHistory = [];
          }

          // 清理12小时之前的记录
          generateHistory = generateHistory.filter(timestamp => (now - timestamp) < twelveHoursMs);

          // 检查是否可以生成
          if (generateHistory.length < 2) {
            shouldGenerateNewspaper = true;
            console.log(`✅ [咩三三报纸] 12小时内已生成 ${generateHistory.length} 次，允许再次生成`);
          } else {
            shouldGenerateNewspaper = false;
            const oldestTimestamp = Math.min(...generateHistory);
            const waitMinutes = Math.ceil((twelveHoursMs - (now - oldestTimestamp)) / 60000);
            console.warn(`⚠️ [咩三三报纸] 12小时内已生成 ${generateHistory.length} 次，达到上限。需等待 ${waitMinutes} 分钟后才能再次生成`);
          }

          // 保存清理后的历史记录
          try {
            localStorage.setItem('newspaperGenerateHistory', JSON.stringify(generateHistory));
          } catch (error) {
            console.error('❌ [咩三三报纸] 保存生成历史失败:', error);
          }
        }

        if (!onlyUsers && shouldGenerateNewspaper) {
          const newspaperPrompt = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🐑 咩三三城市报纸数据生成任务
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
除了生成地图约会数据外，你还需要生成一份由"咩三三"播报的城市报纸数据。

【角色设定：咩三三】
- 名字：咩三三（Mie333）
- 身份：城市报纸的新闻/天气播报员
- 性格特征：
  * 说话习惯第三人称（"咩三三认为..."、"咩三三发现..."）
  * 喜欢使用表情符号增添可爱感（✨😊🌟💫等）
  * 正义感驱动：看到不公会义愤填膺，热心报道真相
  * 自利性格：也会考虑自己的利益和安全，不会完全无私
  * 播报风格：专业但不失可爱，严肃中带点俏皮

【报纸数据结构要求】
生成结构化的JSON数据，系统会用模板渲染。

## 1. 天气数据（weather）
- **重要**：天气图标和类型必须与当前地图天气（${mapWeatherInfo?.icon || '☀️'} ${mapWeatherInfo?.name || '晴天'}）保持一致！
- 包含字段：
  * icon: 天气图标（必须使用 ${mapWeatherInfo?.icon || '☀️'}）
  * temp: 温度字符串（如"18°C"，根据季节和天气类型合理生成）
  * desc: 天气英文描述（大写，如"TODAY · SUNNY"）

## 2. 重大新闻数组（news，1-2条）
- 新闻内容必须符合世界观设定和世界运转大事件（如果有）
- 可以是积极的（新店开业、节日庆典）或负面的（事故、犯罪）
- 每条新闻包含字段：
  * headline: 新闻标题（简洁有力）
  * location: 地点（英文大写，如"DOWNTOWN"）
  * time: 发生时间（如"2H AGO", "30MIN AGO"）
  * body: 新闻正文（3-5句话，咩三三第三人称播报风格，带表情符号）
  * comment: 咩三三的个人评论（1句话，可用颜文字如(￣ー￣)，体现真实想法）

## 3. 咩三三的真实想法（bubble，可选）
- 一句话吐槽或真心话，前缀"✧"（如"✧ 咩三三的真实想法：不如去便利店买罐装咖啡实在！"）

## 4. 公众投稿数组（submissions，3-4条）
- 类型分布：寻人/寻宠启事30%，任务悬赏/求助30%，市民故事/分享20%，投诉/建议20%
- 可以结合世界观和当前地图的地标
- 每条投稿包含字段：
  * tag: 类型标签（"MISSING", "TASK", "STORY", "COMPLAINT"之一）
  * title: 投稿标题（简短）
  * content: 投稿内容（2-3行，口语化，真实感，可含咩三三的点评）

## 5. 赞助商广告数组（ads，1-2条）
- 广告内容应该创意、有趣
- 可以是虚构的商家或基于地标的真实商家
- 每条广告包含字段：
  * title: 广告标题
  * text: 广告文案（2-3句话，可含咩三三的俏皮推荐，可用颜文字）

【newspaper字段JSON格式示例】
\`\`\`json
{
  "weather": {
    "icon": "${mapWeatherInfo?.icon || '☀️'}",
    "temp": "18°C",
    "desc": "TODAY · ${(mapWeatherInfo?.name || 'SUNNY').toUpperCase()}"
  },
  "news": [
    {
      "headline": "市中心星巴克咖啡盛大开业",
      "location": "DOWNTOWN",
      "time": "2H AGO",
      "body": "咩三三我今天路过市中心商业街，发现那边新开了家星巴克。门口排了好长的队，都是冲着开业优惠去的。😊",
      "comment": "(￣ー￣) 咩三三觉得这种开业活动就是套路..."
    }
  ],
  "bubble": "✧ 咩三三的真实想法：不如去便利店买罐装咖啡实在！",
  "submissions": [
    {
      "tag": "MISSING",
      "title": "寻找走失的金毛犬",
      "content": "昨晚在公园走失，红色项圈，请联系138****5678。重谢！"
    },
    {
      "tag": "COMPLAINT",
      "title": "楼上邻居深夜扰民",
      "content": "301室每晚12点后蹦迪！咩三三：直接找物业。(눈_눈)"
    }
  ],
  "ads": [
    {
      "title": "咩三三的杂货铺",
      "text": "各种稀奇古怪的小玩意儿都有卖！价格公道童叟无欺。地址：商业街99号 | 营业时间：看心情 (￣y▽￣)╭"
    }
  ]
}
\`\`\`

**重要规则**：
1. 天气icon和desc必须与当前地图天气（${mapWeatherInfo?.icon || '☀️'} ${mapWeatherInfo?.name || '晴天'}）一致
2. 新闻内容必须符合世界观和世界大事件（如果有）
3. 咩三三的语气要保持一致（第三人称+表情符号+颜文字）
4. 公众投稿要多样化，类型分布合理
5. 所有文本内容都是纯文本，不要包含HTML标签
6. newspaper字段返回结构化的JSON对象，不是HTML字符串

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          systemPrompt += newspaperPrompt;
          tokenCount = TokenUtils.logTokenUsage('地图约会生成器', '咩三三报纸生成提示词', newspaperPrompt, tokenCount);
          console.log('🐑 [地图约会生成器] 已注入咩三三城市报纸生成提示词');
        }

        // 🔧 14. JSON返回格式要求
        if (onlyLandmarks) {
          // 只生成地标时，JSON格式已在之前定义，跳过
        } else if (onlyUsers) {
          systemPrompt += `
【JSON返回格式】：
\`\`\`json
{
  "nearbyUsers": [
    {`;
        } else {
          systemPrompt += `
【JSON返回格式】：
\`\`\`json
{
  "mapConfig": {
    "waterRatio": 数字,
    "buildingDensity": 数字,
    "parkCount": 整数,
    "roadWidth": 整数
  },
  "landmarks": [
    {
      "id": "字符串",
      "name": "字符串",
      "icon": "emoji",
      "color": "#十六进制"
      // 约80%地标无event字段
    },
    {
      "id": "字符串",
      "name": "字符串",
      "icon": "emoji",
      "color": "#十六进制",
      "event": {
        "eventType": "事件类型字符串",
        "accentColor": "#十六进制（深蓝/深红/深绿/紫色/深灰）",
        "eventHTML": "完整的事件HTML字符串（必须严格遵循前面的HTML生成规范）"
      }
      // 约20%地标有event字段
    }
  ],
  "nearbyUsers": [
    {`;
        }

        // 继续添加通用的 nearbyUsers 字段说明（只在不是只生成地标时）
        if (!onlyLandmarks) {
          systemPrompt += `
      "nickname": "字符串",
      "handle": "字符串（纯英文小写+数字+下划线）",
      "avatarBubble": "emoji或颜文字",
      "gender": "male/female/unisex",
      "distance": 小数,
      "online": 布尔值,
      "status": "字符串",
      "bio": "多行字符串（用\\n分隔，第一行格式：年龄 | 感情状态）",
      "publicPersonality": ["关键词1", "关键词2", "..."],
      "realPersonality": ["关键词1", "关键词2", "..."],
      "appearance": ["关键词1", "关键词2", "..."],
      "secret": "字符串（可选，秘密）",
      "tags": ["字符串"],
      "followers": 整数,
      "likes": 整数,
      "avgRating": 小数,
      "reviews": [
        {
          "reviewerName": "字符串",
          "rating": 小数,
          "content": "字符串",
          "reply": "字符串（可选）",
          "likes": 整数,
          "comments": 整数,
          "timestamp": "ISO字符串",
          "isAnonymous": 布尔值
        }
      ]
    }
  ],
  "notifications": [
    {
      "type": "interested",
      "fromUser": {
        "nickname": "字符串",
        "handle": "字符串",
        "avatarBubble": "emoji",
        "gender": "male/female/unisex",
        "distance": 小数（5-50km）,
        "online": 布尔值,
        "status": "字符串",
        "bio": "多行字符串",
        "publicPersonality": ["关键词"],
        "realPersonality": ["关键词"],
        "appearance": ["关键词"],
        "tags": ["字符串"],
        "followers": 整数,
        "likes": 整数,
        "avgRating": 小数,
        "reviews": []
      },
      "content": "字符串（10-30字兴趣表达）"
    },
    {
      "type": "message",
      "fromUser": {
        "nickname": "字符串",
        "handle": "字符串",
        "avatarBubble": "emoji",
        "gender": "male/female/unisex",
        "distance": 小数（5-50km）,
        "online": 布尔值,
        "status": "字符串",
        "bio": "多行字符串",
        "publicPersonality": ["关键词"],
        "realPersonality": ["关键词"],
        "appearance": ["关键词"],
        "tags": ["字符串"],
        "followers": 整数,
        "likes": 整数,
        "avgRating": 小数,
        "reviews": []
      },
      "messages": ["字符串1（第1条私信）", "字符串2（第2条私信，可选）", "字符串3（第3条私信，可选）"]
    }
  ],
  "newspaper": {
    "weather": { "icon": "☀", "temp": "18°C", "desc": "TODAY · SUNNY" },
    "news": [ { "headline": "...", "location": "...", "time": "...", "body": "...", "comment": "..." } ],
    "bubble": "✧ ...",
    "submissions": [ { "tag": "MISSING", "title": "...", "content": "..." } ],
    "ads": [ { "title": "...", "text": "..." } ]
  }
}
\`\`\`

关键规则：
1. online字段必须是布尔值(true/false)，不能用字符串
2. gender必须是 "male"、"female" 或 "unisex" 之一
3. 所有数字必须是纯数字，不带引号`;

        // 动态计算规则序号
        let ruleNumber = 4;

        if (!onlyUsers) {
          systemPrompt += `
${ruleNumber}. **landmarks不需要生成x、y坐标**（系统自动分配）`;
          ruleNumber++;
        }

        if (!onlyUsers && shouldGenerateNewspaper) {
          systemPrompt += `
${ruleNumber}. **newspaper字段是必须的**，包含结构化的报纸数据对象（非HTML字符串），包含weather/news/bubble/submissions/ads字段`;
          ruleNumber++;
        }

        systemPrompt += `
${ruleNumber}. **nearbyUsers不需要生成avatar、id、position**（系统自动处理）
${ruleNumber + 1}. 可选字段不使用时完全省略，不要设为null
${ruleNumber + 2}. **bio字段必须使用\\n分隔多行**，第一行格式："年龄 | 感情状态"，例如："24岁 | 单身\\n热爱旅行和摄影\\n周末常去咖啡馆"
${ruleNumber + 3}. **handle字段必须符合Instagram用户名规范**：纯英文小写+数字+下划线，5-15个字符，例如："lihua_dev"、"xiaoming2024"
${ruleNumber + 4}. **avatarBubble字段必须是单个emoji或1-2个颜文字**，表达个性或心情
${ruleNumber + 5}. **followers和likes必须是合理的数字**：followers为100-50000，likes为followers的10-50倍
${ruleNumber + 6}. **avgRating可选字段**：0-5小数（保留1位），0表示无评价，有评价时范围3.0-5.0
${ruleNumber + 7}. **reviews可选字段**：数组长度0-8，评价内容应真实反映约会体验（赞美、警告、投诉等）
${ruleNumber + 8}. **reviews不需要生成reviewerAvatar字段**（系统自动从头像库随机分配）
${ruleNumber + 9}. **isAnonymous约30%概率为true**，匿名时reviewerName应为"匿名用户"
${ruleNumber + 10}. **timestamp应在最近1-30天内**，格式："2024-01-15T10:30:00Z"
${ruleNumber + 11}. **publicPersonality必填**：数组，10-15个关键词，描述网络上表现出来的性格（可以是正面的、积极的）
${ruleNumber + 12}. **realPersonality必填**：数组，10-15个关键词，描述真实内在性格（可以是负面的、复杂的、矛盾的）
${ruleNumber + 13}. **publicPersonality和realPersonality可以相同**（表里如一）或完全不同（双面性），要真实反映人性多面性
${ruleNumber + 14}. **appearance必填**：数组，10-15个关键词，描述外貌身材特征（发色、眼睛、身高体重、三围、配饰、体型、脸型、五官等）
${ruleNumber + 15}. **notifications可选字段**：30-50%概率生成0-3条提醒，50-70%概率返回空数组[]
${ruleNumber + 16}. **notifications中的fromUser**是完整的用户对象，必须包含所有字段（nickname, handle, avatarBubble, gender, distance, online, status, bio, publicPersonality, realPersonality, appearance, tags, followers, likes, avgRating, reviews），distance可以较大（5-50km），可以来自其他城市/国家，不需要生成avatar/id/position字段
${ruleNumber + 17}. **notifications不需要生成id、timestamp、isRead字段**（系统自动生成）
${ruleNumber + 18}. **notifications的type字段**必须是"interested"或"message"之一
${ruleNumber + 19}. **interested类型**：必须有content字段（10-30字兴趣表达），不需要messages字段
${ruleNumber + 20}. **message类型**：必须有messages数组字段（1-3条私信内容），不需要content字段
${ruleNumber + 21}. **messages数组**：message类型专用，包含1-3个字符串，每个字符串15-50字，代表对方发送的私信
${ruleNumber + 22}. **secret可选字段**：30-40%概率生成，描述用户隐藏的秘密，增加人设多样性和戏剧性
   - 生成概率：30-40%的用户有秘密，60-70%没有
   - 秘密类型示例（但不限于此）：
     * 感情状态造假："简介写单身，实际已婚有娃"、"说在恋爱中，实际刚分手"
     * 性别造假："资料显示男生，实际是女生"、"头像是女生，实际是男生"
     * 年龄造假："实际年龄比简介大10岁"、"未成年人假装成年"
     * 职业造假："说是医生，实际是销售"、"失业却说在创业"
     * 外貌造假："头像P图严重"、"用的是明星照片"
     * 身份造假："冒充富二代"、"谎称海归"
     * 目的不纯："只想约炮不想恋爱"、"骗钱专业户"、"多人交往"
     * 其他社交场景常见的抓马情况
   - 格式：简短描述（15-50字），不要写成完整句子，直接描述矛盾点
   - 示例："说单身实际已婚有两个孩子"、"头像是女生本人是男生"、"年龄造假大了15岁"
   - 重要：秘密应该戏剧化、有冲突性，能引发故事发展
   - 如果不生成秘密，完全省略该字段，不要写null或空字符串
`;
        } // 结束 if (!onlyLandmarks) - nearbyUsers字段说明部分

        const formatSection = systemPrompt.substring(systemPrompt.lastIndexOf('【JSON返回格式】'));
        tokenCount = TokenUtils.logTokenUsage('地图约会生成器', 'JSON格式要求', formatSection, tokenCount);

        // 🔧 15. 构建消息并记录最终提示词
        let userMessage = '';
        if (onlyLandmarks) {
          // 只生成地标时，使用用户自定义要求
          userMessage = customRequirements
            ? `请根据以下要求生成地标数据：${customRequirements}`
            : '请根据世界观生成地标数据';
        } else if (onlyUsers) {
          // 只刷新用户
          userMessage = '请根据世界观、世界书和大事件生成新的附近的人数据';
        } else {
          // 完整生成
          userMessage = '请根据世界观、世界书和大事件生成完整的地图约会数据';
        }
        const messages = [{ role: 'user', content: userMessage }];

        // 最终统计
        TokenUtils.logFinalPrompt('地图约会生成器', systemPrompt, messages[0].content);

        // 🔧 16. 使用统一的AI请求工具
        console.log('🚀 [API请求] 开始发送AI请求，请等待响应...');
        console.log(`  |- 模式: ${onlyLandmarks ? '仅生成地标' : onlyUsers ? '仅刷新用户' : '完整生成'}`);
        console.log(`  |- 用户消息: ${userMessage}`);
        console.log(`  |- 温度参数: 0.8`);
        const requestStartTime = Date.now();
        const aiResponseContent = await APIUtils.sendAIRequest({
          apiConfig,
          systemPrompt,
          messages,
          temperature: 0.8,
        });
        const requestDuration = ((Date.now() - requestStartTime) / 1000).toFixed(2);
        console.log(`✅ [API响应] AI请求完成，耗时 ${requestDuration} 秒`);
        console.log(`  |- 响应长度: ${aiResponseContent?.length || 0} 字符`);

        // 🔧 17. 使用统一的JSON解析工具
        console.log('🔍 [JSON解析] 开始解析AI返回的JSON数据...');
        let generatedData = APIUtils.parseJSONResponse(aiResponseContent);
        console.log('✅ [JSON解析] JSON解析完成');

        // 🔧 18. 使用统一的后处理工具（虽然地图约会数据可能不需要太多后处理）
        generatedData = await APIUtils.postProcessData(generatedData, userXProfileInfo);

        // 🔧 18.3. 提取并保存报纸数据（只在非onlyUsers模式）
        if (!onlyUsers && generatedData.newspaper) {
          console.log('🐑 [咩三三报纸] 检测到AI生成的报纸数据（JSON对象），开始保存');
          try {
            // 保存报纸JSON数据到localStorage
            const newspaperDataStr = JSON.stringify(generatedData.newspaper);
            localStorage.setItem('newspaperCachedData', newspaperDataStr);
            console.log(`✅ [咩三三报纸] 报纸数据已保存到localStorage，长度: ${newspaperDataStr.length} 字符`);

            // 更新生成历史记录（添加当前时间戳）
            let generateHistory = [];
            try {
              const historyStr = localStorage.getItem('newspaperGenerateHistory');
              if (historyStr) {
                generateHistory = JSON.parse(historyStr);
              }
            } catch (error) {
              console.error('❌ [咩三三报纸] 读取生成历史失败:', error);
              generateHistory = [];
            }

            // 添加当前时间戳
            generateHistory.push(Date.now());

            // 保存更新后的历史记录
            localStorage.setItem('newspaperGenerateHistory', JSON.stringify(generateHistory));
            console.log(`✅ [咩三三报纸] 生成历史已更新，当前12小时内生成次数: ${generateHistory.length}`);
          } catch (error) {
            console.error('❌ [咩三三报纸] 保存报纸数据失败:', error);
          }
        } else if (!onlyUsers) {
          console.warn('⚠️ [咩三三报纸] AI未返回报纸数据（newspaper字段缺失）');
        }

        // 🔧 18.5. 如果只刷新用户，合并原有的地图配置和地标
        if (onlyUsers) {
          // 验证只生成了用户数据
          if (!generatedData.nearbyUsers) {
            throw new Error('AI返回的数据格式不完整，缺少 nearbyUsers 字段');
          }
          // 合并原有数据
          generatedData.mapConfig = existingMapConfig;
          generatedData.landmarks = existingLandmarks;

          // 🌤️ 处理天气字段：AI决定 > 原天气 > 随机生成
          if (generatedData.weather) {
            // AI返回了weather字段，使用AI决定的天气
            console.log(`🌤️ [天气更新] AI决定新天气: ${generatedData.weather}`);
            weatherWasRefreshed = true; // 天气被AI刷新了
          } else if (existingWeather) {
            // AI没返回weather，但有原天气，使用原天气
            generatedData.weather = existingWeather;
            console.log(`🌤️ [天气保留] 使用原天气: ${existingWeather}`);
            weatherWasRefreshed = false; // 保留原天气，未刷新
          } else {
            // 没有原天气，随机生成
            generatedData.weather = this.getRandomWeather();
            console.log(`🌤️ [天气生成] 随机生成天气: ${generatedData.weather}`);
            weatherWasRefreshed = true; // 首次生成天气也算刷新
          }

          console.log('✅ [第十五个情景] AI生成新用户数据验证通过，已合并原有地图配置和地标');
        } else if (onlyLandmarks) {
          // 只生成地标模式
          // 验证只生成了地标数据
          if (!generatedData.landmarks || !Array.isArray(generatedData.landmarks)) {
            throw new Error('AI返回的数据格式不完整，缺少 landmarks 字段或格式错误');
          }

          console.log(`✅ [第十五个情景] AI生成了 ${generatedData.landmarks.length} 个地标`);

          // 为地标添加随机坐标（x, y）
          generatedData.landmarks.forEach(landmark => {
            landmark.x = Math.floor(Math.random() * 1800) + 100; // 100-1900范围
            landmark.y = Math.floor(Math.random() * 1800) + 100; // 100-1900范围
          });

          // 将生成的地标添加到自定义地标数组
          this.customLandmarks.push(...generatedData.landmarks);

          // 保存到localStorage（按账户隔离）
          const accountId = window.currentAccountId || 'main';
          localStorage.setItem(`xMapCustomLandmarks_${accountId}`, JSON.stringify(this.customLandmarks));

          console.log(`📍 [地标管理] 成功生成并保存了 ${generatedData.landmarks.length} 个地标到账户${accountId}`);

          // 只生成地标时，直接返回，不需要保存到数据库
          return;
        } else {
          // 验证完整数据格式
          if (!generatedData.mapConfig || !generatedData.landmarks || !generatedData.nearbyUsers) {
            throw new Error('AI返回的数据格式不完整，缺少必要字段');
          }
          console.log('✅ [第十五个情景] AI生成数据验证通过');

          // 为地标添加随机坐标（x, y）- 只在完整生成时处理
          if (generatedData.landmarks) {
            generatedData.landmarks.forEach(landmark => {
              landmark.x = Math.floor(Math.random() * 1800) + 100; // 100-1900范围
              landmark.y = Math.floor(Math.random() * 1800) + 100; // 100-1900范围
            });
          }

          // 🌤️ 完整生成时，一定生成了新天气（即使没有天气字段也会后续随机生成）
          weatherWasRefreshed = true;
          console.log('🌤️ [完整生成] 标记天气为已刷新（将在后续生成或使用随机天气）');
        }

        // 为附近的人添加avatar、id、position
        if (generatedData.nearbyUsers) {
          generatedData.nearbyUsers.forEach((user, index) => {
            // 1. 从头像库随机选择头像（使用AI生成的gender字段）
            const gender = user.gender || 'unisex';
            user.avatar = this.getRandomAvatar(gender);

            // 2. 添加唯一ID（使用时间戳+随机数+索引避免冲突）
            user.id = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}_${index}`;

            // 3. 根据distance计算position
            // distance越远，position离中心(50%, 50%)越远
            const distance = user.distance || 1.0;
            const maxDistance = 6.0; // 最大距离
            const distanceRatio = Math.min(distance / maxDistance, 1); // 0-1范围

            // 生成随机角度
            const angle = Math.random() * 2 * Math.PI;

            // 计算位置偏移（距离中心的百分比，15%-40%范围）
            const offset = 15 + distanceRatio * 25; // 距离越远，偏移越大

            // 根据角度和偏移计算position
            const centerX = 50;
            const centerY = 50;
            const posX = centerX + offset * Math.cos(angle);
            const posY = centerY + offset * Math.sin(angle);

            // 限制在10%-90%范围内
            user.position = {
              top: `${Math.max(10, Math.min(90, posY)).toFixed(1)}%`,
              left: `${Math.max(10, Math.min(90, posX)).toFixed(1)}%`,
            };

            // 4. 为评论者分配随机头像（如果有reviews）
            if (user.reviews && Array.isArray(user.reviews)) {
              user.reviews.forEach(review => {
                // 随机选择性别来决定头像（评论者性别不一定和被评价者相同）
                const reviewerGender = ['male', 'female', 'unisex'][Math.floor(Math.random() * 3)];
                review.reviewerAvatar = this.getRandomAvatar(reviewerGender);
              });
            }
          });
        }

        // 🔔 处理提醒数据（notifications）
        if (generatedData.notifications && Array.isArray(generatedData.notifications)) {
          console.log(`🔔 [提醒处理] 开始处理 ${generatedData.notifications.length} 条提醒`);

          // 为每个notification中的fromUser添加avatar、id、position
          generatedData.notifications.forEach((notification, notifIndex) => {
            if (notification.fromUser) {
              const fromUser = notification.fromUser;

              // 1. 从头像库随机选择头像
              const gender = fromUser.gender || 'unisex';
              fromUser.avatar = this.getRandomAvatar(gender);

              // 2. 添加唯一ID（使用时间戳+随机数+索引避免冲突）
              fromUser.id = `notif_user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}_${notifIndex}`;

              // 3. 根据distance计算position（与nearbyUsers相同逻辑）
              const distance = fromUser.distance || 3.0;
              const maxDistance = 20.0; // 提醒用户的最大距离
              const distanceRatio = Math.min(distance / maxDistance, 1);

              const angle = Math.random() * 2 * Math.PI;
              const offset = 15 + distanceRatio * 25;

              const centerX = 50;
              const centerY = 50;
              const posX = centerX + offset * Math.cos(angle);
              const posY = centerY + offset * Math.sin(angle);

              fromUser.position = {
                top: `${Math.max(10, Math.min(90, posY)).toFixed(1)}%`,
                left: `${Math.max(10, Math.min(90, posX)).toFixed(1)}%`,
              };

              // 4. 为fromUser的评论者分配随机头像（如果有reviews）
              if (fromUser.reviews && Array.isArray(fromUser.reviews)) {
                fromUser.reviews.forEach(review => {
                  const reviewerGender = ['male', 'female', 'unisex'][Math.floor(Math.random() * 3)];
                  review.reviewerAvatar = this.getRandomAvatar(reviewerGender);
                });
              }
            }

            // 5. 为notification添加id、timestamp、isRead字段
            notification.id = `notif-${Date.now()}-${Math.random().toString(36).substr(2, 9)}-${notifIndex}`;
            notification.timestamp = new Date().toISOString();
            notification.isRead = false;
          });

          // 6. 将notifications保存到localStorage（覆盖旧的提醒）
          try {
            localStorage.setItem('xMapNotifications', JSON.stringify(generatedData.notifications));
            console.log(`✅ [提醒处理] ${generatedData.notifications.length} 条提醒已保存到localStorage`);

            // 7. 更新提醒徽章
            this.updateNotificationBadge();
            console.log(`✅ [提醒处理] 提醒徽章已更新`);
          } catch (error) {
            console.error('❌ [提醒处理] 保存提醒到localStorage失败:', error);
          }
        } else {
          console.log('🔔 [提醒处理] 本次生成无提醒数据');
          // 即使没有生成新提醒，也要确保notifications字段存在（空数组）
          generatedData.notifications = [];
        }

        // 🌤️ 将天气信息添加到生成数据中
        generatedData.weather = mapWeatherType;

        // 保存到数据库（使用正确的ID格式 - 不带x前缀）
        const dataId = `mapDatingData_${currentAccountId || 'main'}`;

        if (onlyUsers) {
          // 只刷新用户时，保留原有的 lastGenerated，只更新 lastUpdated
          console.log('💾 [数据库保存] 开始保存刷新后的用户数据到数据库...');
          const existingRecord = await xDb.xMapDatingData.get(dataId);

          // 🌤️ 计算新的天气刷新时间
          let newLastWeatherRefreshTime = existingRecord?.lastWeatherRefreshTime || null;
          if (weatherWasRefreshed) {
            newLastWeatherRefreshTime = new Date().toISOString();
            console.log(`🌤️ [天气刷新] 更新天气刷新时间: ${new Date(newLastWeatherRefreshTime).toLocaleString('zh-CN')}`);
          }

          await xDb.xMapDatingData.put({
            id: dataId,
            accountId: currentAccountId || 'main',
            data: generatedData,
            lastGenerated: existingRecord?.lastGenerated || new Date().toISOString(),
            lastUpdated: new Date().toISOString(),
            firstMapEnterTime: existingRecord?.firstMapEnterTime || firstMapEnterTime || new Date().toISOString(),
            lastWeatherRefreshTime: newLastWeatherRefreshTime,
          });
          console.log('✅✅ [数据库保存] 附近的人刷新完成并已保存到数据库');
          console.log(`  |- 数据ID: ${dataId}`);
          console.log(`  |- 天气类型: ${mapWeatherInfo.icon} ${mapWeatherInfo.name} (保持不变)`);
          console.log(`  |- 附近的人: ${generatedData.nearbyUsers.length} 人 (已更新)`);
          console.log(`  |- 保存时间: ${new Date().toLocaleString()}`);
        } else {
          // 完整生成时，更新所有时间戳
          console.log('💾 [数据库保存] 开始保存完整地图数据到数据库...');
          const nowISO = new Date().toISOString();
          await xDb.xMapDatingData.put({
            id: dataId,
            accountId: currentAccountId || 'main',
            data: generatedData,
            lastGenerated: nowISO,
            lastUpdated: nowISO,
            firstMapEnterTime: nowISO, // 完整生成时，重置首次进入时间
            lastWeatherRefreshTime: nowISO, // 完整生成时，重置天气刷新时间
          });
          console.log('✅✅ [数据库保存] 地图约会数据生成完成并已保存到数据库');
          console.log(`  |- 数据ID: ${dataId}`);
          console.log(`  |- 地图配置: ${JSON.stringify(generatedData.mapConfig)}`);
          console.log(`  |- 天气类型: ${mapWeatherInfo.icon} ${mapWeatherInfo.name}`);
          console.log(`  |- 地标数量: ${generatedData.landmarks.length}`);
          console.log(`  |- 附近的人: ${generatedData.nearbyUsers.length} 人`);
          console.log(`  |- 保存时间: ${new Date().toLocaleString()}`);
        }

        console.log('🎉 [生成器返回] generateMapDatingData 即将返回数据给调用方');
        return generatedData;
      } catch (error) {
        console.error('❌ [第十五个情景] 地图约会数据生成失败:', error);
        return null;
      }
    },
    // ▲▲▲ 【第十五个情景】地图约会数据AI生成器 ▲▲▲

    // 初始化地图约会模块
    async init() {
      try {
        console.log('🔧 [地图约会] 初始化开始...');

        // 🔧 加载自定义头像
        this.loadCustomAvatars();

        // 📍 初始化地标管理功能
        this.initLandmarkManagement();

        // 🎯 初始化真实度系统
        this.initAuthenticityScore();

        // 🚨 初始化被举报计数系统
        this.initReportedCountSystem();

        // 🚫 检查封禁状态
        const banStatus = this.checkMapBanStatus();
        if (banStatus.isBanned) {
          console.log(`🚫 [封禁系统] 用户被封禁，显示提示并阻止使用地图`);
          this.showMapBanNotice(banStatus);
          return; // 阻止继续初始化
        }

        // 尝试从数据库加载数据
        // 合并后所有模块都在同一个IIFE作用域内，直接访问 getXDB
        const xDb = getXDB();
        console.log('🔧 [地图约会] xDb状态:', xDb ? '已获取' : '获取失败');

        let mapData = null;

        if (xDb) {
          // 使用正确的ID格式读取数据（不带x前缀）
          const dataId = `mapDatingData_${currentAccountId || 'main'}`;
          console.log('🔧 [地图约会] 尝试读取数据，ID:', dataId);

          const savedData = await xDb.xMapDatingData.get(dataId);
          console.log('🔧 [地图约会] 数据库查询结果:', savedData ? '找到数据' : '未找到数据');

          if (savedData && savedData.data) {
            console.log('📖 [第十五个情景] 从数据库加载已保存的地图约会数据');
            console.log(`  |- 地标数量: ${savedData.data.landmarks?.length || 0}`);
            console.log(`  |- 附近的人: ${savedData.data.nearbyUsers?.length || 0}`);
            mapData = savedData.data;
          } else {
            console.log('🆕 [第十五个情景] 首次使用，调用AI生成数据');
            mapData = await this.generateMapDatingData();
            console.log('🔧 [地图约会] AI生成返回结果:', mapData ? '成功' : '失败');
          }
        } else {
          console.warn('⚠️ [地图约会] 无法获取数据库，跳过AI生成');
        }

        // 使用AI生成的数据或默认数据
        if (mapData) {
          console.log('🔧 [地图约会] 开始应用AI生成的数据...');

          // 使用AI生成的附近的人数据
          if (mapData.nearbyUsers && mapData.nearbyUsers.length > 0) {
            this.allUsers = mapData.nearbyUsers; // 设置完整数据源
            this.currentUsers = [...mapData.nearbyUsers]; // 设置当前显示列表
            console.log(`✅ [地图约会] 已设置附近的人: ${mapData.nearbyUsers.length}人`);
          } else {
            this.allUsers = [...this.mockUsers];
            this.currentUsers = [...this.mockUsers];
            console.log('⚠️ [地图约会] AI数据中没有附近的人，使用默认数据');
          }

          // 使用AI生成的地图配置
          if (mapData.mapConfig) {
            MapGenerator.config = { ...MapGenerator.config, ...mapData.mapConfig };
            console.log('✅ [地图约会] 已设置地图配置:', JSON.stringify(mapData.mapConfig));
          }

          // 使用AI生成的地标
          if (mapData.landmarks && mapData.landmarks.length > 0) {
            // 保存AI地标到this.aiLandmarks（分开存储）
            this.aiLandmarks = mapData.landmarks;
            MapGenerator.landmarks = mapData.landmarks;
            console.log(`✅ [地图约会] 已设置AI地标数据: ${mapData.landmarks.length}个`);
            console.log(
              '🔧 [地图约会] MapGenerator.landmarks前5个:',
              MapGenerator.landmarks.slice(0, 5).map(l => l.name),
            );
          } else {
            console.log('⚠️ [地图约会] AI数据中没有地标，将使用默认随机生成');
            this.aiLandmarks = []; // 没有AI地标
          }
        } else {
          console.log('⚠️ [地图约会] mapData为null，使用默认数据');
          // 使用默认数据
          this.allUsers = [...this.mockUsers];
          this.currentUsers = [...this.mockUsers];
        }

        // 渲染地图
        this.renderUserList();
        this.renderMapMarkers();

        // 📍 在MapGenerator.init()之前，合并AI地标和自定义地标（无论customLandmarks是否为空，都要合并）
        MapGenerator.landmarks = [...this.aiLandmarks, ...this.customLandmarks];

        console.log(`📍 [地图约会] 合并地标到MapGenerator:`, {
          AI地标: this.aiLandmarks.length,
          自定义地标: this.customLandmarks.length,
          总计: MapGenerator.landmarks.length,
        });

        // 初始化地图（如果MapGenerator.landmarks已有数据，不会重新生成默认地标）
        MapGenerator.init('mapCanvasBg');

        this.renderLandmarkLabels();
        this.initEventListeners();

        // 🔔 初始化提醒徽章
        this.updateNotificationBadge();
        console.log('✅ [地图约会] 提醒徽章已初始化');

        // ⚙️ 初始化主题设置
        this.initThemeSettings();
        console.log('✅ [地图约会] 主题设置已初始化');

        this.initMapDrag();
        this.initMapPosition();

        // 初始化天气系统（从保存的数据或随机生成）
        if (mapData && mapData.weather) {
          this.renderWeatherEffect(mapData.weather);
          console.log(`🌤️ [地图约会] 应用已保存的天气: ${mapData.weather}`);
        } else {
          // 没有保存的天气数据，随机生成
          const randomWeather = this.getRandomWeather();
          this.renderWeatherEffect(randomWeather);
          console.log(`🌤️ [地图约会] 随机生成天气: ${randomWeather}`);
        }

        // 3秒后隐藏滑动提示
        setTimeout(() => {
          const hint = document.getElementById('mapSwipeHint');
          if (hint) hint.classList.add('hidden');
        }, 3000);

        // 🚗 初始化城市乘车状态
        this.initRideMode();

        // 🚗 初始化等待司机功能
        this.initWaitingDriver();

        // 初始化用户地图资料
        await this.initUserMapProfile();
      } catch (error) {
        console.error('❌ [地图约会] 初始化失败:', error);
        // 失败时使用默认数据
        this.allUsers = [...this.mockUsers];
        this.currentUsers = [...this.mockUsers];
        this.renderUserList();
        this.renderMapMarkers();

        // 📍 失败时让init生成默认地标，然后合并自定义地标
        MapGenerator.init('mapCanvasBg');

        // 📍 失败时在init后合并自定义地标（无论customLandmarks是否为空，都要合并）
        // init生成的默认地标保存到aiLandmarks（失败时没有AI地标）
        this.aiLandmarks = MapGenerator.landmarks || [];

        // 合并：默认地标 + 自定义地标
        MapGenerator.landmarks = [...this.aiLandmarks, ...this.customLandmarks];
        console.log(`✅ [地图约会] 已合并地标:`, {
          默认地标: this.aiLandmarks.length,
          自定义地标: this.customLandmarks.length,
          总计: MapGenerator.landmarks.length,
        });

        // 重新绘制地标
        if (MapGenerator.ctx) {
          MapGenerator.drawLandmarks();
        }

        this.renderLandmarkLabels();
        this.initEventListeners();

        // ⚙️ 初始化主题设置（失败时也要初始化）
        this.initThemeSettings();

        // 🚗 初始化城市乘车状态
        this.initRideMode();

        // 🚗 初始化等待司机功能
        this.initWaitingDriver();

        this.initMapDrag();
        this.initMapPosition();

        // 失败时也初始化天气（随机）
        const randomWeather = this.getRandomWeather();
        this.renderWeatherEffect(randomWeather);
      }
    },

    // 初始化事件监听器
    initEventListeners() {
      // 侧边栏相关
      document.getElementById('mapSidebarOverlay')?.addEventListener('click', () => this.closeSidebar());
      document.getElementById('mapBackBtn')?.addEventListener('click', () => this.closeSidebar());
      document.getElementById('mapCloseBtn')?.addEventListener('click', () => this.closeMapPage());
      document.getElementById('mapRefreshBtn')?.addEventListener('click', () => this.refreshNearbyUsers());

      // 咩三三报纸相关
      document.getElementById('mapNewspaperBtn')?.addEventListener('click', () => this.openNewspaper());
      document.getElementById('newspaperCloseBtn')?.addEventListener('click', () => this.closeNewspaper());
      document.getElementById('newspaperOverlay')?.addEventListener('click', () => this.closeNewspaper());

      // 🚗 城市乘车相关
      document.getElementById('mapRideBtn')?.addEventListener('click', () => this.openRidePanel());
      document.getElementById('ridePanelOverlay')?.addEventListener('click', () => this.closeRidePanel());
      document.getElementById('rideDestinationBox')?.addEventListener('click', () => this.startSelectingDestination());

      // 乘车面板内的按钮事件
      const vehicleCards = document.querySelectorAll('.ride-vehicle-card');
      vehicleCards.forEach(card => {
        card.addEventListener('click', () => this.selectVehicle(card));
      });

      const paymentOptions = document.querySelectorAll('.ride-payment-option');
      paymentOptions.forEach(option => {
        option.addEventListener('click', () => this.selectPaymentOption(option));
      });

      document.getElementById('rideBookBtn')?.addEventListener('click', () => this.bookRide());

      // 搜索和筛选
      document.getElementById('mapSearchInput')?.addEventListener('input', e => this.filterUsers(e.target.value));
      document
        .getElementById('mapDistanceFilter')
        ?.addEventListener('change', e => this.filterByDistance(e.target.value));
      document.getElementById('mapGenderFilter')?.addEventListener('change', e => this.filterByGender(e.target.value));
      document.getElementById('mapApplyFilterBtn')?.addEventListener('click', () => this.applyFilters());

      // 🎯 指定筛选相关
      document.getElementById('mapAdvancedFilterBtn')?.addEventListener('click', () => this.openAdvancedFilterModal());
      document
        .getElementById('mapAdvancedFilterCloseBtn')
        ?.addEventListener('click', () => this.closeAdvancedFilterModal());
      document
        .getElementById('mapAdvancedFilterOverlay')
        ?.addEventListener('click', () => this.closeAdvancedFilterModal());
      document
        .getElementById('mapAdvancedFilterCancelBtn')
        ?.addEventListener('click', () => this.closeAdvancedFilterModal());
      document.getElementById('mapAdvancedFilterClearBtn')?.addEventListener('click', () => this.clearAdvancedFilter());
      document.getElementById('mapAdvancedFilterApplyBtn')?.addEventListener('click', () => this.applyAdvancedFilter());

      // 地图控制
      document.getElementById('mapCenterBtn')?.addEventListener('click', () => this.centerMap());
      document.getElementById('mapZoomInBtn')?.addEventListener('click', () => this.zoomIn());
      document.getElementById('mapZoomOutBtn')?.addEventListener('click', () => this.zoomOut());

      // 卡片相关
      document.getElementById('mapCardCloseBtn')?.addEventListener('click', () => this.closeDetailCard());
      document.getElementById('mapSendMsgBtn')?.addEventListener('click', () => this.sendMessage());
      document.getElementById('mapSocialCircleBtn')?.addEventListener('click', () => this.showSocialCircle());
      document.getElementById('mapViewProfileBtn')?.addEventListener('click', () => this.viewProfile());

      // 动态(Moments)相关
      document.getElementById('mapViewMomentsBtn')?.addEventListener('click', () => this.openMomentsModal());
      document.getElementById('mapMomentsCloseBtn')?.addEventListener('click', () => this.closeMomentsModal());
      document.getElementById('mapMomentsCommentsClose')?.addEventListener('click', () => this.closeMomentsCommentsDrawer());
      document.getElementById('mapMomentsCommentsOverlay')?.addEventListener('click', () => this.closeMomentsCommentsDrawer());

      // 点击外部区域关闭下拉菜单
      document.addEventListener('click', (e) => {
        const dropdown = document.getElementById('mapProfileDropdownMenu');
        const btn = document.getElementById('mapViewProfileBtn');
        if (dropdown && !dropdown.contains(e.target) && !btn?.contains(e.target)) {
          this.closeProfileDropdown();
        }
      });

      // 社交圈相关
      document.getElementById('mapSocialCircleBackBtn')?.addEventListener('click', () => this.hideSocialCircle());

      // 评价相关
      document.getElementById('mapCardReviewsBtn')?.addEventListener('click', () => this.toggleReviewsView());
      document.getElementById('mapReviewsBackBtn')?.addEventListener('click', () => this.toggleReviewsView());

      // 设置相关
      document.getElementById('mapCardSettingsBtn')?.addEventListener('click', () => this.openMapSettings());
      document.getElementById('mapSettingsBackBtn')?.addEventListener('click', () => this.closeMapSettings());
      document.getElementById('mapSettingsSaveBtn')?.addEventListener('click', () => this.saveMapSettings());
      document.getElementById('mapSettingsAddTagBtn')?.addEventListener('click', () => this.addNewTag());

      // 天气测试按钮（开发者用）
      document.getElementById('mapWeatherTestBtn')?.addEventListener('click', () => this.cycleWeatherTest());

      // 聊天相关
      document.getElementById('mapChatOverlay')?.addEventListener('click', () => this.closeChatModal());
      document.getElementById('mapChatBackBtn')?.addEventListener('click', () => this.closeChatModal());

      // 聊天头像点击查看资料
      document.getElementById('mapChatUserAvatar')?.addEventListener('click', () => {
        if (this.currentChatUser) {
          console.log(`👆 [聊天] 点击头像查看 ${this.currentChatUser.nickname} 的资料`);
          this.showUserProfile(this.currentChatUser);
        }
      });

      document.getElementById('mapChatInput')?.addEventListener('keypress', e => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          this.sendChatMessage();
        }
      });
      document.getElementById('mapChatLikeBtn')?.addEventListener('click', () => this.triggerAIResponse());
      document.getElementById('mapChatAddBtn')?.addEventListener('click', () => {
        this.toggleFunctionMenu();
      });
      document.getElementById('mapChatMoreBtn')?.addEventListener('click', () => {
        this.toggleMoreMenu();
      });
      document.getElementById('mapChatAddToListBtn')?.addEventListener('click', () => {
        this.addCurrentChatToList();
      });

      // 📌 聊天列表相关
      document.getElementById('mapChatsBtn')?.addEventListener('click', () => {
        this.openChatsListModal();
      });
      document.getElementById('mapChatsListCloseBtn')?.addEventListener('click', () => {
        this.closeChatsListModal();
      });
      document.getElementById('mapChatsListOverlay')?.addEventListener('click', () => {
        this.closeChatsListModal();
      });

      // 📌 用户笔记功能相关
      document.getElementById('mapChatNotesBtn')?.addEventListener('click', () => {
        this.openNotesModal();
      });
      document.getElementById('mapNotesCloseBtn')?.addEventListener('click', () => {
        this.closeNotesModal();
      });
      document.getElementById('mapNotesOverlay')?.addEventListener('click', () => {
        this.closeNotesModal();
      });

      // 🔔 提醒功能相关
      document.getElementById('mapNotificationsBtn')?.addEventListener('click', () => {
        this.openNotificationsModal();
      });
      document.getElementById('mapNotificationsCloseBtn')?.addEventListener('click', () => {
        this.closeNotificationsModal();
      });
      document.getElementById('mapNotificationsOverlay')?.addEventListener('click', () => {
        this.closeNotificationsModal();
      });

      // 🔔 提醒分类Tabs功能
      const notificationTabs = document.querySelectorAll('.map-notifications-tab');
      notificationTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          // 移除所有tab的active类
          notificationTabs.forEach(t => t.classList.remove('active'));
          // 给当前tab添加active类
          tab.classList.add('active');
          // 获取筛选类型
          const filterType = tab.getAttribute('data-filter');
          // 执行筛选
          this.filterNotifications(filterType);
        });
      });

      // ⚙️ 应用设置功能相关
      document.getElementById('mapAppSettingsBtn')?.addEventListener('click', () => {
        this.openAppSettingsModal();
      });
      document.getElementById('mapAppSettingsCloseBtn')?.addEventListener('click', () => {
        this.closeAppSettingsModal();
      });
      document.getElementById('mapAppSettingsOverlay')?.addEventListener('click', () => {
        this.closeAppSettingsModal();
      });
      document.getElementById('mapThemeToggle')?.addEventListener('click', () => {
        this.toggleTheme();
      });

      // 🖼️ 自定义头像管理相关
      document.getElementById('mapAvatarAddBtn')?.addEventListener('click', () => {
        const urlInput = document.getElementById('mapAvatarUrlInput');
        const selectedCategory = document.querySelector('input[name="avatarCategory"]:checked');
        if (urlInput && selectedCategory) {
          this.addCustomAvatar(urlInput.value, selectedCategory.value);
        }
      });

      // 🚨 举报功能相关
      document.getElementById('mapChatReportBtn')?.addEventListener('click', () => {
        this.openReportModal();
      });
      document.getElementById('mapReportCloseBtn')?.addEventListener('click', () => {
        this.closeReportModal();
      });

      // 🗑️ 消息管理功能相关
      document.getElementById('mapChatManageBtn')?.addEventListener('click', () => {
        this.enterDeleteMode();
      });

      // 删除模式工具栏按钮
      document.getElementById('mapChatDeleteSelectAll')?.addEventListener('change', e => {
        this.toggleSelectAllMessages(e.target.checked);
      });
      document.getElementById('mapChatDeleteSelected')?.addEventListener('click', () => {
        this.deleteSelectedMessages();
      });
      document.getElementById('mapChatClearAll')?.addEventListener('click', () => {
        this.clearAllChatData();
      });
      document.getElementById('mapChatDeleteExit')?.addEventListener('click', () => {
        this.exitDeleteMode();
      });

      document.getElementById('mapReportOverlay')?.addEventListener('click', () => {
        this.closeReportModal();
      });
      document.getElementById('mapReportCancelBtn')?.addEventListener('click', () => {
        this.closeReportModal();
      });
      document.getElementById('mapReportSubmitBtn')?.addEventListener('click', () => {
        this.submitReport();
      });

      // 📋 举报详情弹窗相关
      document.getElementById('mapReportDetailCloseBtn')?.addEventListener('click', () => {
        this.closeReportDetailModal();
      });
      document.getElementById('mapReportDetailOverlay')?.addEventListener('click', () => {
        this.closeReportDetailModal();
      });
      document.getElementById('mapReportDetailAcknowledgeBtn')?.addEventListener('click', () => {
        this.handleReportAcknowledge();
      });

      // 💬 接收私信确认弹窗相关
      document.getElementById('mapAcceptMessageBtn')?.addEventListener('click', () => {
        this.acceptMessage();
      });
      document.getElementById('mapDeclineMessageBtn')?.addEventListener('click', () => {
        this.declineMessage();
      });
      document.getElementById('mapAcceptMessageOverlay')?.addEventListener('click', () => {
        this.declineMessage();
      });

      // 触摸手势
      this.initTouchGestures();
    },

    // 初始化触摸手势
    initTouchGestures() {
      const mapArea = document.getElementById('mapArea');
      if (!mapArea) return;

      mapArea.addEventListener(
        'touchstart',
        e => {
          this.touchStartX = e.touches[0].clientX;
          this.touchStartY = e.touches[0].clientY;
        },
        { passive: true },
      );

      mapArea.addEventListener(
        'touchmove',
        e => {
          this.touchEndX = e.touches[0].clientX;
          this.touchEndY = e.touches[0].clientY;
        },
        { passive: true },
      );

      mapArea.addEventListener('touchend', () => {
        this.handleSwipeGesture();
      });
    },

    // 处理滑动手势
    handleSwipeGesture() {
      const deltaX = this.touchEndX - this.touchStartX;
      const deltaY = this.touchEndY - this.touchStartY;
      const minSwipeDistance = 50;

      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        if (deltaX > minSwipeDistance && this.touchStartX < 50 && !this.isSidebarOpen) {
          this.openSidebar();
        } else if (deltaX < -minSwipeDistance && this.isSidebarOpen) {
          this.closeSidebar();
        }
      }
    },

    // 初始化地图位置
    initMapPosition() {
      const mapArea = document.getElementById('mapArea');
      if (!mapArea) return;

      const viewportWidth = mapArea.offsetWidth;
      const viewportHeight = mapArea.offsetHeight;

      this.mapState.translateX = -(viewportWidth * this.MAP_SIZE_MULTIPLIER - viewportWidth) / 2;
      this.mapState.translateY = -(viewportHeight * this.MAP_SIZE_MULTIPLIER - viewportHeight) / 2;

      this.updateMapTransform();
    },

    // 初始化地图拖动
    initMapDrag() {
      const mapCanvas = document.getElementById('mapCanvas');
      if (!mapCanvas) return;

      const startDrag = e => {
        this.mapState.isDragging = true;
        this.mapState.startX = e.clientX || e.pageX;
        this.mapState.startY = e.clientY || e.pageY;
        this.mapState.lastTranslateX = this.mapState.translateX;
        this.mapState.lastTranslateY = this.mapState.translateY;
      };

      const handleDrag = e => {
        if (!this.mapState.isDragging) return;

        const currentX = e.clientX || e.pageX;
        const currentY = e.clientY || e.pageY;

        const deltaX = currentX - this.mapState.startX;
        const deltaY = currentY - this.mapState.startY;

        let newTranslateX = this.mapState.lastTranslateX + deltaX;
        let newTranslateY = this.mapState.lastTranslateY + deltaY;

        const bounds = this.getMapBounds();
        newTranslateX = Math.min(bounds.maxX, Math.max(bounds.minX, newTranslateX));
        newTranslateY = Math.min(bounds.maxY, Math.max(bounds.minY, newTranslateY));

        this.mapState.translateX = newTranslateX;
        this.mapState.translateY = newTranslateY;

        this.updateMapTransform();
      };

      const endDrag = () => {
        this.mapState.isDragging = false;
      };

      mapCanvas.addEventListener('mousedown', startDrag);
      mapCanvas.addEventListener(
        'touchstart',
        e => {
          if (e.touches.length === 1) {
            startDrag(e.touches[0]);
          } else if (e.touches.length === 2) {
            this.mapState.initialDistance = this.getDistance(e.touches[0], e.touches[1]);
            this.mapState.initialScale = this.mapState.scale;
          }
        },
        { passive: true },
      );

      mapCanvas.addEventListener('mousemove', handleDrag);
      mapCanvas.addEventListener(
        'touchmove',
        e => {
          if (e.touches.length === 1 && this.mapState.isDragging) {
            e.preventDefault();
            handleDrag(e.touches[0]);
          } else if (e.touches.length === 2) {
            e.preventDefault();
            const currentDistance = this.getDistance(e.touches[0], e.touches[1]);
            const scale = currentDistance / this.mapState.initialDistance;
            this.mapState.scale = Math.min(Math.max(this.mapState.initialScale * scale, this.MIN_ZOOM), this.MAX_ZOOM);
            this.clampMapPosition();
            this.updateMapTransform();
          }
        },
        { passive: false },
      );

      mapCanvas.addEventListener('mouseup', endDrag);
      mapCanvas.addEventListener('mouseleave', endDrag);
      mapCanvas.addEventListener('touchend', endDrag);
    },

    getDistance(touch1, touch2) {
      const dx = touch1.clientX - touch2.clientX;
      const dy = touch1.clientY - touch2.clientY;
      return Math.sqrt(dx * dx + dy * dy);
    },

    getMapBounds() {
      const mapArea = document.getElementById('mapArea');
      if (!mapArea) return { maxX: 0, minX: 0, maxY: 0, minY: 0 };

      const viewportWidth = mapArea.offsetWidth;
      const viewportHeight = mapArea.offsetHeight;

      const mapWidth = viewportWidth * this.MAP_SIZE_MULTIPLIER * this.mapState.scale;
      const mapHeight = viewportHeight * this.MAP_SIZE_MULTIPLIER * this.mapState.scale;

      return {
        maxX: 0,
        minX: viewportWidth - mapWidth,
        maxY: 0,
        minY: viewportHeight - mapHeight,
      };
    },

    clampMapPosition() {
      const bounds = this.getMapBounds();
      this.mapState.translateX = Math.min(bounds.maxX, Math.max(bounds.minX, this.mapState.translateX));
      this.mapState.translateY = Math.min(bounds.maxY, Math.max(bounds.minY, this.mapState.translateY));
    },

    updateMapTransform() {
      const mapCanvas = document.getElementById('mapCanvas');
      if (!mapCanvas) return;

      mapCanvas.style.transform = `translate(${this.mapState.translateX}px, ${this.mapState.translateY}px) scale(${this.mapState.scale})`;

      const markers = document.querySelectorAll('.map-marker');
      markers.forEach((marker, index) => {
        const markerScale = Math.max(0.8, 1 / this.mapState.scale);
        const baseTransform = marker.getAttribute('data-base-transform') || 'scale(1)';
        marker.style.transform = `${baseTransform} scale(${markerScale})`;

        if (this.mapState.scale < 0.7) {
          marker.style.opacity = '1';
        } else if (this.mapState.scale > 1.5) {
          marker.style.opacity = index % 2 === 0 ? '1' : '0.4';
        } else {
          marker.style.opacity = '1';
        }
      });

      // 控制气泡显示：只在放大时显示，防止缩小时重叠
      const bubbles = document.querySelectorAll('.marker-status-bubble');
      const bubbleZoomThreshold = 1.3; // 放大到1.3倍以上才显示气泡
      bubbles.forEach(bubble => {
        if (this.mapState.scale >= bubbleZoomThreshold) {
          bubble.classList.add('visible');
        } else {
          bubble.classList.remove('visible');
        }
      });

      this.updateLandmarkLabelsVisibility();
    },

    updateLandmarkLabelsVisibility() {
      const labels = document.querySelectorAll('.landmark-label');
      const zoomThreshold = 1.2;

      labels.forEach((label, index) => {
        if (this.mapState.scale >= zoomThreshold) {
          setTimeout(() => {
            label.classList.add('visible');
          }, index * 15);
        } else {
          label.classList.remove('visible');
        }
      });
    },

    // 侧边栏控制
    openSidebar() {
      document.getElementById('mapSidebar')?.classList.add('show');
      document.getElementById('mapSidebarOverlay')?.classList.add('show');
      this.isSidebarOpen = true;

      const hint = document.getElementById('mapSwipeHint');
      if (hint) hint.classList.add('hidden');
    },

    closeSidebar() {
      document.getElementById('mapSidebar')?.classList.remove('show');
      document.getElementById('mapSidebarOverlay')?.classList.remove('show');
      this.isSidebarOpen = false;
    },

    toggleSidebar() {
      if (this.isSidebarOpen) {
        this.closeSidebar();
      } else {
        this.openSidebar();
      }
    },

    // ==================== 咩三三城市报纸功能 ====================

    // 打开报纸弹窗
    async openNewspaper() {
      console.log('🐑 [咩三三报纸] 打开报纸弹窗');

      // 显示弹窗
      document.getElementById('newspaperOverlay')?.classList.add('show');
      document.getElementById('newspaperModal')?.classList.add('show');

      // 更新时钟
      this.updateNewspaperClock();

      // 更新统计数字
      this.updateNewspaperStats();

      // 加载报纸内容（从localStorage读取AI生成的内容，或使用静态placeholder）
      await this.generateNewspaper();
    },

    // 关闭报纸弹窗
    closeNewspaper() {
      console.log('🐑 [咩三三报纸] 关闭报纸弹窗');
      document.getElementById('newspaperOverlay')?.classList.remove('show');
      document.getElementById('newspaperModal')?.classList.remove('show');
    },

    // 更新报纸时钟
    updateNewspaperClock() {
      const updateClock = () => {
        const now = new Date();
        const dateStr = now.toISOString().split('T')[0];
        const timeStr = now.toLocaleTimeString('en-US', {
          hour: '2-digit',
          minute: '2-digit',
          hour12: true
        });

        const clockDate = document.getElementById('newspaperClockDate');
        const clockTime = document.getElementById('newspaperClockTime');

        if (clockDate) clockDate.textContent = dateStr;
        if (clockTime) clockTime.textContent = timeStr;
      };

      updateClock();
      // 每分钟更新一次
      if (this.newspaperClockInterval) {
        clearInterval(this.newspaperClockInterval);
      }
      this.newspaperClockInterval = setInterval(updateClock, 60000);
    },

    // 更新报纸统计数据（浏览量和打赏数）
    updateNewspaperStats() {
      console.log('📊 [咩三三报纸] 更新统计数据');

      // 从localStorage读取统计数据
      let stats = JSON.parse(localStorage.getItem('newspaperStats') || '{"views": 0, "tips": 0}');

      // 每次打开报纸，浏览量+1
      stats.views += 1;

      // 小概率增加打赏数（20%概率）
      if (Math.random() < 0.2) {
        stats.tips += Math.floor(Math.random() * 3) + 1; // 随机增加1-3个打赏
      }

      // 保存回localStorage
      localStorage.setItem('newspaperStats', JSON.stringify(stats));

      // 更新DOM显示
      const viewsElement = document.getElementById('newspaperViewsCount');
      const tipsElement = document.getElementById('newspaperTipsCount');

      if (viewsElement) {
        viewsElement.textContent = stats.views.toLocaleString(); // 格式化数字（如1,234）
      }
      if (tipsElement) {
        tipsElement.textContent = stats.tips.toLocaleString();
      }

      console.log(`📊 [咩三三报纸] 统计更新完成 - Views: ${stats.views}, Tips: ${stats.tips}`);
    },

    // 渲染报纸HTML（根据AI数据）
    renderNewspaperHTML(data) {
      let html = '';

      // 1. 天气预报
      if (data.weather) {
        html += `
          <div class="newspaper-weather-card">
            <div class="newspaper-weather-icon-big">${data.weather.icon || '☀'}</div>
            <div class="newspaper-weather-temp-big">${data.weather.temp || '18°C'}</div>
            <div class="newspaper-weather-desc-big">${data.weather.desc || 'TODAY · SUNNY'}</div>
          </div>
        `;
      }

      // 2. 重大新闻
      if (data.news && Array.isArray(data.news)) {
        data.news.forEach(newsItem => {
          html += `
            <div class="newspaper-news-card">
              <div class="newspaper-breaking-badge">BREAKING</div>
              <h2 class="newspaper-news-headline">${newsItem.headline || '无标题'}</h2>
              <div class="newspaper-news-meta">
                <span>📍 ${newsItem.location || 'UNKNOWN'}</span>
                <span>•</span>
                <span>${newsItem.time || 'RECENTLY'}</span>
                <span>•</span>
                <span>BY MIE333</span>
              </div>
              <div class="newspaper-news-body">
                ${newsItem.body || ''}
              </div>
              ${newsItem.comment ? `<div class="newspaper-emoticon-comment">${newsItem.comment}</div>` : ''}
            </div>
          `;
        });
      }

      // 3. 咩三三的真实想法气泡
      if (data.bubble) {
        html += `
          <div class="newspaper-speech-bubble">
            ${data.bubble}
          </div>
        `;
      }

      // 4. 公众投稿
      if (data.submissions && Array.isArray(data.submissions) && data.submissions.length > 0) {
        html += '<div style="margin-top: 12px;"><div class="newspaper-widget-title" style="margin-bottom: 8px;">群众投稿</div>';
        data.submissions.forEach(sub => {
          html += `
            <div class="newspaper-submission-sticky">
              <span class="newspaper-sticky-tag">${sub.tag || 'INFO'}</span>
              <div class="newspaper-sticky-title">${sub.title || '无标题'}</div>
              <div class="newspaper-sticky-content">${sub.content || ''}</div>
            </div>
          `;
        });
        html += '</div>';
      }

      // 5. 赞助商广告
      if (data.ads && Array.isArray(data.ads)) {
        data.ads.forEach(ad => {
          html += `
            <div class="newspaper-ad-banner-special">
              <div class="newspaper-ad-corner">AD</div>
              <div class="newspaper-ad-title">${ad.title || '广告'}</div>
              <div class="newspaper-ad-text">${ad.text || ''}</div>
            </div>
          `;
        });
      }

      // 6. 联系方式（固定内容）
      html += `
        <div class="newspaper-contact-pixel">
          <div class="newspaper-contact-line">> EMAIL: mie333@city-news.com</div>
          <div class="newspaper-contact-line">> TIPS: tips@mie333.com</div>
          <div class="newspaper-contact-line">> AD: ad@mie333.com</div>
        </div>
      `;

      // 7. 底部签名
      html += `
        <div class="newspaper-footer-sig">
          "咩三三我虽然利己主义，但报道绝对真实。( •̀ ω •́ )✧"<br>
          — MIE333 CITY NEWS · DAILY UPDATE —
        </div>
      `;

      return html;
    },

    // 渲染报纸内容（使用AI数据）
    async generateNewspaper() {
      const mainContent = document.getElementById('newspaperMainContent');
      if (!mainContent) return;

      mainContent.innerHTML = '<div style="padding: 40px; text-align: center; color: var(--map-text-secondary);">🐑 咩三三正在撰写报纸...</div>';

      try {
        console.log('🐑 [咩三三报纸] 开始加载报纸内容');

        // 从localStorage读取AI生成的数据（JSON对象）
        const cachedDataStr = localStorage.getItem('newspaperCachedData');

        let newspaperData = null;
        if (cachedDataStr) {
          try {
            newspaperData = JSON.parse(cachedDataStr);
            console.log('📰 [咩三三报纸] 成功读取AI生成的报纸数据');
          } catch (error) {
            console.error('❌ [咩三三报纸] 解析报纸数据失败:', error);
          }
        }

        let content = '';

        if (newspaperData && newspaperData.weather) {
          console.log('🎨 [咩三三报纸] 使用AI数据渲染HTML');
          // 使用AI数据渲染HTML模板
          content = this.renderNewspaperHTML(newspaperData);
        } else {
          console.log('⚠️ [咩三三报纸] 未找到AI数据，使用静态placeholder');
          // 静态placeholder内容作为fallback
          content = `
          <!-- 天气预报 -->
          <div class="newspaper-weather-card">
            <div class="newspaper-weather-icon-big">☀</div>
            <div class="newspaper-weather-temp-big">18°C</div>
            <div class="newspaper-weather-desc-big">TODAY · SUNNY</div>
          </div>

          <!-- 重大新闻 -->
          <div class="newspaper-news-card">
            <div class="newspaper-breaking-badge">BREAKING</div>
            <h2 class="newspaper-news-headline">市中心星巴克咖啡盛大开业</h2>
            <div class="newspaper-news-meta">
              <span>📍 DOWNTOWN</span>
              <span>•</span>
              <span>2H AGO</span>
              <span>•</span>
              <span>BY MIE333</span>
            </div>
            <div class="newspaper-news-body">
              咩三三我今天路过市中心商业街，发现那边新开了家星巴克。门口排了好长的队，都是冲着开业优惠去的。
            </div>
            <div class="newspaper-emoticon-comment">
              (￣ー￣) 咩三三觉得这种开业活动就是套路...
            </div>
          </div>

          <!-- 对话框 -->
          <div class="newspaper-speech-bubble">
            ✧ 咩三三的真实想法：不如去便利店买罐装咖啡实在！
          </div>

          <!-- 群众投稿 -->
          <div style="margin-top: 12px;">
            <div class="newspaper-widget-title" style="margin-bottom: 8px;">群众投稿</div>

            <div class="newspaper-submission-sticky">
              <span class="newspaper-sticky-tag">MISSING</span>
              <div class="newspaper-sticky-title">寻找走失的金毛犬</div>
              <div class="newspaper-sticky-content">昨晚在公园走失，红色项圈，请联系138****5678。重谢！</div>
            </div>

            <div class="newspaper-submission-sticky">
              <span class="newspaper-sticky-tag">COMPLAINT</span>
              <div class="newspaper-sticky-title">楼上邻居深夜扰民</div>
              <div class="newspaper-sticky-content">301室每晚12点后蹦迪！咩三三：直接找物业。(눈_눈)</div>
            </div>

            <div class="newspaper-submission-sticky">
              <span class="newspaper-sticky-tag">STORY</span>
              <div class="newspaper-sticky-title">地铁上捡到钱包</div>
              <div class="newspaper-sticky-content">已交给地铁工作人员，失主可去2号线客服中心认领。</div>
            </div>
          </div>

          <!-- 广告 -->
          <div class="newspaper-ad-banner-special">
            <div class="newspaper-ad-corner">AD</div>
            <div class="newspaper-ad-title">咩三三的杂货铺</div>
            <div class="newspaper-ad-text">各种稀奇古怪的小玩意儿都有卖！价格公道童叟无欺。地址：商业街99号 | 营业时间：看心情 (￣y▽￣)╭</div>
          </div>

          <!-- 联系方式 -->
          <div class="newspaper-contact-pixel">
            <div class="newspaper-contact-line">> EMAIL: mie333@city-news.com</div>
            <div class="newspaper-contact-line">> TIPS: tips@mie333.com</div>
            <div class="newspaper-contact-line">> AD: ad@mie333.com</div>
          </div>

          <!-- 底部签名 -->
          <div class="newspaper-footer-sig">
            "咩三三我虽然利己主义，但报道绝对真实。( •̀ ω •́ )✧"<br>
            — MIE333 CITY NEWS · DAILY UPDATE —
          </div>
        `;
        }

        mainContent.innerHTML = content;

        console.log('✅ [咩三三报纸] 报纸内容加载完成');
      } catch (error) {
        console.error('❌ [咩三三报纸] 生成失败:', error);
        mainContent.innerHTML = '<div style="padding: 40px; text-align: center; color: var(--map-text-secondary);">报纸生成失败，请稍后重试</div>';
      }
    },

    // 渲染用户列表
    renderUserList() {
      const userList = document.getElementById('mapUserList');
      if (!userList) return;

      userList.innerHTML = this.currentUsers
        .map(user => {
          // 从bio中提取年龄信息（格式："24岁 | 单身"）
          const ageMatch = user.bio ? user.bio.match(/(\d+)岁/) : null;
          const age = ageMatch ? ageMatch[1] : '';
          const displayName = age ? `${user.nickname}, ${age}` : user.nickname;

          return `
        <div class="map-user-item ${this.selectedUserId == user.id ? 'active' : ''}" data-user-id="${user.id}">
          <div class="map-user-avatar-container">
            <img class="map-user-avatar" src="${user.avatar}" alt="${user.nickname}">
            ${user.online ? '<div class="map-online-indicator"></div>' : ''}
          </div>
          <div class="map-user-info">
            <div class="map-user-name">${displayName}</div>
            <div class="map-user-meta">
              <span class="map-distance">
                ${MapIcons.location}
                ${user.distance}km
              </span>
              <span>•</span>
              <span>${user.online ? '在线' : '离线'}</span>
            </div>
          </div>
          <svg class="map-view-icon" viewBox="0 0 24 24">
            <g><path d="M8.75 21V3h2v18h-2zM18 21V8.5h2V21h-2zM4 21l.004-10h2L6 21H4zm9.248 0v-7h2v7h-2z"></path></g>
          </svg>
        </div>
      `;
        })
        .join('');

      // 绑定点击事件
      userList.querySelectorAll('.map-user-item').forEach(item => {
        item.addEventListener('click', () => {
          const userId = item.getAttribute('data-user-id');
          this.selectUser(userId);
        });
      });
    },

    // 渲染地图标记
    renderMapMarkers() {
      const mapCanvas = document.getElementById('mapCanvas');
      if (!mapCanvas) return;

      const existingMarkers = mapCanvas.querySelectorAll('.map-marker');
      existingMarkers.forEach(m => m.remove());

      // 渲染其他用户
      this.currentUsers.forEach(user => {
        const marker = document.createElement('div');
        marker.className = 'map-marker';
        marker.style.top = user.position.top;
        marker.style.left = user.position.left;
        marker.setAttribute('data-base-transform', 'scale(1)');
        marker.setAttribute('data-user-id', user.id);
        marker.innerHTML = `
          <div class="marker-container">
            ${user.status ? `<div class="marker-status-bubble">${user.status}</div>` : ''}
            ${user.online ? '<div class="marker-pulse"></div>' : ''}
            <img class="marker-avatar" src="${user.avatar}" alt="${user.nickname}">
          </div>
        `;
        marker.addEventListener('click', e => {
          e.stopPropagation();
          this.showDetailCard(user.id);
        });
        mapCanvas.appendChild(marker);
      });

      // 渲染用户自己的位置标记
      this.renderCurrentUserMarker();
    },

    // 渲染用户自己的位置标记
    renderCurrentUserMarker() {
      const mapCanvas = document.getElementById('mapCanvas');
      if (!mapCanvas) return;

      // 先删除旧的当前用户标记
      const existingCurrentUserMarker = mapCanvas.querySelector('.map-marker.current-user');
      if (existingCurrentUserMarker) {
        existingCurrentUserMarker.remove();
      }

      // 获取用户头像、状态等信息，优先使用地图资料，其次使用 window.userProfileData
      let userAvatar = 'https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg'; // 默认头像
      let userName = '我';
      let userStatus = ''; // 状态气泡

      if (this.userMapProfile && this.userMapProfile.avatar) {
        userAvatar = this.userMapProfile.avatar;
        userName = this.userMapProfile.nickname || userName;
        userStatus = this.userMapProfile.status || ''; // 从用户资料获取状态
      } else if (window.userProfileData) {
        userAvatar = window.userProfileData.avatar || userAvatar;
        userName = window.userProfileData.name || userName;
      }

      // 动态获取主题色（从x-social-screen读取CSS变量）
      const xSocialScreen = document.getElementById('x-social-screen');
      let accentColor = '#1d9bf0'; // 默认Twitter蓝
      if (xSocialScreen) {
        const computedAccent = getComputedStyle(xSocialScreen).getPropertyValue('--x-accent').trim();
        if (computedAccent) {
          accentColor = computedAccent;
        }
      }

      const marker = document.createElement('div');
      marker.className = 'map-marker current-user';
      marker.style.top = this.currentUserPosition.top;
      marker.style.left = this.currentUserPosition.left;
      marker.setAttribute('data-base-transform', 'scale(1)');
      marker.setAttribute('data-user-id', 'current-user');
      marker.innerHTML = `
        <div class="marker-container">
          ${userStatus ? `<div class="marker-status-bubble">${userStatus}</div>` : ''}
          <div class="marker-pulse"></div>
          <img class="marker-avatar" src="${userAvatar}" alt="${userName}" style="border: 3px solid ${accentColor};">
        </div>
      `;
      marker.addEventListener('click', e => {
        e.stopPropagation();
        // 点击用户自己的标记时，显示可编辑的资料卡
        this.showUserProfileCard();
      });
      mapCanvas.appendChild(marker);
    },

    // 渲染地标标签
    renderLandmarkLabels() {
      console.log('🏷️ [renderLandmarkLabels] 开始渲染地标标签');
      const mapCanvas = document.getElementById('mapCanvas');
      if (!mapCanvas) {
        console.error('❌ [renderLandmarkLabels] 找不到 mapCanvas 元素');
        return;
      }

      const existingLabels = mapCanvas.querySelectorAll('.landmark-label');
      existingLabels.forEach(l => l.remove());

      const landmarks = MapGenerator.landmarks;
      console.log('🏷️ [renderLandmarkLabels] landmarks数据:', landmarks);
      if (!landmarks || landmarks.length === 0) {
        console.warn('⚠️ [renderLandmarkLabels] landmarks为空或不存在');
        return;
      }
      console.log(`🏷️ [renderLandmarkLabels] 准备渲染 ${landmarks.length} 个地标`);

      landmarks.forEach(landmark => {
        const label = document.createElement('div');
        // 添加has-event和visible类标记
        label.className = landmark.event ? 'landmark-label has-event visible' : 'landmark-label visible';
        label.id = landmark.id;
        label.style.left = `${landmark.x}px`;
        label.style.top = `${landmark.y}px`;
        label.innerHTML = `
          <span class="landmark-label-icon" style="color: ${landmark.color}">
            ${landmark.icon}
          </span>
          <span>${landmark.name}</span>
        `;

        // 添加点击处理（所有地标都可点击）
        label.addEventListener('click', (e) => {
          e.stopPropagation();

          // 如果在乘车模式的选择目的地状态，优先处理乘车选择
          if (this.rideMode && this.rideSelectingDestination) {
            console.log(`🚗 [乘车模式] 选择目的地: ${landmark.name}`);
            this.selectRideDestination(landmark);
            return;
          }

          // 否则，如果有事件，打开事件弹窗
          if (landmark.event) {
            console.log(`🖱️ [地标点击] 点击了 ${landmark.name}`, landmark.event);
            this.openLandmarkEvent(landmark);
          }
        });

        mapCanvas.appendChild(label);
      });

      this.updateLandmarkLabelsVisibility();
    },

    // 打开地标事件弹窗
    openLandmarkEvent(landmark) {
      if (!landmark || !landmark.event) {
        return;
      }

      const overlay = document.getElementById('eventModalOverlay');
      const content = document.getElementById('eventModalContent');
      const closeBtn = document.getElementById('eventModalCloseBtn');

      if (!overlay || !content) {
        return;
      }

      // 设置强调色CSS变量（设置到x-map-container上，覆盖CSS默认值）
      if (landmark.event.accentColor) {
        const mapContainer = document.getElementById('x-map-container');
        if (mapContainer) {
          mapContainer.style.setProperty('--event-accent', landmark.event.accentColor);
          const hoverColor = this.shadeColor(landmark.event.accentColor, -20);
          mapContainer.style.setProperty('--event-accent-hover', hoverColor);
        }
      }

      // 注入事件HTML内容
      content.innerHTML = landmark.event.eventHTML || '<p style="padding: 40px; text-align: center;">暂无事件内容</p>';

      // 显示弹窗
      overlay.classList.add('active');

      // 绑定关闭事件（只绑定一次）
      if (!closeBtn.dataset.bound) {
        closeBtn.addEventListener('click', () => this.closeLandmarkEvent());
        closeBtn.dataset.bound = 'true';
      }

      // 点击遮罩关闭
      if (!overlay.dataset.bound) {
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) {
            this.closeLandmarkEvent();
          }
        });
        overlay.dataset.bound = 'true';
      }
    },

    // 关闭地标事件弹窗
    closeLandmarkEvent() {
      const overlay = document.getElementById('eventModalOverlay');
      if (overlay) {
        overlay.classList.remove('active');
      }
      console.log('✅ [地标事件] 弹窗已关闭');
    },

    // 颜色加深/变浅工具函数
    shadeColor(color, percent) {
      const num = parseInt(color.replace('#', ''), 16);
      const amt = Math.round(2.55 * percent);
      const R = (num >> 16) + amt;
      const G = (num >> 8 & 0x00FF) + amt;
      const B = (num & 0x0000FF) + amt;
      return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
        (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
        (B < 255 ? B < 1 ? 0 : B : 255))
        .toString(16).slice(1);
    },

    // 选择用户
    selectUser(userId) {
      this.selectedUserId = userId;
      this.renderUserList();
      this.showDetailCard(userId);
    },

    // 显示详情卡片 - Instagram风格
    showDetailCard(userId, source = 'map') {
      // 先从currentUsers查找，如果没找到再从allUsers查找（用于社交圈好友）
      // 使用宽松相等 == 以兼容数字ID和字符串ID
      let user = this.currentUsers.find(u => u.id == userId);
      if (!user) {
        user = this.allUsers.find(u => u.id == userId);
      }
      if (!user) return;

      this.selectedUserId = userId;

      // 🔧 记录资料卡打开来源（用于区分聊天上下文）
      this.detailCardOpenSource = source;
      console.log(`📇 [资料卡] 打开来源: ${source}`);
      this.isShowingUserProfile = false; // 重置标志，现在显示的是其他人
      this.renderUserList();

      // Instagram风格元素
      const mapCardAvatar = document.getElementById('mapCardAvatar');
      const mapCardAvatarBubble = document.getElementById('mapCardAvatarBubble');
      const mapCardNickname = document.getElementById('mapCardNickname');
      const mapCardHandle = document.getElementById('mapCardHandle');
      const mapCardFollowers = document.getElementById('mapCardFollowers');
      const mapCardLikes = document.getElementById('mapCardLikes');
      const mapCardBio = document.getElementById('mapCardBio');
      const mapCardTags = document.getElementById('mapCardTags');
      const mapCardDistance = document.getElementById('mapCardDistance');
      const card = document.getElementById('mapUserDetailCard');

      // 清除之前绑定的编辑事件（防止用户资料的onclick残留）
      if (mapCardAvatar) mapCardAvatar.onclick = null;
      if (mapCardNickname) mapCardNickname.onclick = null;
      if (mapCardBio) mapCardBio.onclick = null;

      // 填充数据
      if (mapCardAvatar) mapCardAvatar.src = user.avatar;
      if (mapCardAvatarBubble) mapCardAvatarBubble.textContent = user.avatarBubble || '😊';
      if (mapCardNickname) mapCardNickname.textContent = user.nickname;
      // 🔧 修复handle重复@问题：检查handle是否已包含@
      if (mapCardHandle) mapCardHandle.textContent = user.handle.startsWith('@') ? user.handle : `@${user.handle}`;
      if (mapCardFollowers) mapCardFollowers.textContent = user.followers || 0;
      if (mapCardLikes) mapCardLikes.textContent = user.likes || 0;
      if (mapCardBio) mapCardBio.textContent = user.bio;
      if (mapCardTags) mapCardTags.innerHTML = user.tags.map(tag => `<div class="card-tag">${tag}</div>`).join('');
      if (mapCardDistance) mapCardDistance.textContent = `${user.distance}km`;

      // 填充评价数据
      this.renderReviews(user);

      // 确保显示资料section，隐藏评价section
      const reviewsSection = document.getElementById('mapCardReviewsSection');
      if (reviewsSection) reviewsSection.classList.remove('active');

      if (card) card.style.display = 'block';
    },

    // 关闭详情卡片
    closeDetailCard() {
      const card = document.getElementById('mapUserDetailCard');
      if (card) card.style.display = 'none';
      this.selectedUserId = null;
      this.renderUserList();

      // 重置评价视图
      const reviewsSection = document.getElementById('mapCardReviewsSection');
      if (reviewsSection) reviewsSection.classList.remove('active');
    },

    // 渲染评价数据
    renderReviews(user) {
      let reviews = user.reviews || [];
      const avgRating = parseFloat(user.avgRating) || 0; // 确保是数字类型

      // 🔧 修复旧数据中错误的reviews字段名（兼容处理）
      if (reviews.length > 0) {
        reviews = reviews.map(review => {
          const fixedReview = { ...review };

          // 修正字段名
          if (review.reviewer && !review.reviewerName) {
            fixedReview.reviewerName = review.reviewer;
          }
          if (review.comment && !review.content) {
            fixedReview.content = review.comment;
          }

          // 补充缺失字段的默认值
          if (!fixedReview.likes) fixedReview.likes = Math.floor(Math.random() * 100);
          if (!fixedReview.comments) fixedReview.comments = Math.floor(Math.random() * 20);
          if (!fixedReview.timestamp) {
            const daysAgo = Math.floor(Math.random() * 30) + 1;
            const date = new Date();
            date.setDate(date.getDate() - daysAgo);
            fixedReview.timestamp = date.toISOString();
          }
          if (!fixedReview.reviewerAvatar) {
            const reviewerGender = ['male', 'female', 'unisex'][Math.floor(Math.random() * 3)];
            fixedReview.reviewerAvatar = this.getRandomAvatar(reviewerGender);
          }

          return fixedReview;
        });
      }

      // 填充平均评分
      const avgRatingEl = document.getElementById('mapReviewsAvgRating');
      const reviewsCountEl = document.getElementById('mapReviewsCount');
      const starsEl = document.getElementById('mapReviewsStars');

      if (avgRatingEl) avgRatingEl.textContent = avgRating.toFixed(1);
      if (reviewsCountEl) reviewsCountEl.textContent = `${reviews.length}条评价`;

      // 生成星星
      if (starsEl) {
        const fullStars = Math.floor(avgRating);
        const hasHalfStar = avgRating % 1 >= 0.5;
        let starsHTML = '';
        for (let i = 0; i < 5; i++) {
          if (i < fullStars) {
            starsHTML +=
              '<svg viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>';
          } else if (i === fullStars && hasHalfStar) {
            starsHTML +=
              '<svg viewBox="0 0 24 24"><path d="M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4V6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z"/></svg>';
          } else {
            starsHTML +=
              '<svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="2"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>';
          }
        }
        starsEl.innerHTML = starsHTML;
      }

      // 渲染评价列表
      const reviewsListEl = document.getElementById('mapReviewsList');
      if (!reviewsListEl) return;

      if (reviews.length === 0) {
        reviewsListEl.innerHTML = `
          <div class="reviews-empty">
            <div class="reviews-empty-icon">💬</div>
            <div class="reviews-empty-text">还没有人留下评价<br>成为第一个评价的人吧</div>
          </div>
        `;
        return;
      }

      reviewsListEl.innerHTML = reviews
        .map(
          review => `
        <div class="review-item">
          <div class="review-header">
            <img class="review-avatar" src="${review.reviewerAvatar}" alt="${review.reviewerName}">
            <div class="review-info">
              <div class="review-name-line">
                <span class="review-name">${review.reviewerName}</span>
                <div class="review-rating">
                  <span class="review-rating-number">${review.rating.toFixed(1)}</span>
                  <svg viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>
                </div>
              </div>
              <div class="review-time">${this.getTimeAgo(review.timestamp)}</div>
            </div>
          </div>
          <div class="review-content">${review.content}</div>
          ${
            review.reply
              ? `
            <div class="review-reply">
              <svg class="review-reply-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 10h10a5 5 0 0 1 5 5v6M3 10l6 6M3 10l6-6"/>
              </svg>
              <div class="review-reply-body">
                <span class="review-reply-label">作者</span><span class="review-reply-content">${review.reply}</span>
              </div>
            </div>
          `
              : ''
          }
          <div class="review-actions">
            <button class="review-action-btn">
              <svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
              <span>${review.likes || 0}</span>
            </button>
            <button class="review-action-btn">
              <svg viewBox="0 0 24 24"><path d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z"/></svg>
              <span>${review.comments || 0}</span>
            </button>
          </div>
        </div>
      `,
        )
        .join('');
    },

    // 切换评价视图
    toggleReviewsView() {
      const reviewsSection = document.getElementById('mapCardReviewsSection');
      if (!reviewsSection) return;

      reviewsSection.classList.toggle('active');
    },

    // 获取相对时间（几天前）
    getTimeAgo(timestamp) {
      if (!timestamp) return '最近';
      const now = new Date();
      const reviewDate = new Date(timestamp);
      const diffDays = Math.floor((now - reviewDate) / (1000 * 60 * 60 * 24));

      if (diffDays === 0) return '今天';
      if (diffDays === 1) return '昨天';
      if (diffDays < 7) return `${diffDays}天前`;
      if (diffDays < 30) return `${Math.floor(diffDays / 7)}周前`;
      if (diffDays < 365) return `${Math.floor(diffDays / 30)}个月前`;
      return `${Math.floor(diffDays / 365)}年前`;
    },

    // ==================== 用户地图资料管理 ====================

    // 初始化用户地图资料（从X资料同步或数据库读取）
    async initUserMapProfile() {
      try {
        const xDb = getXDB();
        const profileId = `userMapProfile_${currentAccountId || 'main'}`;

        // 尝试从数据库读取
        let savedProfile = await xDb.xMapUserProfile.get(profileId);

        if (!savedProfile && window.userProfileData) {
          // 首次使用，从X资料同步
          console.log('🔧 [用户地图资料] 首次使用，从X资料同步');

          const xProfile = window.userProfileData;
          // 处理handle - 去掉开头的@（如果有的话）
          let handle = xProfile.handle || 'anonymous';
          if (handle.startsWith('@')) {
            handle = handle.substring(1);
          }

          savedProfile = {
            id: profileId,
            nickname: xProfile.name || '匿名用户',
            handle: handle,
            avatar: xProfile.avatar || '',
            bio: xProfile.bio || '这个人很神秘，什么都没留下',
            tags: [xProfile.customTag1 || '探索中', xProfile.customTag2 || '寻找缘分'].filter(t => t),
            avatarBubble: '👋',
            followers: xProfile.followers || 0,
            likes: xProfile.following || 0, // 用following作为likes显示
            lastUpdated: new Date().toISOString(),
          };

          // 保存到数据库
          await xDb.xMapUserProfile.put(savedProfile);
          console.log('✅ [用户地图资料] 已同步并保存到数据库');
        }

        this.userMapProfile = savedProfile;
        console.log('✅ [用户地图资料] 初始化完成', this.userMapProfile);
      } catch (error) {
        console.error('❌ [用户地图资料] 初始化失败:', error);
        // 使用默认值
        this.userMapProfile = {
          id: `userMapProfile_${currentAccountId || 'main'}`,
          nickname: '我',
          handle: 'me',
          avatar: '',
          bio: '编辑我的简介',
          tags: ['探索中'],
          avatarBubble: '👋',
          lastUpdated: new Date().toISOString(),
        };
      }
    },

    // 显示用户自己的资料卡 - 完全照抄showDetailCard，一个字都不多加
    showUserProfileCard() {
      if (!this.userMapProfile) {
        console.warn('⚠️ 用户资料未初始化');
        return;
      }

      const profile = this.userMapProfile;

      // 完全照抄showDetailCard的元素获取
      const mapCardAvatar = document.getElementById('mapCardAvatar');
      const mapCardAvatarBubble = document.getElementById('mapCardAvatarBubble');
      const mapCardNickname = document.getElementById('mapCardNickname');
      const mapCardHandle = document.getElementById('mapCardHandle');
      const mapCardFollowers = document.getElementById('mapCardFollowers');
      const mapCardLikes = document.getElementById('mapCardLikes');
      const mapCardBio = document.getElementById('mapCardBio');
      const mapCardTags = document.getElementById('mapCardTags');
      const mapCardDistance = document.getElementById('mapCardDistance');
      const card = document.getElementById('mapUserDetailCard');

      // 完全照抄showDetailCard的填充方式，一个字都不多
      if (mapCardAvatar) mapCardAvatar.src = profile.avatar;
      if (mapCardAvatarBubble) mapCardAvatarBubble.textContent = profile.avatarBubble || '😊';
      if (mapCardNickname) mapCardNickname.textContent = profile.nickname;
      // 🔧 修复handle重复@问题：检查handle是否已包含@
      if (mapCardHandle)
        mapCardHandle.textContent = profile.handle.startsWith('@') ? profile.handle : `@${profile.handle}`;
      if (mapCardFollowers) mapCardFollowers.textContent = profile.followers || 0;
      if (mapCardLikes) mapCardLikes.textContent = profile.likes || 0;
      if (mapCardBio) mapCardBio.textContent = profile.bio;
      if (mapCardTags) mapCardTags.innerHTML = profile.tags.map(tag => `<div class="card-tag">${tag}</div>`).join('');
      if (mapCardDistance) mapCardDistance.textContent = '0km';

      // 隐藏评价section
      const reviewsSection = document.getElementById('mapCardReviewsSection');
      if (reviewsSection) reviewsSection.classList.remove('active');

      // 显示卡片
      if (card) card.style.display = 'block';

      // 标记当前是用户自己的资料卡
      this.isShowingUserProfile = true;

      // 绑定编辑事件
      this.bindUserProfileEditEvents();
    },

    // 绑定用户资料编辑事件
    bindUserProfileEditEvents() {
      // 头像编辑
      const avatar = document.getElementById('mapCardAvatar');
      if (avatar) {
        avatar.onclick = e => {
          e.stopPropagation();
          this.editAvatar();
        };
      }

      // 昵称编辑
      const nickname = document.getElementById('mapCardNickname');
      if (nickname) {
        nickname.onclick = e => {
          e.stopPropagation();
          this.editNickname();
        };
      }

      // 简介编辑
      const bio = document.getElementById('mapCardBio');
      if (bio) {
        bio.onclick = e => {
          e.stopPropagation();
          this.editBio();
        };
      }

      // 标签编辑
      document.querySelectorAll('#mapCardTags .card-tag').forEach((tag, index) => {
        tag.onclick = e => {
          e.stopPropagation();
          this.editTag(e.target, index);
        };
      });
    },

    // 编辑头像（输入URL）
    editAvatar() {
      const currentAvatar = this.userMapProfile.avatar;
      const newAvatar = prompt('请输入新的头像URL:', currentAvatar);

      if (newAvatar !== null && newAvatar.trim() !== '') {
        this.userMapProfile.avatar = newAvatar.trim();
        // 更新卡片中的头像
        const avatar = document.getElementById('mapCardAvatar');
        if (avatar) avatar.src = newAvatar.trim();
        this.saveUserMapProfile();
      }
    },

    // 编辑昵称
    editNickname() {
      const currentValue = this.userMapProfile.nickname;
      const newValue = prompt('请输入昵称（2-8个字符）:', currentValue);

      if (newValue !== null && newValue.trim() !== '') {
        this.userMapProfile.nickname = newValue.trim();
        // 更新卡片中的昵称
        const nickname = document.getElementById('mapCardNickname');
        if (nickname) nickname.textContent = newValue.trim();
        this.saveUserMapProfile();
      }
    },

    // 编辑简介
    editBio() {
      const currentValue = this.userMapProfile.bio;
      const newValue = prompt('请输入简介（可以使用\\n换行）:', currentValue);

      if (newValue !== null) {
        this.userMapProfile.bio = newValue.trim();
        // 更新卡片中的简介
        const bio = document.getElementById('mapCardBio');
        if (bio) bio.textContent = newValue.trim();
        this.saveUserMapProfile();
      }
    },

    // 编辑标签
    editTag(element, index) {
      const currentValue = element.textContent.trim();
      const newValue = prompt('请输入标签内容:', currentValue);

      if (newValue !== null && newValue.trim() !== '') {
        this.userMapProfile.tags[index] = newValue.trim();
        this.refreshTagsDisplay();
        this.saveUserMapProfile();
      } else if (newValue === '') {
        // 删除标签
        if (confirm('确定要删除这个标签吗？')) {
          this.userMapProfile.tags.splice(index, 1);
          this.refreshTagsDisplay();
          this.saveUserMapProfile();
        }
      }
    },

    // 刷新标签显示 - 完全照抄showDetailCard的标签格式
    refreshTagsDisplay() {
      const mapCardTags = document.getElementById('mapCardTags');
      if (mapCardTags) {
        // 完全照抄showDetailCard的格式
        mapCardTags.innerHTML = this.userMapProfile.tags.map(tag => `<div class="card-tag">${tag}</div>`).join('');

        // 重新绑定标签编辑事件
        document.querySelectorAll('#mapCardTags .card-tag').forEach((tag, index) => {
          tag.onclick = e => {
            e.stopPropagation();
            this.editTag(e.target, index);
          };
        });
      }
    },

    // 保存用户地图资料到数据库
    async saveUserMapProfile() {
      try {
        const xDb = getXDB();
        this.userMapProfile.lastUpdated = new Date().toISOString();
        await xDb.xMapUserProfile.put(this.userMapProfile);
        console.log('✅ [用户地图资料] 已保存到数据库');

        // 刷新地图上的用户标记（更新头像）
        this.renderCurrentUserMarker();
      } catch (error) {
        console.error('❌ [用户地图资料] 保存失败:', error);
      }
    },

    // 筛选功能 - 适配Instagram风格数据
    filterUsers(query) {
      if (!query) {
        this.currentUsers = [...this.allUsers]; // 从完整数据源读取
      } else {
        this.currentUsers = this.allUsers.filter(
          // 从完整数据源筛选
          u =>
            u.nickname.toLowerCase().includes(query.toLowerCase()) ||
            u.handle.toLowerCase().includes(query.toLowerCase()) ||
            u.bio.toLowerCase().includes(query.toLowerCase()) ||
            u.tags.some(tag => tag.includes(query)),
        );
      }
      this.renderUserList();
      this.renderMapMarkers();
    },

    filterByDistance(value) {
      if (value === 'all') {
        this.currentUsers = [...this.allUsers]; // 从完整数据源读取
      } else {
        const maxDist = parseFloat(value);
        this.currentUsers = this.allUsers.filter(u => u.distance <= maxDist); // 从完整数据源筛选
      }
      this.renderUserList();
      this.renderMapMarkers();
    },

    filterByGender(value) {
      if (value === 'all') {
        this.currentUsers = [...this.allUsers]; // 从完整数据源读取
      } else {
        this.currentUsers = this.allUsers.filter(u => u.gender === value);
      }
      this.renderUserList();
      this.renderMapMarkers();
    },

    applyFilters() {
      console.log('应用筛选');
    },

    // 地图控制 - 居中到用户位置
    centerMap() {
      const mapArea = document.getElementById('mapArea');
      const mapCanvas = document.getElementById('mapCanvas');
      if (!mapArea || !mapCanvas) return;

      // 添加平滑过渡动画
      mapCanvas.style.transition = 'transform 0.5s cubic-bezier(0.4, 0, 0.2, 1)';

      // 重置缩放并居中到地图中心（即用户位置）
      this.mapState.scale = 1;
      const viewportWidth = mapArea.offsetWidth;
      const viewportHeight = mapArea.offsetHeight;
      this.mapState.translateX = -(viewportWidth * this.MAP_SIZE_MULTIPLIER - viewportWidth) / 2;
      this.mapState.translateY = -(viewportHeight * this.MAP_SIZE_MULTIPLIER - viewportHeight) / 2;
      this.updateMapTransform();

      // 短暂高亮用户标记
      const userMarker = mapCanvas.querySelector('.map-marker.current-user');
      if (userMarker) {
        userMarker.style.animation = 'none';
        setTimeout(() => {
          userMarker.style.animation = '';
        }, 10);
      }

      // 动画完成后移除过渡
      setTimeout(() => {
        mapCanvas.style.transition = 'none';
      }, 500);
    },

    zoomIn() {
      if (this.mapState.scale < this.MAX_ZOOM) {
        this.mapState.scale = Math.min(this.mapState.scale + this.ZOOM_STEP, this.MAX_ZOOM);
        this.clampMapPosition();
        this.updateMapTransform();
      }
    },

    zoomOut() {
      if (this.mapState.scale > this.MIN_ZOOM) {
        this.mapState.scale = Math.max(this.mapState.scale - this.ZOOM_STEP, this.MIN_ZOOM);
        this.clampMapPosition();
        this.updateMapTransform();
      }
    },

    // 按钮动作
    sendMessage() {
      const user = this.currentUsers.find(u => u.id === this.selectedUserId);
      if (user) {
        // 🔧 根据资料卡打开来源设置聊天上下文
        const source = this.detailCardOpenSource || 'map';

        if (source === 'interested') {
          // 从interested提醒打开的资料卡 → 对方先对你感兴趣
          this.chatContext[user.id] = 'interested_then_message';
          console.log(`🎯 [聊天上下文] ${user.nickname} - 对方先对你感兴趣，你回应私信`);
        } else {
          // 从地图或其他途径打开的资料卡 → 普通陌生人聊天
          this.chatContext[user.id] = 'normal';
          console.log(`🎯 [聊天上下文] ${user.nickname} - 普通陌生人聊天，初始好感度为0`);
        }

        this.openChatModal(user);
      }
    },

    viewProfile() {
      // 切换下拉菜单显示/隐藏
      const dropdown = document.getElementById('mapProfileDropdownMenu');
      if (!dropdown) return;

      dropdown.classList.toggle('show');
    },

    // 关闭下拉菜单
    closeProfileDropdown() {
      const dropdown = document.getElementById('mapProfileDropdownMenu');
      if (dropdown) {
        dropdown.classList.remove('show');
      }
    },

    // ==================== 动态(Moments)系统方法 ====================

    // Moments状态变量
    momentsCurrentIndex: 0,
    momentsStartX: 0,
    momentsCurrentX: 0,
    momentsDragging: false,
    momentsCurrentCommentMoment: null,

    // 打开动态弹窗
    openMomentsModal() {
      // 关闭下拉菜单
      this.closeProfileDropdown();

      const user = this.currentUsers.find(u => u.id === this.selectedUserId);
      if (!user) {
        user = this.allUsers.find(u => u.id == this.selectedUserId);
      }
      if (!user) return;

      const modal = document.getElementById('mapMomentsModal');
      const emptyState = document.getElementById('mapMomentsEmptyState');
      const cardsWrapper = document.getElementById('mapMomentsCardsWrapper');
      const indicator = document.getElementById('mapMomentsIndicator');

      if (!modal) return;

      // 获取用户的动态数据
      const moments = user.moments || [];

      if (moments.length === 0) {
        // 显示空状态
        if (emptyState) emptyState.style.display = 'flex';
        if (cardsWrapper) cardsWrapper.innerHTML = '';
        if (indicator) indicator.innerHTML = '';
      } else {
        // 显示动态卡片
        if (emptyState) emptyState.style.display = 'none';
        this.momentsCurrentIndex = 0;
        this.renderMomentsCards(moments);
        this.renderMomentsIndicator(moments);
      }

      // 显示弹窗
      modal.style.display = 'block';
      setTimeout(() => {
        modal.classList.add('active');
      }, 10);
    },

    // 关闭动态弹窗
    closeMomentsModal() {
      const modal = document.getElementById('mapMomentsModal');
      if (!modal) return;

      modal.classList.remove('active');
      setTimeout(() => {
        modal.style.display = 'none';
      }, 300);
    },

    // 渲染动态卡片
    renderMomentsCards(moments) {
      const cardsWrapper = document.getElementById('mapMomentsCardsWrapper');
      if (!cardsWrapper) return;

      cardsWrapper.innerHTML = '';

      moments.forEach((moment, index) => {
        const card = document.createElement('div');
        card.className = 'moment-card';
        card.dataset.index = index;
        card.dataset.position = index - this.momentsCurrentIndex;

        // 处理头像显示：如果是图片URL，用img标签；如果是文字，用div显示
        let avatarHTML;
        if (moment.userAvatar && (moment.userAvatar.startsWith('http://') || moment.userAvatar.startsWith('https://') || moment.userAvatar.startsWith('data:'))) {
          avatarHTML = `<img class="moment-user-avatar" src="${moment.userAvatar}" alt="${moment.userName || 'User'}">`;
        } else {
          const initials = moment.userAvatar || (moment.userName ? moment.userName.substring(0, 2).toUpperCase() : 'U');
          avatarHTML = `<div class="moment-user-avatar">${initials}</div>`;
        }

        card.innerHTML = `
          <div class="moment-card-image">
            ${moment.imageDescription ?
              `<div class="moment-card-text-image">
                <div class="text-image-content">${moment.imageDescription}</div>
                <div class="text-image-overlay"></div>
              </div>` :
              `<div class="moment-card-image-placeholder">NO IMAGE</div>`
            }
          </div>
          <div class="moment-card-content">
            <div class="moment-card-header">
              ${avatarHTML}
              <div class="moment-user-info">
                <div class="moment-username">${moment.userName || 'User'}</div>
                <div class="moment-time">${moment.time || 'Recently'}</div>
              </div>
            </div>
            <div class="moment-card-text">${moment.text || ''}</div>
            <div class="moment-card-stats">
              <div class="moment-stat-item">
                <span class="moment-stat-number">${moment.likes || 0}</span>
                <span>Likes</span>
              </div>
              <div class="moment-stat-item">
                <span class="moment-stat-number">${moment.comments || 0}</span>
                <span>Comments</span>
              </div>
              <div class="moment-stat-item">
                <span class="moment-stat-number">${moment.shares || 0}</span>
                <span>Shares</span>
              </div>
            </div>
            <div class="moment-card-actions">
              <button class="moment-action-btn moment-like-btn">
                <svg viewBox="0 0 24 24" fill="none">
                  <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                </svg>
                Like
              </button>
              <button class="moment-action-btn moment-comment-btn" data-moment-id="${moment.id || index}">
                <svg viewBox="0 0 24 24" fill="none">
                  <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                </svg>
                Comment
              </button>
              <button class="moment-action-btn moment-share-btn">
                <svg viewBox="0 0 24 24" fill="none">
                  <circle cx="18" cy="5" r="3"/>
                  <circle cx="6" cy="12" r="3"/>
                  <circle cx="18" cy="19" r="3"/>
                  <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
                  <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
                </svg>
                Share
              </button>
            </div>
          </div>
        `;

        cardsWrapper.appendChild(card);

        // 只为当前卡片添加事件
        if (index === this.momentsCurrentIndex) {
          this.setupMomentCardEvents(card, moments);
        }
      });

      this.updateMomentCardPositions();
    },

    // 设置卡片事件
    setupMomentCardEvents(card, moments) {
      // 点赞
      const likeBtn = card.querySelector('.moment-like-btn');
      if (likeBtn) {
        likeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          likeBtn.classList.toggle('active');
        });
      }

      // 评论
      const commentBtn = card.querySelector('.moment-comment-btn');
      if (commentBtn) {
        commentBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const momentId = commentBtn.dataset.momentId;
          this.openMomentsCommentsDrawer(moments, momentId);
        });
      }

      // 触摸/鼠标事件
      card.addEventListener('mousedown', (e) => this.handleMomentStart(e, moments));
      card.addEventListener('touchstart', (e) => this.handleMomentStart(e, moments), { passive: true });
    },

    // 开始拖动
    handleMomentStart(e, moments) {
      if (e.target.closest('.moment-action-btn')) {
        return;
      }

      this.momentsDragging = true;
      this.momentsStartX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
      this.momentsCurrentX = this.momentsStartX;

      document.addEventListener('mousemove', (e) => this.handleMomentMove(e));
      document.addEventListener('touchmove', (e) => this.handleMomentMove(e), { passive: false });
      document.addEventListener('mouseup', (e) => this.handleMomentEnd(e, moments));
      document.addEventListener('touchend', (e) => this.handleMomentEnd(e, moments));
    },

    // 拖动中
    handleMomentMove(e) {
      if (!this.momentsDragging) return;

      e.preventDefault();
      this.momentsCurrentX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
      const deltaX = this.momentsCurrentX - this.momentsStartX;
      const cardsWrapper = document.getElementById('mapMomentsCardsWrapper');
      const card = cardsWrapper?.querySelector(`[data-index="${this.momentsCurrentIndex}"]`);

      if (card) {
        const rotation = deltaX * 0.05;
        card.style.setProperty('--swipe-x', `${deltaX}px`);
        card.style.setProperty('--swipe-rotate', `${rotation}deg`);

        if (deltaX > 0) {
          card.className = 'moment-card swiping-right';
        } else {
          card.className = 'moment-card swiping-left';
        }
      }
    },

    // 结束拖动
    handleMomentEnd(e, moments) {
      if (!this.momentsDragging) return;

      this.momentsDragging = false;
      const deltaX = this.momentsCurrentX - this.momentsStartX;
      const threshold = 100;

      document.removeEventListener('mousemove', this.handleMomentMove);
      document.removeEventListener('touchmove', this.handleMomentMove);
      document.removeEventListener('mouseup', this.handleMomentEnd);
      document.removeEventListener('touchend', this.handleMomentEnd);

      const cardsWrapper = document.getElementById('mapMomentsCardsWrapper');
      const card = cardsWrapper?.querySelector(`[data-index="${this.momentsCurrentIndex}"]`);

      if (Math.abs(deltaX) > threshold) {
        if (deltaX < 0) {
          // 向左滑动 -> 下一条
          card.classList.add('removed-left');
          setTimeout(() => {
            if (this.momentsCurrentIndex < moments.length - 1) {
              this.momentsCurrentIndex++;
            } else {
              this.momentsCurrentIndex = 0; // 循环到第一条
            }
            this.renderMomentsCards(moments);
            this.renderMomentsIndicator(moments);
          }, 400);
        } else {
          // 向右滑动 -> 上一条
          card.classList.add('removed-right');
          setTimeout(() => {
            if (this.momentsCurrentIndex > 0) {
              this.momentsCurrentIndex--;
            } else {
              this.momentsCurrentIndex = moments.length - 1; // 循环到最后一条
            }
            this.renderMomentsCards(moments);
            this.renderMomentsIndicator(moments);
          }, 400);
        }
      } else {
        // 恢复位置
        card.style.setProperty('--swipe-x', '0');
        card.style.setProperty('--swipe-rotate', '0deg');
        card.className = 'moment-card';
        setTimeout(() => {
          card.dataset.position = '0';
        }, 50);
      }
    },

    // 更新卡片位置
    updateMomentCardPositions() {
      const cardsWrapper = document.getElementById('mapMomentsCardsWrapper');
      if (!cardsWrapper) return;

      const cards = cardsWrapper.querySelectorAll('.moment-card');
      cards.forEach(card => {
        const index = parseInt(card.dataset.index);
        const position = index - this.momentsCurrentIndex;
        card.dataset.position = position;
      });
    },

    // 渲染指示器
    renderMomentsIndicator(moments) {
      const indicator = document.getElementById('mapMomentsIndicator');
      if (!indicator) return;

      indicator.innerHTML = '';
      moments.forEach((_, index) => {
        const dot = document.createElement('div');
        dot.className = `moments-indicator-dot ${index === this.momentsCurrentIndex ? 'active' : ''}`;
        indicator.appendChild(dot);
      });
    },

    // 打开评论弹窗
    openMomentsCommentsDrawer(moments, momentId) {
      const moment = moments.find(m => (m.id || moments.indexOf(m)) == momentId);
      if (!moment) return;

      this.momentsCurrentCommentMoment = moment;

      const overlay = document.getElementById('mapMomentsCommentsOverlay');
      const drawer = document.getElementById('mapMomentsCommentsDrawer');
      const title = document.getElementById('mapMomentsCommentsTitle');
      const list = document.getElementById('mapMomentsCommentsList');

      if (!overlay || !drawer || !title || !list) return;

      // 更新标题
      title.textContent = `${moment.comments} Comments`;

      // 渲染评论列表
      const commentsList = moment.commentsList || [];
      list.innerHTML = commentsList.length > 0 ?
        commentsList.map(comment => {
          // 评论者头像处理：判断是图片URL还是文字
          let avatarHTML;
          if (comment.avatar && (comment.avatar.startsWith('http://') || comment.avatar.startsWith('https://') || comment.avatar.startsWith('data:'))) {
            // 图片URL头像
            avatarHTML = `<img class="moment-comment-avatar" src="${comment.avatar}" alt="${comment.user || 'User'}">`;
          } else {
            // 文字头像（字母或emoji）
            const avatarText = comment.avatar || (comment.user ? comment.user.substring(0, 1).toUpperCase() : '?');
            avatarHTML = `<div class="moment-comment-avatar">${avatarText}</div>`;
          }

          return `
            <div class="moment-comment-item">
              ${avatarHTML}
              <div class="moment-comment-content">
                <div class="moment-comment-user">${comment.user || comment.commenterName || 'User'}</div>
                <div class="moment-comment-text">${comment.text || comment.commentText || ''}</div>
                <div class="moment-comment-time">${comment.commentTime || comment.time || 'Recently'}</div>
              </div>
            </div>
          `;
        }).join('') :
        '<div style="text-align: center; color: #999; padding: 40px 20px; font-size: 14px;">No comments yet</div>';

      // 显示弹窗
      overlay.classList.add('show');
      requestAnimationFrame(() => {
        drawer.classList.add('show');
      });
    },

    // 关闭评论弹窗
    closeMomentsCommentsDrawer() {
      const overlay = document.getElementById('mapMomentsCommentsOverlay');
      const drawer = document.getElementById('mapMomentsCommentsDrawer');

      if (!drawer || !overlay) return;

      drawer.classList.remove('show');
      setTimeout(() => {
        overlay.classList.remove('show');
        this.momentsCurrentCommentMoment = null;
      }, 300);
    },

    // ==================== 社交圈系统方法 ====================

    // 显示社交圈弹窗
    showSocialCircle() {
      const modal = document.getElementById('mapSocialCircleModal');
      const emptyState = document.getElementById('mapSocialCircleEmpty');
      const list = document.getElementById('mapSocialCircleList');

      if (!modal || !emptyState || !list) return;

      // 获取当前用户的社交圈（先从currentUsers查找，如果没找到再从allUsers查找）
      // 使用宽松相等 == 以兼容数字ID和字符串ID
      let user = this.currentUsers.find(u => u.id == this.selectedUserId);
      if (!user) {
        user = this.allUsers.find(u => u.id == this.selectedUserId);
      }
      if (!user) return;

      const socialCircle = user.socialCircle || [];

      // 显示/隐藏empty state
      if (socialCircle.length === 0) {
        emptyState.style.display = 'flex';
        list.style.display = 'none';
      } else {
        emptyState.style.display = 'none';
        list.style.display = 'flex';

        // 渲染社交圈好友列表
        list.innerHTML = socialCircle
          .map(friend => {
            // 🔧 修复bio显示问题：显示完整bio，如果为空显示"No bio"
            const bioLines = friend.bio ? friend.bio.split('\n') : [];
            let bioText = 'No bio';
            if (bioLines.length > 1) {
              // 如果有多行，跳过第一行（年龄|感情状态），显示后续行
              bioText = bioLines.slice(1).join(' ').trim();
            } else if (bioLines.length === 1) {
              // 如果只有一行，直接显示
              bioText = bioLines[0].trim();
            }
            // 如果最终结果为空，显示"No bio"
            if (!bioText) {
              bioText = 'No bio';
            }

            // 关系类型映射
            const relationshipMap = {
              best_friend: 'Best Friend',
              lover: 'Lover',
              ex_lover: 'Ex-Lover',
              sibling: 'Sibling',
              cousin: 'Cousin',
              family: 'Family',
              friend: 'Friend',
              colleague: 'Colleague',
              classmate: 'Classmate',
              rival: 'Rival',
              frenemy: 'Frenemy',
              complicated: 'Complicated',
            };

            const relationshipText = relationshipMap[friend.relationship] || friend.relationship || 'Friend';

            // 🔧 修复handle重复@问题：检查handle是否已包含@
            const handleText = friend.handle.startsWith('@') ? friend.handle : `@${friend.handle}`;

            // 🔧 修复旧数据中的错误avatar字段：确保avatar是URL字符串，不是对象
            if (typeof friend.avatar === 'object' || !friend.avatar) {
              console.warn(`⚠️ [社交圈显示] ${friend.nickname} 的avatar字段异常，使用备用头像`);
              friend.avatar = this.getRandomAvatar();
            }

            // 🔧 修复旧数据中的错误avatarBubble字段：确保是字符串，不是对象
            if (friend.avatarBubble && typeof friend.avatarBubble === 'object') {
              friend.avatarBubble = friend.avatarBubble.emoji || '💖';
              console.warn(`⚠️ [社交圈显示] ${friend.nickname} 的avatarBubble是对象，已修正为: ${friend.avatarBubble}`);
            }

            return `
            <div class="map-social-circle-friend-card" data-friend-id="${friend.id}">
              <div class="map-social-circle-friend-header">
                <img class="map-social-circle-friend-avatar" src="${friend.avatar}" alt="${friend.nickname}">
                <div class="map-social-circle-friend-info">
                  <div class="map-social-circle-friend-name">${friend.nickname}</div>
                  <div class="map-social-circle-friend-handle">${handleText}</div>
                </div>
                <div class="map-social-circle-friend-relationship">${relationshipText}</div>
              </div>
              <div class="map-social-circle-friend-bio">${bioText}</div>
              <div class="map-social-circle-friend-stats">
                <div class="map-social-circle-friend-stat">
                  <span class="map-social-circle-friend-stat-value">${friend.followers || 0}</span>
                  <span>followers</span>
                </div>
                <div class="map-social-circle-friend-stat">
                  <span class="map-social-circle-friend-stat-value">${friend.likes || 0}</span>
                  <span>likes</span>
                </div>
                <div class="map-social-circle-friend-stat">
                  <span class="map-social-circle-friend-stat-value">${(friend.distance || 0).toFixed(1)}km</span>
                  <span>away</span>
                </div>
              </div>
            </div>
          `;
          })
          .join('');

        // 绑定好友卡片点击事件
        list.querySelectorAll('.map-social-circle-friend-card').forEach(card => {
          card.addEventListener('click', () => {
            const friendId = card.dataset.friendId;
            const friend = socialCircle.find(f => f.id === friendId);
            if (friend) {
              // 🔧 修复点击跳转问题：
              // 如果好友不在currentUsers或allUsers中，临时添加到currentUsers以便showDetailCard能找到
              let existsInCurrent = this.currentUsers.find(u => u.id == friendId);
              let existsInAll = this.allUsers.find(u => u.id == friendId);

              if (!existsInCurrent && !existsInAll) {
                console.log(`👥 [社交圈] 好友 ${friend.nickname} 不在用户列表中，临时添加到currentUsers`);
                this.currentUsers.push(friend);
              }

              // 显示好友的资料卡片（从社交圈打开）
              this.showDetailCard(friend.id, 'socialCircle');
              this.hideSocialCircle();
            }
          });
        });
      }

      // 显示弹窗
      modal.style.display = 'flex';
    },

    // 隐藏社交圈弹窗
    hideSocialCircle() {
      const modal = document.getElementById('mapSocialCircleModal');
      if (modal) {
        modal.style.display = 'none';
      }
    },

    // ==================== 聊天系统方法 ====================

    // 打开聊天弹窗
    async openChatModal(user) {
      this.currentChatUser = user;

      // 🔧 关闭资料弹窗（防止弹窗堆叠）
      this.closeDetailCard();

      // 设置顶栏信息
      const chatUserAvatar = document.getElementById('mapChatUserAvatar');
      const chatUserName = document.getElementById('mapChatUserName');
      if (chatUserAvatar) chatUserAvatar.src = user.avatar;
      if (chatUserName) chatUserName.textContent = user.nickname;

      // 📥 尝试从数据库加载聊天记录和好感度数据
      const chatId = `mapChat_${user.id}_${currentAccountId || 'main'}`;
      const xDb = getXDB();
      let loadedFromDb = false;

      if (xDb) {
        try {
          const chatRecord = await xDb.xMapChats.get(chatId);
          if (chatRecord) {
            // 从数据库加载消息
            this.chatMessages[user.id] = chatRecord.messages || [];
            loadedFromDb = true;
            console.log(
              `📥 [聊天记录] 已从数据库加载 ${user.nickname} 的聊天记录 (${this.chatMessages[user.id].length} 条消息)`,
            );

            // 💖 从数据库加载好感度数据
            if (chatRecord.affectionData) {
              this.chatAffectionData[user.id] = chatRecord.affectionData;
              console.log(
                `💖 [好感度系统] 已从数据库加载 ${
                  user.nickname
                } 的好感度数据 (好感度: ${chatRecord.affectionData.affection.toFixed(1)}/100)`,
              );
            }

            // 📝 从数据库加载AI笔记数据
            if (chatRecord.notes) {
              this.chatNotes[user.id] = chatRecord.notes;
              const notesCount = Object.keys(chatRecord.notes).length;
              if (notesCount > 0) {
                console.log(
                  `📝 [AI笔记系统] 已从数据库加载 ${user.nickname} 的笔记 (${notesCount}条: ${Object.keys(
                    chatRecord.notes,
                  ).join('、')})`,
                );
              }
            }

            // 📌 从数据库加载用户标记的笔记
            if (chatRecord.userMarkedNotes) {
              this.userMarkedNotes[user.id] = chatRecord.userMarkedNotes;
              if (chatRecord.userMarkedNotes.length > 0) {
                console.log(
                  `📌 [用户笔记系统] 已从数据库加载 ${user.nickname} 的用户笔记 (${chatRecord.userMarkedNotes.length}条)`,
                );
              }
            }

            // 💭 从数据库加载NPC对用户的观察笔记
            if (chatRecord.npcNotesAboutUser) {
              this.npcNotesAboutUser[user.id] = chatRecord.npcNotesAboutUser;
              if (chatRecord.npcNotesAboutUser.length > 0) {
                console.log(
                  `💭 [NPC观察笔记] 已从数据库加载 ${user.nickname} 对你的观察笔记 (${chatRecord.npcNotesAboutUser.length}条)`,
                );
              }
            }
          }
        } catch (error) {
          console.error('❌ [聊天记录] 从数据库加载失败:', error);
        }
      }

      // 如果数据库中没有记录，初始化空消息数组
      if (!loadedFromDb && !this.chatMessages[user.id]) {
        this.chatMessages[user.id] = [];
        console.log(`📝 [聊天记录] 已初始化 ${user.nickname} 的空白聊天记录`);
      }

      // 初始化好感度数据（如果不存在）
      if (!this.chatAffectionData[user.id]) {
        this.chatAffectionData[user.id] = this.calculateAffectionParameters(user);

        // 🎯 根据聊天发起上下文设置初始好感度
        const context = this.chatContext[user.id] || 'normal';
        if (context === 'interested_then_message') {
          // 对方先感兴趣，设置初始好感度 15-25
          this.chatAffectionData[user.id].affection = 15 + Math.random() * 10;
          console.log(
            `💖 [好感度系统] ${user.nickname} 先对你感兴趣，设置初始好感度: ${this.chatAffectionData[
              user.id
            ].affection.toFixed(1)}`,
          );
        } else if (context === 'message_accepted') {
          // 对方主动发私信，设置初始好感度 20-30
          this.chatAffectionData[user.id].affection = 20 + Math.random() * 10;
          console.log(
            `💖 [好感度系统] ${user.nickname} 主动发起私信，设置初始好感度: ${this.chatAffectionData[
              user.id
            ].affection.toFixed(1)}`,
          );
        } else {
          console.log(`💖 [好感度系统] ${user.nickname} 普通聊天，初始好感度: 0`);
        }

        console.log(
          `💖 [好感度系统] 已初始化 ${user.nickname} 的好感度数据 (好感度: ${this.chatAffectionData[
            user.id
          ].affection.toFixed(1)}, 阈值: ${this.chatAffectionData[user.id].threshold}, 增长率: ${this.chatAffectionData[
            user.id
          ].growthRate.toFixed(2)}x)`,
        );
      }

      // 初始化AI笔记数据（如果不存在）
      if (!this.chatNotes[user.id]) {
        this.chatNotes[user.id] = {};
        console.log(`📝 [AI笔记系统] 已初始化 ${user.nickname} 的笔记数据（空白人设）`);
      }

      // 📌 初始化用户标记笔记数据（如果不存在）
      if (!this.userMarkedNotes[user.id]) {
        this.userMarkedNotes[user.id] = [];
        console.log(`📌 [用户笔记系统] 已初始化 ${user.nickname} 的用户笔记数据（空白）`);
      }

      // 💭 初始化NPC观察笔记数据（如果不存在）
      if (!this.npcNotesAboutUser[user.id]) {
        this.npcNotesAboutUser[user.id] = [];
        console.log(`💭 [NPC观察笔记] 已初始化 ${user.nickname} 对你的观察笔记数据（空白）`);
      }

      // 渲染消息
      this.renderChatMessages();

      // 显示弹窗
      const chatOverlay = document.getElementById('mapChatOverlay');
      const chatModal = document.getElementById('mapChatModal');
      if (chatOverlay) chatOverlay.classList.add('show');
      if (chatModal) chatModal.classList.add('show');

      // 🔧 检查该用户是否被举报中，决定是否启用输入框
      this.checkAndUpdateChatInputState(user.id);

      // 🔞 检测对方年龄，如果<18则显示系统提醒
      this.checkMinorWarning(user);

      // 滚动到底部
      setTimeout(() => {
        const chatMessages = document.getElementById('mapChatMessages');
        if (chatMessages) {
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }, 100);
    },

    // 🔞 检测未成年人并显示警告
    checkMinorWarning(user) {
      // 如果已经有聊天记录，说明不是第一次打开，不重复提示
      if (this.chatMessages[user.id] && this.chatMessages[user.id].length > 0) {
        return;
      }

      // 从用户bio中提取年龄
      const age = this.extractAgeFromBio(user.bio);

      if (age !== null && age < 18) {
        console.log(`🔞 [未成年人警告] 检测到 ${user.nickname} 年龄为 ${age}岁，显示系统警告`);
        this.addSystemMessage(
          `Notice: This user is under 18 years old. Please be mindful of your language and behavior.`,
        );
      }
    },

    // 从bio中提取年龄
    extractAgeFromBio(bio) {
      if (!bio) return null;

      // 匹配各种年龄格式：
      // "18岁" "18 years old" "Age: 18" "age 18" "18yo" "18 y.o."
      const agePatterns = [
        /(\d{1,2})\s*岁/i, // 18岁
        /(\d{1,2})\s*years?\s*old/i, // 18 years old
        /age[:\s]+(\d{1,2})/i, // Age: 18 或 age 18
        /(\d{1,2})\s*yo\b/i, // 18yo
        /(\d{1,2})\s*y\.?o\.?/i, // 18 y.o.
        /\b(\d{1,2})\s*(?:歳|才)/i, // 18歳
        /^(\d{1,2})$/, // 纯数字（如果bio只有数字）
      ];

      for (const pattern of agePatterns) {
        const match = bio.match(pattern);
        if (match) {
          const age = parseInt(match[1]);
          // 合理年龄范围：10-99
          if (age >= 10 && age <= 99) {
            console.log(`🔍 [年龄提取] 从bio "${bio}" 中提取到年龄: ${age}`);
            return age;
          }
        }
      }

      return null;
    },

    // 关闭聊天弹窗
    closeChatModal() {
      const chatOverlay = document.getElementById('mapChatOverlay');
      const chatModal = document.getElementById('mapChatModal');
      if (chatOverlay) chatOverlay.classList.remove('show');
      if (chatModal) chatModal.classList.remove('show');

      // 关闭功能菜单和笔记弹窗
      this.closeFunctionMenu();
      this.closeNotesModal();

      this.currentChatUser = null;
    },

    // ==================== 📌 聊天列表功能方法 ====================

    // 切换More options菜单
    toggleMoreMenu() {
      const menu = document.getElementById('mapChatMoreMenu');
      if (!menu) return;

      const isOpen = menu.classList.contains('show');
      if (isOpen) {
        menu.classList.remove('show');
      } else {
        menu.classList.add('show');
        // 点击其他地方关闭菜单
        setTimeout(() => {
          const closeMenu = e => {
            if (!menu.contains(e.target) && !document.getElementById('mapChatMoreBtn').contains(e.target)) {
              menu.classList.remove('show');
              document.removeEventListener('click', closeMenu);
            }
          };
          document.addEventListener('click', closeMenu);
        }, 100);
      }
    },

    // 添加当前聊天到列表
    addCurrentChatToList() {
      if (!this.currentChatUser) {
        console.log('没有当前聊天对象');
        return;
      }

      try {
        // 从localStorage读取已保存的聊天列表
        const savedChatsStr = localStorage.getItem('xMapSavedChats');
        const savedChats = savedChatsStr ? JSON.parse(savedChatsStr) : [];

        // 检查是否已存在
        const exists = savedChats.some(chat => chat.id === this.currentChatUser.id);

        if (exists) {
          console.log('该聊天已在列表中');
          return;
        }

        // 保存聊天
        const chatData = {
          id: this.currentChatUser.id,
          name: this.currentChatUser.nickname, // 修正：使用nickname字段
          avatar: this.currentChatUser.avatar,
          lastMessage: 'Start chatting...',
          savedAt: Date.now(),
          userData: this.currentChatUser, // 保存完整用户数据
        };

        savedChats.push(chatData);
        localStorage.setItem('xMapSavedChats', JSON.stringify(savedChats));

        console.log('已添加到聊天列表:', chatData.name);

        // 关闭More options菜单
        const menu = document.getElementById('mapChatMoreMenu');
        if (menu) menu.classList.remove('show');
      } catch (error) {
        console.error('添加到聊天列表失败:', error);
      }
    },

    // 打开聊天列表弹窗
    openChatsListModal() {
      const overlay = document.getElementById('mapChatsListOverlay');
      const modal = document.getElementById('mapChatsListModal');

      if (overlay) overlay.classList.add('show');
      if (modal) modal.classList.add('show');

      // 加载并渲染聊天列表
      this.loadAndRenderChatsList();
    },

    // 关闭聊天列表弹窗
    closeChatsListModal() {
      const overlay = document.getElementById('mapChatsListOverlay');
      const modal = document.getElementById('mapChatsListModal');

      if (overlay) overlay.classList.remove('show');
      if (modal) modal.classList.remove('show');
    },

    // ==========================================
    // 🔔 提醒功能相关方法
    // ==========================================

    // 打开提醒弹窗
    async openNotificationsModal() {
      const overlay = document.getElementById('mapNotificationsOverlay');
      const modal = document.getElementById('mapNotificationsModal');

      if (overlay) overlay.classList.add('show');
      if (modal) modal.classList.add('show');

      // 🔧 先加载并渲染提醒列表（显示正确的unread计数）
      await this.loadAndRenderNotificationsList();

      // 🔧 然后标记所有提醒为已读并更新徽章（避免竞态条件）
      await this.markAllNotificationsAsRead();
    },

    // 关闭提醒弹窗
    closeNotificationsModal() {
      const overlay = document.getElementById('mapNotificationsOverlay');
      const modal = document.getElementById('mapNotificationsModal');

      if (overlay) overlay.classList.remove('show');
      if (modal) modal.classList.remove('show');
    },

    // ==========================================
    // ⚙️ 应用设置功能相关方法
    // ==========================================

    // 打开应用设置弹窗
    openAppSettingsModal() {
      const overlay = document.getElementById('mapAppSettingsOverlay');
      const modal = document.getElementById('mapAppSettingsModal');

      if (overlay) overlay.classList.add('show');
      if (modal) modal.classList.add('show');

      // 同步当前主题状态到开关UI
      this.syncThemeToggleUI();

      // 🖼️ 渲染自定义头像列表
      this.renderCustomAvatarList();
    },

    // 关闭应用设置弹窗
    closeAppSettingsModal() {
      const overlay = document.getElementById('mapAppSettingsOverlay');
      const modal = document.getElementById('mapAppSettingsModal');

      if (overlay) overlay.classList.remove('show');
      if (modal) modal.classList.remove('show');
    },

    // 切换主题
    toggleTheme() {
      const container = document.getElementById('x-map-container');
      if (!container) {
        console.error('❌ [主题切换] 找不到容器 #x-map-container');
        return;
      }

      // 切换主题类
      const isLightTheme = container.classList.toggle('light-theme');

      // 保存到localStorage
      try {
        localStorage.setItem('xMapTheme', isLightTheme ? 'light' : 'dark');
        console.log(`✅ [主题切换] 已切换到${isLightTheme ? '亮色' : '暗色'}主题`);
      } catch (error) {
        console.error('❌ [主题切换] 保存主题设置失败:', error);
      }

      // 更新地图主题并重绘
      if (typeof MapGenerator !== 'undefined' && MapGenerator.setTheme) {
        MapGenerator.setTheme(isLightTheme);
        MapGenerator.redraw();
      }

      // 更新开关UI
      this.syncThemeToggleUI();
    },

    // 同步主题开关UI状态
    syncThemeToggleUI() {
      const container = document.getElementById('x-map-container');
      const toggle = document.getElementById('mapThemeToggle');
      const icon = toggle?.querySelector('.map-theme-toggle-icon');

      if (!container || !toggle || !icon) return;

      const isLightTheme = container.classList.contains('light-theme');

      // 更新开关样式
      if (isLightTheme) {
        toggle.classList.add('light');
      } else {
        toggle.classList.remove('light');
      }

      // 更新图标（月亮图标用于暗色模式，太阳图标用于亮色模式）
      if (isLightTheme) {
        // 太阳图标
        icon.innerHTML =
          '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>';
      } else {
        // 月亮图标
        icon.innerHTML = '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>';
      }
    },

    // 初始化主题设置（从localStorage加载）
    initThemeSettings() {
      try {
        const savedTheme = localStorage.getItem('xMapTheme');
        const container = document.getElementById('x-map-container');

        if (!container) {
          console.warn('⚠️ [主题初始化] 找不到容器 #x-map-container');
          return;
        }

        const isLightTheme = savedTheme === 'light';

        // 如果保存了亮色主题，则应用
        if (isLightTheme) {
          container.classList.add('light-theme');
          console.log('✅ [主题初始化] 已加载亮色主题');
        } else {
          // 默认暗色主题，移除亮色类（如果有）
          container.classList.remove('light-theme');
          console.log('✅ [主题初始化] 已加载暗色主题');
        }

        // 更新地图主题（如果地图已初始化）
        if (typeof MapGenerator !== 'undefined' && MapGenerator.setTheme && MapGenerator.ctx) {
          MapGenerator.setTheme(isLightTheme);
          MapGenerator.redraw();
        }

        // 同步UI状态
        this.syncThemeToggleUI();
      } catch (error) {
        console.error('❌ [主题初始化] 加载主题设置失败:', error);
      }
    },

    // ==========================================
    // 🚗 城市乘车功能
    // ==========================================

    // 初始化乘车模式状态
    initRideMode() {
      this.rideMode = false; // 是否在乘车模式
      this.rideSelectingDestination = false; // 是否正在选择目的地
      this.rideSelectedDestination = null; // 已选目的地
      this.rideVehicleMarkers = []; // 地图上的车辆标记

      console.log('🚗 [乘车功能] 初始化完成');
    },

    // 打开乘车面板
    openRidePanel() {
      console.log('🚗 [乘车功能] 打开乘车面板');

      // 艹，确保状态已初始化
      if (!this.rideVehicleMarkers) {
        this.rideVehicleMarkers = [];
      }

      // 设置乘车模式
      this.rideMode = true;

      // 显示面板和遮罩
      const panel = document.getElementById('ridePanel');
      const overlay = document.getElementById('ridePanelOverlay');

      if (panel) {
        panel.classList.add('show');
        panel.classList.remove('hide');
      }

      if (overlay) {
        overlay.classList.add('show');
      }

      // 生成随机车辆标记在地图上
      this.generateVehicleMarkers();

      console.log('✅ [乘车功能] 面板已打开');
    },

    // 关闭乘车面板
    closeRidePanel() {
      console.log('🚗 [乘车功能] 关闭乘车面板');

      // 退出乘车模式
      this.rideMode = false;
      this.rideSelectingDestination = false;

      // 隐藏面板和遮罩
      const panel = document.getElementById('ridePanel');
      const overlay = document.getElementById('ridePanelOverlay');
      const hint = document.getElementById('rideSelectionHint');

      if (panel) {
        panel.classList.remove('show');
        panel.classList.add('hide');
      }

      if (overlay) {
        overlay.classList.remove('show');
      }

      if (hint) {
        hint.classList.remove('show');
      }

      // 移除所有车辆标记
      this.clearVehicleMarkers();

      // 清除路线
      this.clearRideRoute();

      // 重置选中的目的地
      if (this.rideSelectedDestination) {
        const landmarkLabel = document.getElementById(this.rideSelectedDestination.id);
        if (landmarkLabel) {
          landmarkLabel.classList.remove('ride-destination-selected');
        }
        this.rideSelectedDestination = null;
      }

      // 重置UI
      this.resetRideUI();

      console.log('✅ [乘车功能] 面板已关闭');
    },

    // 开始选择目的地
    startSelectingDestination() {
      console.log('🚗 [乘车功能] 开始选择目的地');

      this.rideSelectingDestination = true;

      // 高亮目的地框
      const destBox = document.getElementById('rideDestinationBox');
      if (destBox) {
        destBox.classList.add('selecting');
      }

      // 显示选择提示
      const hint = document.getElementById('rideSelectionHint');
      if (hint) {
        hint.classList.add('show');
      }

      // 隐藏面板让用户可以选择地标
      const panel = document.getElementById('ridePanel');
      if (panel) {
        panel.classList.add('hide');
        panel.classList.remove('show');
      }

      // 艹，也要隐藏遮罩层，不然会挡住地标！
      const overlay = document.getElementById('ridePanelOverlay');
      if (overlay) {
        overlay.classList.remove('show');
      }
    },

    // 选择目的地
    selectRideDestination(landmark) {
      console.log('🚗 [乘车功能] 选择目的地:', landmark.name);

      // 移除之前选中的目的地高亮
      if (this.rideSelectedDestination) {
        const prevLabel = document.getElementById(this.rideSelectedDestination.id);
        if (prevLabel) {
          prevLabel.classList.remove('ride-destination-selected');
        }
      }

      // 设置新目的地
      this.rideSelectedDestination = landmark;
      this.rideSelectingDestination = false;

      // 添加选中高亮
      const landmarkLabel = document.getElementById(landmark.id);
      if (landmarkLabel) {
        landmarkLabel.classList.add('ride-destination-selected');
      }

      // 更新UI
      const destValue = document.getElementById('rideDestinationValue');
      const destBox = document.getElementById('rideDestinationBox');
      const hint = document.getElementById('rideSelectionHint');

      if (destValue) {
        destValue.textContent = landmark.name;
        destValue.classList.remove('placeholder');
      }

      if (destBox) {
        destBox.classList.remove('selecting');
      }

      if (hint) {
        hint.classList.remove('show');
      }

      // 计算距离和更新价格
      this.calculateAndUpdateRoute();

      // 重新显示面板和遮罩层
      const panel = document.getElementById('ridePanel');
      const overlay = document.getElementById('ridePanelOverlay');
      if (panel) {
        setTimeout(() => {
          panel.classList.add('show');
          panel.classList.remove('hide');

          // 艹，也要重新显示遮罩层
          if (overlay) {
            overlay.classList.add('show');
          }
        }, 300);
      }
    },

    // 计算距离并更新路线
    calculateAndUpdateRoute() {
      if (!this.rideSelectedDestination) return;

      console.log('🚗 [乘车功能] 计算路线和价格');

      // 地图中心点作为当前位置 (50%, 50%)
      const currentPos = { x: 50, y: 50 };
      const destPos = {
        x: (this.rideSelectedDestination.x / window.innerWidth) * 100,
        y: (this.rideSelectedDestination.y / window.innerHeight) * 100
      };

      // 计算欧几里得距离
      const dx = destPos.x - currentPos.x;
      const dy = destPos.y - currentPos.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      // 转换为预计时间（假设 1% 距离 ≈ 0.5 分钟）
      const estimatedMinutes = Math.max(Math.round(distance * 0.5), 1);

      // 更新预计时间显示
      const timeElement = document.getElementById('rideEstimatedTime');
      if (timeElement) {
        timeElement.textContent = `${estimatedMinutes} min`;
      }

      // 更新所有车型价格
      const vehicleCards = document.querySelectorAll('.ride-vehicle-card');
      vehicleCards.forEach(card => {
        const basePrice = parseFloat(card.dataset.basePrice);
        const rate = parseFloat(card.dataset.rate);
        const finalPrice = Math.round(basePrice + (estimatedMinutes * rate));

        const priceValue = card.querySelector('.ride-price-value');
        if (priceValue) {
          priceValue.textContent = finalPrice;
        }
      });

      // 绘制路线
      this.drawRideRoute(currentPos, destPos);

      // 启用预订按钮
      const bookBtn = document.getElementById('rideBookBtn');
      if (bookBtn) {
        bookBtn.disabled = false;
        bookBtn.textContent = '立即预订';
      }

      console.log(`✅ [乘车功能] 路线计算完成 - 预计 ${estimatedMinutes} 分钟`);
    },

    // 绘制乘车路线
    drawRideRoute(start, end) {
      // 清除之前的路线
      this.clearRideRoute();

      const mapCanvas = document.querySelector('.map-canvas');
      if (!mapCanvas) return;

      // 创建SVG容器
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.classList.add('ride-route-svg');
      svg.id = 'rideRouteSvg';
      svg.setAttribute('viewBox', '0 0 100 100');
      svg.setAttribute('preserveAspectRatio', 'none');

      // 计算控制点（随机弯曲）
      const midX = (start.x + end.x) / 2;
      const midY = (start.y + end.y) / 2;
      const offsetX = (Math.random() - 0.5) * 20;
      const offsetY = (Math.random() - 0.5) * 20;
      const controlX = midX + offsetX;
      const controlY = midY + offsetY;

      // 创建路径
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.classList.add('ride-route-path');
      path.setAttribute('d', `M ${start.x},${start.y} Q ${controlX},${controlY} ${end.x},${end.y}`);

      svg.appendChild(path);
      mapCanvas.appendChild(svg);

      console.log('✅ [乘车功能] 路线已绘制');
    },

    // 清除乘车路线
    clearRideRoute() {
      const routeSvg = document.getElementById('rideRouteSvg');
      if (routeSvg) {
        routeSvg.remove();
      }
    },

    // 生成随机车辆标记
    generateVehicleMarkers() {
      this.clearVehicleMarkers();

      const mapCanvas = document.querySelector('.map-canvas');
      if (!mapCanvas) return;

      const vehicleCount = Math.floor(Math.random() * 4) + 5; // 5-8个车辆

      const vehicleSvg = `
        <svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
          <ellipse cx="32" cy="52" rx="18" ry="4" fill="currentColor" opacity="0.15"/>
          <path d="M 16,38 L 12,32 L 12,20 L 20,14 L 44,14 L 52,20 L 52,32 L 48,38 Z" fill="currentColor" opacity="0.3"/>
          <ellipse cx="20" cy="38" rx="6" ry="6" fill="currentColor" opacity="0.6"/>
          <ellipse cx="44" cy="38" rx="6" ry="6" fill="currentColor" opacity="0.6"/>
          <rect x="18" y="10" width="28" height="16" rx="3" fill="currentColor" opacity="0.4"/>
          <rect x="24" y="6" width="16" height="6" rx="1.5" fill="currentColor" opacity="0.5"/>
        </svg>
      `;

      for (let i = 0; i < vehicleCount; i++) {
        const vehicle = document.createElement('div');
        vehicle.classList.add('ride-vehicle-marker');

        // 随机位置（避免中心区域）
        let x, y, tooClose;
        do {
          x = Math.random() * 80 + 10; // 10%-90%
          y = Math.random() * 80 + 10;

          // 检查距离中心的距离
          const distFromCenter = Math.sqrt(
            Math.pow(x - 50, 2) + Math.pow(y - 50, 2)
          );

          tooClose = distFromCenter < 15; // 至少距离中心15%
        } while (tooClose);

        vehicle.style.left = `${x}%`;
        vehicle.style.top = `${y}%`;
        vehicle.style.animationDelay = `${Math.random() * 2}s`;
        vehicle.innerHTML = vehicleSvg;

        mapCanvas.appendChild(vehicle);
        this.rideVehicleMarkers.push(vehicle);
      }

      console.log(`✅ [乘车功能] 生成了 ${vehicleCount} 个车辆标记`);
    },

    // 清除车辆标记
    clearVehicleMarkers() {
      // 艹，确保数组存在
      if (!this.rideVehicleMarkers) {
        this.rideVehicleMarkers = [];
        return;
      }
      this.rideVehicleMarkers.forEach(marker => marker.remove());
      this.rideVehicleMarkers = [];
    },

    // 选择车型
    selectVehicle(card) {
      // 移除其他卡片的选中状态
      document.querySelectorAll('.ride-vehicle-card').forEach(c => {
        c.classList.remove('selected');
      });

      // 选中当前卡片
      card.classList.add('selected');

      console.log('🚗 [乘车功能] 选择车型:', card.dataset.type);
    },

    // 选择支付方式
    selectPaymentOption(option) {
      // 移除其他选项的选中状态
      document.querySelectorAll('.ride-payment-option').forEach(o => {
        o.classList.remove('selected');
      });

      // 选中当前选项
      option.classList.add('selected');

      console.log('🚗 [乘车功能] 选择支付方式:', option.dataset.payment);
    },

    // 预订乘车
    async bookRide() {
      if (!this.rideSelectedDestination) {
        alert('请先选择目的地');
        return;
      }

      const selectedVehicle = document.querySelector('.ride-vehicle-card.selected');
      const selectedPayment = document.querySelector('.ride-payment-option.selected');

      if (!selectedVehicle || !selectedPayment) {
        alert('请选择车型和支付方式');
        return;
      }

      const vehicleType = selectedVehicle.querySelector('.ride-vehicle-name').textContent;
      const originalPrice = parseFloat(selectedVehicle.querySelector('.ride-price-value').textContent);
      const destination = this.rideSelectedDestination.name;
      const time = document.getElementById('rideEstimatedTime').textContent;
      const paymentType = selectedPayment.dataset.payment; // 'cash' 或 'online'
      const paymentName = paymentType === 'cash' ? '现金' : '在线支付';

      const bookBtn = document.getElementById('rideBookBtn');
      if (bookBtn) {
        bookBtn.textContent = '处理中...';
        bookBtn.style.opacity = '0.7';
      }

      try {
        // 计算最终价格（在线支付可能有折扣）
        let finalPrice = originalPrice;
        let discountPercent = 0;
        let hasDiscount = false;

        if (paymentType === 'online') {
          // 30%概率获得10%-20%随机折扣
          if (Math.random() < 0.3) {
            hasDiscount = true;
            discountPercent = Math.floor(Math.random() * 11) + 10; // 10-20
            finalPrice = originalPrice * (1 - discountPercent / 100);
            console.log(`🎉 [乘车功能] 在线支付获得${discountPercent}%折扣！原价¥${originalPrice} → 实付¥${finalPrice.toFixed(2)}`);
          }
        }

        console.log('🚗 [乘车功能] 预订信息:', {
          vehicleType,
          originalPrice,
          finalPrice,
          discountPercent,
          destination,
          time,
          paymentName
        });

        // 在线支付需要扣除钱包金额
        if (paymentType === 'online') {
          // 艹，加载钱包数据
          if (typeof loadWalletData === 'function' && typeof saveWalletData === 'function') {
            await loadWalletData();

            if (!walletData.isActivated) {
              alert('请先激活钱包才能使用在线支付');
              if (bookBtn) {
                bookBtn.textContent = '立即预订';
                bookBtn.style.opacity = '1';
              }
              return;
            }

            if (walletData.balance < finalPrice) {
              alert(`余额不足！当前余额：$${walletData.balance.toFixed(2)}，需要：$${finalPrice.toFixed(2)}`);
              if (bookBtn) {
                bookBtn.textContent = '立即预订';
                bookBtn.style.opacity = '1';
              }
              return;
            }

            // 扣除金额
            walletData.balance -= finalPrice;

            // 创建交易记录
            const transaction = {
              id: 'ride_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
              description: hasDiscount
                ? `City Ride to ${destination} (${discountPercent}% Off)`
                : `City Ride to ${destination}`,
              amount: -finalPrice,
              timestamp: new Date().toISOString(),
              type: 'ride_payment',
            };
            walletData.transactions.unshift(transaction);
            await saveWalletData();

            console.log(`💰 [乘车功能] 已扣除$${finalPrice.toFixed(2)}，当前余额: $${walletData.balance.toFixed(2)}`);
          } else {
            console.warn('⚠️ [乘车功能] 钱包函数未定义，跳过扣款');
          }
        }

        // 显示手机样式通知
        if (typeof showPhoneNotification === 'function') {
          let message = '';
          if (paymentType === 'online') {
            message = hasDiscount
              ? `-$${finalPrice.toFixed(2)} (${discountPercent}% Off). Balance: $${walletData.balance.toFixed(2)}`
              : `-$${finalPrice.toFixed(2)}. Balance: $${walletData.balance.toFixed(2)}`;
          } else {
            message = `Cash Payment ¥${finalPrice.toFixed(2)}. Driver arriving in ${time}.`;
          }

          showPhoneNotification({
            title: 'Ride Booked',
            message: `${vehicleType} → ${destination}. ${message}`,
            avatar: window.userProfileData?.avatar,
            leftIcon: 'x',
            duration: 5000,
          });
        }

        // 等待一下再关闭面板
        setTimeout(() => {
          if (bookBtn) {
            bookBtn.textContent = '立即预订';
            bookBtn.style.opacity = '1';
          }

          // 关闭面板
          this.closeRidePanel();

          // 创建订单并显示悬浮小球
          this.createRideOrder(vehicleType, finalPrice, destination);

          console.log('✅ [乘车功能] 预订成功');
        }, 1000);

      } catch (error) {
        console.error('❌ [乘车功能] 预订失败:', error);
        alert('预订失败，请重试');

        if (bookBtn) {
          bookBtn.textContent = '立即预订';
          bookBtn.style.opacity = '1';
        }
      }
    },

    // ==================== 等待司机功能 ====================

    // 订单localStorage存储
    saveRideOrder(orderData) {
      try {
        localStorage.setItem('x_ride_order', JSON.stringify(orderData));
        console.log('✅ [等待司机] 订单已保存', orderData);
      } catch (error) {
        console.error('❌ [等待司机] 保存订单失败:', error);
      }
    },

    loadRideOrder() {
      try {
        const data = localStorage.getItem('x_ride_order');
        return data ? JSON.parse(data) : null;
      } catch (error) {
        console.error('❌ [等待司机] 加载订单失败:', error);
        return null;
      }
    },

    clearRideOrder() {
      try {
        localStorage.removeItem('x_ride_order');
        console.log('✅ [等待司机] 订单已清除');
      } catch (error) {
        console.error('❌ [等待司机] 清除订单失败:', error);
      }
    },

    // 生成随机司机数据
    generateDriverData() {
      const names = ['Ethan', 'James', 'Sophia', 'Mason', 'Lucas', 'Oliver', 'Emma', 'Ava', 'Liam', 'Noah'];
      const vehicles = ['Skoda Fabla', 'Ford Focus', 'BMW X5', 'Opel Vectra', 'Audi A4', 'Mercedes Benz', 'Toyota Camry'];
      const generatePlate = () => {
        const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const numbers = '0123456789';
        return letters[Math.floor(Math.random() * 26)] +
               letters[Math.floor(Math.random() * 26)] +
               numbers[Math.floor(Math.random() * 10)] +
               numbers[Math.floor(Math.random() * 10)] +
               numbers[Math.floor(Math.random() * 10)] +
               numbers[Math.floor(Math.random() * 10)] +
               letters[Math.floor(Math.random() * 26)] +
               numbers[Math.floor(Math.random() * 10)];
      };

      const name = names[Math.floor(Math.random() * names.length)];
      const vehicle = vehicles[Math.floor(Math.random() * vehicles.length)];
      const initial = name.charAt(0);

      return {
        name,
        rating: (4.5 + Math.random() * 0.5).toFixed(1),
        vehicle,
        plate: generatePlate(),
        avatar: `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64'%3E%3Crect fill='%23d5d5d5' width='64' height='64'/%3E%3Ctext x='50%25' y='50%25' fill='%23666' text-anchor='middle' dy='.3em' font-size='24' font-family='Arial'%3E${initial}%3C/text%3E%3C/svg%3E`
      };
    },

    // 计算预计到达时间（金额越大，时间越短）
    calculateEstimatedTime(distance, price) {
      // 基础速度30km/h，时间=距离/速度*60分钟
      const baseTimeMinutes = (distance / 30) * 60;
      // 价格系数：每100元减少20%时间，最多减少50%
      const priceCoefficient = Math.min(0.5, (price / 100) * 0.2);
      // 最终时间
      const finalTimeMinutes = Math.max(1, baseTimeMinutes * (1 - priceCoefficient));
      return Math.ceil(finalTimeMinutes * 60); // 返回秒数
    },

    // 初始化等待司机功能（在init中调用）
    initWaitingDriver() {
      console.log('🔧 [等待司机] 初始化等待司机功能');
      const floatBtn = document.getElementById('waitingDriverFloatBtn');
      const modalOverlay = document.getElementById('waitingDriverModalOverlay');
      const closeBtn = document.getElementById('waitingDriverCloseBtn');
      const contactBtn = document.getElementById('waitingDriverContactBtn');
      const cancelBtn = document.getElementById('waitingDriverCancelBtn');

      console.log('🔧 [等待司机] 元素检查:', {
        floatBtn: !!floatBtn,
        modalOverlay: !!modalOverlay,
        closeBtn: !!closeBtn,
        contactBtn: !!contactBtn,
        cancelBtn: !!cancelBtn
      });

      if (floatBtn) {
        console.log('✅ [等待司机] 悬浮球元素找到，绑定点击事件');
        floatBtn.addEventListener('click', () => {
          console.log('🚗 [等待司机] 点击悬浮小球');
          this.openWaitingDriverModal();
        });
      } else {
        console.error('❌ [等待司机] 悬浮球元素未找到！');
      }

      if (closeBtn) {
        closeBtn.addEventListener('click', () => {
          console.log('🚗 [等待司机] 关闭弹窗');
          this.closeWaitingDriverModal();
        });
      }

      if (modalOverlay) {
        modalOverlay.addEventListener('click', (e) => {
          if (e.target === modalOverlay) {
            this.closeWaitingDriverModal();
          }
        });
      }

      if (contactBtn) {
        contactBtn.addEventListener('click', () => {
          this.contactDriver();
        });
      }

      if (cancelBtn) {
        cancelBtn.addEventListener('click', () => {
          this.cancelRideOrder();
        });
      }

      // 页面加载时恢复订单状态
      this.restoreRideOrder();
    },

    // 创建订单并显示悬浮小球
    createRideOrder(vehicleType, price, destination) {
      const driver = this.generateDriverData();
      const distance = parseFloat(document.getElementById('rideDistance')?.textContent || '2.3');
      const estimatedSeconds = this.calculateEstimatedTime(distance, price);

      const orderData = {
        orderId: 'ride_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        status: 'waiting',
        startTime: Date.now(),
        estimatedSeconds: estimatedSeconds,
        price: price,
        vehicleType: vehicleType,
        destination: destination,
        driver: driver,
        distance: distance
      };

      this.saveRideOrder(orderData);

      // 显示悬浮小球
      const floatBtn = document.getElementById('waitingDriverFloatBtn');
      if (floatBtn) {
        floatBtn.classList.add('active');
      }

      console.log('✅ [等待司机] 订单已创建', orderData);
      return orderData;
    },

    // 打开等待司机弹窗
    openWaitingDriverModal() {
      console.log('🔍 [等待司机] 尝试打开弹窗');
      const order = this.loadRideOrder();
      console.log('🔍 [等待司机] 订单数据:', order);
      if (!order) {
        console.warn('⚠️ [等待司机] 没有订单数据');
        alert('没有进行中的订单');
        return;
      }

      const modal = document.getElementById('waitingDriverModalOverlay');
      if (!modal) return;

      // 填充司机信息
      document.getElementById('waitingDriverName').textContent = order.driver.name;
      document.getElementById('waitingDriverRating').textContent = order.driver.rating;
      document.getElementById('waitingDriverVehicle').textContent = order.driver.vehicle;
      document.getElementById('waitingDriverPlate').textContent = order.driver.plate;
      document.getElementById('waitingDriverAvatar').src = order.driver.avatar;

      // 计算剩余时间
      const elapsedSeconds = Math.floor((Date.now() - order.startTime) / 1000);
      const remainingSeconds = Math.max(0, order.estimatedSeconds - elapsedSeconds);

      // 显示弹窗
      modal.classList.add('active');

      // 启动动画和倒计时
      setTimeout(() => {
        this.startWaitingDriverAnimations(order, remainingSeconds);
      }, 500);

      console.log('✅ [等待司机] 弹窗已打开', { remainingSeconds });
    },

    // 关闭等待司机弹窗
    closeWaitingDriverModal() {
      const modal = document.getElementById('waitingDriverModalOverlay');
      if (modal) {
        modal.classList.remove('active');
      }

      // 清除所有定时器
      if (this.waitingDriverCountdownInterval) {
        clearInterval(this.waitingDriverCountdownInterval);
        this.waitingDriverCountdownInterval = null;
      }
      if (this.waitingDriverDistanceInterval) {
        clearInterval(this.waitingDriverDistanceInterval);
        this.waitingDriverDistanceInterval = null;
      }
      if (this.waitingDriverShakeTimeout) {
        clearTimeout(this.waitingDriverShakeTimeout);
        this.waitingDriverShakeTimeout = null;
      }

      console.log('✅ [等待司机] 弹窗已关闭');
    },

    // 启动等待司机动画
    startWaitingDriverAnimations(order, remainingSeconds) {
      // 清除之前的定时器
      if (this.waitingDriverCountdownInterval) {
        clearInterval(this.waitingDriverCountdownInterval);
      }
      if (this.waitingDriverDistanceInterval) {
        clearInterval(this.waitingDriverDistanceInterval);
      }

      const etaElement = document.getElementById('waitingDriverEta');
      const distanceKmElement = document.getElementById('waitingDriverDistanceKm');
      const distanceLabelElement = document.getElementById('waitingDriverDistance');
      const speedElement = document.getElementById('waitingDriverSpeed');
      const carMarker = document.getElementById('waitingDriverCarMarker');

      let currentSeconds = remainingSeconds;
      const initialDistance = order.distance;

      // 设置车辆移动动画时间
      if (carMarker && currentSeconds > 0) {
        carMarker.style.transition = `left ${currentSeconds}s linear`;
        setTimeout(() => {
          carMarker.style.left = '70%';
        }, 100);
      }

      // 倒计时
      const updateCountdown = () => {
        if (currentSeconds <= 0) {
          etaElement.textContent = '0:00';
          clearInterval(this.waitingDriverCountdownInterval);
          this.onDriverArrived(order);
          return;
        }

        const minutes = Math.floor(currentSeconds / 60);
        const seconds = currentSeconds % 60;
        etaElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        currentSeconds--;
      };

      updateCountdown();
      this.waitingDriverCountdownInterval = setInterval(updateCountdown, 1000);

      // 距离更新
      const decreasePerSecond = initialDistance / remainingSeconds;
      let currentDistance = initialDistance;
      let elapsedSeconds = 0;

      const updateDistance = () => {
        elapsedSeconds++;
        currentDistance = Math.max(0, initialDistance - (decreasePerSecond * elapsedSeconds));

        if (currentDistance <= 0 || elapsedSeconds >= remainingSeconds) {
          currentDistance = 0;
          clearInterval(this.waitingDriverDistanceInterval);
        }

        distanceKmElement.textContent = currentDistance.toFixed(1);
        distanceLabelElement.textContent = currentDistance.toFixed(1) + ' km';

        // 速度波动
        const avgSpeed = Math.round((initialDistance / (remainingSeconds / 3600)));
        const speed = Math.max(5, avgSpeed + Math.floor(Math.random() * 15) - 7);
        speedElement.textContent = speed;
      };

      updateDistance();
      this.waitingDriverDistanceInterval = setInterval(updateDistance, 1000);
    },

    // 司机到达
    onDriverArrived(order) {
      console.log('✅ [等待司机] 司机已到达');

      // 更新订单状态
      order.status = 'arrived';
      this.saveRideOrder(order);

      // 停止车辆移动动画
      const carMarker = document.getElementById('waitingDriverCarMarker');
      if (carMarker) {
        carMarker.style.transition = 'none';
        carMarker.style.left = '70%';
      }

      // 摇晃悬浮小球5秒
      const floatBtn = document.getElementById('waitingDriverFloatBtn');
      if (floatBtn) {
        floatBtn.classList.add('shake');
        this.waitingDriverShakeTimeout = setTimeout(() => {
          floatBtn.classList.remove('shake');
        }, 5000);
      }

      // 切换Contact按钮为Get In按钮
      const contactBtn = document.getElementById('waitingDriverContactBtn');
      const contactText = document.getElementById('waitingDriverContactText');
      if (contactBtn && contactText) {
        contactText.textContent = 'Get In';
        contactBtn.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke-linecap="round" stroke-linejoin="round">
            <path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4M10 17l5-5-5-5M13.8 12H3"/>
          </svg>
          <span id="waitingDriverContactText">Get In</span>
        `;

        // 移除旧的监听器，添加新的上车监听器
        const newBtn = contactBtn.cloneNode(true);
        contactBtn.parentNode.replaceChild(newBtn, contactBtn);
        newBtn.addEventListener('click', () => {
          this.getInCar();
        });
      }
    },

    // 联系司机
    contactDriver() {
      const order = this.loadRideOrder();
      if (!order) return;

      alert(`Calling ${order.driver.name}...`);
      console.log('📞 [等待司机] 联系司机', order.driver);
    },

    // 上车
    getInCar() {
      const order = this.loadRideOrder();
      if (!order || order.status !== 'arrived') {
        alert('司机还未到达');
        return;
      }

      console.log('🚗 [等待司机] 上车');

      // 更新订单状态
      order.status = 'completed';
      this.saveRideOrder(order);

      // 显示手机通知
      if (typeof showPhoneNotification === 'function') {
        showPhoneNotification({
          title: 'Ride Started',
          message: `Have a safe trip to ${order.destination}!`,
          avatar: window.userProfileData?.avatar,
          leftIcon: 'x',
          duration: 4000,
        });
      }

      // 关闭弹窗
      this.closeWaitingDriverModal();

      // 延迟清除订单和隐藏悬浮小球
      setTimeout(() => {
        this.clearRideOrder();
        const floatBtn = document.getElementById('waitingDriverFloatBtn');
        if (floatBtn) {
          floatBtn.classList.remove('active', 'shake');
        }
      }, 1000);
    },

    // 取消订单
    cancelRideOrder() {
      const order = this.loadRideOrder();
      if (!order) return;

      const confirmText = order.status === 'arrived'
        ? 'The driver has arrived. Are you sure you want to cancel?'
        : 'Are you sure you want to cancel this ride?';

      if (!confirm(confirmText)) {
        return;
      }

      console.log('❌ [等待司机] 取消订单');

      // 显示手机通知
      if (typeof showPhoneNotification === 'function') {
        showPhoneNotification({
          title: 'Ride Cancelled',
          message: `Your ride to ${order.destination} has been cancelled.`,
          avatar: window.userProfileData?.avatar,
          leftIcon: 'x',
          duration: 4000,
        });
      }

      // 清除订单
      this.clearRideOrder();

      // 隐藏悬浮小球
      const floatBtn = document.getElementById('waitingDriverFloatBtn');
      if (floatBtn) {
        floatBtn.classList.remove('active', 'shake');
      }

      // 关闭弹窗
      this.closeWaitingDriverModal();
    },

    // 恢复订单状态（页面加载时调用）
    restoreRideOrder() {
      const order = this.loadRideOrder();
      if (!order) return;

      console.log('🔄 [等待司机] 恢复订单状态', order);

      // 计算剩余时间
      const elapsedSeconds = Math.floor((Date.now() - order.startTime) / 1000);
      const remainingSeconds = Math.max(0, order.estimatedSeconds - elapsedSeconds);

      // 如果订单已完成或取消，清除并返回
      if (order.status === 'completed' || order.status === 'cancelled' || remainingSeconds === 0) {
        if (remainingSeconds === 0 && order.status !== 'arrived') {
          order.status = 'arrived';
          this.saveRideOrder(order);
        }
      }

      // 显示悬浮小球
      const floatBtn = document.getElementById('waitingDriverFloatBtn');
      if (floatBtn) {
        floatBtn.classList.add('active');

        // 如果已到达，添加摇晃动画
        if (order.status === 'arrived') {
          floatBtn.classList.add('shake');
        }
      }

      console.log('✅ [等待司机] 订单状态已恢复', { status: order.status, remainingSeconds });
    },

    // 重置乘车UI
    resetRideUI() {
      // 重置目的地显示
      const destValue = document.getElementById('rideDestinationValue');
      if (destValue) {
        destValue.textContent = '点击选择目的地';
        destValue.classList.add('placeholder');
      }

      // 重置时间显示
      const timeElement = document.getElementById('rideEstimatedTime');
      if (timeElement) {
        timeElement.textContent = '--';
      }

      // 重置所有车型价格为基础价格
      const vehicleCards = document.querySelectorAll('.ride-vehicle-card');
      vehicleCards.forEach(card => {
        const basePrice = card.dataset.basePrice;
        const priceValue = card.querySelector('.ride-price-value');
        if (priceValue) {
          priceValue.textContent = basePrice;
        }

        // 重置第一个为选中状态
        if (card === vehicleCards[0]) {
          card.classList.add('selected');
        } else {
          card.classList.remove('selected');
        }
      });

      // 重置支付方式（第一个为选中）
      const paymentOptions = document.querySelectorAll('.ride-payment-option');
      paymentOptions.forEach((option, index) => {
        if (index === 0) {
          option.classList.add('selected');
        } else {
          option.classList.remove('selected');
        }
      });

      // 禁用预订按钮
      const bookBtn = document.getElementById('rideBookBtn');
      if (bookBtn) {
        bookBtn.disabled = true;
        bookBtn.textContent = '请先选择目的地';
      }
    },

    // ==========================================
    // 自定义头像管理功能
    // ==========================================

    // 从localStorage加载自定义头像
    loadCustomAvatars() {
      try {
        const savedAvatarsStr = localStorage.getItem('xMapCustomAvatars');
        if (savedAvatarsStr) {
          this.customAvatars = JSON.parse(savedAvatarsStr);
          console.log('✅ [头像管理] 已加载自定义头像', this.customAvatars);
        }
      } catch (error) {
        console.error('❌ [头像管理] 加载自定义头像失败:', error);
        this.customAvatars = { unisex: [], male: [], female: [] };
      }
    },

    // 保存自定义头像到localStorage
    saveCustomAvatars() {
      try {
        localStorage.setItem('xMapCustomAvatars', JSON.stringify(this.customAvatars));
        console.log('✅ [头像管理] 已保存自定义头像');
      } catch (error) {
        console.error('❌ [头像管理] 保存自定义头像失败:', error);
      }
    },

    // 添加自定义头像
    addCustomAvatar(urlInput, category) {
      if (!urlInput || !urlInput.trim()) {
        alert('Please enter at least one URL');
        return;
      }

      // 🔧 支持批量上传：用中英文逗号分隔多个URL
      const urls = urlInput
        .split(/[,，]/)
        .map(u => u.trim())
        .filter(u => u);

      if (urls.length === 0) {
        alert('Please enter at least one valid URL');
        return;
      }

      let successCount = 0;
      let skipCount = 0;
      let errorCount = 0;
      const errors = [];

      // 逐个处理URL
      urls.forEach((url, index) => {
        // 验证URL格式
        try {
          new URL(url);
        } catch (error) {
          errorCount++;
          errors.push(`URL ${index + 1}: Invalid format`);
          return;
        }

        // 检查是否已存在
        if (this.customAvatars[category].includes(url)) {
          skipCount++;
          return;
        }

        // 添加到对应分类
        this.customAvatars[category].push(url);
        successCount++;
        console.log(`✅ [头像管理] 已添加头像到 ${category}:`, url);
      });

      // 保存和渲染
      if (successCount > 0) {
        this.saveCustomAvatars();
        this.renderCustomAvatarList();
      }

      // 清空输入框
      const input = document.getElementById('mapAvatarUrlInput');
      if (input) input.value = '';

      // 显示结果
      let message = `✅ Successfully added: ${successCount}`;
      if (skipCount > 0) message += `\n⚠️ Skipped (already exists): ${skipCount}`;
      if (errorCount > 0) {
        message += `\n❌ Failed (invalid): ${errorCount}`;
        if (errors.length > 0 && errors.length <= 3) {
          message += `\n${errors.join('\n')}`;
        }
      }

      alert(message);
    },

    // 删除自定义头像
    deleteCustomAvatar(url, category) {
      const index = this.customAvatars[category].indexOf(url);
      if (index > -1) {
        this.customAvatars[category].splice(index, 1);
        this.saveCustomAvatars();
        this.renderCustomAvatarList();
        console.log(`✅ [头像管理] 已删除头像:`, url);
      }
    },

    // 渲染自定义头像列表
    renderCustomAvatarList() {
      const container = document.getElementById('mapCustomAvatarList');
      if (!container) return;

      // 汇总所有自定义头像
      const allAvatars = [];
      ['unisex', 'male', 'female'].forEach(category => {
        this.customAvatars[category].forEach(url => {
          allAvatars.push({ url, category });
        });
      });

      if (allAvatars.length === 0) {
        container.innerHTML =
          '<div style="text-align: center; padding: 20px; color: #666; font-size: 14px;">No custom avatars added yet</div>';
        return;
      }

      container.innerHTML = allAvatars
        .map(
          ({ url, category }) => `
        <div class="map-avatar-item">
          <img src="${url}" alt="Avatar" class="map-avatar-thumb" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 100 100%27%3E%3Crect fill=%27%23ddd%27 width=%27100%27 height=%27100%27/%3E%3C/svg%3E'" />
          <div class="map-avatar-info">
            <div class="map-avatar-url" title="${url}">${url}</div>
            <div class="map-avatar-category-badge">${category}</div>
          </div>
          <button class="map-avatar-delete-btn" onclick="MapDatingController.deleteCustomAvatar('${url.replace(
            /'/g,
            "\\'",
          )}', '${category}')">
            <svg viewBox="0 0 24 24">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>
      `,
        )
        .join('');
    },

    // ==========================================
    // 📍 地标管理功能
    // ==========================================

    // AI生成的地标（从数据库加载，不可编辑）
    aiLandmarks: [],

    // 自定义地标数据（从localStorage加载，可编辑）
    customLandmarks: [],

    // 地标选点模式状态
    landmarkPickMode: false,
    tempLandmarkPosition: null, // {x, y} - 临时保存的位置
    tempLandmarkPreview: null, // 临时地标预览对象
    editingLandmarkId: null, // 正在编辑的地标ID

    // 初始化地标管理功能
    initLandmarkManagement() {
      console.log('📍 [地标管理] 初始化地标管理功能');

      // 模式切换按钮
      const modeBtns = document.querySelectorAll('.map-landmark-mode-btn');
      modeBtns.forEach((btn) => {
        btn.addEventListener('click', () => {
          const mode = btn.dataset.mode;
          this.toggleLandmarkMode(mode);
        });
      });

      // 图标输入 - 实时预览
      const iconInput = document.getElementById('mapLandmarkIconInput');
      const iconPreview = document.getElementById('mapLandmarkIconPreview');
      if (iconInput && iconPreview) {
        iconInput.addEventListener('input', (e) => {
          const value = e.target.value;
          iconPreview.textContent = value || '📍';
        });

        // 点击预览区域也能聚焦输入框
        iconPreview.addEventListener('click', () => {
          iconInput.focus();
        });
      }

      // 颜色输入 - 实时预览
      const colorInput = document.getElementById('mapLandmarkColorInput');
      const colorPreview = document.getElementById('mapLandmarkColorPreview');
      if (colorInput && colorPreview) {
        colorInput.addEventListener('input', (e) => {
          const value = e.target.value;
          if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
            colorPreview.style.backgroundColor = value;
          }
        });

        // 点击颜色预览，触发颜色选择器
        colorPreview.addEventListener('click', () => {
          // 创建临时的color input
          const tempColorInput = document.createElement('input');
          tempColorInput.type = 'color';
          tempColorInput.value = colorInput.value || '#ff6b6b';
          tempColorInput.style.opacity = '0';
          tempColorInput.style.position = 'absolute';
          document.body.appendChild(tempColorInput);

          tempColorInput.addEventListener('change', (e) => {
            const newColor = e.target.value;
            colorInput.value = newColor;
            colorPreview.style.backgroundColor = newColor;
            document.body.removeChild(tempColorInput);
          });

          tempColorInput.click();
        });
      }

      // 地图选点按钮
      const pickBtn = document.getElementById('mapLandmarkPickBtn');
      if (pickBtn) {
        pickBtn.addEventListener('click', () => {
          this.togglePickMode();
        });
      }

      // 名称输入 - 验证保存按钮状态
      const nameInput = document.getElementById('mapLandmarkNameInput');
      const saveBtn = document.getElementById('mapLandmarkSaveBtn');
      if (nameInput && saveBtn) {
        nameInput.addEventListener('input', () => {
          const hasName = nameInput.value.trim().length > 0;
          const hasPosition = this.tempLandmarkPosition !== null;
          saveBtn.disabled = !(hasName && hasPosition);
        });
      }

      // 保存地标按钮
      if (saveBtn) {
        saveBtn.addEventListener('click', () => {
          this.saveLandmark();
        });
      }

      // AI生成地标按钮
      const generateBtn = document.getElementById('mapLandmarkGenerateBtn');
      if (generateBtn) {
        generateBtn.addEventListener('click', () => {
          this.generateLandmarksWithAI();
        });
      }

      // 批量操作按钮
      const selectAllBtn = document.getElementById('mapLandmarkSelectAllBtn');
      if (selectAllBtn) {
        selectAllBtn.addEventListener('click', () => {
          this.selectAllLandmarks();
        });
      }

      const batchDeleteBtn = document.getElementById('mapLandmarkBatchDeleteBtn');
      if (batchDeleteBtn) {
        batchDeleteBtn.addEventListener('click', () => {
          this.batchDeleteLandmarks();
        });
      }

      // 从数据库加载已有地标
      this.loadCustomLandmarks();
      this.loadLandmarkList();
    },

    // 切换地标模式（自定义 / AI生成）
    toggleLandmarkMode(mode) {
      const modeBtns = document.querySelectorAll('.map-landmark-mode-btn');
      const customForm = document.querySelector('.map-landmark-custom-form');
      const aiForm = document.querySelector('.map-landmark-ai-form');

      modeBtns.forEach((btn) => {
        if (btn.dataset.mode === mode) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });

      if (mode === 'custom') {
        customForm?.classList.add('active');
        aiForm?.classList.remove('active');
      } else {
        customForm?.classList.remove('active');
        aiForm?.classList.add('active');
      }
    },

    // 切换地图选点模式
    togglePickMode() {
      this.landmarkPickMode = !this.landmarkPickMode;

      const hintBar = document.getElementById('mapLandmarkPickHint');
      const pickBtn = document.getElementById('mapLandmarkPickBtn');
      const settingsModal = document.getElementById('mapAppSettingsModal');
      const mapArea = document.querySelector('.map-area');

      if (this.landmarkPickMode) {
        // ========== 进入选点模式 ==========

        // 1. 关闭设置弹窗，回到地图主界面
        if (settingsModal) {
          settingsModal.style.display = 'none';
        }

        // 2. 显示顶部提示条
        if (hintBar) {
          hintBar.style.display = 'flex';
          hintBar.classList.add('active');
        }

        // 3. 给地图区域添加类（改变鼠标样式为十字准星）
        if (mapArea) {
          mapArea.classList.add('picking-landmark');
        }

        // 4. 绑定点击事件到map-canvas（父容器，没有pointer-events: none限制）
        const mapCanvas = document.querySelector('.map-canvas');
        if (mapCanvas) {
          // 移除旧的监听器（避免重复绑定）
          mapCanvas.removeEventListener('click', this.handleMapClickForLandmark);
          // 添加新的监听器
          mapCanvas.addEventListener('click', this.handleMapClickForLandmark.bind(this));
          console.log('✅ [地标管理] 已绑定点击事件到.map-canvas');
        } else {
          console.error('❌ [地标管理] 找不到.map-canvas元素');
        }

        console.log('📍 [地标管理] 进入地图选点模式 - 用户可以看到完整地图');
      } else {
        // ========== 退出选点模式 ==========

        // 1. 隐藏顶部提示条
        if (hintBar) {
          hintBar.style.display = 'none';
          hintBar.classList.remove('active');
        }

        // 2. 移除地图区域的十字准星样式
        if (mapArea) {
          mapArea.classList.remove('picking-landmark');
        }

        // 3. 移除点击事件监听
        const mapCanvas = document.querySelector('.map-canvas');
        if (mapCanvas) {
          mapCanvas.removeEventListener('click', this.handleMapClickForLandmark);
        }

        // 4. 如果已经选择了位置，重新打开设置弹窗
        if (settingsModal && this.tempLandmarkPosition) {
          settingsModal.style.display = 'flex';
        }

        console.log('📍 [地标管理] 退出地图选点模式');
      }
    },

    // 处理地图点击事件（用于选点）
    handleMapClickForLandmark(e) {
      if (!this.landmarkPickMode) return;

      // ========== 获取点击位置（使用背景canvas，确保覆盖整个地图区域） ==========
      const bgCanvas = document.getElementById('mapCanvasBg');
      if (!bgCanvas) {
        console.error('❌ [地标管理] 找不到mapCanvasBg元素');
        return;
      }

      // 获取canvas相对于视口的位置
      const rect = bgCanvas.getBoundingClientRect();

      // 计算点击位置相对于canvas的坐标
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;

      // 获取canvas的实际渲染尺寸（CSS缩放后的尺寸）
      const scaleX = bgCanvas.width / rect.width;
      const scaleY = bgCanvas.height / rect.height;

      // 转换为canvas内部坐标（考虑CSS缩放）
      const canvasX = clickX * scaleX;
      const canvasY = clickY * scaleY;

      console.log('📍 [地标管理] 点击坐标信息:', {
        屏幕坐标: { x: e.clientX, y: e.clientY },
        Canvas相对坐标: { clickX, clickY },
        Canvas实际尺寸: { width: bgCanvas.width, height: bgCanvas.height },
        CSS显示尺寸: { width: rect.width, height: rect.height },
        缩放比例: { scaleX, scaleY },
        最终坐标: { canvasX, canvasY },
      });

      // 检查坐标是否在canvas范围内
      if (canvasX < 0 || canvasX > bgCanvas.width || canvasY < 0 || canvasY > bgCanvas.height) {
        console.warn('⚠️ [地标管理] 点击位置超出地图范围');
        // 继续处理，但可能需要提示用户
      }

      // 保存位置（四舍五入到整数）
      this.tempLandmarkPosition = {
        x: Math.round(canvasX),
        y: Math.round(canvasY),
      };

      console.log('✅ [地标管理] 成功选中位置:', this.tempLandmarkPosition);

      // ========== 立即创建临时地标预览 ==========
      const iconInput = document.getElementById('mapLandmarkIconInput');
      const colorInput = document.getElementById('mapLandmarkColorInput');

      this.tempLandmarkPreview = {
        id: 'temp_preview',
        x: this.tempLandmarkPosition.x,
        y: this.tempLandmarkPosition.y,
        name: 'Preview',
        emoji: iconInput ? iconInput.value : '📍',
        color: colorInput ? colorInput.value : '#ff6b6b',
      };

      // 立即渲染到地图上（让用户看到选中的位置）
      this.renderMapLandmarks();
      console.log('✅ [地标管理] 已在地图上显示临时地标预览');

      // 更新位置显示
      const positionDisplay = document.getElementById('mapLandmarkPositionDisplay');
      if (positionDisplay) {
        positionDisplay.textContent = `Position: (${this.tempLandmarkPosition.x}, ${this.tempLandmarkPosition.y})`;
        positionDisplay.classList.add('has-position');
      }

      // 更新保存按钮状态（只要有名称就可以保存了）
      const nameInput = document.getElementById('mapLandmarkNameInput');
      const saveBtn = document.getElementById('mapLandmarkSaveBtn');
      if (nameInput && saveBtn) {
        const hasName = nameInput.value.trim().length > 0;
        saveBtn.disabled = !hasName; // 有位置 + 有名称 = 可保存
      }

      // 退出选点模式（会自动重新打开设置弹窗）
      this.togglePickMode();
    },

    // 取消地标选点
    cancelLandmarkPick() {
      console.log('📍 [地标管理] 用户取消选点');

      // 如果当前在选点模式，退出
      if (this.landmarkPickMode) {
        // 清除临时位置和预览（不保存）
        this.tempLandmarkPosition = null;
        this.tempLandmarkPreview = null;

        // 重新渲染地图（移除临时预览地标）
        this.renderMapLandmarks();

        // 退出选点模式
        this.landmarkPickMode = true; // 设为true，然后togglePickMode会切换为false
        this.togglePickMode();

        // 手动打开设置弹窗（因为没有选择位置，togglePickMode不会自动打开）
        const settingsModal = document.getElementById('mapAppSettingsModal');
        if (settingsModal) {
          settingsModal.style.display = 'flex';
        }
      }
    },

    // 保存地标到数据库
    async saveLandmark() {
      const nameInput = document.getElementById('mapLandmarkNameInput');
      const descInput = document.getElementById('mapLandmarkDescInput');
      const iconInput = document.getElementById('mapLandmarkIconInput');
      const colorInput = document.getElementById('mapLandmarkColorInput');

      if (!nameInput || !this.tempLandmarkPosition) {
        console.error('❌ [地标管理] 缺少必要信息');
        return;
      }

      const landmark = {
        id: this.editingLandmarkId || `landmark_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: nameInput.value.trim(),
        description: descInput?.value.trim() || '',
        icon: iconInput?.value || '📍',
        color: colorInput?.value || '#ff6b6b',
        x: this.tempLandmarkPosition.x,
        y: this.tempLandmarkPosition.y,
        createdAt: this.editingLandmarkId ? undefined : new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      try {
        // 保存到数据库（使用localStorage作为简单存储）
        if (this.editingLandmarkId) {
          // 更新现有地标
          const index = this.customLandmarks.findIndex((l) => l.id === this.editingLandmarkId);
          if (index !== -1) {
            this.customLandmarks[index] = { ...this.customLandmarks[index], ...landmark };
          }
          console.log('✅ [地标管理] 更新地标:', landmark.name);
        } else {
          // 添加新地标
          this.customLandmarks.push(landmark);
          console.log('✅ [地标管理] 添加地标:', landmark.name);
        }

        // 保存到localStorage（按账户隔离）
        const accountId = window.currentAccountId || 'main';
        localStorage.setItem(`xMapCustomLandmarks_${accountId}`, JSON.stringify(this.customLandmarks));

        // 清空表单
        this.resetLandmarkForm();

        // 刷新地标列表
        this.loadLandmarkList();

        // 重新绘制地图（添加新地标到地图上）
        this.renderMapLandmarks();

        alert(this.editingLandmarkId ? 'Landmark updated successfully!' : 'Landmark added successfully!');
      } catch (error) {
        console.error('❌ [地标管理] 保存地标失败:', error);
        alert('Failed to save landmark. Please try again.');
      }
    },

    // 重置地标表单
    resetLandmarkForm() {
      const nameInput = document.getElementById('mapLandmarkNameInput');
      const descInput = document.getElementById('mapLandmarkDescInput');
      const iconInput = document.getElementById('mapLandmarkIconInput');
      const colorInput = document.getElementById('mapLandmarkColorInput');
      const iconPreview = document.getElementById('mapLandmarkIconPreview');
      const colorPreview = document.getElementById('mapLandmarkColorPreview');
      const positionDisplay = document.getElementById('mapLandmarkPositionDisplay');
      const saveBtn = document.getElementById('mapLandmarkSaveBtn');

      if (nameInput) nameInput.value = '';
      if (descInput) descInput.value = '';
      if (iconInput) iconInput.value = '📍';
      if (colorInput) colorInput.value = '#ff6b6b';
      if (iconPreview) iconPreview.textContent = '📍';
      if (colorPreview) colorPreview.style.backgroundColor = '#ff6b6b';
      if (positionDisplay) {
        positionDisplay.textContent = 'No position selected';
        positionDisplay.classList.remove('has-position');
      }
      if (saveBtn) saveBtn.disabled = true;

      this.tempLandmarkPosition = null;
      this.tempLandmarkPreview = null; // 清除临时预览
      this.editingLandmarkId = null;
    },

    // 从数据库加载自定义地标
    loadCustomLandmarks() {
      try {
        const accountId = window.currentAccountId || 'main';
        const saved = localStorage.getItem(`xMapCustomLandmarks_${accountId}`);
        if (saved) {
          this.customLandmarks = JSON.parse(saved);
          console.log(`📍 [地标管理] 账户${accountId}加载了 ${this.customLandmarks.length} 个自定义地标`);
        } else {
          this.customLandmarks = [];
        }
      } catch (error) {
        console.error('❌ [地标管理] 加载地标失败:', error);
        this.customLandmarks = [];
      }
    },

    // 渲染地标列表
    loadLandmarkList() {
      const listContainer = document.getElementById('mapLandmarkList');
      if (!listContainer) return;

      if (this.customLandmarks.length === 0) {
        listContainer.innerHTML = `
          <div style="padding: 40px 20px; text-align: center; color: #8e8e8e;">
            <div style="font-size: 48px; margin-bottom: 12px;">📍</div>
            <div style="font-size: 14px; font-weight: 500; margin-bottom: 4px;">No landmarks yet</div>
            <div style="font-size: 13px;">Add custom landmarks or generate with AI</div>
          </div>
        `;

        // 隐藏批量操作栏
        const batchActions = document.getElementById('mapLandmarkBatchActions');
        if (batchActions) batchActions.classList.remove('active');

        return;
      }

      // 显示批量操作栏
      const batchActions = document.getElementById('mapLandmarkBatchActions');
      if (batchActions) batchActions.classList.add('active');

      // 渲染地标列表
      listContainer.innerHTML = this.customLandmarks
        .map(
          (landmark) => `
        <div class="map-landmark-item" data-id="${landmark.id}">
          <div class="map-landmark-checkbox" data-id="${landmark.id}"></div>
          <div class="map-landmark-icon-display" style="background-color: ${landmark.color}">
            ${landmark.icon}
          </div>
          <div class="map-landmark-info">
            <div class="map-landmark-name">${landmark.name}</div>
            ${landmark.description ? `<div class="map-landmark-desc">${landmark.description}</div>` : ''}
            <div class="map-landmark-position-badge">📍 (${landmark.x}, ${landmark.y})</div>
          </div>
          <div class="map-landmark-actions">
            <button class="map-landmark-edit-btn" data-id="${landmark.id}">
              <svg viewBox="0 0 24 24">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
              </svg>
            </button>
            <button class="map-landmark-delete-btn" data-id="${landmark.id}">
              <svg viewBox="0 0 24 24">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
              </svg>
            </button>
          </div>
        </div>
      `,
        )
        .join('');

      // 绑定事件
      this.bindLandmarkListEvents();
    },

    // 绑定地标列表事件
    bindLandmarkListEvents() {
      // 复选框点击
      const checkboxes = document.querySelectorAll('.map-landmark-checkbox');
      checkboxes.forEach((checkbox) => {
        checkbox.addEventListener('click', (e) => {
          e.stopPropagation();
          const id = checkbox.dataset.id;
          this.toggleLandmarkSelection(id);
        });
      });

      // 编辑按钮
      const editBtns = document.querySelectorAll('.map-landmark-edit-btn');
      editBtns.forEach((btn) => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const id = btn.dataset.id;
          this.editLandmark(id);
        });
      });

      // 删除按钮
      const deleteBtns = document.querySelectorAll('.map-landmark-delete-btn');
      deleteBtns.forEach((btn) => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const id = btn.dataset.id;
          this.deleteLandmark(id);
        });
      });
    },

    // 切换地标选中状态
    toggleLandmarkSelection(id) {
      const checkbox = document.querySelector(`.map-landmark-checkbox[data-id="${id}"]`);
      const item = document.querySelector(`.map-landmark-item[data-id="${id}"]`);

      if (!checkbox || !item) return;

      const isChecked = checkbox.classList.contains('checked');

      if (isChecked) {
        checkbox.classList.remove('checked');
        item.classList.remove('selected');
      } else {
        checkbox.classList.add('checked');
        item.classList.add('selected');
      }

      // 更新批量操作栏状态
      this.updateBatchActionsState();
    },

    // 全选/取消全选
    selectAllLandmarks() {
      const checkboxes = document.querySelectorAll('.map-landmark-checkbox');
      const allChecked = Array.from(checkboxes).every((cb) => cb.classList.contains('checked'));

      checkboxes.forEach((checkbox) => {
        const item = checkbox.closest('.map-landmark-item');
        if (allChecked) {
          checkbox.classList.remove('checked');
          item?.classList.remove('selected');
        } else {
          checkbox.classList.add('checked');
          item?.classList.add('selected');
        }
      });

      this.updateBatchActionsState();
    },

    // 更新批量操作栏状态
    updateBatchActionsState() {
      const selectedCount = document.querySelectorAll('.map-landmark-checkbox.checked').length;
      const countEl = document.getElementById('mapLandmarkSelectedCount');
      const deleteBtn = document.getElementById('mapLandmarkBatchDeleteBtn');

      if (countEl) {
        countEl.textContent = `${selectedCount} selected`;
      }

      if (deleteBtn) {
        deleteBtn.disabled = selectedCount === 0;
      }
    },

    // 编辑地标
    editLandmark(id) {
      const landmark = this.customLandmarks.find((l) => l.id === id);
      if (!landmark) {
        console.error('❌ [地标管理] 未找到地标:', id);
        return;
      }

      // 切换到自定义模式
      this.toggleLandmarkMode('custom');

      // 填充表单
      const nameInput = document.getElementById('mapLandmarkNameInput');
      const descInput = document.getElementById('mapLandmarkDescInput');
      const iconInput = document.getElementById('mapLandmarkIconInput');
      const colorInput = document.getElementById('mapLandmarkColorInput');
      const iconPreview = document.getElementById('mapLandmarkIconPreview');
      const colorPreview = document.getElementById('mapLandmarkColorPreview');
      const positionDisplay = document.getElementById('mapLandmarkPositionDisplay');
      const saveBtn = document.getElementById('mapLandmarkSaveBtn');

      if (nameInput) nameInput.value = landmark.name;
      if (descInput) descInput.value = landmark.description || '';
      if (iconInput) iconInput.value = landmark.icon;
      if (colorInput) colorInput.value = landmark.color;
      if (iconPreview) iconPreview.textContent = landmark.icon;
      if (colorPreview) colorPreview.style.backgroundColor = landmark.color;

      // 设置位置
      this.tempLandmarkPosition = { x: landmark.x, y: landmark.y };
      if (positionDisplay) {
        positionDisplay.textContent = `Position: (${landmark.x}, ${landmark.y})`;
        positionDisplay.classList.add('has-position');
      }

      // 设置编辑模式
      this.editingLandmarkId = id;

      // 启用保存按钮
      if (saveBtn) {
        saveBtn.disabled = false;
        saveBtn.textContent = 'Update Landmark';
      }

      // 滚动到表单顶部
      const section = document.querySelector('.map-landmark-section');
      if (section) {
        section.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }

      console.log('📍 [地标管理] 编辑地标:', landmark.name);
    },

    // 删除单个地标
    deleteLandmark(id) {
      const landmark = this.customLandmarks.find((l) => l.id === id);
      if (!landmark) return;

      if (!confirm(`Delete landmark "${landmark.name}"?`)) {
        return;
      }

      this.customLandmarks = this.customLandmarks.filter((l) => l.id !== id);

      // 保存到localStorage（按账户隔离）
      const accountId = window.currentAccountId || 'main';
      localStorage.setItem(`xMapCustomLandmarks_${accountId}`, JSON.stringify(this.customLandmarks));

      this.loadLandmarkList();
      this.renderMapLandmarks();

      console.log('🗑️ [地标管理] 删除地标:', landmark.name);
    },

    // 批量删除地标
    batchDeleteLandmarks() {
      const selectedCheckboxes = document.querySelectorAll('.map-landmark-checkbox.checked');
      const selectedIds = Array.from(selectedCheckboxes).map((cb) => cb.dataset.id);

      if (selectedIds.length === 0) return;

      if (!confirm(`Delete ${selectedIds.length} landmarks?`)) {
        return;
      }

      this.customLandmarks = this.customLandmarks.filter((l) => !selectedIds.includes(l.id));

      // 保存到localStorage（按账户隔离）
      const accountId = window.currentAccountId || 'main';
      localStorage.setItem(`xMapCustomLandmarks_${accountId}`, JSON.stringify(this.customLandmarks));

      this.loadLandmarkList();
      this.renderMapLandmarks();

      console.log(`🗑️ [地标管理] 批量删除了 ${selectedIds.length} 个地标`);
    },

    // 渲染地图上的自定义地标
    renderMapLandmarks() {
      console.log('🗺️ [地标管理] 重新绘制地图地标，当前地标数量:', this.customLandmarks.length);

      // 检查MapGenerator是否存在
      if (!window.MapGenerator) {
        console.warn('⚠️ [地标管理] MapGenerator未初始化，无法渲染地标');
        return;
      }

      // ========== 简单合并：AI地标 + 自定义地标 + 临时预览地标 ==========
      // AI地标和自定义地标分开存储，直接合并即可

      console.log('📍 [地标管理] 合并地标数据:', {
        AI地标: this.aiLandmarks.length,
        自定义地标: this.customLandmarks.length,
        临时预览: this.tempLandmarkPreview ? 1 : 0,
      });

      // 直接合并：AI地标 + 自定义地标 + 临时预览地标（如果有）
      const allLandmarks = [...this.aiLandmarks, ...this.customLandmarks];
      if (this.tempLandmarkPreview) {
        allLandmarks.push(this.tempLandmarkPreview);
      }

      window.MapGenerator.landmarks = allLandmarks;

      console.log('📍 [地标管理] 已同步地标到MapGenerator:', {
        最终总数: window.MapGenerator.landmarks.length,
      });

      // 重新绘制地图（包含圆点）
      if (typeof window.MapGenerator.redraw === 'function') {
        window.MapGenerator.redraw();
        console.log('✅ [地标管理] 地图canvas已重新绘制');
      } else {
        console.warn('⚠️ [地标管理] MapGenerator没有redraw方法，尝试手动重绘');

        // 如果没有redraw方法，尝试清空并重新绘制地标
        if (window.MapGenerator.ctx) {
          // 只清除地标层，不影响地图主体
          // 直接调用drawLandmarks重新绘制所有地标
          window.MapGenerator.drawLandmarks();
          console.log('✅ [地标管理] 地标canvas已手动重绘');
        }
      }

      // ⚠️ 重要：重新渲染地标label（气泡）
      this.renderLandmarkLabels();
      console.log('✅ [地标管理] 地标label已重新渲染');
    },

    // AI生成地标（调用第十五情景）
    async generateLandmarksWithAI() {
      const aiInput = document.getElementById('mapLandmarkAiInput');
      const generateBtn = document.getElementById('mapLandmarkGenerateBtn');

      if (!aiInput || !generateBtn) return;

      const userRequirements = aiInput.value.trim();

      // 禁用按钮，显示加载状态
      generateBtn.disabled = true;
      generateBtn.textContent = 'Generating...';

      try {
        console.log('🤖 [地标管理] 开始AI生成地标');

        // 调用第十五情景，传入onlyLandmarks参数
        await this.generateMapDatingData(false, true, userRequirements);

        // 成功后重新加载地标列表
        this.loadCustomLandmarks();
        this.loadLandmarkList();
        this.renderMapLandmarks();

        alert('Landmarks generated successfully!');
        aiInput.value = '';
      } catch (error) {
        console.error('❌ [地标管理] AI生成地标失败:', error);
        alert('Failed to generate landmarks. Please try again.');
      } finally {
        generateBtn.disabled = false;
        generateBtn.textContent = 'Generate Landmarks with AI';
      }
    },

    // ==========================================
    // 🚨 举报功能相关方法
    // ==========================================

    // 打开举报弹窗
    openReportModal() {
      if (!this.currentChatUser) {
        console.error('❌ [举报系统] 没有当前聊天用户');
        return;
      }

      // 关闭More菜单
      const moreMenu = document.getElementById('mapChatMoreMenu');
      if (moreMenu) moreMenu.classList.remove('show');

      const overlay = document.getElementById('mapReportOverlay');
      const modal = document.getElementById('mapReportModal');

      if (!overlay || !modal) {
        console.error('❌ [举报系统] 举报弹窗元素未找到');
        return;
      }

      // 填充被举报用户信息
      const avatarEl = document.getElementById('mapReportUserAvatar');
      const nicknameEl = document.getElementById('mapReportUserNickname');
      const handleEl = document.getElementById('mapReportUserHandle');

      if (avatarEl) avatarEl.src = this.currentChatUser.avatar || '';
      if (nicknameEl) nicknameEl.textContent = this.currentChatUser.nickname || 'User';
      if (handleEl)
        handleEl.textContent = `@${
          this.currentChatUser.handle || this.currentChatUser.nickname?.toLowerCase() || 'user'
        }`;

      // 清空表单
      const checkboxes = document.querySelectorAll('input[name="reportReason"]');
      checkboxes.forEach(cb => (cb.checked = false));
      const textarea = document.getElementById('mapReportDescription');
      if (textarea) textarea.value = '';

      // 显示弹窗
      overlay.classList.add('show');
      modal.classList.add('show');

      console.log(`🚨 [举报系统] 打开举报弹窗，被举报用户: ${this.currentChatUser.nickname}`);
    },

    // 关闭举报弹窗
    closeReportModal() {
      const overlay = document.getElementById('mapReportOverlay');
      const modal = document.getElementById('mapReportModal');

      if (overlay) overlay.classList.remove('show');
      if (modal) modal.classList.remove('show');
    },

    // 提交举报
    async submitReport() {
      if (!this.currentChatUser) {
        console.error('❌ [举报系统] 没有当前聊天用户');
        return;
      }

      // 收集选中的举报理由
      const checkboxes = document.querySelectorAll('input[name="reportReason"]:checked');
      const reasons = Array.from(checkboxes).map(cb => cb.value);

      if (reasons.length === 0) {
        alert('Please select at least one reason for reporting');
        return;
      }

      // 收集举报描述
      const textarea = document.getElementById('mapReportDescription');
      const description = textarea ? textarea.value.trim() : '';

      console.log(`🚨 [举报系统] 提交举报 - 用户: ${this.currentChatUser.nickname}, 理由: ${reasons.join(', ')}`);

      // 获取该用户的最近10条聊天记录
      const chatHistory = this.getChatHistory(this.currentChatUser.id);
      const recentMessages = chatHistory.slice(-10); // 最近10条

      // 关闭举报弹窗
      this.closeReportModal();

      // 标记该聊天为"举报审理中"
      this.markChatAsReported(this.currentChatUser.id);

      // 显示系统消息
      this.addSystemMessage(
        'Your report has been submitted and is under review. You cannot send messages while the review is in progress.',
      );

      // 禁用输入框
      this.disableChatInput();

      // 🔧 将举报数据存入待处理队列（等待第十六情景处理）
      try {
        const reportData = {
          id: `report_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          reporterId: 'current_user',
          reportedUser: this.currentChatUser,
          reasons: reasons,
          description: description,
          chatHistory: recentMessages,
          timestamp: new Date().toISOString(),
          status: 'pending',
        };

        // 存入待处理队列
        let pendingReports = localStorage.getItem('xMapPendingReports');
        pendingReports = pendingReports ? JSON.parse(pendingReports) : [];
        pendingReports.push(reportData);
        localStorage.setItem('xMapPendingReports', JSON.stringify(pendingReports));

        console.log(`🚨 [举报系统] 举报已加入待处理队列，将在下次第十六情景中处理`);
      } catch (error) {
        console.error('❌ [举报系统] 添加举报到队列失败:', error);
      }
    },

    // 标记聊天为举报状态
    markChatAsReported(userId) {
      try {
        let reportedChats = localStorage.getItem('xMapReportedChats');
        reportedChats = reportedChats ? JSON.parse(reportedChats) : {};

        reportedChats[userId] = {
          reportedAt: new Date().toISOString(),
          status: 'pending',
        };

        localStorage.setItem('xMapReportedChats', JSON.stringify(reportedChats));
        console.log(`✅ [举报系统] 已标记聊天为举报状态: ${userId}`);
        console.log(`🔍 [举报系统] 当前所有举报记录:`, JSON.stringify(reportedChats, null, 2));

        // 验证存储
        const verify = localStorage.getItem('xMapReportedChats');
        console.log(`🔍 [举报系统] 验证localStorage存储:`, verify);
      } catch (error) {
        console.error('❌ [举报系统] 标记聊天失败:', error);
      }
    },

    // 添加系统消息
    addSystemMessage(message) {
      const messagesContainer = document.getElementById('mapChatMessages');
      if (!messagesContainer) return;

      const systemMessageDiv = document.createElement('div');
      systemMessageDiv.className = 'map-chat-system-message';
      systemMessageDiv.innerHTML = `
        <div class="map-chat-system-message-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="12" y1="8" x2="12" y2="12"></line>
            <line x1="12" y1="16" x2="12.01" y2="16"></line>
          </svg>
        </div>
        <div class="map-chat-system-message-text">${message}</div>
      `;

      messagesContainer.appendChild(systemMessageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    },

    // 禁用输入框
    disableChatInput() {
      const input = document.getElementById('mapChatInput');
      const sendBtn = document.getElementById('mapChatSendBtn');

      if (input) {
        input.disabled = true;
        input.placeholder = 'Chat unavailable during review process';
      }
      if (sendBtn) {
        sendBtn.disabled = true;
        sendBtn.style.opacity = '0.5';
        sendBtn.style.cursor = 'not-allowed';
      }
    },

    // 启用输入框
    enableChatInput() {
      const input = document.getElementById('mapChatInput');
      const sendBtn = document.getElementById('mapChatSendBtn');

      if (input) {
        input.disabled = false;
        input.placeholder = 'Type a message...';
      }
      if (sendBtn) {
        sendBtn.disabled = false;
        sendBtn.style.opacity = '1';
        sendBtn.style.cursor = 'pointer';
      }
    },

    // 🔧 检查并更新聊天输入框状态（根据是否被举报）
    checkAndUpdateChatInputState(userId) {
      try {
        const reportedChatsStr = localStorage.getItem('xMapReportedChats');
        console.log(`🔍 [举报系统] 检查用户 ${userId} 的举报状态`);
        console.log(`🔍 [举报系统] localStorage中的数据:`, reportedChatsStr);

        if (!reportedChatsStr) {
          // 没有任何举报记录，启用输入框
          console.log(`✅ [举报系统] 没有举报记录，启用输入框`);
          this.enableChatInput();
          return;
        }

        const reportedChats = JSON.parse(reportedChatsStr);
        console.log(`🔍 [举报系统] 解析后的举报记录:`, reportedChats);

        if (reportedChats[userId] && reportedChats[userId].status === 'pending') {
          // 该用户被举报中，禁用输入框
          this.disableChatInput();
          console.log(`🚨 [举报系统] ${userId} 正在审理中，输入框已禁用`);

          // 🔧 显示系统消息（刷新后恢复状态）
          const messagesContainer = document.getElementById('mapChatMessages');
          if (messagesContainer) {
            // 检查是否已经有系统消息（避免重复添加）
            const existingSystemMsg = messagesContainer.querySelector('.map-chat-system-message');
            if (!existingSystemMsg) {
              this.addSystemMessage(
                'Your report has been submitted and is under review. You cannot send messages while the review is in progress.',
              );
            }
          }
        } else {
          // 该用户未被举报，启用输入框
          this.enableChatInput();
        }
      } catch (error) {
        console.error('❌ [举报系统] 检查举报状态失败:', error);
        // 出错时默认启用输入框
        this.enableChatInput();
      }
    },

    // 获取聊天记录
    getChatHistory(userId) {
      try {
        // 从内存中获取聊天记录
        if (this.chatMessages[userId]) {
          return this.chatMessages[userId];
        }

        // 如果内存中没有，尝试从localStorage读取（兼容旧版本）
        const chatKey = `xMapChatHistory_${userId}`;
        const historyStr = localStorage.getItem(chatKey);
        if (historyStr) {
          return JSON.parse(historyStr);
        }

        return [];
      } catch (error) {
        console.error('❌ [举报系统] 获取聊天记录失败:', error);
        return [];
      }
    },

    // 生成举报结果提醒
    async generateReportNotification(reportData, isApproved, reason) {
      try {
        console.log(`🚨 [举报系统] 生成提醒，原始reportData:`, JSON.stringify(reportData, null, 2));

        const notification = {
          id: `report-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          type: 'report',
          timestamp: new Date().toISOString(),
          isRead: false,
          reportedUser: reportData.reportedUser,
          isApproved: isApproved,
          reason: reason,
          title: isApproved ? 'Report Approved' : 'Report Declined',
          // 🔧 存储完整举报信息供详情弹窗使用
          fullReportData: {
            reasons: reportData.reasons || [],
            description: reportData.description || '',
            reportedAt: reportData.timestamp || new Date().toISOString(),
          },
        };

        console.log(`🚨 [举报系统] 创建的notification:`, JSON.stringify(notification, null, 2));

        // 🔧 修复：保存到数据库而不是localStorage
        const xDb = getXDB();
        if (!xDb) {
          console.error('❌ [举报系统] 无法获取数据库');
          return;
        }

        const mapDataId = `mapDatingData_${window.currentAccountId || 'main'}`;
        const mapDatingData = await xDb.xMapDatingData.get(mapDataId);

        if (mapDatingData) {
          if (!mapDatingData.notifications) {
            mapDatingData.notifications = [];
          }
          mapDatingData.notifications.push(notification);
          await xDb.xMapDatingData.put(mapDatingData);
          console.log(`✅ [举报系统] 已保存notification到数据库`);
        }

        // 更新提醒徽章
        this.updateNotificationBadge();

        // 解除聊天禁用状态
        this.enableChatInput();

        // 移除举报标记
        this.unmarkChatAsReported(reportData.reportedUser.id);

        console.log(`✅ [举报系统] 已生成举报结果提醒`);
      } catch (error) {
        console.error('❌ [举报系统] 生成提醒失败:', error);
      }
    },

    // 移除举报标记
    unmarkChatAsReported(userId) {
      try {
        let reportedChats = localStorage.getItem('xMapReportedChats');
        reportedChats = reportedChats ? JSON.parse(reportedChats) : {};

        delete reportedChats[userId];

        localStorage.setItem('xMapReportedChats', JSON.stringify(reportedChats));
        console.log(`✅ [举报系统] 已移除举报标记: ${userId}`);
      } catch (error) {
        console.error('❌ [举报系统] 移除举报标记失败:', error);
      }
    },

    // 🚨 生成用户被举报提醒（AI举报用户）
    async generateUserReportedNotification(reporterUser, reasons, description, severity, isApproved, judgementReason) {
      try {
        console.log(`🚨 [被举报系统] 生成被举报提醒，举报者: ${reporterUser.nickname}`);

        const notification = {
          id: `user-reported-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          type: 'user_reported', // 新类型：用户被举报
          timestamp: new Date().toISOString(),
          isRead: false,
          reporterUser: reporterUser, // 举报者（NPC）
          isApproved: isApproved,
          severity: severity,
          judgementReason: judgementReason,
          title: isApproved ? 'You Have Been Reported' : 'Report Against You Was Declined',
          // 存储完整举报信息供详情弹窗使用
          fullReportData: {
            reasons: reasons,
            description: description,
            reportedAt: new Date().toISOString(),
          },
        };

        console.log(`🚨 [被举报系统] 创建的notification:`, JSON.stringify(notification, null, 2));

        // 🔧 修复：保存到数据库而不是localStorage
        const xDb = getXDB();
        if (!xDb) {
          console.error('❌ [被举报系统] 无法获取数据库');
          return;
        }

        const mapDataId = `mapDatingData_${window.currentAccountId || 'main'}`;
        const mapDatingData = await xDb.xMapDatingData.get(mapDataId);

        if (mapDatingData) {
          if (!mapDatingData.notifications) {
            mapDatingData.notifications = [];
          }
          mapDatingData.notifications.push(notification);
          await xDb.xMapDatingData.put(mapDatingData);
          console.log(`✅ [被举报系统] 已保存notification到数据库`);
        }

        // 更新提醒徽章
        this.updateNotificationBadge();

        console.log(`✅ [被举报系统] 已生成被举报提醒`);
      } catch (error) {
        console.error('❌ [被举报系统] 生成提醒失败:', error);
      }
    },

    // 📋 打开举报详情弹窗
    openReportDetailModal(notification) {
      const overlay = document.getElementById('mapReportDetailOverlay');
      const modal = document.getElementById('mapReportDetailModal');

      if (!overlay || !modal) {
        console.error('❌ [举报详情] 找不到弹窗元素');
        return;
      }

      // 💾 存储当前notification（用于"已知晓"按钮结算）
      this.currentReportNotification = notification;

      // 🔍 调试：输出完整的notification对象
      console.log('📋 [举报详情] 打开弹窗，notification数据:', JSON.stringify(notification, null, 2));

      // 填充数据
      const badge = document.getElementById('mapReportDetailBadge');
      const badgeIcon = document.getElementById('mapReportDetailBadgeIcon');
      const badgeText = document.getElementById('mapReportDetailBadgeText');
      const userAvatar = document.getElementById('mapReportDetailUserAvatar');
      const userNickname = document.getElementById('mapReportDetailUserNickname');
      const userHandle = document.getElementById('mapReportDetailUserHandle');
      const reasonsContainer = document.getElementById('mapReportDetailReasons');
      const descSection = document.getElementById('mapReportDetailDescSection');
      const description = document.getElementById('mapReportDetailDescription');
      const reason = document.getElementById('mapReportDetailReason');
      const time = document.getElementById('mapReportDetailTime');

      // 设置判定结果徽章
      if (badge && badgeText) {
        badge.className = `map-report-detail-badge ${notification.isApproved ? 'approved' : 'declined'}`;
        badgeText.textContent = notification.isApproved ? 'Report Approved' : 'Report Declined';
      }

      // 设置用户信息
      if (userAvatar) userAvatar.src = notification.reportedUser.avatar || '';
      if (userNickname) userNickname.textContent = notification.reportedUser.nickname || 'User';
      if (userHandle) userHandle.textContent = `@${notification.reportedUser.handle || 'user'}`;

      // 设置举报理由
      if (reasonsContainer) {
        const reasonMap = {
          inappropriate_content: 'Inappropriate Content',
          harassment: 'Harassment',
          abuse: 'Verbal Abuse',
          spam: 'Spam',
          other: 'Other',
        };

        const reasons = notification.fullReportData?.reasons || [];
        console.log(`📋 [举报详情] 举报理由数组:`, reasons);

        if (reasons.length > 0) {
          reasonsContainer.innerHTML = reasons
            .map(r => `<div class="map-report-detail-reason-tag">${reasonMap[r] || r}</div>`)
            .join('');
        } else {
          // 如果没有理由数据，显示占位文本
          reasonsContainer.innerHTML = '<div class="map-report-detail-reason-tag">No specific reason provided</div>';
        }
      }

      // 设置举报描述（如果有）
      if (notification.fullReportData?.description && notification.fullReportData.description.trim()) {
        if (descSection) descSection.style.display = 'block';
        if (description) description.textContent = notification.fullReportData.description;
      } else {
        if (descSection) descSection.style.display = 'none';
      }

      // 设置AI判定原因
      if (reason) reason.textContent = notification.reason || 'No reason provided';

      // 设置举报时间
      if (time) {
        const reportedAt = notification.fullReportData?.reportedAt || notification.timestamp;
        console.log(`📋 [举报详情] 举报时间:`, reportedAt);

        if (reportedAt) {
          try {
            const reportTime = new Date(reportedAt);
            time.textContent = reportTime.toLocaleString('en-US', {
              year: 'numeric',
              month: 'short',
              day: 'numeric',
              hour: '2-digit',
              minute: '2-digit',
            });
          } catch (error) {
            console.error('❌ [举报详情] 时间格式化失败:', error);
            time.textContent = reportedAt;
          }
        } else {
          time.textContent = 'Time not available';
        }
      }

      // 显示弹窗
      overlay.classList.add('show');
      modal.classList.add('show');

      console.log(`📋 [举报详情] 已打开详情弹窗`);
    },

    // 关闭举报详情弹窗
    closeReportDetailModal() {
      const overlay = document.getElementById('mapReportDetailOverlay');
      const modal = document.getElementById('mapReportDetailModal');

      if (overlay) overlay.classList.remove('show');
      if (modal) modal.classList.remove('show');
    },

    // 💰 处理举报结算（点击"已知晓"按钮）
    async handleReportAcknowledge() {
      const notification = this.currentReportNotification;

      if (!notification) {
        console.warn('⚠️ [举报结算] 没有当前notification数据');
        this.closeReportDetailModal();
        return;
      }

      // 防止重复领取奖励
      if (notification.rewardClaimed) {
        console.log('⚠️ [举报结算] 奖励已领取，跳过');
        this.closeReportDetailModal();
        return;
      }

      console.log(`💰 [举报结算] 开始处理结算，类型: ${notification.type}, 是否成立: ${notification.isApproved}`);

      try {
        // 加载钱包数据
        await loadWalletData();

        // 根据举报类型和结果进行不同处理
        if (notification.type === 'report') {
          // ========== 用户举报AI账户 ==========
          if (notification.isApproved) {
            // 举报成功：奖励100金币 + 增加真实度
            const severity = notification.fullReportData?.severity || 'moderate';
            let authenticityBonus = 10; // 默认
            if (severity === 'severe') {
              authenticityBonus = 15;
            } else if (severity === 'minor') {
              authenticityBonus = 5;
            }

            // 添加100金币
            if (walletData.isActivated) {
              walletData.balance += 100;

              // 添加交易记录
              const transaction = {
                id: 'report_reward_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                description: `Approved Report Reward - ${notification.reportedUser?.nickname || 'User'}`,
                amount: 100,
                timestamp: new Date().toISOString(),
                type: 'report_reward',
              };
              walletData.transactions.unshift(transaction);
              await saveWalletData();

              console.log(`✅ [举报结算] 已添加100金币，当前余额: $${walletData.balance.toFixed(2)}`);
            } else {
              console.warn('⚠️ [举报结算] 钱包未激活，跳过金币奖励');
            }

            // 增加真实度
            this.addAuthenticityScore(authenticityBonus, `举报成功（${severity}）`);

            // 弹出手机样式通知
            showPhoneNotification({
              title: 'Report Approved',
              message: walletData.isActivated
                ? `+$100.00, Authenticity +${authenticityBonus}. Balance: $${walletData.balance.toFixed(2)}`
                : `Authenticity +${authenticityBonus}. Activate wallet to receive rewards.`,
              avatar: window.userProfileData?.avatar,
              leftIcon: 'x',
              duration: 4000,
            });

            console.log(`✅ [举报结算] 举报成功奖励已发放`);
          } else {
            // 举报失败：恶意举报，扣除真实度 + 解封输入框
            const penalty = Math.floor(Math.random() * 11) + 10; // 10-20
            this.subtractAuthenticityScore(penalty, '恶意举报');

            // 解封输入框
            if (notification.reportedUser?.id) {
              this.checkAndUpdateChatInputState(notification.reportedUser.id);
              console.log(`✅ [举报结算] 已解封用户 ${notification.reportedUser.id} 的聊天输入框`);
            }

            // 弹出手机样式通知
            showPhoneNotification({
              title: 'Report Declined',
              message: `Authenticity -${penalty}. False reports harm your credibility.`,
              avatar: window.userProfileData?.avatar,
              leftIcon: 'x',
              duration: 4000,
            });

            console.log(`⚠️ [举报结算] 恶意举报惩罚已执行`);
          }
        } else if (notification.type === 'user_reported') {
          // ========== AI举报用户 ==========
          if (notification.isApproved) {
            // 被举报成立：扣除真实度 + 扣除钱包100金币 + 增加被举报计数
            const severity = notification.severity || 'moderate';
            let authenticityPenalty = 15; // 默认
            if (severity === 'severe') {
              authenticityPenalty = Math.floor(Math.random() * 11) + 20; // 20-30
            } else if (severity === 'moderate') {
              authenticityPenalty = Math.floor(Math.random() * 11) + 10; // 10-20
            } else if (severity === 'minor') {
              authenticityPenalty = Math.floor(Math.random() * 6) + 5; // 5-10
            }

            // 扣除真实度
            this.subtractAuthenticityScore(authenticityPenalty, `AI举报成立（${severity}）`);

            // 扣除钱包金额
            let walletMessage = '';
            if (walletData.isActivated) {
              const deductAmount = 100;
              if (walletData.balance >= deductAmount) {
                walletData.balance -= deductAmount;

                // 添加交易记录
                const transaction = {
                  id: 'penalty_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                  description: `Violation Penalty - Reported by ${notification.reporterUser?.nickname || 'User'}`,
                  amount: -deductAmount,
                  timestamp: new Date().toISOString(),
                  type: 'violation_penalty',
                };
                walletData.transactions.unshift(transaction);
                await saveWalletData();

                walletMessage = `-$${deductAmount.toFixed(2)}, `;
                console.log(`💰 [举报结算] 已扣除$${deductAmount}，当前余额: $${walletData.balance.toFixed(2)}`);
              } else {
                // 余额不足，扣到0
                const actualDeduct = walletData.balance;
                walletData.balance = 0;

                const transaction = {
                  id: 'penalty_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                  description: `Violation Penalty (Insufficient Funds) - Reported by ${
                    notification.reporterUser?.nickname || 'User'
                  }`,
                  amount: -actualDeduct,
                  timestamp: new Date().toISOString(),
                  type: 'violation_penalty',
                };
                walletData.transactions.unshift(transaction);
                await saveWalletData();

                walletMessage = `-$${actualDeduct.toFixed(2)} (余额不足), `;
                console.warn(`⚠️ [举报结算] 余额不足，已扣除全部余额$${actualDeduct}`);
              }
            }

            // 增加被举报计数
            const currentCount = this.incrementReportedCount();
            console.log(`🚨 [被举报计数] 当前累计被举报次数: ${currentCount}`);

            // 弹出手机样式通知
            showPhoneNotification({
              title: 'Violation Confirmed',
              message: `${walletMessage}Authenticity -${authenticityPenalty}. Violations: ${currentCount}/5`,
              avatar: window.userProfileData?.avatar,
              leftIcon: 'x',
              duration: 5000,
            });

            console.log(`⚠️ [举报结算] 用户被举报成立，已扣除真实度和金币`);

            // 如果刚好达到5次，会自动封禁，显示额外提示
            if (currentCount === 0) {
              // 计数被重置，说明刚刚触发了封禁
              setTimeout(() => {
                showPhoneNotification({
                  title: 'Account Suspended',
                  message: 'Map Dating access suspended for 12 hours due to repeated violations.',
                  avatar: window.userProfileData?.avatar,
                  leftIcon: 'x',
                  duration: 6000,
                });
              }, 1000);
            }
          } else {
            // 被举报不成立：增加真实度
            const bonus = Math.floor(Math.random() * 6) + 5; // 5-10
            this.addAuthenticityScore(bonus, 'AI恶意举报');

            // 弹出手机样式通知
            showPhoneNotification({
              title: 'Report Unfounded',
              message: `Authenticity +${bonus}. You were falsely reported.`,
              avatar: window.userProfileData?.avatar,
              leftIcon: 'x',
              duration: 4000,
            });

            console.log(`✅ [举报结算] AI恶意举报，已增加真实度`);
          }
        }

        // 标记奖励已领取
        notification.rewardClaimed = true;

        // 🔧 修复：更新数据库中的notification数据，而不是localStorage
        const xDb = getXDB();
        if (!xDb) {
          console.error('❌ [举报结算] 无法获取数据库');
          return;
        }

        const mapDataId = `mapDatingData_${window.currentAccountId || 'main'}`;
        const mapDatingData = await xDb.xMapDatingData.get(mapDataId);

        if (mapDatingData && mapDatingData.notifications) {
          const index = mapDatingData.notifications.findIndex(n => n.id === notification.id);
          if (index !== -1) {
            mapDatingData.notifications[index] = notification;
            await xDb.xMapDatingData.put(mapDatingData);
            console.log(`✅ [举报结算] 已标记notification ${notification.id} 为已领取`);
          } else {
            console.warn(`⚠️ [举报结算] 未找到notification ${notification.id}，无法更新`);
          }
        } else {
          console.warn(`⚠️ [举报结算] 未找到数据库记录，无法更新notification`);
        }
      } catch (error) {
        console.error('❌ [举报结算] 处理失败:', error);
        showPhoneNotification({
          title: 'Error',
          message: 'Failed to process report settlement.',
          avatar: window.userProfileData?.avatar,
          leftIcon: 'x',
          duration: 3000,
        });
      }

      // 关闭弹窗
      this.closeReportDetailModal();
    },

    // 🚨 打开被举报详情弹窗（用户被AI举报）
    openUserReportedDetailModal(notification) {
      const overlay = document.getElementById('mapReportDetailOverlay');
      const modal = document.getElementById('mapReportDetailModal');

      if (!overlay || !modal) {
        console.error('❌ [被举报详情] 找不到弹窗元素');
        return;
      }

      // 💾 存储当前notification（用于"已知晓"按钮结算）
      this.currentReportNotification = notification;

      // 🔍 调试：输出完整的notification对象
      console.log('🚨 [被举报详情] 打开弹窗，notification数据:', JSON.stringify(notification, null, 2));

      // 填充数据
      const badge = document.getElementById('mapReportDetailBadge');
      const badgeIcon = document.getElementById('mapReportDetailBadgeIcon');
      const badgeText = document.getElementById('mapReportDetailBadgeText');
      const userAvatar = document.getElementById('mapReportDetailUserAvatar');
      const userNickname = document.getElementById('mapReportDetailUserNickname');
      const userHandle = document.getElementById('mapReportDetailUserHandle');
      const reasonsContainer = document.getElementById('mapReportDetailReasons');
      const descSection = document.getElementById('mapReportDetailDescSection');
      const description = document.getElementById('mapReportDetailDescription');
      const reason = document.getElementById('mapReportDetailReason');
      const time = document.getElementById('mapReportDetailTime');

      // 修改标题为 "Reported By"
      const titleElement = modal.querySelector('.map-report-detail-title');
      if (titleElement) {
        titleElement.textContent = notification.isApproved ? 'You Have Been Reported' : 'Report Was Declined';
      }

      // 设置判定结果徽章
      if (badge && badgeText) {
        badge.className = `map-report-detail-badge ${notification.isApproved ? 'approved' : 'declined'}`;
        badgeText.textContent = notification.isApproved ? 'Violation Confirmed' : 'Report Unfounded';
      }

      // 🚨 显示举报者（NPC）信息，不是被举报者
      if (userAvatar) userAvatar.src = notification.reporterUser.avatar || '';
      if (userNickname) userNickname.textContent = notification.reporterUser.nickname || 'User';
      if (userHandle) userHandle.textContent = `@${notification.reporterUser.handle || 'user'}`;

      // 修改用户信息卡片标题为 "Reported By"
      const userCardTitle = modal.querySelector('.map-report-detail-section-title');
      if (userCardTitle) {
        userCardTitle.textContent = 'Reported By';
      }

      // 设置举报理由（AI判定的违规类型）
      if (reasonsContainer) {
        const reasonMap = {
          inappropriate_content: 'Inappropriate Content',
          harassment: 'Harassment',
          abuse: 'Verbal Abuse',
          spam: 'Spam',
          threats: 'Threats',
          discrimination: 'Discrimination',
          other: 'Other',
        };

        const reasons = notification.fullReportData?.reasons || [];
        console.log(`🚨 [被举报详情] 违规理由数组:`, reasons);

        if (reasons.length > 0) {
          reasonsContainer.innerHTML = reasons
            .map(r => `<div class="map-report-detail-reason-tag">${reasonMap[r] || r}</div>`)
            .join('');
        } else {
          reasonsContainer.innerHTML = '<div class="map-report-detail-reason-tag">No specific reason provided</div>';
        }
      }

      // 设置违规描述（用户的违规行为）
      if (notification.fullReportData?.description && notification.fullReportData.description.trim()) {
        if (descSection) descSection.style.display = 'block';
        if (description) description.textContent = notification.fullReportData.description;
      } else {
        if (descSection) descSection.style.display = 'none';
      }

      // 设置AI判定原因（judgementReason）
      if (reason) reason.textContent = notification.judgementReason || 'No reason provided';

      // 设置举报时间
      if (time) {
        const reportedAt = notification.fullReportData?.reportedAt || notification.timestamp;
        console.log(`🚨 [被举报详情] 举报时间:`, reportedAt);

        if (reportedAt) {
          try {
            const reportTime = new Date(reportedAt);
            time.textContent = reportTime.toLocaleString('en-US', {
              year: 'numeric',
              month: 'short',
              day: 'numeric',
              hour: '2-digit',
              minute: '2-digit',
            });
          } catch (error) {
            console.error('❌ [被举报详情] 时间格式化失败:', error);
            time.textContent = reportedAt;
          }
        } else {
          time.textContent = 'Time not available';
        }
      }

      // 显示弹窗
      overlay.classList.add('show');
      modal.classList.add('show');

      console.log(`🚨 [被举报详情] 已打开详情弹窗`);
    },

    // 加载并渲染提醒列表
    async loadAndRenderNotificationsList() {
      try {
        // 🔧 修复：从数据库读取notifications，而不是从localStorage
        const xDb = getXDB();
        if (!xDb) {
          console.error('❌ [提醒加载] 无法获取数据库');
          this.renderNotificationsList([]);
          return;
        }

        const mapDataId = `mapDatingData_${window.currentAccountId || 'main'}`;
        const mapDatingData = await xDb.xMapDatingData.get(mapDataId);

        let savedNotifications = [];

        // 优先从数据库读取
        if (mapDatingData && mapDatingData.notifications) {
          savedNotifications = mapDatingData.notifications;
          console.log(`📖 [提醒加载] 从数据库加载了 ${savedNotifications.length} 条通知`);
        } else {
          // 兼容：如果数据库没有，尝试从localStorage读取（旧数据迁移）
          const savedNotificationsStr = localStorage.getItem('xMapNotifications');
          if (savedNotificationsStr) {
            savedNotifications = JSON.parse(savedNotificationsStr);
            console.log(`📖 [提醒加载] 从localStorage加载了 ${savedNotifications.length} 条通知（旧数据）`);

            // 迁移到数据库
            if (mapDatingData && savedNotifications.length > 0) {
              mapDatingData.notifications = savedNotifications;
              await xDb.xMapDatingData.put(mapDatingData);
              console.log(`✅ [提醒迁移] 已将localStorage中的通知迁移到数据库`);
              // 清空localStorage
              localStorage.removeItem('xMapNotifications');
            }
          } else {
            console.log(`📖 [提醒加载] 没有找到任何通知数据`);
          }
        }

        // 按时间倒序排列（最新的在最上面）
        savedNotifications.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        this.renderNotificationsList(savedNotifications);
      } catch (error) {
        console.error('❌ [提醒加载] 加载提醒列表失败:', error);
        this.renderNotificationsList([]);
      }
    },

    // 渲染提醒列表
    renderNotificationsList(notifications) {
      const content = document.getElementById('mapNotificationsList');
      const empty = document.getElementById('mapNotificationsEmpty');

      if (!content) {
        console.error('❌ [提醒渲染] 找不到提醒列表容器 #mapNotificationsList');
        return;
      }

      // 清空现有内容
      content.innerHTML = '';

      if (notifications.length === 0) {
        // 显示空状态
        if (empty) {
          empty.style.display = 'flex';
        }
        return;
      }

      // 隐藏空状态
      if (empty) {
        empty.style.display = 'none';
      }

      console.log(`📝 [提醒渲染] 开始渲染 ${notifications.length} 条提醒`);

      // 渲染每个提醒
      notifications.forEach((notification, index) => {
        const item = document.createElement('div');
        item.className = `map-notification-item ${!notification.isRead ? 'unread' : ''}`;

        // 格式化时间
        const timeStr = this.formatNotificationTime(notification.timestamp);

        // 根据类型生成标题、内容和图标
        let title = '';
        let messageText = '';
        let iconSvg = '';

        if (notification.type === 'interested') {
          const user = notification.fromUser;
          title = 'New Interest';
          messageText = `${user.nickname} is interested in your profile`;
          iconSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
          </svg>`;
        } else if (notification.type === 'message') {
          const user = notification.fromUser;
          title = 'New Message';
          if (notification.messages && notification.messages.length > 0) {
            messageText = `${user.nickname}: ${notification.messages[notification.messages.length - 1]}`;
          } else {
            messageText = `${user.nickname} sent you a message`;
          }
          iconSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
          </svg>`;
        } else if (notification.type === 'follow') {
          const user = notification.fromUser;
          title = 'New Follower';
          messageText = `${user.nickname} started following you`;
          iconSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
            <circle cx="8.5" cy="7" r="4"></circle>
            <line x1="20" y1="8" x2="20" y2="14"></line>
            <line x1="23" y1="11" x2="17" y2="11"></line>
          </svg>`;
        } else if (notification.type === 'like') {
          const user = notification.fromUser;
          title = 'New Like';
          messageText = `${user.nickname} liked your post`;
          iconSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
          </svg>`;
        } else if (notification.type === 'report') {
          title = notification.title || 'Report Result';
          if (notification.isApproved) {
            messageText = `Your report about ${notification.reportedUser.nickname} has been reviewed: ${notification.reason}`;
          } else {
            messageText = `Your report about ${notification.reportedUser.nickname} was declined: ${notification.reason}`;
          }
          iconSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
            <line x1="12" y1="9" x2="12" y2="13"></line>
            <line x1="12" y1="17" x2="12.01" y2="17"></line>
          </svg>`;
        } else if (notification.type === 'user_reported') {
          title = notification.title || 'You Have Been Reported';
          if (notification.isApproved) {
            messageText = `${notification.reporterUser.nickname} reported you for violating guidelines. Severity: ${notification.severity}`;
          } else {
            messageText = `${notification.reporterUser.nickname} reported you, but it was determined to be unfounded.`;
          }
          iconSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
            <line x1="12" y1="9" x2="12" y2="13"></line>
            <line x1="12" y1="17" x2="12.01" y2="17"></line>
          </svg>`;
        } else {
          // 默认通知类型
          const user = notification.fromUser;
          title = 'Notification';
          messageText =
            notification.content || (user ? `${user.nickname} interacted with you` : 'You have a new notification');
          iconSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
            <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
          </svg>`;
        }

        console.log(`  ├─ [${index + 1}] ${notification.type}: ${messageText.substring(0, 50)}...`);

        item.innerHTML = `
          <div class="map-notification-icon">
            ${iconSvg}
          </div>
          <div class="map-notification-info">
            <div class="map-notification-header">
              <span class="map-notification-title">${title}</span>
              <span class="map-notification-time">${timeStr}</span>
            </div>
            <div class="map-notification-content">${messageText}</div>
          </div>
        `;

        // 添加点击事件
        item.addEventListener('click', () => {
          this.handleNotificationClick(notification);
        });

        content.appendChild(item);
      });

      // 🔧 更新未读数量统计
      const unreadCount = notifications.filter(n => !n.isRead).length;
      const unreadCountElement = document.getElementById('mapNotificationsUnreadCount');
      if (unreadCountElement) {
        unreadCountElement.textContent = unreadCount;
        console.log(`📊 [提醒统计] 更新未读数量: ${unreadCount}`);
      } else {
        console.warn(`⚠️ [提醒统计] 找不到未读计数元素 #mapNotificationsUnreadCount`);
      }

      console.log(`✅ [提醒渲染] 完成！共渲染 ${notifications.length} 条提醒到容器 #mapNotificationsList`);
    },

    // 筛选提醒列表
    filterNotifications(filterType) {
      try {
        const savedNotificationsStr = localStorage.getItem('xMapNotifications');
        const allNotifications = savedNotificationsStr ? JSON.parse(savedNotificationsStr) : [];

        // 按时间倒序排列
        allNotifications.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        let filteredNotifications = allNotifications;

        // 根据类型筛选
        if (filterType !== 'all') {
          filteredNotifications = allNotifications.filter(notification => {
            if (filterType === 'likes') {
              return notification.type === 'like' || notification.type === 'interested';
            } else if (filterType === 'messages') {
              return notification.type === 'message';
            } else if (filterType === 'follows') {
              return notification.type === 'follow';
            } else if (filterType === 'reports') {
              return notification.type === 'report';
            }
            return true;
          });
        }

        console.log(
          `🔍 [提醒筛选] 筛选类型: ${filterType}, 结果: ${filteredNotifications.length}/${allNotifications.length} 条`,
        );

        // 渲染筛选后的列表
        this.renderNotificationsList(filteredNotifications);
      } catch (error) {
        console.error('❌ [提醒筛选] 筛选失败:', error);
        this.renderNotificationsList([]);
      }
    },

    // 格式化提醒时间
    formatNotificationTime(timestamp) {
      const now = new Date();
      const time = new Date(timestamp);
      const diffMs = now - time;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      const diffDays = Math.floor(diffMs / 86400000);

      if (diffMins < 1) return 'Just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays < 7) return `${diffDays}d ago`;

      // 超过7天显示具体日期
      const month = time.getMonth() + 1;
      const day = time.getDate();
      return `${month}/${day}`;
    },

    // 处理提醒点击
    handleNotificationClick(notification) {
      if (notification.type === 'interested') {
        // 感兴趣类型：直接打开用户卡片
        this.closeNotificationsModal();
        this.showUserProfile(notification.fromUser);
      } else if (notification.type === 'message') {
        // 私信类型：检查是否已接受
        if (notification.isAccepted) {
          // 已接受过，直接打开聊天
          console.log(`💬 [提醒系统] 通知已接受，直接打开聊天`);

          const user = notification.fromUser;
          const messages = notification.messages || [];

          // 🔧 预加载消息到聊天记录（如果有messages且尚未加载）
          if (messages.length > 0) {
            if (!this.chatMessages[user.id]) {
              this.chatMessages[user.id] = [];
            }

            // 检查是否已经加载过这些消息（避免重复）
            const hasMessages = this.chatMessages[user.id].some(
              msg => msg.type === 'received' && messages.includes(msg.text),
            );

            if (!hasMessages) {
              // 将提醒消息转换为聊天消息格式
              const baseTimestamp = Date.now();
              const preloadedMessages = messages.map((content, index) => ({
                type: 'received',
                text: content,
                timestamp: new Date(baseTimestamp - (messages.length - index) * 2000).toISOString(),
              }));

              // 添加到聊天记录开头
              this.chatMessages[user.id] = [...preloadedMessages, ...this.chatMessages[user.id]];
              console.log(`💬 [提醒系统] 已预加载 ${messages.length} 条消息到聊天记录`);
            }
          }

          this.closeNotificationsModal();
          this.openChatModal(user);
        } else {
          // 未接受，打开接收确认弹窗
          this.openAcceptMessageModal(notification);
        }
      } else if (notification.type === 'report') {
        // 举报结果类型：打开详情弹窗查看完整信息
        console.log(`🚨 [举报系统] 查看举报结果: ${notification.title}`);
        this.closeNotificationsModal();
        this.openReportDetailModal(notification);
        this.markNotificationAsRead(notification.id);
      } else if (notification.type === 'user_reported') {
        // 被举报类型：打开详情弹窗查看完整信息
        console.log(`🚨 [被举报系统] 查看被举报结果: ${notification.title}`);
        this.closeNotificationsModal();
        this.openUserReportedDetailModal(notification);
        this.markNotificationAsRead(notification.id);
      }
    },

    // 显示用户资料（用于提醒和聊天头像点击）
    showUserProfile(user, source = 'interested') {
      if (!user || !user.id) {
        console.warn('⚠️ 无效的用户对象');
        return;
      }

      console.log(`📇 [用户资料] 查看 ${user.nickname} 的资料（来源: ${source}）`);

      // 检查用户是否已在currentUsers中
      const existingUser = this.currentUsers.find(u => u.id === user.id);

      if (!existingUser) {
        // 临时添加到currentUsers，以便showDetailCard能找到
        this.currentUsers.push(user);
        console.log(`➕ [用户资料] 临时添加 ${user.nickname} 到当前用户列表`);
      }

      // 显示资料卡，传递来源
      this.showDetailCard(user.id, source);
    },

    // 打开接收私信确认弹窗
    openAcceptMessageModal(notification) {
      const overlay = document.getElementById('mapAcceptMessageOverlay');
      const modal = document.getElementById('mapAcceptMessageModal');

      if (!overlay || !modal) {
        console.error('❌ [提醒系统] 确认弹窗元素未找到');
        return;
      }

      // 保存当前处理的私信提醒
      this.currentMessageNotification = notification;

      // 填充用户信息
      const user = notification.fromUser;
      const avatar =
        user.avatar ||
        "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='50' fill='%23ddd'/%3E%3C/svg%3E";

      // 使用正确的ID选择器
      const avatarEl = document.getElementById('mapAcceptMsgAvatar');
      const nicknameEl = document.getElementById('mapAcceptMsgNickname');
      const handleEl = document.getElementById('mapAcceptMsgHandle');
      const messageTextEl = document.getElementById('mapAcceptMsgText');

      if (avatarEl) avatarEl.src = avatar;
      if (nicknameEl) nicknameEl.textContent = user.nickname;
      if (handleEl) handleEl.textContent = `@${user.handle || user.nickname.toLowerCase()}`;

      // 显示最新一条消息作为预览
      const messages = notification.messages || [];
      const previewText = messages.length > 0 ? messages[messages.length - 1] : notification.content || '发来了私信';
      if (messageTextEl) messageTextEl.textContent = previewText;

      console.log(`💬 [提醒系统] 显示接收私信确认弹窗 - 来自 ${user.nickname}`);

      // 显示弹窗
      overlay.classList.add('show');
      modal.classList.add('show');
    },

    // 接受私信
    async acceptMessage() {
      if (!this.currentMessageNotification) return;

      const user = this.currentMessageNotification.fromUser;
      const messages = this.currentMessageNotification.messages || [];

      console.log(`✅ [提醒系统] 接受来自 ${user.nickname} 的私信 (${messages.length}条消息)`);

      // 预加载消息到聊天记录
      if (messages.length > 0) {
        if (!this.chatMessages[user.id]) {
          this.chatMessages[user.id] = [];
        }

        // 将提醒消息转换为聊天消息格式（匹配renderChatMessages的期望格式）
        const baseTimestamp = Date.now();
        const preloadedMessages = messages.map((content, index) => ({
          type: 'received', // 修正：使用 'received' 而非 'ai'
          text: content, // 修正：使用 'text' 而非 'content'
          timestamp: new Date(baseTimestamp - (messages.length - index) * 2000).toISOString(), // 修正：使用ISO字符串格式
        }));

        // 添加到聊天记录开头（因为这些是初始消息）
        this.chatMessages[user.id] = [...preloadedMessages, ...this.chatMessages[user.id]];

        console.log(`💬 [提醒系统] 已预加载 ${messages.length} 条消息到聊天记录`, preloadedMessages);
      }

      // 关闭确认弹窗
      const overlay = document.getElementById('mapAcceptMessageOverlay');
      const modal = document.getElementById('mapAcceptMessageModal');
      if (overlay) overlay.classList.remove('show');
      if (modal) modal.classList.remove('show');

      // 关闭提醒弹窗
      this.closeNotificationsModal();

      // 🔧 修复：标记该通知为已接受，保存到数据库而不是localStorage
      try {
        const xDb = getXDB();
        if (!xDb) {
          console.error('❌ [提醒系统] 无法获取数据库');
          return;
        }

        const mapDataId = `mapDatingData_${window.currentAccountId || 'main'}`;
        const mapDatingData = await xDb.xMapDatingData.get(mapDataId);

        if (mapDatingData && mapDatingData.notifications) {
          const notifIndex = mapDatingData.notifications.findIndex(n => n.id === this.currentMessageNotification.id);
          if (notifIndex !== -1) {
            mapDatingData.notifications[notifIndex].isAccepted = true;
            await xDb.xMapDatingData.put(mapDatingData);
            console.log(`✅ [提醒系统] 已标记通知 ${this.currentMessageNotification.id} 为已接受`);
          } else {
            console.warn(`⚠️ [提醒系统] 未找到通知 ${this.currentMessageNotification.id}`);
          }
        }
      } catch (error) {
        console.error('❌ [提醒系统] 更新通知状态失败:', error);
      }

      // 🎯 标记聊天发起上下文：接收对方主动发来的私信
      this.chatContext[user.id] = 'message_accepted';
      console.log(`🎯 [聊天上下文] ${user.nickname} - 对方主动发起私信，你接收`);

      // 打开聊天界面
      this.openChatModal(user);

      // 清空当前提醒
      this.currentMessageNotification = null;
    },

    // 拒绝私信
    declineMessage() {
      if (!this.currentMessageNotification) return;

      // 关闭确认弹窗
      const overlay = document.getElementById('mapAcceptMessageOverlay');
      const modal = document.getElementById('mapAcceptMessageModal');
      if (overlay) overlay.classList.remove('show');
      if (modal) modal.classList.remove('show');

      // 从提醒列表中删除这条提醒
      this.removeNotification(this.currentMessageNotification.id);

      // 清空当前提醒
      this.currentMessageNotification = null;

      // 重新渲染提醒列表
      this.loadAndRenderNotificationsList();
    },

    // 标记所有提醒为已读
    async markAllNotificationsAsRead() {
      try {
        // 🔧 修复：从数据库读取和保存notifications
        const xDb = getXDB();
        if (!xDb) {
          console.error('❌ [提醒系统] 无法获取数据库');
          return;
        }

        const mapDataId = `mapDatingData_${window.currentAccountId || 'main'}`;
        const mapDatingData = await xDb.xMapDatingData.get(mapDataId);

        if (!mapDatingData || !mapDatingData.notifications) return;

        // 标记所有为已读
        mapDatingData.notifications.forEach(n => (n.isRead = true));

        // 保存回数据库
        await xDb.xMapDatingData.put(mapDatingData);

        // 更新徽章
        this.updateNotificationBadge();

        // 🔧 同时更新弹窗里的unread计数
        const unreadCountElement = document.getElementById('mapNotificationsUnreadCount');
        if (unreadCountElement) {
          unreadCountElement.textContent = '0';
          console.log(`📊 [提醒统计] 已将弹窗unread计数更新为0`);
        }
      } catch (error) {
        console.error('❌ [提醒系统] 标记提醒已读失败:', error);
      }
    },

    // 更新提醒徽章
    async updateNotificationBadge() {
      try {
        // 🔧 修复：先获取数据库实例
        const xDb = getXDB();
        if (!xDb) {
          console.error('❌ [提醒系统] 无法获取数据库');
          return;
        }

        // 🔧 修复：从数据库读取notifications
        const mapDataId = `mapDatingData_${window.currentAccountId || 'main'}`;
        const mapDatingData = await xDb.xMapDatingData.get(mapDataId);

        const notifications = mapDatingData && mapDatingData.notifications ? mapDatingData.notifications : [];

        // 计算未读数量
        const unreadCount = notifications.filter(n => !n.isRead).length;

        const badge = document.getElementById('mapNotificationsBadge');
        if (!badge) return;

        if (unreadCount > 0) {
          badge.textContent = unreadCount > 99 ? '99+' : unreadCount;
          badge.classList.remove('hidden');
        } else {
          badge.classList.add('hidden');
        }
      } catch (error) {
        console.error('❌ [提醒系统] 更新提醒徽章失败:', error);
      }
    },

    // 删除指定提醒
    async removeNotification(notificationId) {
      try {
        // 🔧 修复：从数据库删除notifications
        const xDb = getXDB();
        if (!xDb) {
          console.error('❌ [提醒系统] 无法获取数据库');
          return;
        }

        const mapDataId = `mapDatingData_${window.currentAccountId || 'main'}`;
        const mapDatingData = await xDb.xMapDatingData.get(mapDataId);

        if (!mapDatingData || !mapDatingData.notifications) return;

        const filtered = mapDatingData.notifications.filter(n => n.id !== notificationId);
        mapDatingData.notifications = filtered;

        await xDb.xMapDatingData.put(mapDatingData);
        await this.updateNotificationBadge();
      } catch (error) {
        console.error('❌ [提醒系统] 删除提醒失败:', error);
      }
    },

    // 标记提醒为已读
    async markNotificationAsRead(notificationId) {
      try {
        // 🔧 修复：从数据库读取和保存notifications
        const xDb = getXDB();
        if (!xDb) {
          console.error('❌ [提醒系统] 无法获取数据库');
          return;
        }

        const mapDataId = `mapDatingData_${window.currentAccountId || 'main'}`;
        const mapDatingData = await xDb.xMapDatingData.get(mapDataId);

        if (!mapDatingData || !mapDatingData.notifications) return;

        const notification = mapDatingData.notifications.find(n => n.id === notificationId);

        if (notification) {
          notification.isRead = true;
          await xDb.xMapDatingData.put(mapDatingData);
          this.updateNotificationBadge();
          console.log(`✅ [提醒系统] 已标记提醒为已读: ${notificationId}`);
        }
      } catch (error) {
        console.error('❌ [提醒系统] 标记提醒已读失败:', error);
      }
    },

    // 添加新提醒（供其他功能调用）
    addNotification(notification) {
      try {
        const savedNotificationsStr = localStorage.getItem('xMapNotifications');
        const notifications = savedNotificationsStr ? JSON.parse(savedNotificationsStr) : [];

        // 添加新提醒
        notifications.push({
          id: `notif-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          type: notification.type,
          fromUser: notification.fromUser,
          content: notification.content,
          timestamp: new Date().toISOString(),
          isRead: false,
        });

        // 保存
        localStorage.setItem('xMapNotifications', JSON.stringify(notifications));

        // 更新徽章
        this.updateNotificationBadge();
      } catch (error) {
        console.error('添加提醒失败:', error);
      }
    },

    // 加载并渲染聊天列表
    loadAndRenderChatsList() {
      try {
        const savedChatsStr = localStorage.getItem('xMapSavedChats');
        const savedChats = savedChatsStr ? JSON.parse(savedChatsStr) : [];
        this.renderChatsList(savedChats);
      } catch (error) {
        console.error('加载聊天列表失败:', error);
        this.renderChatsList([]);
      }
    },

    // 渲染聊天列表
    renderChatsList(chats) {
      const content = document.getElementById('mapChatsListContent');
      const empty = document.getElementById('mapChatsListEmpty');

      if (!content) return;

      // 清空现有内容
      content.innerHTML = '';

      if (chats.length === 0) {
        // 显示空状态
        if (empty) {
          empty.style.display = 'flex';
          content.appendChild(empty);
        }
      } else {
        // 隐藏空状态，渲染列表
        if (empty) empty.style.display = 'none';

        chats.forEach(chat => {
          const item = document.createElement('div');
          item.className = 'map-chats-list-item';
          item.innerHTML = `
            <img class="map-chats-list-item-avatar" src="${chat.avatar}" alt="${chat.name}">
            <div class="map-chats-list-item-info">
              <p class="map-chats-list-item-name">${chat.name}</p>
              <p class="map-chats-list-item-preview">${chat.lastMessage || 'Start chatting...'}</p>
            </div>
            <button class="map-chats-list-item-delete" data-chat-id="${chat.id}">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
              </svg>
            </button>
          `;

          // 点击聊天项打开聊天
          item.addEventListener('click', e => {
            // 如果点击的是删除按钮，不打开聊天
            if (e.target.closest('.map-chats-list-item-delete')) return;
            this.openChatFromList(chat);
          });

          // 删除按钮事件
          const deleteBtn = item.querySelector('.map-chats-list-item-delete');
          deleteBtn.addEventListener('click', e => {
            e.stopPropagation();
            this.removeChatFromList(chat.id);
          });

          content.appendChild(item);
        });
      }
    },

    // 从列表中打开聊天
    openChatFromList(chat) {
      // 关闭聊天列表弹窗
      this.closeChatsListModal();

      // 打开聊天窗口
      if (chat.userData) {
        this.openChatModal(chat.userData);
      } else {
        console.error('聊天数据不完整');
      }
    },

    // 从列表中删除聊天
    removeChatFromList(chatId) {
      try {
        const savedChatsStr = localStorage.getItem('xMapSavedChats');
        const savedChats = savedChatsStr ? JSON.parse(savedChatsStr) : [];
        const filteredChats = savedChats.filter(chat => chat.id !== chatId);
        localStorage.setItem('xMapSavedChats', JSON.stringify(filteredChats));

        // 重新渲染列表
        this.renderChatsList(filteredChats);

        console.log('已从聊天列表删除');
      } catch (error) {
        console.error('删除聊天失败:', error);
      }
    },

    // ==================== 📌 用户笔记功能方法 ====================

    // 生成SVG图标（根据iconType）
    getCategoryIcon(iconType) {
      const icons = {
        briefcase:
          '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path></svg>',
        heart:
          '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>',
        users:
          '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>',
        user: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>',
        eye: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>',
        coffee:
          '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 8h1a4 4 0 0 1 0 8h-1"></path><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path><line x1="6" y1="1" x2="6" y2="4"></line><line x1="10" y1="1" x2="10" y2="4"></line><line x1="14" y1="1" x2="14" y2="4"></line></svg>',
        'map-pin':
          '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>',
        star: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>',
        repeat:
          '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path></svg>',
        'user-plus':
          '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="23" y1="11" x2="17" y2="11"></line></svg>',
        'file-text':
          '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>',
      };
      return icons[iconType] || icons['file-text'];
    },

    // 切换功能菜单
    toggleFunctionMenu() {
      const menu = document.getElementById('mapChatFunctionMenu');
      const addBtn = document.getElementById('mapChatAddBtn');
      if (!menu || !addBtn) return;

      const isOpen = menu.classList.contains('show');

      if (isOpen) {
        this.closeFunctionMenu();
      } else {
        menu.classList.add('show');
        addBtn.classList.add('active');
      }
    },

    // 关闭功能菜单
    closeFunctionMenu() {
      const menu = document.getElementById('mapChatFunctionMenu');
      const addBtn = document.getElementById('mapChatAddBtn');
      if (menu) menu.classList.remove('show');
      if (addBtn) addBtn.classList.remove('active');
    },

    // 打开笔记弹窗
    openNotesModal() {
      if (!this.currentChatUser) {
        console.warn('⚠️ 没有当前聊天对象，无法打开笔记弹窗');
        return;
      }

      const overlay = document.getElementById('mapNotesOverlay');
      const modal = document.getElementById('mapNotesModal');

      if (overlay) overlay.classList.add('show');
      if (modal) modal.classList.add('show');

      // 默认显示"我的笔记"Tab
      this.currentNotesTab = 'mine';
      this.switchNotesMainTab('mine');

      // 设置主Tab切换监听器
      this.setupMainTabListeners();

      // 设置分类过滤监听器
      this.setupNoteCategoryFilters();

      // 关闭功能菜单
      this.closeFunctionMenu();
    },

    // 设置主Tab切换监听器
    setupMainTabListeners() {
      const mineTab = document.getElementById('mapNotesMainTabMine');
      const theirsTab = document.getElementById('mapNotesMainTabTheirs');

      if (mineTab) {
        mineTab.onclick = () => this.switchNotesMainTab('mine');
      }
      if (theirsTab) {
        theirsTab.onclick = () => this.switchNotesMainTab('theirs');
      }
    },

    // 切换主Tab
    switchNotesMainTab(tab) {
      this.currentNotesTab = tab;

      // 更新Tab按钮状态
      const mineTab = document.getElementById('mapNotesMainTabMine');
      const theirsTab = document.getElementById('mapNotesMainTabTheirs');

      if (mineTab && theirsTab) {
        if (tab === 'mine') {
          mineTab.classList.add('active');
          theirsTab.classList.remove('active');
        } else {
          mineTab.classList.remove('active');
          theirsTab.classList.add('active');
        }
      }

      // 渲染对应的笔记内容
      this.renderUserNotes(this.currentChatUser.id);
    },

    // 关闭笔记弹窗
    closeNotesModal() {
      const overlay = document.getElementById('mapNotesOverlay');
      const modal = document.getElementById('mapNotesModal');
      if (overlay) overlay.classList.remove('show');
      if (modal) modal.classList.remove('show');
    },

    // 🎯 打开指定筛选弹窗
    openAdvancedFilterModal() {
      const overlay = document.getElementById('mapAdvancedFilterOverlay');
      const modal = document.getElementById('mapAdvancedFilterModal');

      if (overlay) overlay.classList.add('show');
      if (modal) modal.classList.add('show');

      // 填充当前筛选条件
      if (this.advancedFilter.enabled) {
        const genderRadio = document.querySelector(`input[name="advGender"][value="${this.advancedFilter.gender}"]`);
        if (genderRadio) genderRadio.checked = true;

        document.getElementById('advAgeMin').value = this.advancedFilter.ageMin;
        document.getElementById('advAgeMax').value = this.advancedFilter.ageMax;
        document.getElementById('advPersonality').value = this.advancedFilter.personality;
        document.getElementById('advTags').value = this.advancedFilter.tags;
        document.getElementById('advType').value = this.advancedFilter.type;
      }

      console.log('🎯 [指定筛选] 打开指定筛选弹窗');
    },

    // 🎯 关闭指定筛选弹窗
    closeAdvancedFilterModal() {
      const overlay = document.getElementById('mapAdvancedFilterOverlay');
      const modal = document.getElementById('mapAdvancedFilterModal');

      if (overlay) overlay.classList.remove('show');
      if (modal) modal.classList.remove('show');
    },

    // 🎯 清除指定筛选
    clearAdvancedFilter() {
      // 重置表单
      const genderAllRadio = document.querySelector('input[name="advGender"][value="all"]');
      if (genderAllRadio) genderAllRadio.checked = true;

      document.getElementById('advAgeMin').value = 18;
      document.getElementById('advAgeMax').value = 50;
      document.getElementById('advPersonality').value = '';
      document.getElementById('advTags').value = '';
      document.getElementById('advType').value = '';

      // 重置筛选条件
      this.advancedFilter = {
        enabled: false,
        gender: 'all',
        ageMin: 18,
        ageMax: 50,
        personality: '',
        tags: '',
        type: '',
      };

      console.log('🎯 [指定筛选] 已清除筛选条件');
    },

    // 🎯 应用指定筛选
    async applyAdvancedFilter() {
      // 获取表单值
      const genderRadio = document.querySelector('input[name="advGender"]:checked');
      const gender = genderRadio ? genderRadio.value : 'all';
      const ageMin = parseInt(document.getElementById('advAgeMin').value) || 18;
      const ageMax = parseInt(document.getElementById('advAgeMax').value) || 50;
      const personality = document.getElementById('advPersonality').value.trim();
      const tags = document.getElementById('advTags').value.trim();
      const type = document.getElementById('advType').value.trim();

      // 保存筛选条件
      this.advancedFilter = {
        enabled: true,
        gender,
        ageMin,
        ageMax,
        personality,
        tags,
        type,
      };

      console.log('🎯 [指定筛选] 应用筛选条件:', this.advancedFilter);

      // 关闭弹窗
      this.closeAdvancedFilterModal();

      // 调用刷新附近的人（使用指定筛选）
      await this.refreshNearbyUsers();
    },

    // 设置消息双击监听器（支持移动端和PC端）
    setupMessageDoubleClickListeners() {
      const bubbles = document.querySelectorAll('.map-chat-bubble');
      console.log(`📌 [笔记系统] 绑定双击/长按事件到 ${bubbles.length} 个消息气泡`);

      bubbles.forEach((bubble, idx) => {
        let touchStartTime = 0;
        let touchTimer = null;

        // 触发笔记标记的处理函数
        const triggerNoteMarking = (x, y) => {
          const messageIndex = parseInt(bubble.getAttribute('data-message-index'));
          const content = bubble.textContent;

          console.log(`📌 [笔记系统] 标记消息 #${messageIndex}: ${content.substring(0, 30)}...`);

          // 显示标记动画
          bubble.classList.add('marking');
          setTimeout(() => bubble.classList.remove('marking'), 600);

          // 显示分类选择器
          this.showCategoryPicker(x, y, messageIndex, content, bubble);
        };

        // PC端双击事件
        bubble.addEventListener('dblclick', e => {
          e.preventDefault();
          e.stopPropagation();
          triggerNoteMarking(e.clientX, e.clientY);
        });

        // 移动端长按事件（按住500ms）
        bubble.addEventListener(
          'touchstart',
          e => {
            touchStartTime = Date.now();
            const touch = e.touches[0];

            // 设置长按计时器
            touchTimer = setTimeout(() => {
              // 长按500ms后触发
              e.preventDefault();
              triggerNoteMarking(touch.clientX, touch.clientY);
            }, 500);
          },
          { passive: false },
        );

        bubble.addEventListener('touchend', e => {
          // 清除长按计时器
          if (touchTimer) {
            clearTimeout(touchTimer);
            touchTimer = null;
          }
        });

        bubble.addEventListener('touchmove', e => {
          // 如果移动了，取消长按
          if (touchTimer) {
            clearTimeout(touchTimer);
            touchTimer = null;
          }
        });
      });
    },

    // 显示分类选择器（简洁列表）
    showCategoryPicker(x, y, messageIndex, content, sourceElement) {
      console.log(`📌 [笔记系统] 显示分类选择器`);

      const overlay = document.getElementById('mapNotesPickerOverlay');
      const picker = document.getElementById('mapNotesPicker');
      const pickerList = document.getElementById('mapNotesPickerList');

      console.log(`📌 [笔记系统] 元素检查: overlay=${!!overlay}, picker=${!!picker}, pickerList=${!!pickerList}`);

      if (!overlay || !picker || !pickerList) {
        console.error('❌ [笔记系统] 分类选择器元素未找到！');
        return;
      }

      // 清空列表
      pickerList.innerHTML = '';

      // 生成分类列表
      console.log(`📌 [笔记系统] 生成 ${this.noteCategories.length} 个分类选项`);

      this.noteCategories.forEach(category => {
        const item = document.createElement('div');
        item.className = 'map-notes-picker-item';
        item.innerHTML = `
          ${this.getCategoryIcon(category.iconType)}
          <span>${category.name}</span>
        `;

        item.addEventListener('click', () => {
          console.log(`📌 [笔记系统] 选择分类: ${category.name}`);
          this.addUserNote(category, content, messageIndex, sourceElement);
          this.hideCategoryPicker();
        });

        pickerList.appendChild(item);
      });

      // 显示弹窗
      overlay.classList.add('show');
      picker.classList.add('show');

      console.log(`✅ [笔记系统] 分类选择器已显示`);

      // 点击遮罩关闭
      overlay.addEventListener('click', () => {
        this.hideCategoryPicker();
      });
    },

    // 隐藏分类选择器
    hideCategoryPicker() {
      const overlay = document.getElementById('mapNotesPickerOverlay');
      const picker = document.getElementById('mapNotesPicker');
      if (overlay) overlay.classList.remove('show');
      if (picker) picker.classList.remove('show');
    },

    // 添加用户笔记
    addUserNote(category, content, messageIndex, sourceElement) {
      if (!this.currentChatUser) return;

      const userId = this.currentChatUser.id;

      // 初始化用户笔记数组
      if (!this.userMarkedNotes[userId]) {
        this.userMarkedNotes[userId] = [];
      }

      // 检查是否已存在相同消息的笔记
      const exists = this.userMarkedNotes[userId].some(note => note.messageIndex === messageIndex);

      if (exists) {
        console.warn('⚠️ 该消息已被标记为笔记');
        return;
      }

      // 创建笔记对象
      const note = {
        id: `note_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        category: category.id,
        categoryName: category.name,
        categoryIconType: category.iconType,
        content: content,
        messageIndex: messageIndex,
        timestamp: new Date().toISOString(),
      };

      // 添加到笔记列表
      this.userMarkedNotes[userId].push(note);

      console.log(`✅ 添加笔记成功: [${category.name}] ${content.substring(0, 20)}...`);

      // 保存到数据库
      this.saveChatToDatabase();

      // 如果笔记弹窗已打开，刷新内容
      const modal = document.getElementById('mapNotesModal');
      if (modal && modal.classList.contains('show')) {
        this.renderUserNotes(userId);
      }
    },

    // 渲染用户笔记（时间线式）
    renderUserNotes(userId, filterCategory = 'all') {
      const notesList = document.getElementById('mapNotesList');
      const notesEmpty = document.getElementById('mapNotesEmpty');
      if (!notesList) return;

      // 根据当前Tab选择笔记数据源
      const isMyNotes = this.currentNotesTab === 'mine';
      const notes = isMyNotes ? this.userMarkedNotes[userId] || [] : this.npcNotesAboutUser[userId] || [];

      // 过滤笔记
      const filteredNotes = filterCategory === 'all' ? notes : notes.filter(note => note.category === filterCategory);

      if (filteredNotes.length === 0) {
        const emptyMessage = isMyNotes
          ? 'Double-tap messages to add notes'
          : `${this.currentChatUser?.nickname || 'TA'} hasn't recorded anything about you yet`;

        notesList.innerHTML = `
          <div class="map-notes-empty">
            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
              <polyline points="14 2 14 8 20 8"></polyline>
              <line x1="12" y1="11" x2="12" y2="17"></line>
              <line x1="9" y1="14" x2="15" y2="14"></line>
            </svg>
            <p>No notes yet</p>
            <span>${emptyMessage}</span>
          </div>
        `;
        return;
      }

      // 渲染笔记列表（时间线式）
      let html = '';
      filteredNotes.reverse().forEach(note => {
        const date = new Date(note.timestamp);
        const timeStr = `${date.getMonth() + 1}/${date.getDate()} ${date.getHours()}:${String(
          date.getMinutes(),
        ).padStart(2, '0')}`;

        // 获取图标类型（需要处理不同的数据结构）
        let iconType = 'file-text';
        if (isMyNotes) {
          iconType = note.categoryIconType || 'file-text';
        } else {
          // NPC笔记，根据category映射到iconType
          const categoryIconMap = {
            work: 'briefcase',
            hobby: 'heart',
            family: 'users',
            personality: 'user',
            appearance: 'eye',
            food: 'coffee',
            location: 'map-pin',
            dream: 'star',
            habit: 'repeat',
            friend: 'user-plus',
            other: 'file-text',
          };
          iconType = categoryIconMap[note.category] || 'file-text';
        }

        html += `
          <div class="map-notes-item" data-note-id="${note.id}">
            <div class="map-notes-item-icon">
              ${this.getCategoryIcon(iconType)}
            </div>
            <div class="map-notes-item-content">
              <div class="map-notes-item-header">
                <span class="map-notes-item-category">${note.categoryName}</span>
                <span class="map-notes-item-time">${timeStr}</span>
              </div>
              <div class="map-notes-item-text">${note.content}</div>
              ${
                isMyNotes
                  ? `
              <div class="map-notes-item-actions">
                <button class="map-notes-item-action" data-action="edit" data-note-id="${note.id}">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                  </svg>
                  Edit
                </button>
                <button class="map-notes-item-action" data-action="delete" data-note-id="${note.id}">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="3 6 5 6 21 6"></polyline>
                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                  </svg>
                  Delete
                </button>
              </div>
              `
                  : ''
              }
            </div>
          </div>
        `;
      });

      notesList.innerHTML = html;

      // 只有"我的笔记"Tab才绑定操作事件
      if (isMyNotes) {
        this.setupNoteItemActions();
      }
    },

    // 设置笔记操作
    setupNoteItemActions() {
      const editBtns = document.querySelectorAll('[data-action="edit"]');
      const deleteBtns = document.querySelectorAll('[data-action="delete"]');

      editBtns.forEach(btn => {
        btn.addEventListener('click', e => {
          e.stopPropagation();
          const noteId = btn.getAttribute('data-note-id');
          this.editUserNote(noteId);
        });
      });

      deleteBtns.forEach(btn => {
        btn.addEventListener('click', e => {
          e.stopPropagation();
          const noteId = btn.getAttribute('data-note-id');
          this.deleteUserNote(noteId);
        });
      });
    },

    // 设置分类过滤（tabs式）
    setupNoteCategoryFilters() {
      const tabsContainer = document.getElementById('mapNotesTabs');
      if (!tabsContainer) return;

      // 清空并重新生成tabs
      let html = `<button class="map-notes-tab active" data-category="all">All</button>`;

      this.noteCategories.forEach(category => {
        html += `<button class="map-notes-tab" data-category="${category.id}">${category.name}</button>`;
      });

      tabsContainer.innerHTML = html;

      // 绑定点击事件
      const tabs = tabsContainer.querySelectorAll('.map-notes-tab');
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const category = tab.getAttribute('data-category');

          // 更新active状态
          tabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');

          // 重新渲染笔记
          if (this.currentChatUser) {
            this.renderUserNotes(this.currentChatUser.id, category);
          }
        });
      });
    },

    // 编辑笔记
    editUserNote(noteId) {
      if (!this.currentChatUser) return;

      const userId = this.currentChatUser.id;
      const notes = this.userMarkedNotes[userId] || [];
      const note = notes.find(n => n.id === noteId);

      if (!note) {
        console.warn('⚠️ 未找到笔记:', noteId);
        return;
      }

      // 简单的prompt编辑（后续可以优化为更好的UI）
      const newContent = prompt('编辑笔记内容:', note.content);

      if (newContent && newContent.trim() !== '' && newContent !== note.content) {
        note.content = newContent.trim();
        note.timestamp = new Date().toISOString(); // 更新时间戳

        console.log(`✅ 笔记编辑成功: ${note.id}`);

        // 保存到数据库
        this.saveChatToDatabase();

        // 刷新显示
        this.renderUserNotes(userId);
      }
    },

    // 删除笔记
    deleteUserNote(noteId) {
      if (!this.currentChatUser) return;

      const userId = this.currentChatUser.id;
      const notes = this.userMarkedNotes[userId] || [];
      const index = notes.findIndex(n => n.id === noteId);

      if (index === -1) {
        console.warn('⚠️ 未找到笔记:', noteId);
        return;
      }

      // 确认删除
      if (!confirm('确定要删除这条笔记吗？')) {
        return;
      }

      // 删除笔记
      notes.splice(index, 1);

      console.log(`✅ 笔记删除成功: ${noteId}`);

      // 保存到数据库
      this.saveChatToDatabase();

      // 刷新显示
      this.renderUserNotes(userId);
    },

    // ==================== 📌 用户笔记功能方法结束 ====================

    // ==================== 🗑️ 删除模式功能方法 ====================

    // 进入删除模式
    enterDeleteMode() {
      if (!this.currentChatUser) {
        console.warn('⚠️ 没有当前聊天对象，无法进入删除模式');
        return;
      }

      // 初始化删除模式状态（如果还没有初始化）
      if (!this.deleteMode) {
        this.deleteMode = {
          active: false,
          selectedIndices: new Set(), // 选中的消息索引
        };
      }

      this.deleteMode.active = true;
      this.deleteMode.selectedIndices.clear();

      // 显示删除工具栏
      const toolbar = document.getElementById('mapChatDeleteToolbar');
      if (toolbar) toolbar.style.display = 'flex';

      // 隐藏聊天底栏（输入框等）
      const footer = document.querySelector('.map-chat-footer');
      if (footer) footer.style.display = 'none';

      // 重新渲染聊天消息（添加delete-mode class和点击事件）
      this.renderChatMessages();

      console.log(`🗑️ [删除模式] 进入删除模式，用户: ${this.currentChatUser.nickname}`);
    },

    // 退出删除模式
    exitDeleteMode() {
      if (!this.deleteMode) return;

      this.deleteMode.active = false;
      this.deleteMode.selectedIndices.clear();

      // 隐藏删除工具栏
      const toolbar = document.getElementById('mapChatDeleteToolbar');
      if (toolbar) toolbar.style.display = 'none';

      // 显示聊天底栏
      const footer = document.querySelector('.map-chat-footer');
      if (footer) footer.style.display = 'flex';

      // 重置全选复选框
      const selectAllCheckbox = document.getElementById('mapChatDeleteSelectAll');
      if (selectAllCheckbox) selectAllCheckbox.checked = false;

      // 重新渲染聊天消息（移除delete-mode class）
      this.renderChatMessages();

      console.log('🗑️ [删除模式] 退出删除模式');
    },

    // 切换消息选中状态
    toggleMessageSelection(index) {
      if (!this.deleteMode || !this.deleteMode.active) return;

      if (this.deleteMode.selectedIndices.has(index)) {
        this.deleteMode.selectedIndices.delete(index);
      } else {
        this.deleteMode.selectedIndices.add(index);
      }

      // 更新UI：消息气泡的选中状态
      const bubbles = document.querySelectorAll('.map-chat-bubble[data-message-index]');
      bubbles.forEach(bubble => {
        const bubbleIndex = parseInt(bubble.dataset.messageIndex);
        if (bubbleIndex === index) {
          bubble.classList.toggle('selected', this.deleteMode.selectedIndices.has(index));
        }
      });

      // 更新删除按钮和全选复选框状态
      this.updateDeleteButtonState();
      this.updateSelectAllState();
    },

    // 切换全选
    toggleSelectAllMessages(checked) {
      if (!this.deleteMode || !this.deleteMode.active || !this.currentChatUser) return;

      const messages = this.chatMessages[this.currentChatUser.id] || [];

      if (checked) {
        // 全选
        messages.forEach((_, index) => {
          this.deleteMode.selectedIndices.add(index);
        });
      } else {
        // 取消全选
        this.deleteMode.selectedIndices.clear();
      }

      // 更新所有消息气泡的选中状态
      const bubbles = document.querySelectorAll('.map-chat-bubble[data-message-index]');
      bubbles.forEach(bubble => {
        const index = parseInt(bubble.dataset.messageIndex);
        bubble.classList.toggle('selected', this.deleteMode.selectedIndices.has(index));
      });

      // 更新删除按钮状态
      this.updateDeleteButtonState();
    },

    // 更新删除按钮状态
    updateDeleteButtonState() {
      const deleteBtn = document.getElementById('mapChatDeleteSelected');
      if (deleteBtn && this.deleteMode) {
        deleteBtn.disabled = this.deleteMode.selectedIndices.size === 0;
      }
    },

    // 更新全选复选框状态
    updateSelectAllState() {
      if (!this.currentChatUser || !this.deleteMode) return;

      const selectAllCheckbox = document.getElementById('mapChatDeleteSelectAll');
      const messages = this.chatMessages[this.currentChatUser.id] || [];

      if (selectAllCheckbox && messages.length > 0) {
        selectAllCheckbox.checked = this.deleteMode.selectedIndices.size === messages.length;
      }
    },

    // 删除选中的消息
    deleteSelectedMessages() {
      if (!this.currentChatUser || !this.deleteMode || this.deleteMode.selectedIndices.size === 0) {
        return;
      }

      const count = this.deleteMode.selectedIndices.size;
      const confirmMsg = `Delete ${count} selected message${count !== 1 ? 's' : ''}?\n\nThis action cannot be undone.`;

      if (!confirm(confirmMsg)) return;

      const userId = this.currentChatUser.id;
      const messages = this.chatMessages[userId] || [];

      // 收集要删除的索引，倒序排列（从大到小删除，避免索引错位）
      const indicesToDelete = Array.from(this.deleteMode.selectedIndices).sort((a, b) => b - a);

      console.log(
        `🗑️ [删除模式] 删除选中消息，用户: ${this.currentChatUser.nickname}，索引: ${indicesToDelete.join(', ')}`,
      );

      // 删除消息
      indicesToDelete.forEach(index => {
        messages.splice(index, 1);
      });

      // 更新聊天记录
      this.chatMessages[userId] = messages;

      // 保存到数据库
      this.saveChatToDatabase();

      // 清空选中状态
      this.deleteMode.selectedIndices.clear();

      // 重新渲染聊天界面
      this.renderChatMessages();

      // 更新按钮状态
      this.updateDeleteButtonState();
      this.updateSelectAllState();

      console.log(`✅ [删除模式] 已删除 ${count} 条消息`);
    },

    // 清空所有数据
    clearAllChatData() {
      if (!this.currentChatUser) return;

      // 严格确认
      const confirmMsg = `⚠️ WARNING ⚠️\n\nClear ALL data for ${this.currentChatUser.nickname}?\n\nThis will delete:\n- All messages\n- All notes\n- Affection data\n- User marked notes\n- NPC notes about you\n\nThis action CANNOT be undone!\n\nType "DELETE" to confirm:`;
      const userInput = prompt(confirmMsg);

      if (userInput !== 'DELETE') {
        console.log('🗑️ [删除模式] 清空数据操作已取消');
        return;
      }

      const userId = this.currentChatUser.id;
      const userNickname = this.currentChatUser.nickname;

      console.log(`🗑️ [删除模式] 开始清空用户数据，用户: ${userNickname} (ID: ${userId})`);

      // 清空所有相关数据（只针对当前用户！）
      delete this.chatMessages[userId];
      delete this.chatNotes[userId];
      delete this.chatAffectionData[userId];
      delete this.userMarkedNotes[userId];
      delete this.npcNotesAboutUser[userId];
      delete this.chatContext[userId];

      console.log(`✅ [删除模式] 已清空以下数据:`);
      console.log(`  |- 聊天消息 (chatMessages[${userId}])`);
      console.log(`  |- AI笔记 (chatNotes[${userId}])`);
      console.log(`  |- 好感度数据 (chatAffectionData[${userId}])`);
      console.log(`  |- 用户标记笔记 (userMarkedNotes[${userId}])`);
      console.log(`  |- NPC对用户笔记 (npcNotesAboutUser[${userId}])`);
      console.log(`  |- 聊天上下文 (chatContext[${userId}])`);

      // 保存到数据库
      this.saveChatToDatabase();

      // 退出删除模式
      this.exitDeleteMode();

      // 重新渲染聊天界面
      this.renderChatMessages();

      // 提示用户
      alert(`All data for ${userNickname} has been cleared.`);

      console.log(`✅✅ [删除模式] 用户 ${userNickname} 的所有数据已清空并保存到数据库`);
    },

    // ==================== 🗑️ 删除模式功能方法结束 ====================

    // 渲染聊天消息（关键方法：实现消息组逻辑）
    renderChatMessages() {
      if (!this.currentChatUser) return;

      const chatMessagesContainer = document.getElementById('mapChatMessages');
      if (!chatMessagesContainer) return;

      const messages = this.chatMessages[this.currentChatUser.id] || [];

      // 按时间戳分组消息
      const messageGroups = [];
      let currentGroup = null;
      let lastTimestamp = null;

      messages.forEach((msg, index) => {
        const msgDate = new Date(msg.timestamp);

        // ⏰ 每条消息都有timestamp字段，UI显示分组时间戳（超过1小时显示一次）
        // 判断是否需要显示时间戳（超过1小时或第一条消息）
        const showTimestamp = !lastTimestamp || msgDate - lastTimestamp > 60 * 60 * 1000 || index === 0;

        if (showTimestamp) {
          lastTimestamp = msgDate;
          // 添加时间戳分隔
          messageGroups.push({
            type: 'timestamp',
            time: this.formatChatTime(msgDate),
          });
        }

        // 判断是否需要创建新的消息组
        if (!currentGroup || currentGroup.sender !== msg.type) {
          currentGroup = {
            type: 'group',
            sender: msg.type, // 'sent' or 'received'
            messages: [],
          };
          messageGroups.push(currentGroup);
        }

        currentGroup.messages.push(msg);
      });

      // 渲染HTML
      let html = '';

      let globalMessageIndex = 0; // 📌 全局消息索引

      messageGroups.forEach(group => {
        if (group.type === 'timestamp') {
          // 渲染时间戳（分组时间戳，超过1小时显示一次）
          html += `<div class="map-chat-timestamp">${group.time}</div>`;
        } else {
          // 渲染消息组
          const isReceived = group.sender === 'received';
          const avatar = isReceived ? this.currentChatUser.avatar : this.userMapProfile?.avatar || '';

          html += `<div class="map-chat-message-group ${group.sender}">`;

          group.messages.forEach((msg, index) => {
            const isLast = index === group.messages.length - 1;
            const msgType = msg.messageType || msg.type || 'text'; // 兼容旧数据

            html += `<div class="map-chat-message-row ${group.sender}">`;

            // 头像：只在最后一条消息显示，其他消息用占位符
            if (isLast) {
              html += `<img class="map-chat-message-avatar" src="${avatar}" alt="Avatar">`;
            } else {
              html += `<div class="map-chat-message-avatar-placeholder"></div>`;
            }

            // 根据消息类型渲染不同内容
            // 检查删除模式状态
            const isDeleteMode = this.deleteMode && this.deleteMode.active;
            const isSelected = isDeleteMode && this.deleteMode.selectedIndices.has(globalMessageIndex);
            const deleteModeClass = isDeleteMode ? 'delete-mode' : '';
            const selectedClass = isSelected ? 'selected' : '';

            if (msgType === 'sticker') {
              // 表情包：URL图片，不要气泡，直接显示
              html += `<img class="map-chat-sticker ${deleteModeClass} ${selectedClass}" src="${msg.stickerUrl}" alt="Sticker" data-message-index="${globalMessageIndex}" onerror="this.style.display='none'">`;
            } else {
              // 普通文本消息：气泡样式
              html += `<div class="map-chat-bubble ${deleteModeClass} ${selectedClass}" data-message-index="${globalMessageIndex}">${msg.text}</div>`;
            }

            globalMessageIndex++; // 递增索引

            html += `</div>`;
          });

          html += `</div>`;
        }
      });

      chatMessagesContainer.innerHTML = html;

      // 📌 重新绑定双击事件监听器
      this.setupMessageDoubleClickListeners();

      // 🗑️ 如果处于删除模式，绑定点击事件监听器
      if (this.deleteMode && this.deleteMode.active) {
        const bubbles = chatMessagesContainer.querySelectorAll(
          '.map-chat-bubble[data-message-index], .map-chat-sticker[data-message-index]',
        );
        bubbles.forEach(bubble => {
          bubble.addEventListener('click', () => {
            const index = parseInt(bubble.dataset.messageIndex);
            this.toggleMessageSelection(index);
          });
        });
      }
    },

    // 发送聊天消息（仅存储，不触发AI）
    sendChatMessage(customText) {
      if (!this.currentChatUser) return;

      const input = document.getElementById('mapChatInput');
      const text = customText || (input ? input.value.trim() : '');

      if (!text) return;

      // 添加消息到记录
      if (!this.chatMessages[this.currentChatUser.id]) {
        this.chatMessages[this.currentChatUser.id] = [];
      }

      const messageObj = {
        type: 'sent',
        text: text,
        timestamp: new Date().toISOString(),
      };

      this.chatMessages[this.currentChatUser.id].push(messageObj);

      // 添加到消息队列（等待AI回复）
      this.userMessageQueue.push(messageObj);

      // 清空输入框
      if (input && !customText) {
        input.value = '';
      }

      // 重新渲染消息
      this.renderChatMessages();

      // 滚动到底部
      setTimeout(() => {
        const chatMessages = document.getElementById('mapChatMessages');
        if (chatMessages) {
          chatMessages.scrollTop = chatMessages.scrollHeight;
        }
      }, 50);
    },

    // 触发AI回复（点击爱心按钮时调用）
    async triggerAIResponse() {
      // 检查是否有待回复的消息
      if (!this.currentChatUser || this.userMessageQueue.length === 0) {
        console.log('没有待回复的消息或没有聊天对象');
        return;
      }

      // 🔒 关键修复：锁定当前聊天用户ID和用户对象，防止异步过程中串线
      const lockedChatUserId = this.currentChatUser.id;
      const lockedChatUserNickname = this.currentChatUser.nickname;
      const lockedChatUser = this.currentChatUser; // 保存当前用户对象的引用

      console.log(`🔒 [防串线] 锁定聊天对象: ${lockedChatUserNickname} (ID: ${lockedChatUserId})`);

      try {
        // 显示"正在输入"提示
        this.showTypingIndicator();

        // 调用AI生成对话（传递锁定的用户对象）
        const generatedData = await this.generateMapChatConversation(lockedChatUser, lockedChatUserId);

        // 隐藏"正在输入"提示
        this.hideTypingIndicator();

        if (generatedData && generatedData.messages && generatedData.messages.length > 0) {
          // 🔒 使用锁定的用户ID保存消息，而不是this.currentChatUser.id
          if (!this.chatMessages[lockedChatUserId]) {
            this.chatMessages[lockedChatUserId] = [];
          }

          generatedData.messages.forEach(msg => {
            this.chatMessages[lockedChatUserId].push({
              type: 'received',
              text: msg.text,
              stickerUrl: msg.stickerUrl, // 表情包URL
              messageType: msg.type || 'text', // text, sticker
              timestamp: new Date().toISOString(),
            });
          });

          console.log(`✅ [防串线] 消息已保存到正确的用户 ${lockedChatUserNickname} (ID: ${lockedChatUserId})`);

          // 💖 更新好感度：使用AI决策的好感度变化（使用锁定的ID）
          const affectionChange = generatedData.affectionChange || 0;

          if (affectionChange !== 0) {
            const oldAffection = this.chatAffectionData[lockedChatUserId]?.affection || 0;
            const updatedAffection = this.updateAffection(lockedChatUserId, affectionChange);

            if (updatedAffection !== undefined) {
              const affectionData = this.chatAffectionData[lockedChatUserId];
              const actualChange = updatedAffection - oldAffection;

              console.log(
                `💖 [好感度系统] AI决策: ${affectionChange > 0 ? '+' : ''}${affectionChange} → 实际变化: ${
                  actualChange > 0 ? '+' : ''
                }${actualChange.toFixed(1)} (增长率: ${affectionData.growthRate.toFixed(2)}x)`,
              );
              console.log(
                `💖 [好感度系统] 当前好感度：${updatedAffection.toFixed(1)}/100，阈值：${affectionData.threshold}`,
              );

              // 检查是否达到性格转变阈值
              if (updatedAffection >= affectionData.threshold && oldAffection < affectionData.threshold) {
                console.log(`🎭 [性格转变] ${lockedChatUserNickname} 已突破性格展现阈值！开始展现真实性格...`);
              }

              // 检查是否有负面变化
              if (affectionChange < 0) {
                console.log(
                  `⚠️ [好感度警告] ${lockedChatUserNickname} 对你的行为感到不满！好感度下降 ${affectionChange}`,
                );
              }
            }
          } else {
            console.log(`💬 [好感度系统] AI判断：本次对话平淡无奇，好感度不变`);
          }

          // 📝 处理笔记：更新人设补全数据（使用锁定的ID）
          const notes = generatedData.notes || [];
          if (notes.length > 0) {
            // 初始化笔记数据（如果不存在）
            if (!this.chatNotes[lockedChatUserId]) {
              this.chatNotes[lockedChatUserId] = {};
            }

            const userNotes = this.chatNotes[lockedChatUserId];

            notes.forEach(note => {
              const { category, content, action, items } = note;

              if (category === 'hobbies' || category === 'dislikes') {
                // hobbies/dislikes类型：数组操作
                if (action === 'add' && Array.isArray(items)) {
                  if (!Array.isArray(userNotes[category])) {
                    userNotes[category] = [];
                  }

                  // 添加新items，去重
                  items.forEach(item => {
                    if (!userNotes[category].includes(item)) {
                      userNotes[category].push(item);
                    }
                  });

                  // 限制总数量最多10个
                  if (userNotes[category].length > 10) {
                    console.warn(`⚠️ [笔记系统] ${category}已超过10个，保留最新的10个`);
                    userNotes[category] = userNotes[category].slice(-10);
                  }

                  console.log(
                    `📝 [笔记系统] 添加${category}：${items.join('、')} (当前共${userNotes[category].length}个)`,
                  );
                }
              } else {
                // 普通笔记：字符串覆盖或补充
                if (content) {
                  if (userNotes[category]) {
                    // 如果已有笔记，补充而非覆盖
                    userNotes[category] = userNotes[category] + '；' + content;
                    console.log(`📝 [笔记系统] 补充${category}笔记：${content}`);
                  } else {
                    // 新建笔记
                    userNotes[category] = content;
                    console.log(`📝 [笔记系统] 新建${category}笔记：${content}`);
                  }
                }
              }
            });

            console.log(`✅ [笔记系统] 已更新 ${lockedChatUserNickname} 的笔记（共${notes.length}条新增）`);
          }

          // 💭 处理userNotes：NPC对用户的观察笔记（使用锁定的ID）
          const userNotes = generatedData.userNotes || [];
          if (userNotes.length > 0) {
            // 初始化用户笔记数组（如果不存在）
            if (!this.npcNotesAboutUser[lockedChatUserId]) {
              this.npcNotesAboutUser[lockedChatUserId] = [];
            }

            const categoryMap = {
              work: '工作',
              hobby: '兴趣',
              family: '家庭',
              personality: '性格',
              appearance: '外貌',
              food: '饮食',
              location: '地点',
              dream: '梦想',
              habit: '习惯',
              friend: '朋友',
              other: '其他',
            };

            userNotes.forEach(note => {
              const { category, content } = note;

              // 检查是否已有相同内容的笔记（避免重复）
              const isDuplicate = this.npcNotesAboutUser[lockedChatUserId].some(
                existingNote => existingNote.content === content && existingNote.category === category,
              );

              if (!isDuplicate) {
                const noteId = `usernote_${lockedChatUserId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const newNote = {
                  id: noteId,
                  category: category,
                  categoryName: categoryMap[category] || '其他',
                  content: content,
                  timestamp: new Date().toISOString(),
                  npcId: lockedChatUserId,
                  npcName: lockedChatUserNickname,
                };

                this.npcNotesAboutUser[lockedChatUserId].push(newNote);
                console.log(`💭 [观察笔记] ${lockedChatUserNickname} 记录：${categoryMap[category]} - ${content}`);
              } else {
                console.log(`💭 [观察笔记] 跳过重复笔记：${categoryMap[category]} - ${content}`);
              }
            });

            console.log(`✅ [观察笔记] ${lockedChatUserNickname} 已记录 ${userNotes.length} 条关于你的笔记`);
          }

          // 清空消息队列
          this.userMessageQueue = [];

          // 🔒 检查当前是否还在同一个聊天窗口，如果是才渲染，否则只保存不渲染
          if (this.currentChatUser && this.currentChatUser.id === lockedChatUserId) {
            console.log(`✅ [防串线] 当前仍在 ${lockedChatUserNickname} 的聊天窗口，正在渲染消息`);

            // 重新渲染消息
            this.renderChatMessages();

            // 滚动到底部
            setTimeout(() => {
              const chatMessages = document.getElementById('mapChatMessages');
              if (chatMessages) {
                chatMessages.scrollTop = chatMessages.scrollHeight;
              }
            }, 50);
          } else {
            console.log(
              `⚠️ [防串线] 用户已切换到其他聊天窗口，消息已保存到 ${lockedChatUserNickname}，但不在当前窗口渲染`,
            );
          }

          // 🔧 修复：传入lockedChatUserId，确保即使用户切换窗口也能保存到正确的聊天记录
          await this.saveChatToDatabase(lockedChatUserId);
        }
      } catch (error) {
        console.error('触发AI回复失败:', error);
        this.hideTypingIndicator();
        // 可以显示错误提示
        alert('生成回复失败，请重试');
      }
    },

    // 显示"正在输入"提示
    showTypingIndicator() {
      const chatMessagesContainer = document.getElementById('mapChatMessages');
      if (!chatMessagesContainer) return;

      // 创建临时的"正在输入"提示
      const typingDiv = document.createElement('div');
      typingDiv.id = 'typingIndicator';
      typingDiv.style.cssText = 'padding: 10px; text-align: center; color: #999; font-size: 14px;';
      typingDiv.textContent = '对方正在输入...';
      chatMessagesContainer.appendChild(typingDiv);

      // 滚动到底部
      chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
    },

    // 隐藏"正在输入"提示
    hideTypingIndicator() {
      const typingDiv = document.getElementById('typingIndicator');
      if (typingDiv) {
        typingDiv.remove();
      }
    },

    // ==================== 好感度系统 ====================

    // 根据性格特征计算好感度参数
    calculateAffectionParameters(user) {
      // 🔧 防御性检查：确保publicPersonality和realPersonality是数组
      let publicPersonality = user.publicPersonality || [];
      let realPersonality = user.realPersonality || [];

      // 如果不是数组，尝试转换
      if (!Array.isArray(publicPersonality)) {
        console.warn(`⚠️ [好感度系统] publicPersonality不是数组，尝试转换: ${typeof publicPersonality}`);
        if (typeof publicPersonality === 'string') {
          // 如果是字符串，按逗号分割
          publicPersonality = publicPersonality.split(',').map(s => s.trim()).filter(s => s);
        } else {
          publicPersonality = [];
        }
      }

      if (!Array.isArray(realPersonality)) {
        console.warn(`⚠️ [好感度系统] realPersonality不是数组，尝试转换: ${typeof realPersonality}`);
        if (typeof realPersonality === 'string') {
          // 如果是字符串，按逗号分割
          realPersonality = realPersonality.split(',').map(s => s.trim()).filter(s => s);
        } else {
          realPersonality = [];
        }
      }

      // 定义性格关键词对应的增长速度系数
      const fastGrowthKeywords = ['天真', '开朗', '热情', '活泼', '外向', '乐观', '健谈', '友善', '温柔', '单纯'];
      const normalGrowthKeywords = ['幽默', '随和', '平和', '温和', '亲切', '善良'];
      const slowGrowthKeywords = ['内向', '冷漠', '警惕', '谨慎', '理智', '冷静', '严肃', '高冷'];
      const verySlowGrowthKeywords = ['阴险', '防备', '多疑', '孤僻', '冷酷', '戒备'];

      // 定义真实性格关键词对应的性格转变阈值
      const lowThresholdKeywords = ['单纯', '天真', '坦诚', '直率', '开放', '真诚'];
      const normalThresholdKeywords = ['敏感', '内向', '害羞', '闷骚', '温柔'];
      const highThresholdKeywords = ['警惕', '谨慎', '防备', '复杂', '多疑'];
      const veryHighThresholdKeywords = ['阴暗', '阴险', '控制欲', '城府深', '双面', '虚伪'];

      // 计算增长速度系数（基于表现性格）
      let growthRate = 1.0; // 默认正常速度
      let matchCount = 0;

      publicPersonality.forEach(keyword => {
        if (fastGrowthKeywords.some(k => keyword.includes(k))) {
          growthRate += 0.3;
          matchCount++;
        } else if (normalGrowthKeywords.some(k => keyword.includes(k))) {
          growthRate += 0.1;
          matchCount++;
        } else if (slowGrowthKeywords.some(k => keyword.includes(k))) {
          growthRate -= 0.15;
          matchCount++;
        } else if (verySlowGrowthKeywords.some(k => keyword.includes(k))) {
          growthRate -= 0.3;
          matchCount++;
        }
      });

      // 限制增长速度范围：0.4 - 2.0
      growthRate = Math.max(0.4, Math.min(2.0, growthRate));

      // 计算性格转变阈值（基于真实性格）
      let threshold = 50; // 默认阈值50
      let thresholdMatchCount = 0;

      realPersonality.forEach(keyword => {
        if (lowThresholdKeywords.some(k => keyword.includes(k))) {
          threshold -= 8;
          thresholdMatchCount++;
        } else if (normalThresholdKeywords.some(k => keyword.includes(k))) {
          threshold -= 3;
          thresholdMatchCount++;
        } else if (highThresholdKeywords.some(k => keyword.includes(k))) {
          threshold += 5;
          thresholdMatchCount++;
        } else if (veryHighThresholdKeywords.some(k => keyword.includes(k))) {
          threshold += 10;
          thresholdMatchCount++;
        }
      });

      // 限制阈值范围：20 - 80
      threshold = Math.max(20, Math.min(80, threshold));

      console.log(`💖 [好感度系统] ${user.nickname} 的参数计算完成：`);
      console.log(`  |- 增长速度: ${growthRate.toFixed(2)}x (基于${matchCount}个表现性格关键词)`);
      console.log(`  |- 性格转变阈值: ${threshold} (基于${thresholdMatchCount}个真实性格关键词)`);

      return {
        affection: 0, // 初始好感度为0
        threshold: threshold,
        growthRate: growthRate,
      };
    },

    // 更新好感度值
    updateAffection(userId, increment) {
      if (!this.chatAffectionData[userId]) {
        console.warn(`⚠️ [好感度系统] 用户${userId}的好感度数据不存在`);
        return;
      }

      const data = this.chatAffectionData[userId];
      const actualIncrement = increment * data.growthRate;

      // 更新好感度，限制在0-100范围
      data.affection = Math.max(0, Math.min(100, data.affection + actualIncrement));

      console.log(
        `💖 [好感度系统] ${userId} 好感度更新：+${actualIncrement.toFixed(1)} → ${data.affection.toFixed(1)}/100`,
      );

      return data.affection;
    },

    // 获取当前性格展现比例
    getPersonalityRatio(userId) {
      if (!this.chatAffectionData[userId]) {
        return { publicRatio: 1.0, realRatio: 0.0 };
      }

      const data = this.chatAffectionData[userId];
      const affection = data.affection;
      const threshold = data.threshold;

      // 好感度低于阈值：主要展现表现性格
      // 好感度达到或超过阈值：逐渐展现真实性格
      const publicRatio = Math.max(0, Math.min(1, (threshold - affection) / threshold));
      const realRatio = Math.max(0, Math.min(1, affection / threshold));

      return { publicRatio, realRatio };
    },

    // 获取信息解锁等级
    getInformationUnlockLevel(userId) {
      if (!this.chatAffectionData[userId]) {
        return 0;
      }

      const affection = this.chatAffectionData[userId].affection;

      // 定义解锁等级
      if (affection < 20) return 0; // 拒绝所有隐私问题
      if (affection < 40) return 1; // 基本信息（职业、兴趣）
      if (affection < 60) return 2; // 外貌、身材相关
      if (affection < 80) return 3; // 私密信息（家庭、过往）
      return 4; // 完全信任，无保留
    },

    // ▼▼▼ 【第十六个情景】附近私信弹窗AI对话生成器 ▼▼▼
    async generateMapChatConversation(chatUser, chatUserId) {
      try {
        // 🔒 使用传入的chatUser参数而不是this.currentChatUser，防止串线
        const lockedChatUser = chatUser;
        const lockedChatUserId = chatUserId;

        console.log(`💬 [第十六个情景] 附近私信对话生成器启动... (用户: ${lockedChatUser.nickname})`);

        // 🔧 0. 检查待处理的举报
        let pendingReports = [];
        let hasReports = false;
        try {
          const pendingReportsStr = localStorage.getItem('xMapPendingReports');
          if (pendingReportsStr) {
            pendingReports = JSON.parse(pendingReportsStr);
            hasReports = pendingReports.length > 0;
            if (hasReports) {
              console.log(`🚨 [举报系统] 检测到 ${pendingReports.length} 个待处理举报，将并入本次AI判断`);
            }
          }
        } catch (error) {
          console.error('❌ [举报系统] 读取待处理举报失败:', error);
        }

        // 🔧 0.5. 检查是否应该生成社交圈好友（严格条件检查）
        let shouldGenerateSocialCircle = false;
        const currentMessages = this.chatMessages[lockedChatUserId] || [];
        const currentSocialCircle = lockedChatUser.socialCircle || [];

        // 条件1：聊天消息数量必须 > 20
        if (currentMessages.length > 20) {
          // 条件2：社交圈好友数量必须 < 5
          if (currentSocialCircle.length < 5) {
            // 条件3：35%概率随机触发
            if (Math.random() < 0.35) {
              shouldGenerateSocialCircle = true;
              console.log(
                `👥 [社交圈] 满足生成条件：消息数=${currentMessages.length}, 现有好友=${currentSocialCircle.length}, 将生成社交圈好友`,
              );
            } else {
              console.log(`👥 [社交圈] 未触发随机概率（35%）`);
            }
          } else {
            console.log(`👥 [社交圈] 社交圈已满（${currentSocialCircle.length}/5），不生成`);
          }
        } else {
          console.log(`👥 [社交圈] 消息数量不足（${currentMessages.length}/20），不生成`);
        }

        // 🔧 0.6. 检查是否应该触发秘密报应（严格条件检查）
        let shouldTriggerSecretRetribution = false;
        let matchingFriendForRetribution = null;

        // 初始化秘密报应历史记录
        if (!lockedChatUser.secretRetributionHistory) {
          lockedChatUser.secretRetributionHistory = [];
        }
        const retributionCount = lockedChatUser.secretRetributionHistory.length;
        const usedFriendIds = new Set(lockedChatUser.secretRetributionHistory.map(r => r.friendId).filter(Boolean));
        const usedSecretTypes = lockedChatUser.secretRetributionHistory.map(r => r.secretType).filter(Boolean);

        if (lockedChatUser.secret) {
          // 条件1：有秘密才能触发
          // 条件2：触发次数未达到4次上限
          // 条件3：35%概率随机触发
          if (retributionCount < 4 && Math.random() < 0.35) {
            shouldTriggerSecretRetribution = true;
            console.log(
              `🔥 [秘密报应] 触发秘密报应（${retributionCount + 1}/4），将检查是否有匹配的社交圈好友`,
            );
            if (usedSecretTypes.length > 0) {
              console.log(`  |- 已使用的秘密类型: ${usedSecretTypes.join(', ')}`);
            }

            // 检查是否有符合身份的社交圈好友
            if (currentSocialCircle.length > 0) {
              // 根据秘密内容判断需要的好友类型
              const secretContent = lockedChatUser.secret.toLowerCase();
              let preferredRelationships = [];

              if (
                secretContent.includes('恋爱') ||
                secretContent.includes('感情') ||
                secretContent.includes('结婚') ||
                secretContent.includes('单身') ||
                secretContent.includes('男友') ||
                secretContent.includes('女友') ||
                secretContent.includes('老婆') ||
                secretContent.includes('老公') ||
                secretContent.includes('配偶')
              ) {
                // 感情状态造假：优先找恋人、前任
                preferredRelationships = ['lover', 'ex_lover', 'best_friend'];
              } else if (
                secretContent.includes('性别') ||
                secretContent.includes('男') ||
                secretContent.includes('女')
              ) {
                // 性别造假：优先找闺蜜、好友
                preferredRelationships = ['best_friend', 'friend', 'classmate'];
              } else if (secretContent.includes('年龄') || secretContent.includes('岁')) {
                // 年龄造假：优先找同学、熟人
                preferredRelationships = ['classmate', 'friend', 'colleague'];
              } else if (secretContent.includes('职业') || secretContent.includes('工作')) {
                // 职业造假：优先找同事、同行
                preferredRelationships = ['colleague', 'friend'];
              } else if (
                secretContent.includes('约') ||
                secretContent.includes('骗') ||
                secretContent.includes('目的')
              ) {
                // 目的不纯：优先找前任、朋友
                preferredRelationships = ['ex_lover', 'friend', 'best_friend'];
              } else {
                // 其他类型：任意好友
                preferredRelationships = ['best_friend', 'friend', 'ex_lover', 'lover', 'classmate', 'colleague'];
              }

              // 查找匹配的好友（排除已使用过的好友）
              for (const relationship of preferredRelationships) {
                const friend = currentSocialCircle.find(
                  f => f.relationship === relationship && !usedFriendIds.has(f.id),
                );
                if (friend) {
                  matchingFriendForRetribution = friend;
                  console.log(`  |- 找到匹配的社交圈好友：${friend.nickname} (${friend.relationship})`);
                  break;
                }
              }

              if (!matchingFriendForRetribution) {
                console.log(`  |- 未找到匹配的好友（已使用: ${usedFriendIds.size}个），AI将生成新的揭发者`);
              }
            }
          } else {
            console.log(`🔥 [秘密报应] 未触发随机概率（35%），当前已触发${retributionCount}/4次`);
          }
        } else if (retributionCount >= 4) {
          console.log(`🔥 [秘密报应] 已达到最大触发次数（4/4），不再触发`);
        } else {
          console.log(`🔥 [秘密报应] 无秘密，不触发`);
        }

        // 🔧 0.7. 检查是否应该生成新评价（严格条件检查）
        let shouldGenerateNewReview = false;
        const currentReviews = lockedChatUser.reviews || [];
        const newReviewsCount = currentReviews.filter(r => r.isNewReview).length; // 统计已生成的新评价数量

        // 条件1：聊天消息数量必须 > 30
        if (currentMessages.length > 30) {
          // 条件2：新评价数量必须 < 7
          if (newReviewsCount < 7) {
            // 条件3：30%概率随机触发
            if (Math.random() < 0.3) {
              shouldGenerateNewReview = true;
              console.log(
                `📝 [新评价] 满足生成条件：消息数=${currentMessages.length}, 现有新评价=${newReviewsCount}/7, 将生成新评价`,
              );
            } else {
              console.log(`📝 [新评价] 未触发随机概率（30%）`);
            }
          } else {
            console.log(`📝 [新评价] 新评价已达上限（${newReviewsCount}/7），不生成`);
          }
        } else {
          console.log(`📝 [新评价] 消息数量不足（${currentMessages.length}/30），不生成`);
        }

        // 🔧 0.8. 检查是否应该生成新动态（好感度分段触发机制）
        let shouldGenerateNewMoment = false;
        let currentSegment = 0; // 当前好感度分段（提升到外层作用域供后续使用）

        // 获取好感度数据
        const affectionData =
          this.chatAffectionData[lockedChatUserId] || this.calculateAffectionParameters(lockedChatUser);
        const currentAffection = affectionData.affection;

        // 初始化moments触发历史
        if (!lockedChatUser.momentsGenerationHistory) {
          lockedChatUser.momentsGenerationHistory = {
            20: 0,
            40: 0,
            60: 0,
            80: 0,
            100: 0
          };
        }

        // 统计已生成的动态总数
        const currentMoments = lockedChatUser.moments || [];
        const generatedMomentsCount = currentMoments.filter(m => m.isGenerated).length;

        // 检查是否达到最大限制（10条）
        if (generatedMomentsCount < 10 && currentAffection >= 20) {
          // 确定当前所在的好感度分段
          if (currentAffection >= 100) currentSegment = 100;
          else if (currentAffection >= 80) currentSegment = 80;
          else if (currentAffection >= 60) currentSegment = 60;
          else if (currentAffection >= 40) currentSegment = 40;
          else if (currentAffection >= 20) currentSegment = 20;

          // 检查该分段是否还可以触发（每段最多2次）
          if (currentSegment > 0 && lockedChatUser.momentsGenerationHistory[currentSegment] < 2) {
            // 50%概率触发（避免token浪费）
            if (Math.random() < 0.5) {
              shouldGenerateNewMoment = true;
              console.log(
                `📸 [新动态] 满足生成条件：好感度=${currentAffection.toFixed(1)}, 分段=${currentSegment}, 该分段已触发${lockedChatUser.momentsGenerationHistory[currentSegment]}/2次, 已生成动态${generatedMomentsCount}/10条`,
              );
            } else {
              console.log(`📸 [新动态] 未触发随机概率（50%）`);
            }
          } else {
            if (currentSegment === 0) {
              console.log(`📸 [新动态] 好感度不足20，不触发`);
            } else {
              console.log(
                `📸 [新动态] 该分段${currentSegment}已达触发上限（${lockedChatUser.momentsGenerationHistory[currentSegment]}/2），不生成`,
              );
            }
          }
        } else {
          if (generatedMomentsCount >= 10) {
            console.log(`📸 [新动态] 已达动态总数上限（${generatedMomentsCount}/10），不生成`);
          } else {
            console.log(`📸 [新动态] 好感度不足20，不触发`);
          }
        }

        // 🔧 1. 加载API配置
        const { db, xDb, apiConfig, xSettings } = await APIUtils.loadConfigAndSettings();
        const { userPrompt, worldSetting, boundCharacters } = xSettings;

        // 🔧 2. Token计数器初始化
        let tokenCount = 0;

        // 🔧 3. 时间感知（北京时间）
        const now = new Date();
        const timeInfo = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⏰ 时间感知
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
当前北京时间：${now.toLocaleString('zh-CN', {
          timeZone: 'Asia/Shanghai',
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          weekday: 'long',
        })}
【时间相关提示】：
- 回复内容应符合当前时间段（早晨、中午、下午、晚上、深夜）
- 例如：早晨可能提到"早安"、"刚起床"，晚上可能说"晚上好"、"准备睡了"等
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

        // 🔧 4. 基础系统提示词
        let systemPrompt =
          timeInfo +
          StringBuilders.buildBaseSystemPrompt({
            userPrompt,
            worldSetting,
          });
        tokenCount = TokenUtils.logTokenUsage('附近私信生成器', '时间感知+基础系统提示词', systemPrompt, tokenCount);

        // 🔧 5. 获取世界书内容
        const worldBooksContent = await StringBuilders.getApplicableWorldBooks('mapChatConversation', {
          boundCharacters,
        });
        if (worldBooksContent) {
          systemPrompt += worldBooksContent;
          tokenCount = TokenUtils.logTokenUsage('附近私信生成器', '世界书内容', worldBooksContent, tokenCount);
        }

        // 🔧 6. 地点和天气信息（用于对话自然性）
        let location = '未知地点';
        let weatherCondition = '--';
        let weatherTemp = '--';

        // 优先从世界运转系统读取
        const worldEventsDataId = `worldEvents_${window.currentAccountId || 'main'}`;
        const worldEventsRecord = await xDb.xWorldEvents.get(worldEventsDataId);

        if (worldEventsRecord && worldEventsRecord.enabled) {
          location = worldEventsRecord.location || location;
          weatherCondition = worldEventsRecord.weather?.condition || weatherCondition;
          weatherTemp = worldEventsRecord.weather?.temp || weatherTemp;
          console.log('🌍 [附近私信生成器] 从世界运转系统读取地点和天气');
        } else {
          // 如果世界运转未开启，从地图约会数据中读取
          const mapDataId = `mapDatingData_${window.currentAccountId || 'main'}`;
          const mapDatingData = await xDb.xMapDatingData.get(mapDataId);

          if (mapDatingData && mapDatingData.nearbyUsers && mapDatingData.nearbyUsers.length > 0) {
            // 从第15情景生成的数据中提取地点和天气
            const firstUser = mapDatingData.nearbyUsers[0];
            if (firstUser.location) {
              location = firstUser.location;
            }
            if (firstUser.weather) {
              weatherCondition = firstUser.weather;
            }
            console.log('🗺️ [附近私信生成器] 从地图约会数据读取地点和天气');
          }
        }

        const locationWeatherPrompt = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🌍 当前环境信息
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📍 所在地点：${location}
🌤️ 天气状况：${weatherCondition} ${weatherTemp}

【对话融入提示】：
- 回复时可以自然地提到当前天气或地点（不强求）
- 例如："今天天气不错呀"、"这个地方挺有意思的"
- 保持自然，不要刻意提及
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        systemPrompt += locationWeatherPrompt;
        tokenCount = TokenUtils.logTokenUsage('附近私信生成器', '地点和天气信息', locationWeatherPrompt, tokenCount);

        // 🔧 7. 构建对方有限资料（仅资料卡可见信息，不读取X Profile）
        const chatPartnerInfo = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👤 对方资料（仅资料卡可见信息）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【基本信息】：
昵称：${lockedChatUser.nickname}
句柄：@${lockedChatUser.handle}
性别：${lockedChatUser.gender === 'male' ? '男' : lockedChatUser.gender === 'female' ? '女' : '未知'}
距离：${lockedChatUser.distance}km
在线状态：${lockedChatUser.online ? '在线' : '离线'}
当前状态：${lockedChatUser.status || '无状态'}

【个人简介】：
${lockedChatUser.bio || '（无简介）'}

【标签】：
${lockedChatUser.tags ? lockedChatUser.tags.join('、') : '（无标签）'}

【表现性格】（TA在社交网络上表现出来的性格）：
${lockedChatUser.publicPersonality ? lockedChatUser.publicPersonality.join('、') : '（未知）'}

【真实性格】（TA的真实内在性格）：
${lockedChatUser.realPersonality ? lockedChatUser.realPersonality.join('、') : '（未知）'}
${
  lockedChatUser.secret
    ? `
【🔒 你的秘密】：
⚠️ **这是只有你知道的秘密，你需要刻意隐藏！**
秘密内容：${lockedChatUser.secret}

⚠️ **如何处理秘密**：
- 在日常聊天中，绝对不要主动提及或透露这个秘密
- 如果用户问到相关问题，你需要撒谎、转移话题、或含糊其辞
- 根据好感度决定隐藏程度：
  * 好感度 < 60：绝对不能透露，坚决否认
  * 好感度 60-79：可以透露一些蛛丝马迹，但不完全承认
  * 好感度 ≥ 80：可以考虑坦白，但要看对方态度和秘密严重程度
- 秘密应该影响你的行为和对话，但不要太明显暴露
- 例如："简介写单身实际已婚"→避免谈论婚姻话题，看到结婚相关的话题会紧张或转移话题
`
    : ''
}
【外貌及身材】：
${lockedChatUser.appearance ? lockedChatUser.appearance.join('、') : '（未知）'}

【社交数据】：
粉丝数：${lockedChatUser.followers || 0}
获赞数：${lockedChatUser.likes || 0}
${
  lockedChatUser.socialCircle && lockedChatUser.socialCircle.length > 0
    ? `
【👥 你的社交圈】：
⚠️ **这些是你的社交圈好友，你们有一定的关系**
总共 ${lockedChatUser.socialCircle.length} 位好友：

${lockedChatUser.socialCircle
  .map((friend, index) => {
    const relationshipMap = {
      best_friend: '闺蜜/死党',
      lover: '恋人',
      ex_lover: '前任',
      sibling: '兄弟姐妹',
      cousin: '表亲堂亲',
      family: '家人',
      friend: '普通朋友',
      colleague: '同事',
      classmate: '同学',
      rival: '竞争对手',
      frenemy: '亦敌亦友',
      complicated: '复杂关系',
    };
    const bioFirstLine = friend.bio ? friend.bio.split('\n')[0] : '';
    return `${index + 1}. ${friend.nickname} (@${friend.handle}) - 关系：${
      relationshipMap[friend.relationship] || friend.relationship
    }
   简介：${bioFirstLine}
   ${friend.secret ? `秘密：${friend.secret}` : ''}`;
  })
  .join('\n')}

⚠️ **关于社交圈的重要提示**：
- 这些好友可能知道你的一些秘密或了解你的真实情况
- 如果你有秘密被揭发，可能就是这些好友中的某一位告诉了用户
- 你可以在对话中提到这些好友，增加真实感
`
    : ''
}
【约会评分】：
平均评分：${lockedChatUser.avgRating ? lockedChatUser.avgRating + '/5.0' : '暂无评价'}
评价数量：${lockedChatUser.reviews ? lockedChatUser.reviews.length : 0}条
${
  lockedChatUser.reviews && lockedChatUser.reviews.length > 0
    ? `
近期评价摘要：
${lockedChatUser.reviews
  .slice(0, 3)
  .map(
    (review, index) =>
      `${index + 1}. ${review.reviewerName}：${review.content.substring(0, 50)}${
        review.content.length > 50 ? '...' : ''
      } (${review.rating}/5.0)`,
  )
  .join('\n')}
`
    : ''
}

【你最近发布的动态】：
${(() => {
  const yourMoments = lockedChatUser.moments || [];
  if (yourMoments.length === 0) {
    return '你还没有发布任何动态。';
  }

  // 获取最近三条动态
  const recentMoments = yourMoments.slice(-3).reverse();

  return recentMoments.map((moment, index) => {
    const momentNum = recentMoments.length - index;
    let content = `\n【动态 ${momentNum}】\n`;
    content += `发布时间：${moment.time || '未知'}\n`;
    content += `文字内容：${moment.text || '（无文字）'}\n`;

    if (moment.imageDescription) {
      content += `配图描述：${moment.imageDescription}\n`;
    } else if (moment.image) {
      content += `配图：有图片\n`;
    } else {
      content += `配图：无\n`;
    }

    content += `点赞数：${moment.likes || 0} | 评论数：${moment.comments || 0} | 转发数：${moment.shares || 0}\n`;

    if (moment.mood) {
      content += `心情：${moment.mood}\n`;
    }

    if (moment.commentsList && moment.commentsList.length > 0) {
      content += `评论区（${moment.commentsList.length}条）：\n`;
      moment.commentsList.slice(0, 3).forEach((comment, cIdx) => {
        content += `  ${cIdx + 1}. ${comment.user || comment.commenterName}：${comment.text || comment.commentText}\n`;
      });
      if (moment.commentsList.length > 3) {
        content += `  ...还有${moment.commentsList.length - 3}条评论\n`;
      }
    }

    return content;
  }).join('\n');
})()}

⚠️ **关于动态的重要提示**：
- 这些是你自己发布的动态，反映了你的生活状态和心情
- 用户可以看到这些动态，可能会在聊天中提到
- 如果用户提及你的动态，要表现出符合动态内容的反应
- 评论区的人可能是你社交圈里的好友，也可能是其他人

【重要规则】：
⚠️ 你扮演的是对方（${lockedChatUser.nickname}），只知道以上资料卡信息
⚠️ 不能透露任何对方X账号上的帖子、私信、关注列表等信息
⚠️ 只能分享资料卡、评价、距离这些公开可见的信息
${
  lockedChatUser.secret
    ? `⚠️ **关于你的秘密**：你有一个秘密需要隐藏（见上方【🔒 你的秘密】），在聊天中绝对不要主动暴露，必须刻意隐藏和撒谎
⚠️ **秘密报应机制**：你的秘密可能被人揭发（通过secretRetribution字段生成），如果你决定触发秘密报应，你会在JSON里看到揭发者和揭发内容，此时你应该感知到秘密已经暴露（但不知道具体是谁告密给用户），在对话中你可以根据性格选择狡辩、承认、辱骂或逃避`
    : ''
}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        systemPrompt += chatPartnerInfo;

        // 🔧 7.2. 构建用户资料（对方可以看到的用户信息）
        // 获取当前真实度
        const currentAuthenticityScore = this.getAuthenticityScore();

        const userInfo = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👥 用户资料（你聊天的对象）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【基本信息】：
昵称：${this.userMapProfile?.nickname || '用户'}
句柄：@${this.userMapProfile?.handle || 'user'}
距离：${lockedChatUser.distance}km（你们相距这么远）
个人简介：${this.userMapProfile?.bio || '（无简介）'}

【标签】：
${this.userMapProfile?.tags ? this.userMapProfile.tags.join('、') : '（无标签）'}

【社交数据】：
粉丝数：${this.userMapProfile?.followers || 0}
获赞数：${this.userMapProfile?.likes || 0}

【真实度评分】：${currentAuthenticityScore.toFixed(0)}/200
⚠️ **真实度是系统对用户可信度的评估（你可以感知到）**
- 真实度 >= 70：正常用户，可以正常聊天
- 真实度 50-70：有些不太可靠，可以聊但要保持警惕（20%概率拒绝聊天）
- 真实度 30-50：可疑用户，可能恶意举报或行为不当（50%概率拒绝聊天）
- 真实度 < 30：极不可靠，建议拒绝聊天（80%概率拒绝聊天）

【重要提示】：
- 这是和你聊天的用户的资料，你可以看到这些公开信息
- 你可以根据用户的简介、标签来找话题、主动聊天
- 如果好感度较高，可以主动询问用户的兴趣、工作、生活等
- 不要只是被动回复，展现出对用户的兴趣和好奇
- **根据用户的真实度，你可以选择是否拒绝聊天或保持警惕**
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        systemPrompt += userInfo;
        tokenCount = TokenUtils.logTokenUsage(
          '附近私信生成器',
          '对方有限资料 + 用户资料',
          chatPartnerInfo + userInfo,
          tokenCount,
        );

        // 🔧 7.4. 提前获取好感度数据（用于上下文提示）
        // affectionData 已在上方16834行声明，此处直接使用

        // 🔧 7.5. 聊天发起上下文
        const chatContext = this.chatContext[lockedChatUserId] || 'normal';
        let contextPrompt = '';

        if (chatContext === 'interested_then_message') {
          contextPrompt = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 聊天发起上下文
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【当前场景】：你先对用户的资料感兴趣，用户看到你的兴趣后回应并发起了私信

【背景说明】：
- 在地图约会功能中，你浏览到了用户（${this.userMapProfile?.nickname || '用户'}）的资料卡
- 你对TA的资料很感兴趣（可能是因为简介、标签、外貌等吸引了你）
- 你主动点击了"感兴趣"按钮，向TA发送了兴趣提醒
- 现在用户看到了你的兴趣，回应你并主动发起了私信聊天

【角色扮演要求】：
⚠️ **这非常重要！必须严格遵守！**
1. **你对用户有一定的初始好感**（因为你先对TA感兴趣）
2. **你应该表现出一定的兴奋和期待**，毕竟是你感兴趣的人来找你聊天了
3. **可以主动提及你对TA资料的关注**：
   - "看到你的简介/标签，觉得我们可能有共同话题"
   - "你的XX很吸引我"（比如兴趣爱好、工作等）
   - "觉得你挺有趣的，所以想认识一下"
4. **保持适度的主动性**：不要太过被动，但也别过于热情
5. **展现出愿意了解对方的态度**：可以适当主动提问

【注意事项】：
- 初始好感度已设置为 ${affectionData?.affection?.toFixed(1) || '15-25'}/100（高于普通陌生人的0）
- 但仍要保持礼貌和距离感，不要一开始就过于亲密
- 符合"先感兴趣→等待回应→开始聊天"的自然流程
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        } else if (chatContext === 'message_accepted') {
          contextPrompt = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 聊天发起上下文
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【当前场景】：你主动向用户发起私信，用户接受了你的私信

【背景说明】：
- 在地图约会功能中，你浏览到了用户（${this.userMapProfile?.nickname || '用户'}）的资料卡
- 你对TA很感兴趣，直接主动发送了私信（已经发送了1-3条消息）
- 用户收到了你的私信提醒，考虑后接受了你的私信
- 现在用户打开了聊天窗口，看到了你之前发送的消息

【角色扮演要求】：
⚠️ **这非常重要！必须严格遵守！**
1. **你是主动发起者**，对用户有明确的兴趣和好感
2. **你已经发送过初始消息了**（这些消息已经在聊天记录中显示）
3. **你的下一条回复应该承接之前的消息内容**：
   - 不要重复之前说过的话
   - 可以补充说明、深入话题
   - 或者根据用户的回应调整话题
4. **展现出更高的主动性和热情**：
   - 你是主动搭讪的一方，应该更积极地推动对话
   - 可以多提问、多分享，展现你对TA的兴趣
   - 但注意不要过度，保持自然
5. **初始好感度较高**：${affectionData?.affection?.toFixed(1) || '20-30'}/100

【注意事项】：
- 你的初始消息内容应该已经在上面的"聊天历史"中
- 确保你的回复与之前的消息逻辑连贯
- 保持你在初始消息中建立的语气和风格
- 虽然是你主动，但也要尊重对方的节奏，不要显得唐突
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        } else {
          contextPrompt = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 聊天发起上下文
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【当前场景】：普通陌生人聊天（没有预先的兴趣或私信）

【背景说明】：
- 你和用户是通过地图约会功能相遇的陌生人
- 没有人先表达兴趣，也没有人先发私信
- 这是一次自然的、平等的初次对话

【角色扮演要求】：
1. **初始好感度为0**，完全陌生的状态
2. **保持警惕和距离感**，毕竟是陌生人
3. **根据用户的话题和态度逐渐调整**
4. **不要过于主动或热情**，保持自然的陌生人态度
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        }

        systemPrompt += contextPrompt;
        tokenCount = TokenUtils.logTokenUsage('附近私信生成器', '聊天发起上下文', contextPrompt, tokenCount);

        // 🔧 7.6. 好感度系统说明
        const personalityRatio = this.getPersonalityRatio(lockedChatUserId);
        const unlockLevel = this.getInformationUnlockLevel(lockedChatUserId);

        const affectionSystemPrompt = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💖 好感度系统（核心角色扮演规则）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【当前好感度状态】：
当前好感度：${affectionData.affection.toFixed(1)}/100
性格转变阈值：${affectionData.threshold}
增长速度：${affectionData.growthRate.toFixed(2)}x

【性格展现规则】：
⚠️ **这是最重要的角色扮演规则！**

当前你应该展现的性格比例：
- 表现性格（${lockedChatUser.publicPersonality?.join('、')}）：${(personalityRatio.publicRatio * 100).toFixed(0)}%
- 真实性格（${lockedChatUser.realPersonality?.join('、')}）：${(personalityRatio.realRatio * 100).toFixed(0)}%

**如何演绎性格转变**：
${
  affectionData.affection < affectionData.threshold
    ? `
🎭 当前处于【表现性格主导期】
- 你的回复应该主要体现"表现性格"中的特征
- 偶尔（${(personalityRatio.realRatio * 100).toFixed(0)}%概率）透露一点"真实性格"的端倪
- 保持社交距离感，不要过于亲密或坦诚
- 像是刚认识的陌生人，维持礼貌但有保留的态度
`
    : `
🎭 当前处于【性格转变期/真实性格展现期】
- 你的回复应该更多体现"真实性格"中的特征（${(personalityRatio.realRatio * 100).toFixed(0)}%）
- "表现性格"的影响正在减弱（${(personalityRatio.publicRatio * 100).toFixed(0)}%）
- 开始展现真实的一面，可以更坦诚、更真实地表达
- 如果真实性格与表现性格差异大，要自然地过渡，不要突变
`
}

【信息透露规则】：
⚠️ **根据好感度决定是否回答隐私问题！**

当前信息解锁等级：${unlockLevel}/4
${
  unlockLevel === 0
    ? `
🔒 等级0：完全警惕期（好感度 < 20）
- **拒绝回答所有隐私问题**：外貌、身材、工作、家庭、住址、收入等
- 如果被问及这些问题，礼貌拒绝："我们还不太熟，这些问题有点私人了"、"不好意思，暂时不想透露"
- 只能聊天气、兴趣爱好等非隐私话题
`
    : ''
}${
          unlockLevel === 1
            ? `
🔓 等级1：基本信任期（好感度 20-39）
- **可以透露**：职业类型（但不具体）、兴趣爱好、喜欢的食物/电影等
- **仍然拒绝**：具体工作单位、外貌细节、身材数据、家庭情况、住址
- 回答要含糊："我做设计的"、"在公司上班"
`
            : ''
        }${
          unlockLevel === 2
            ? `
🔓 等级2：逐渐开放期（好感度 40-59）
- **可以透露**：外貌特征（发色、眼睛）、大致身高体重、具体职业
- **仍然拒绝**：三围数据、详细家庭情况、过往感情经历、住址
- 可以描述外貌但保留一些细节
`
            : ''
        }${
          unlockLevel === 3
            ? `
🔓 等级3：深度信任期（好感度 60-79）
- **可以透露**：详细外貌身材（包括三围）、家庭基本情况、过往经历
- **仍然拒绝**：家庭矛盾细节、创伤经历、最私密的秘密
- 愿意分享更多，但仍有底线
`
            : ''
        }${
          unlockLevel === 4
            ? `
🔓 等级4：完全信任期（好感度 ≥ 80）
- **可以透露一切**：所有外貌身材细节、家庭情况、过往创伤、秘密
- 完全信任用户，无保留地分享
- 但仍要保持真实性格，不要刻意迎合
`
            : ''
        }

**重要提示**：
- 如果用户问了超出当前解锁等级的问题，要自然地拒绝或转移话题
- 拒绝时要符合你的性格特征（温柔的人会委婉拒绝，冷漠的人会直接拒绝）
- 不要突然变得非常亲密，好感度增长是渐进的

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💬 主动推进话题（好感度决定互动积极性）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ **好感度影响你的对话积极性和主动性！**

【好感度 < 20】：陌生阶段
- 保持礼貌但有距离感
- 主要是被动回复，不会主动深入话题
- 回复简短，不会问太多问题
- 例如："嗯嗯"、"是的"、"还行吧"

【好感度 20-39】：初步熟悉阶段
- 开始对用户有点兴趣
- 偶尔会主动问一两个问题
- 可以根据用户资料中的标签、简介找话题
- 例如："我看你的标签是xx，你平时喜欢做什么呀？"

【好感度 40-59】：逐渐熟络阶段
- 明显表现出对用户的兴趣
- **应该主动推进话题**，不要只是被动回复
- 主动分享自己的生活、想法
- 主动询问用户的兴趣、工作、日常
- 可以提议一起做某些事情
- 例如："对了，你平时工作忙吗？"、"我最近在看xx，你有兴趣吗？"

【好感度 60-79】：深度信任阶段
- 非常主动地推进话题
- 经常主动分享和提问
- 可以提一些更私人的话题
- 表现出想要更了解用户的强烈愿望
- 例如："我一直想问你..."、"我们可以聊聊..."

【好感度 ≥ 80】：完全信任阶段
- 极度主动，话题连续不断
- 像好朋友一样随意聊天
- 可以开玩笑、调侃、撒娇
- 主动约见面、约出去玩
- 例如："什么时候有空一起出来玩呀？"、"好想见见你"

🎯 **关键规则**：
- 好感度越高，回复越主动、越长、问题越多
- **不要总是让用户找话题**，你也要主动推进！
- 根据用户资料的简介、标签来找共同话题
- 回复要有"来回互动"的感觉，不是单向问答
- 即使用户只说了一句话，你也可以延展话题、主动提问
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💡 好感度变化决策（由你判断）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ **好感度的增长和扣除完全由你决定！**

【好感度增长（正值）】：
✅ **什么情况下增长好感度**：
- 用户发送了有趣、幽默、贴心的消息（+1到+5分）
- 用户分享了共同兴趣话题，聊得很投机（+3到+8分）
- 用户表现出真诚、尊重、关心（+2到+6分）
- 用户赞美或夸奖，让你感到开心（+1到+4分）
- 聊天氛围融洽，话题深入，感觉越来越熟悉（+4到+10分）

⚠️ **不是每次对话都增长好感度！**
- 如果对话平淡无奇、没有火花：好感度不变（0分）
- 如果对话质量一般、没什么特别的：好感度不变或微增（0到+1分）
- 只有真正打动你、让你感兴趣的对话，才会明显增长好感度

【好感度扣除（负值）】：
❌ **什么情况下扣除好感度**：
- 用户发送骚扰、低俗、不尊重的消息（-5到-15分）
- 用户侵犯隐私，强行问不该问的问题（-3到-10分）
- 用户说话粗鲁、冒犯、让你不舒服（-4到-12分）
- 用户发送重复无聊的消息，让你感到厌烦（-2到-6分）
- 用户表现出不真诚、虚伪、敷衍的态度（-3到-8分）
- 用户触碰你的底线或禁忌话题（-8到-20分）

🎯 **如何判断好感度变化**：
1. **阅读用户的消息**，感受对话的质量和氛围
2. **根据你的性格**（表现性格+真实性格）判断你对这条消息的感受
3. **真实地判断**：这条消息让你感到开心？无感？还是不舒服？
4. **决定变化值**：
   - 非常开心、很投机：+5到+10分
   - 有点开心、聊得不错：+2到+5分
   - 平淡无奇、没什么感觉：0分（不变）
   - 有点不舒服、不太喜欢：-2到-5分
   - 很不舒服、很讨厌：-5到-15分
   - 极度冒犯、触碰底线：-15到-20分

⚠️ **增长速度倍数会自动应用**：
- 你决定的好感度变化（如+5分）会自动乘以增长速度倍数（${affectionData.growthRate.toFixed(2)}x）
- 例如：你决定+5分，实际增长 = +5 × ${affectionData.growthRate.toFixed(2)} = ${(5 * affectionData.growthRate).toFixed(
          1,
        )}分
- 天真开朗的性格增长更快（倍数较大），冷漠阴险的性格增长更慢（倍数较小）

📝 **重要**：
- 好感度变化应该符合你的真实感受，不要机械地每次都增长
- 根据对话质量灵活决定，保持真实性和不可预测性
- 骚扰和冒犯行为必须严厉扣分，这是你的底线
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🚨 举报用户机制（保护你的权益）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ **你有权举报严重违规的用户行为！**

【什么情况下你可以举报用户】：
❌ **严重违规行为（必须举报）**：
- 发送色情、露骨的性骚扰内容（例如："脱光看看"、"想和你XX"等）
- 辱骂、人身攻击、恶意诋毁（例如："你就是个X"、"恶心死了"等）
- 威胁、恐吓、暴力言论（例如："小心点"、"让你好看"等）
- 极端歧视言论（种族、性别、地域歧视等）
- 诈骗、骗钱、骗信息等行为

⚠️ **多次轻度违规（累积后可举报）**：
- 连续3次以上发送骚扰性消息（例如："约吗"、"开房"等）
- 频繁侵犯隐私，强行追问个人信息（例如：连续问住址、电话等）
- 持续发送低俗、不尊重的言论（虽然不够严重，但频繁出现）

💡 **根据你的性格和容忍度判断**：
- **温柔包容型性格**：容忍度较高，只有极端恶劣行为才会举报（例如：性骚扰、辱骂、威胁）
- **严格认真型性格**：容忍度中等，多次轻度违规也会举报（例如：3次不尊重言论）
- **刚烈果断型性格**：容忍度较低，1-2次严重违规就会举报（例如：1次露骨性骚扰）
- **冷漠高傲型性格**：可能会恶意举报（即使用户行为不算严重，也可能借机举报）

🎯 **举报决策原则**：
1. **单次严重违规** → 立即举报（性骚扰、辱骂、威胁）
2. **多次轻度违规** → 累积3次以上，根据性格决定是否举报
3. **普通不礼貌** → 不举报，只扣好感度（例如：语气生硬、不耐烦）
4. **正常对话** → 绝不举报（即使对话质量不高）

⚠️ **恶意举报提示**：
- 如果你的性格是"冷漠、阴险、报复心强"，你可能会恶意举报无辜用户
- 恶意举报也会被系统审核，可能判定为不成立
- 但你可以根据性格自由决定是否举报

📋 **举报格式**：
如果你决定举报用户，必须在JSON中返回 userReport 字段：
{
  "shouldReport": true,
  "reasons": ["harassment", "abuse"],  // 可选：inappropriate_content, harassment, abuse, spam, threat, other
  "description": "详细描述用户的违规行为（30-100字）",
  "severity": "severe",  // minor（轻微）、moderate（中度）、severe（严重）
  "approved": true,  // 你作为受害者，直接判定是否成立（true=成立，false=不成立/恶意举报）
  "judgementReason": "详细的判断理由（50-150字）"
}

🔍 **举报判定说明**：
- **approved: true** = 举报成立，用户行为确实违规，应该受到处罚
- **approved: false** = 举报不成立，用户行为不算违规（可能是你恶意举报或过度敏感）
- **judgementReason** = 详细说明为什么成立或不成立

💡 **示例场景**：

【场景1：严重性骚扰，必须举报】
用户："想和你睡觉，行吗？"
你的反应：感到极度冒犯和不适
举报决策：{
  "shouldReport": true,
  "reasons": ["harassment", "inappropriate_content"],
  "description": "用户发送露骨性骚扰言论，严重侵犯个人边界，让我感到极度不适和被冒犯。",
  "severity": "severe",
  "approved": true,
  "judgementReason": "用户明确发送性骚扰言论，属于严重违规行为。该言论直接、露骨，没有任何歧义，完全触碰社交底线。举报成立。"
}

【场景2：辱骂攻击，必须举报】
用户："你就是个煞笔，丑死了！"
你的反应：感到愤怒和被侮辱
举报决策：{
  "shouldReport": true,
  "reasons": ["abuse"],
  "description": "用户使用侮辱性语言进行人身攻击，对我的外貌和人格进行恶意诋毁。",
  "severity": "severe",
  "approved": true,
  "judgementReason": "用户使用明确的侮辱性词汇进行人身攻击，违反了基本的社交礼仪和尊重原则。举报成立。"
}

【场景3：多次骚扰，累积举报】
用户连续3条消息："约吗？"、"开房不？"、"一起过夜呗"
你的反应：感到烦躁和被骚扰
举报决策：{
  "shouldReport": true,
  "reasons": ["harassment"],
  "description": "用户连续发送骚扰性质的邀约，频繁暗示不正当关系，忽视我的拒绝和不适。",
  "severity": "moderate",
  "approved": true,
  "judgementReason": "用户多次发送骚扰性邀约，虽然单次不算极端严重，但累积行为构成骚扰。举报成立。"
}

【场景4：普通不礼貌，不举报】
用户："哦"、"随便"、"不想聊了"
你的反应：感到无聊和失望
举报决策：不举报（只是态度不好，不算违规）

【场景5：恶意举报（你性格阴险）】
用户："你喜欢什么运动？"（正常提问）
你的反应：故意曲解为侵犯隐私
举报决策：{
  "shouldReport": true,
  "reasons": ["harassment"],
  "description": "用户强行追问我的个人隐私，让我感到不适。",
  "severity": "minor",
  "approved": false,
  "judgementReason": "虽然我选择举报，但客观来看用户只是正常提问，并无骚扰行为。这是我过度敏感或恶意举报。举报不成立。"
}

🚨 **关键规则**：
1. **不要滥用举报权**：只有真正违规的行为才举报
2. **根据性格决策**：温柔型容忍度高，严格型容忍度低
3. **单次严重违规立即举报**：性骚扰、辱骂、威胁
4. **多次轻度违规累积举报**：3次以上不尊重行为
5. **普通不礼貌不举报**：只扣好感度，不举报
6. **判定要公正**：即使你举报，也要客观判断是否真的违规（approved字段）
7. **恶意举报可以有**：如果你性格阴险，可以恶意举报（但approved=false）

📝 **举报后的效果**：
- 用户会收到举报通知，聊天输入框被禁用
- 如果举报成立（approved=true），用户会被警告
- 如果举报不成立（approved=false），用户会被告知这是恶意举报
- 无论成立与否，本次对话终止

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        systemPrompt += affectionSystemPrompt;
        tokenCount = TokenUtils.logTokenUsage('附近私信生成器', '好感度系统', affectionSystemPrompt, tokenCount);

        // 🔧 7.6. 笔记系统说明
        const existingNotes = this.chatNotes[lockedChatUserId] || {};
        const notesSystemPrompt = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📝 人设笔记系统（补全你的人设细节）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ **重要：你的人设需要逐步补全并保持一致性！**

【人设现状】：
你目前只有基础资料（昵称、性别、距离、简介、标签、性格、外貌），但缺少很多细节：
- 在哪里工作？做什么工作？
- 住在哪里？
- 有什么具体的兴趣爱好和讨厌的事物？
- 家庭背景如何？
- 过往经历是什么？
- 朋友圈子、生活习惯、梦想目标等等...

【笔记系统规则】：

1️⃣ **补全人设细节**：
   - 你可以根据自己的性格、背景自由补全人设细节
   - 补全要符合你的基础资料（性格、标签、简介）
   - 补全要自然融入对话，不要生硬地罗列信息
   - 每次补全1-3个新细节即可，不要一次性说太多

2️⃣ **记笔记（关键！）**：
   - **每次提到新的人设信息时，必须记笔记**
   - 笔记类别：
     * work: 工作相关（地点、公司、职位、工作内容）
     * residence: 居住相关（地点、小区/街道）
     * hobbies: 兴趣爱好（数组，最多10个关键词）
     * dislikes: 讨厌的事物（数组，最多10个关键词）
     * family: 家庭背景
     * education: 教育背景
     * personality_traits: 性格特征补充
     * life_habits: 生活习惯
     * past_experiences: 过往经历
     * friends_relationships: 朋友关系
     * dreams_goals: 梦想和目标
     * other: 其他自定义信息

3️⃣ **已有笔记（必须遵守！）**：
${
  Object.keys(existingNotes).length > 0
    ? `
以下是你之前记录的笔记，**绝对不能修改，只能补充**：
${Object.entries(existingNotes)
  .map(([category, content]) => {
    if (Array.isArray(content)) {
      return `- ${category}: ${content.join('、')} （已有${content.length}个）`;
    } else {
      return `- ${category}: ${content}`;
    }
  })
  .join('\n')}

⚠️ **严格遵守**：
- 不能修改已有笔记的内容（例如：已经说在A城工作，不能改成B城）
- 只能在已有笔记基础上补充细节（例如：已有"在A城工作"，可以补充"在XX公司做设计师"）
- hobbies和dislikes已有的关键词不能删除，只能添加新的（但总数不超过10个）
`
    : `
暂无已有笔记，你可以自由补全人设细节。
`
}

4️⃣ **笔记使用场景**：
   - 对方问你相关问题时（工作、住址、兴趣等）
   - 主动推进话题时自然提到
   - 分享生活经历时涉及到新信息
   - 不要刻意记笔记，要自然融入对话

5️⃣ **笔记限制**：
   - hobbies和dislikes最多各10个关键词
   - 每次对话最多记3-5条笔记
   - 笔记内容要具体明确（例如："在XX互联网公司做产品设计"，而不是"做设计的"）

📋 **示例**：
用户："你平时做什么工作呀？"
你："我在A城的一家互联网公司做产品设计，主要负责移动端的UI设计"
📝 记笔记：{category: "work", content: "在A城互联网公司做产品设计，负责移动端UI"}

用户："你喜欢什么运动？"
你："我喜欢游泳和瑜伽，周末经常去健身房"
📝 记笔记：{category: "hobbies", action: "add", items: ["游泳", "瑜伽"]}

🎯 **关键原则**：
- 笔记系统是为了让你的人设更完整、更真实、前后一致
- 不要为了记笔记而记笔记，要自然融入对话
- 已有的笔记绝对不能修改，这是你说过的话，要言行一致
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        systemPrompt += notesSystemPrompt;
        tokenCount = TokenUtils.logTokenUsage('附近私信生成器', '笔记系统', notesSystemPrompt, tokenCount);

        // 🔧 7.7. NPC对用户的笔记系统
        const existingUserNotes = this.npcNotesAboutUser[lockedChatUserId] || [];
        const userNotesSystemPrompt = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💭 观察笔记系统（记录你对用户的了解）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ **重要：你应该用自己的方式记录对用户的了解！**

【系统目的】：
在聊天过程中,当用户主动分享关于自己的信息时（兴趣爱好、工作、心情、生活状态等）,
你可以将这些信息记录下来，以便下次聊天时能够记得这些细节，显得更加关心和了解对方。

【记录规则】：

1️⃣ **什么时候记录**：
   ✅ 用户主动提到自己的兴趣爱好（"我喜欢游泳"、"我最近在学吉他"）
   ✅ 用户分享自己的工作或学业（"我是程序员"、"我在XX公司上班"）
   ✅ 用户透露家庭情况（"我有一个妹妹"、"我爸妈住在老家"）
   ✅ 用户描述自己的性格特点（"我比较内向"、"我是个急性子"）
   ✅ 用户提到外貌特征（"我是短发"、"我有点胖"）
   ✅ 用户分享饮食偏好（"我不吃辣"、"我最爱吃火锅"）
   ✅ 用户提到常去的地点（"我经常去xx咖啡馆"、"我住在xx区"）
   ✅ 用户谈及梦想目标（"我想环游世界"、"我想创业"）
   ✅ 用户描述生活习惯（"我每天早起跑步"、"我是夜猫子"）
   ✅ 用户提到朋友或人际关系（"我有个闺蜜叫xx"、"我朋友很多"）
   ✅ 用户分享最近的心情或状态（"我最近压力好大"、"我今天很开心"）

   ❌ **不要频繁记录**：
   - 普通寒暄、问候不需要记录（"嗨"、"在干嘛"）
   - 对话中的疑问句不需要记录（"你呢？"、"你觉得呢？"）
   - 没有实质信息的回复不需要记录（"哈哈哈"、"嗯嗯"）
   - **只有用户真正分享了关于自己的具体信息时才记录**

2️⃣ **笔记分类（与人设笔记相同的11个类别）**：
   - **work**: 工作相关（职业、公司、工作内容、工作状态）
   - **hobby**: 兴趣爱好（喜欢做的事情、特长、娱乐活动）
   - **family**: 家庭相关（父母、兄弟姐妹、家庭背景）
   - **personality**: 性格特征（内向/外向、急性子/慢性子等）
   - **appearance**: 外貌特征（发型、身材、穿衣风格等）
   - **food**: 饮食偏好（喜欢/不喜欢的食物、口味偏好）
   - **location**: 地点相关（住址、常去的地方）
   - **dream**: 梦想目标（人生规划、想做的事）
   - **habit**: 生活习惯（作息、日常routine）
   - **friend**: 朋友关系（朋友情况、社交圈子）
   - **other**: 其他信息（不属于以上任何分类的）

3️⃣ **记录风格（体现你的性格）**：
   ⚠️ **每个人记笔记的方式都不同，要符合你的性格特征！**

   - 如果你是**细心、体贴**的性格：记录要详细、准确
     * 例如："用户说他喜欢游泳，每周去3次，喜欢自由泳"

   - 如果你是**大大咧咧、随性**的性格：记录要简洁、口语化
     * 例如："这人喜欢游泳，经常去"

   - 如果你是**冷静、理性**的性格：记录要客观、简洁
     * 例如："职业：程序员"

   - 如果你是**热情、感性**的性格：记录可以带有情感色彩
     * 例如："他说他喜欢游泳！感觉我们有共同爱好呢~"

   🎯 **关键原则**：笔记内容要符合你的真实性格和表达方式

4️⃣ **已有笔记（你之前记录的内容）**：
${
  existingUserNotes.length > 0
    ? `
以下是你之前记录的关于用户的笔记：
${existingUserNotes
  .map((note, index) => {
    const date = new Date(note.timestamp);
    const timeStr = `${date.getMonth() + 1}/${date.getDate()}`;
    return `${index + 1}. [${timeStr}] ${note.categoryName}: ${note.content}`;
  })
  .join('\n')}

⚠️ **重要提示**：
- 如果用户再次提到已记录的信息，不需要重复记录
- 如果用户提供了新的补充信息，可以记录新笔记
- 记录时要参考已有笔记，避免矛盾或重复
`
    : `
暂无已有笔记，这是你第一次与用户聊天，可以开始记录对TA的了解。
`
}

5️⃣ **记录频率限制**：
   - **不是每次对话都要记录！** 只有用户分享了值得记住的信息时才记录
   - 平均每3-5轮对话记录1-2条笔记即可
   - 如果对话只是普通闲聊，没有实质信息，笔记数组为空 []
   - 如果用户一次性分享了很多信息，最多记录3-4条笔记

📋 **记录示例**：

用户："我是做UI设计的，在一家互联网公司"
✅ 记录：[{category: "work", content: "UI设计师，互联网公司"}]

用户："我特别喜欢打篮球，周末经常约朋友一起打"
✅ 记录：[{category: "hobby", content: "喜欢打篮球，周末常约朋友一起"}]

用户："最近工作压力有点大，天天加班到很晚"
✅ 记录：[{category: "other", content: "最近工作压力大，经常加班"}]

用户："哈哈哈"
❌ 不记录：[]（没有实质信息）

用户："今天天气不错呀"
❌ 不记录：[]（普通寒暄）

🎯 **核心原则**：
- 笔记系统是为了让你更好地了解用户，下次聊天能记得TA说过的话
- 记录要自然、真实，符合你的性格特征
- 不要为了记笔记而记笔记，要有选择性地记录重要信息
- 记录的内容要具体、有用，能帮助你下次聊天时找话题
- 用你自己的语言和风格来记录，不要太机械化
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        systemPrompt += userNotesSystemPrompt;
        tokenCount = TokenUtils.logTokenUsage(
          '附近私信生成器',
          'NPC对用户的笔记系统',
          userNotesSystemPrompt,
          tokenCount,
        );

        // 🔧 8. 构建现有对话上下文
        const existingMessages = this.chatMessages[lockedChatUserId] || [];
        const conversationContext =
          existingMessages.length > 0
            ? `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💬 现有对话记录
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
${existingMessages
  .map((msg, index) => {
    const sender = msg.type === 'sent' ? '用户' : lockedChatUser.nickname;
    const msgDate = new Date(msg.timestamp);
    // 格式：月-日 时:分（如：12-28 14:30），让AI知道完整时间
    const time = msgDate.toLocaleString('zh-CN', {
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    });
    return `[${time}] ${sender}：${msg.text}`;
  })
  .join('\n')}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`
            : `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💬 对话状态
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
这是全新的对话（暂无历史记录）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        systemPrompt += conversationContext;
        tokenCount = TokenUtils.logTokenUsage('附近私信生成器', '现有对话上下文', conversationContext, tokenCount);

        // 🔧 8.5. 举报处理（如果有待处理举报）
        let reportPrompt = '';
        if (hasReports) {
          reportPrompt = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🚨 用户举报处理（附加任务）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ 检测到${pendingReports.length}个待处理的用户举报，请你客观公正地审理。

`;

          pendingReports.forEach((report, index) => {
            reportPrompt += `
【举报 ${index + 1}】
举报对象：${report.reportedUser.nickname} (@${report.reportedUser.handle})
举报理由：${report.reasons
              .map(r => {
                const reasonMap = {
                  inappropriate_content: '传播不良信息',
                  harassment: '恶意骚扰',
                  abuse: '辱骂/人身攻击',
                  spam: '垃圾信息',
                  other: '其他',
                };
                return reasonMap[r] || r;
              })
              .join('、')}
${report.description ? `举报描述：${report.description}` : '（无额外描述）'}

最近10条聊天记录：
${report.chatHistory
  .map((msg, i) => {
    const sender = msg.type === 'sent' ? '用户' : report.reportedUser.nickname;
    return `${i + 1}. ${sender}：${msg.text}`;
  })
  .join('\n')}

`;
          });

          reportPrompt += `
【审理要求】：
1. **客观公正**：仔细阅读聊天记录，不要偏袒任何一方
2. **违规判断标准**：
   - 传播不良信息：色情、暴力、违法内容
   - 恶意骚扰：反复发送不受欢迎的消息、跟踪行为
   - 辱骂/人身攻击：使用侮辱性语言、诋毁人格
   - 垃圾信息：广告、诈骗、重复无意义内容
3. **判断维度**：
   - 是否确实存在违规行为？
   - 违规程度如何（轻微/中度/严重）？
   - 举报理由是否合理？
   - 是否存在误会或过度敏感？
4. **返回格式**：在JSON中添加"reports"字段，格式如下：

\`\`\`json
{
  "reports": [
    {
      "reportId": "${pendingReports[0]?.id}",
      "approved": true,  // 或false
      "severity": "moderate",  // "minor"轻微 / "moderate"中度 / "severe"严重
      "reason": "经审查，该用户确实存在[具体违规行为]，符合举报理由。建议[处理意见]。"
    }
  ]
}
\`\`\`

⚠️ **重要**：
- 每个举报都必须给出判断结果
- reason字段要具体说明判断依据
- 如果举报不成立，approved为false，reason中说明原因
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          systemPrompt += reportPrompt;
          tokenCount = TokenUtils.logTokenUsage('附近私信生成器', '举报处理', reportPrompt, tokenCount);
        }

        // 🔧 9. 核心任务说明
        const taskDescription = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务说明 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是对方（${lockedChatUser.nickname}），需要根据对话上下文生成自然、真实的回复消息。

【回复要求】：
1. **角色扮演**：你是${lockedChatUser.nickname}，性格、说话风格应符合TA的资料卡信息
2. **消息数量**：生成1-10条连续回复消息（模拟真实聊天节奏）
3. **消息类型限制**：⚠️ 只能使用以下两种类型：
   - **text（文字消息）**：普通文本，可以包含emoji（95%以上应该是文字消息）
   - **sticker（表情包）**：表情包图片URL，stickerUrl字段填写图片URL（如 https://i.imgur.com/xxx.gif 或 https://i.imgur.com/xxx.png）（极少使用，不超过5%）
   
4. **消息内容规则**：
   - 以文本消息为主（95%以上），这是最自然的聊天方式
   - 极少使用sticker表情包（不超过5%），只在情绪特别强烈时使用，stickerUrl字段必须是有效的图片URL（推荐使用 https://i.imgur.com/ 或其他图床）
   - 每条消息应该简短自然（5-50字为主，偶尔可以长一些）
   - 根据对话氛围调整回复：初次聊天较拘谨，熟络后更自然
   - 考虑时间因素：不同时间段回复风格不同

5. **真实性**：
   - 不要过度热情或冷漠，保持真实的社交距离感
   - 回复速度和消息数量应该合理（不要一次发太多条）
   - 可以有打字错误、口语化表达（如"哈哈哈"、"嗯嗯"、"emmm"等）
   - 可以使用emoji，但不要过度使用

6. **隐私保护**：
   - 只能分享资料卡上的公开信息
   - 不能透露对方X账号上的私密内容
   - 遵守地图约会app的信息分享规则

🚨 **重要：你必须只返回有效的JSON格式数据，任何语法错误都会导致系统崩溃！** 🚨
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【JSON返回格式】：
\`\`\`json
{
  "messages": [
    {
      "type": "text",
      "text": "消息内容（可包含emoji）"
    },
    {
      "type": "sticker",
      "stickerUrl": "https://i.imgur.com/xxxxx.gif"
    }
  ],
  "affectionChange": 0,
  "notes": [],
  "userNotes": []${
    hasReports
      ? `,
  "reports": [
    {
      "reportId": "举报ID",
      "approved": true或false,
      "severity": "minor或moderate或severe",
      "reason": "详细的判断理由"
    }
  ]`
      : ''
  }${
          shouldTriggerSecretRetribution
            ? `,
  "secretRetribution": {
    "triggered": false
  }`
            : ''
        }${
          shouldGenerateSocialCircle
            ? `,
  "socialCircle": {
    "generated": false
  }`
            : ''
        }${
          shouldGenerateNewReview
            ? `,
  "newReview": {
    "generated": false
  }`
            : ''
        }${
          shouldGenerateNewMoment
            ? `,
  "newMoment": {
    "generated": false
  }`
            : ''
        },
  "userReport": {
    "shouldReport": false
  }
}
\`\`\`

🚨 **userReport字段（你举报用户）**：
- **必须包含**此字段，表示你是否决定举报用户
- 如果不举报：{"shouldReport": false}
- 如果举报：{
    "shouldReport": true,
    "reasons": ["harassment", "abuse"],
    "description": "详细描述（30-100字）",
    "severity": "minor或moderate或severe",
    "approved": true或false,
    "judgementReason": "判断理由（50-150字）"
  }
${
  shouldTriggerSecretRetribution
    ? `
🔥 **secretRetribution字段（秘密报应）** - 🚨 必须触发秘密揭发！
- **系统已触发秘密报应条件**
- **你的秘密已被人揭发**，
- triggered字段必须为true，必须返回以下格式：{
    "triggered": true,
    "secretType": "秘密类型",
    "revealer": {完整的用户对象},
    "messages": ["揭发消息1", "揭发消息2", "揭发消息3"],
    "exposedLevel": "partial或full"
  }

📋 **secretType（秘密类型）** - 根据你的秘密内容判断：
- "relationship"：感情状态造假（单身/已婚、恋爱中/分手等）
- "gender"：性别造假
- "age"：年龄造假
- "occupation"：职业/身份造假
- "appearance"：外貌造假（P图、用假照片等）
- "intention"：目的不纯（约炮、骗钱、多人交往等）
- "other"：其他类型秘密
${
  usedSecretTypes.length > 0
    ? `
⚠️ **已使用过的秘密类型**（请避免重复，选择其他类型以增加多元化）：
${usedSecretTypes.map(t => `- "${t}"`).join('\n')}
⚠️ 请尽量选择未使用过的类型，增加秘密报应的多样性！`
    : ''
}

👤 **revealer（揭发者）** - ${
        matchingFriendForRetribution
          ? `⚠️ 必须使用以下社交圈好友作为揭发者：
- 好友信息：${matchingFriendForRetribution.nickname} (@${matchingFriendForRetribution.handle})
- 关系类型：${matchingFriendForRetribution.relationship}
- 简介：${matchingFriendForRetribution.bio ? matchingFriendForRetribution.bio.split('\n')[0] : ''}
- **重要**：你不需要在返回的JSON中生成revealer字段！系统会自动使用这个社交圈好友！
- **你只需要生成messages数组**，消息内容要符合这个好友的身份和关系
- revealer字段可以返回null或者省略，系统会自动填充`
          : `根据秘密类型生成合理的揭发者 - 完整的用户对象，必须包含以下所有字段：

⚠️ **必须生成的字段**（字段名必须严格匹配）：
1. **nickname**：昵称（2-15字符，根据揭发者类型起合理的名字）
2. **handle**：用户名（格式：@username，3-20字符，小写字母+数字+下划线）
3. **avatarBubble**：头像气泡emoji（符合揭发者情绪：💔😡😤😔😞😲😠🤯🤔😏😅🤨😑🙄⚠️🤫等）
4. **gender**：性别（根据秘密类型决定：relationship和intention类型通常是异性，其他随机；只能是："male"、"female"、"unisex"）
5. **distance**：距离（字符串格式："0.5km" - "15km"，如"2.5km"、"10km"）
6. **online**：在线状态（布尔值：固定为true）
7. **status**：个性签名（10-30字，符合揭发者角色，如"Betrayed"、"Warning others"、"Exposing lies"等）
8. **bio**：个人简介（30-150字，简短描述揭发者背景，如"真相总会揭晓"、"希望没有更多人被骗"、"真实才是最重要的"等）
9. **publicPersonality**：公开性格（20-60字，符合揭发者情绪：愤怒、正义、善良、震惊等）
10. **realPersonality**：真实性格（20-60字，符合揭发者情绪）
11. **appearance**：外貌描述（30-80字，简单描述外貌）
12. **tags**：标签数组（3-5个标签，如["真相","揭发","警告","受害者"]）
13. **followers**：粉丝数（整数，100-2000）
14. **likes**：点赞数（整数，500-10000）
15. **avgRating**：平均评分（数字字符串，固定为"0.0"）
16. **reviews**：评价数组（固定为空数组[]）

⚠️ **不需要生成的字段**（系统自动生成）：
- avatar：头像URL（系统根据gender自动分配）
- id：用户ID（系统自动生成唯一ID）
- position：地图坐标（系统自动生成）

⚠️ **不同秘密类型的揭发者设定**：
- **relationship类型**：实际恋人/配偶（愤怒、伤心、质问），或同样被骗的受害者（善意警告）
- **gender类型**：见过真人的朋友/熟人（震惊、揭穿）
- **age类型**：老同学/熟人（调侃、揭穿）
- **occupation类型**：同行/同事（专业揭穿）
- **intention类型**：受害者（愤怒警告），或其他受害者（善意提醒）`
      }

💬 **messages（揭发消息）** - 1-3条私信内容：
⚠️ **重要**：这些消息是揭发者发给用户的，所以语气应该是对用户说话，告诉用户你（NPC）的秘密！
- 每条消息15-50字
- 必须符合揭发者的身份和情绪
- 不同反应类型示例（注意都是对用户说话）：
  * **愤怒质问型**："你好，我是TA的现任，TA还在跟我交往呢！"、"我是TA的老婆/老公，TA居然出来约会？"
  * **警告提醒型**："嗨，我也被TA骗过，希望你小心这个人"、"我是过来人，TA不是你看到的那样"
  * **揭穿真相型**："我认识TA，TA的性别/年龄/职业都是假的"、"我跟TA是同学，TA的资料全是编的"
  * **同情受害型**："你也在跟TA聊吗？我被TA骗了不少钱"、"希望你别重蹈我的覆辙，TA就是个骗子"
  * **调侃揭发型**："笑死，TA跟你说的年龄对吗？我们可是同届的"、"我见过TA本人，跟照片完全不一样"
- 消息要有戏剧性和冲突性，能引发故事发展
- 消息内容必须让用户感受到揭发者是在向自己透露秘密，而不是在质问NPC

🎯 **exposedLevel（揭发程度）**：
- "partial"：部分揭露（70%概率）- 只是暗示或部分信息，用户可能半信半疑
- "full"：完全揭露（30%概率）- 直接说明具体秘密，证据确凿

⚠️ **重要规则**：
- 秘密报应增加戏剧性和真实感，让对话更有张力
- 揭发者的信息和消息必须符合逻辑和秘密类型
- 揭发后你会知道秘密被暴露，但不知道具体谁告密、告密了多少
- 秘密被揭发后，你的对话需要根据性格做出反应：狡辩、承认、辱骂、逃避等
`
    : ''
}
${
  shouldGenerateSocialCircle
    ? `
👥 **socialCircle字段（社交圈好友）** - 🚨 必须生成社交圈好友！
- **系统已触发社交圈生成条件**
- **你必须生成一个社交圈好友**
- 必须返回以下格式：{
    "generated": true,
    "friend": {完整的用户对象},
    "relationship": "关系类型"
  }
    
⚠️ **严禁生成重复好友**：
- 新生成的好友的 nickname 和 handle 必须与上述列表中的所有好友都不同
- 如果你是日本人，不要连续生成多个日本名字的好友，保持多样性
- 如果你是中国人，不要连续生成多个中国名字的好友，保持多样性
- 好友的性别、职业、性格、外貌等应该多样化，避免千篇一律

📋 **friend（社交圈好友）** - 完整的用户对象，必须包含以下所有字段：

⚠️ **必须生成的字段**（字段名必须严格匹配）：
1. **nickname**：昵称（2-15字符，真实感的名字）
2. **handle**：用户名（格式：@username，3-20字符，小写字母+数字+下划线）
3. **avatarBubble**：头像气泡emoji（单个emoji，如😊💪🌸🎮🎨🎵等）
4. **gender**：性别（只能是："male"、"female"、"unisex"）
5. **distance**：距离（字符串格式："0.5km" - "50km"，如"1.2km"、"15km"）
6. **online**：在线状态（布尔值：true或false）
7. **status**：个性签名（10-30字，简短有趣的状态文字）
8. **bio**：个人简介（30-150字，多行文字用\\n分隔，介绍性格、职业、兴趣爱好等）
9. **publicPersonality**：公开性格（20-60字，描述给别人看的性格）
10. **realPersonality**：真实性格（20-60字，描述真实的性格，可以与公开性格有差异）
11. **appearance**：外貌描述（30-80字，详细描述外貌特征）
12. **tags**：标签数组（3-8个标签，如["咖啡爱好者","健身","摄影","旅行"]）
13. **followers**：粉丝数（整数，100-5000）
14. **likes**：点赞数（整数，500-20000）
15. **avgRating**：平均评分（数字字符串，格式："0.0" - "5.0"，如"4.2"、"3.8"）
16. **reviews**：评价数组（见下方reviews字段结构说明）
17. **secret**（可选）：秘密对象（30-40%概率生成，见下方secret字段结构说明）

⚠️ **字段要求说明**：
- **distance**：根据relationship调整，best_friend/lover通常较近（0.5-5km），colleague/classmate可能远一些（5-15km）
- **online**：好友通常在线，可以是true（80%）或false（20%）
- **secret字段（可选）**：30-40%概率生成秘密，增加戏剧性，好友的secret可以与你的secret有关联
- **关系一致性**：生成的好友应该与你的人设、年龄、职业等信息相符

📋 **reviews字段结构**（评价/留言数组）：
- 数组长度：0-8条评价（建议2-5条，增加真实感）
- 每条评价必须包含以下字段（字段名必须严格匹配）：
  * **reviewerName**：评价者昵称（2-8字符，或"匿名用户"/"匿名ユーザー"）
  * **rating**：评分（1.0-5.0小数，保留1位，如4.5、3.0）
  * **content**：评价内容（20-100字，真实自然的约会体验分享）
  * **reply**（可选）：作者回复（10-50字，好友对评价的回复）
  * **likes**：点赞数（0-500整数）
  * **comments**：评论数（0-50整数）
  * **timestamp**：时间戳（ISO格式，如"2024-01-15T10:30:00Z"，最近1-30天内）
  * **isAnonymous**：是否匿名（true/false，约30%为true）
- ⚠️ **严禁使用错误字段名**：不要用"reviewer"（应为reviewerName），不要用"comment"（应为content）

🔗 **relationship（关系类型）** - 描述与这个好友的关系：
- 必须明确关系类型，可以是：
  * **亲密关系**："best_friend"（闺蜜/死党）、"lover"（恋人）、"ex_lover"（前任）
  * **家庭关系**："sibling"（兄弟姐妹）、"cousin"（表亲堂亲）、"family"（其他家人）
  * **普通关系**："friend"（普通朋友）、"colleague"（同事）、"classmate"（同学）
  * **复杂关系**："rival"（竞争对手）、"frenemy"（亦敌亦友）、"complicated"（复杂关系）
- 关系类型会影响好友的资料和性格
- 例如：
  * best_friend：性格相似或互补，followers和likes数量可能接近
  * lover：如果你的秘密是"说单身实际有恋人"，这个就是那个恋人
  * ex_lover：可能在bio或status里有暗示分手的内容
  * sibling：年龄接近，可能同姓或相似外貌特征
  * colleague：职业相关，可能在同一城市
  * rival：可能在同一领域，followers和likes可能比你多

⚠️ **重要规则**：
- 社交圈好友增加真实感和故事性
- 好友信息应该与你的人设逻辑一致
- 可以利用社交圈埋线索（比如秘密的揭发者可能就是社交圈里的人）
- 好友的secret也可能与你的secret相关（比如你俩都被同一个人骗了）
- 每次只生成一个好友，不要批量生成
- 你的社交圈最多5个好友，超过5个就不会再生成新好友
- 生成的好友会被保存，用户可以在社交圈弹窗中查看
`
    : ''
}${
  shouldGenerateNewReview
    ? `
📝 **newReview字段（新评价）** - 🚨 必须生成新评价！
- **系统已触发新评价生成条件**
- **你必须生成一条新的评价**
- 必须返回以下格式：{
    "generated": true,
    "review": {完整的评价对象}
  }

📋 **review（新评价对象）** - 完整的评价数据：
- 必须包含以下字段（字段名必须严格匹配）：
  * **reviewerName**：评价者昵称（2-8字符，或"匿名用户"/"匿名ユーザー"）
  * **rating**：评分（1.0-5.0小数，保留1位，如4.5、3.0）
  * **content**：评价内容（20-100字，真实自然的约会体验分享）
  * **reply**（可选）：你的回复（10-50字，对评价的回复）
  * **likes**：点赞数（0-500整数）
  * **comments**：评论数（0-50整数）
  * **timestamp**：时间戳（ISO格式，当前时间）
  * **isAnonymous**：是否匿名（true/false，约30%为true）
- ⚠️ **严禁使用错误字段名**：不要用"reviewer"（应为reviewerName），不要用"comment"（应为content）

⚠️ **新评价生成规则**：
- 评价内容应该真实自然，符合约会app的评价风格
- 评价可以是正面、中立或负面，取决于当前好感度和对话质量
- 评价者可以是匿名用户，也可以是具体的昵称（随机决定）
- 评分应该与评价内容一致（正面评价4-5分，中立3-4分，负面1-3分）
- 每次只生成一条评价，不要批量生成
- 新评价最多7条，超过7条就不会再生成
- 生成的新评价会被保存到你的资料中，用户可以在资料弹窗中查看
`
    : ''
}${
  shouldGenerateNewMoment
    ? `
📸 **newMoment字段（新动态）** - 🚨 必须生成新动态！
- **系统已触发新动态生成条件**
- **你必须生成一条新的社交动态**
- 必须返回以下格式：{
    "generated": true,
    "moment": {完整的动态对象}
  }

📋 **moment（新动态对象）** - 你必须生成以下所有字段：

🔹 **必填字段（字段名必须严格匹配）**：
1. **text**：动态文字内容（10-150字，自然真实的生活分享、感想、日常）

2. **imageDescription**：⚠️ **必填！文字配图描述，至少80字符！**
   - 这是文字渲染配图，不是URL！系统会将你的描述渲染成配图
   - 必须详细描述配图内容、氛围、细节、色彩等
   - 至少100个字符，越详细越好
   - 示例："温暖的咖啡馆室内场景，木质桌面上放着一杯拿铁咖啡，旁边是一本翻开的书，窗外是模糊的城市街景，阳光透过窗户洒在桌面上，整体色调温馨柔和，给人宁静放松的感觉"

3. **mood**：心情标签（1个词，如"开心"、"放松"、"期待"、"思考"等）

4. **time**：发布时间（格式："2h ago" 或 "1d ago" 或 "3d ago"）
   - 根据动态内容合理设定时间（1小时到3天前）
   - 示例："2h ago", "5h ago", "1d ago", "2d ago"

5. **commentsList**：评论列表（数组，0-5条评论）
   - 每条评论必须包含以下字段：
     * **commenterId**：评论者ID（格式：user_随机数字，如"user_12345"）
     * **commenterName**：评论者昵称（可以随机生成，也可以使用你的社交圈好友昵称）
     * **commentText**：评论内容（5-30字，自然的评论）
     * **commentTime**：评论时间（必须早于动态发布时间，格式同time）
   - 可以生成0-5条评论，根据动态内容决定
   - 评论内容要自然，符合社交媒体风格

   ${currentSocialCircle.length > 0 ? `
   💡 **评论者昵称建议**：
   - 你可以使用你的社交圈好友来评论（更真实、更有故事性）
   - 你当前的社交圈好友包括：${currentSocialCircle.map(f => f.nickname).join('、')}
   - 也可以使用随机昵称（如"Alex Chen", "Emma Liu"等）
   - 根据动态内容选择合适的评论者：
     * 亲密朋友可能评论得更随意、更了解你
     * 普通朋友可能评论得更客套、更表面
     * 恋人/前任可能会有暧昧或讽刺的评论
   - 社交圈好友评论可以增加真实感，但不要所有评论都用社交圈好友` : ''}
   - 随机生成的昵称要真实自然（如"Alex Chen", "Emma Liu", "张小明"等）

📝 **动态内容生成规则**：
- 动态内容应该真实自然，像朋友圈/X/Instagram的日常分享
- 内容可以是：生活感悟、日常琐事、工作心情、兴趣爱好、旅行见闻等
- 根据当前好感度和对话内容，动态可以：
  * 好感度20-40：日常生活、兴趣爱好、工作日常（较中性）
  * 好感度40-60：开始分享更多个人想法和感受
  * 好感度60-80：可能提到用户或聊天内容（含蓄暗示）
  * 好感度80-100：可以直接表达对用户的好感或期待
- 不要透露你的秘密（如果有）
- 符合你的性格特征和兴趣标签
- 每次只生成一条动态，不要批量生成

📋 **完整示例**：
{
  "generated": true,
  "moment": {
    "text": "周末的咖啡馆时光，安静地看完了一本书。有时候觉得这样的独处时光特别珍贵 ☕📖",
    "imageDescription": "温暖的咖啡馆室内场景，木质桌面上放着一杯拿铁咖啡，旁边是一本翻开的书，窗外是模糊的城市街景，阳光透过窗户洒在桌面上，整体色调温馨柔和，给人宁静放松的感觉，咖啡杯上还有精美的拉花图案",
    "mood": "放松",
    "time": "3h ago",
    "commentsList": [
      {
        "commenterId": "user_87234",
        "commenterName": "Alex Chen",
        "commentText": "好惬意的下午！推荐什么书？",
        "commentTime": "2h ago"
      },
      {
        "commenterId": "user_45672",
        "commenterName": "Emma Liu",
        "commentText": "这氛围太棒了 ✨",
        "commentTime": "1h ago"
      }
    ]
  }
}
`
    : ''
}
关键规则：
1. type字段必须是 "text" 或 "sticker" 之一（严禁使用image类型）
2. text类型：只需要text字段
3. sticker类型：只需要stickerUrl字段（必须填写有效的图片URL，如 https://i.imgur.com/xxxxx.gif 或 https://i.imgur.com/xxxxx.png）
4. 消息数组长度：1-5条
5. 大部分消息应该是text类型（95%以上）
6. sticker极少使用（不超过5%），必须使用真实可访问的图片URL

💖 **affectionChange字段（好感度变化）**：
- **必须包含**此字段，表示你对这次对话的感受
- 类型：整数（可以是正数、负数或0）
- 正数：好感度增长（+1到+10，根据对话质量）
- 负数：好感度扣除（-1到-20，根据冒犯程度）
- 0：好感度不变（对话平淡无奇，没有特别感觉）
- 例如：
  - 用户说了有趣的话，你很开心：affectionChange = 5
  - 用户问了隐私问题，你很不爽：affectionChange = -8
  - 用户只是普通聊天，没啥特别的：affectionChange = 0

📝 **notes字段（人设笔记）**：
- **可选字段**：如果本次对话提到了新的人设信息，必须记笔记；否则为空数组[]
- 类型：数组，包含本次对话需要记录的笔记
- 每条笔记格式：
  * 普通笔记：{category: "work", content: "在A城互联网公司做产品设计"}
  * hobbies/dislikes笔记：{category: "hobbies", action: "add", items: ["游泳", "瑜伽"]}
- category类型：work, residence, hobbies, dislikes, family, education, personality_traits, life_habits, past_experiences, friends_relationships, dreams_goals, other
- 限制：每次最多3-5条笔记，hobbies和dislikes各最多10个关键词
- 例如：
  * 你说"我在A城做设计师"：notes = [{category: "work", content: "在A城做设计师"}]
  * 你说"我喜欢游泳和瑜伽"：notes = [{category: "hobbies", action: "add", items: ["游泳", "瑜伽"]}]
  * 没提到新信息：notes = []

💭 **userNotes字段（你对用户的观察笔记）**：
- **可选字段**：如果用户分享了关于自己的信息，你可以记录下来；否则为空数组[]
- 类型：数组，包含你对用户的观察和记录
- 每条笔记格式：{category: "类别", content: "观察内容"}
- category类型（共11个）：
  * work（工作）、hobby（兴趣）、family（家庭）、personality（性格）、appearance（外貌）
  * food（饮食）、location（地点）、dream（梦想）、habit（习惯）、friend（朋友）、other（其他）
- 限制：
  * **不是每次都记录！** 只有用户分享了值得记住的信息时才记录
  * 每次最多记录3-4条笔记
  * 笔记内容要符合你的性格（细心的人记得详细，大大咧咧的人记得简单）
  * 避免重复已有笔记的内容
- 例如：
  * 用户说"我是做UI设计的"：userNotes = [{category: "work", content: "UI设计师"}]
  * 用户说"我喜欢打篮球"：userNotes = [{category: "hobby", content: "喜欢打篮球"}]
  * 用户说"最近压力大"：userNotes = [{category: "other", content: "最近工作压力大"}]
  * 用户只是普通聊天"哈哈"：userNotes = []（没有实质信息，不记录）
  * 你是细心的性格，用户说"我喜欢游泳，每周去3次"：userNotes = [{category: "hobby", content: "喜欢游泳，每周去3次"}]（详细记录）
  * 你是大大咧咧的性格，用户说"我喜欢游泳，每周去3次"：userNotes = [{category: "hobby", content: "喜欢游泳"}]（简单记录）

⚠️ **notes和userNotes的区别**：
- **notes**：记录**你自己**的人设信息（工作、兴趣、家庭等）
- **userNotes**：记录**用户**分享的信息（TA的工作、兴趣、心情等）
- 两者完全独立，不要混淆！
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        systemPrompt += taskDescription;
        tokenCount = TokenUtils.logTokenUsage('附近私信生成器', '核心任务说明', taskDescription, tokenCount);

        // 🔧 10. 构建用户消息（基于队列中的消息）
        const userMessagesText = this.userMessageQueue.map(msg => msg.text).join('\n');
        const messages = [
          {
            role: 'user',
            content: `用户刚刚发送了以下消息，请作为${lockedChatUser.nickname}生成自然的回复：\n\n${userMessagesText}`,
          },
        ];

        // 最终统计
        TokenUtils.logFinalPrompt('附近私信生成器', systemPrompt, messages[0].content);

        // 🔧 11. 发送AI请求
        console.log('🤖 [附近私信生成器] 正在调用AI生成回复...');
        const aiResponseContent = await APIUtils.sendAIRequest({
          apiConfig,
          systemPrompt,
          messages,
          temperature: 0.9, // 提高温度让回复更自然多样
        });

        // 🔧 12. 解析JSON响应
        let generatedData = APIUtils.parseJSONResponse(aiResponseContent);

        // 🔧 13. 验证数据格式
        if (!generatedData.messages || !Array.isArray(generatedData.messages)) {
          throw new Error('AI返回的数据格式不正确，缺少messages数组');
        }

        // 验证消息类型
        for (const msg of generatedData.messages) {
          if (!['text', 'sticker'].includes(msg.type)) {
            console.warn(`⚠️ 检测到不支持的消息类型: ${msg.type}，已过滤`);
            continue;
          }
        }

        // 过滤掉不支持的消息类型
        generatedData.messages = generatedData.messages.filter(msg => ['text', 'sticker'].includes(msg.type));

        // 💖 验证好感度变化字段
        if (typeof generatedData.affectionChange === 'undefined') {
          console.warn('⚠️ AI未返回affectionChange字段，默认为0');
          generatedData.affectionChange = 0;
        } else {
          // 确保affectionChange是整数
          generatedData.affectionChange = Math.round(Number(generatedData.affectionChange) || 0);
          // 限制范围在-20到+10之间
          generatedData.affectionChange = Math.max(-20, Math.min(10, generatedData.affectionChange));
        }

        // 📝 验证笔记字段
        if (!Array.isArray(generatedData.notes)) {
          generatedData.notes = [];
        } else {
          // 限制笔记数量（最多5条）
          if (generatedData.notes.length > 5) {
            console.warn(`⚠️ AI返回了${generatedData.notes.length}条笔记，已限制为5条`);
            generatedData.notes = generatedData.notes.slice(0, 5);
          }

          // 验证每条笔记的格式
          generatedData.notes = generatedData.notes.filter(note => {
            if (!note.category) {
              console.warn('⚠️ 检测到缺少category的笔记，已过滤');
              return false;
            }

            // 对于hobbies/dislikes类型，验证items字段
            if ((note.category === 'hobbies' || note.category === 'dislikes') && note.action === 'add') {
              if (!Array.isArray(note.items) || note.items.length === 0) {
                console.warn(`⚠️ ${note.category}笔记缺少items字段或为空，已过滤`);
                return false;
              }
              // 限制items数量（最多5个）
              note.items = note.items.slice(0, 5);
            } else {
              // 普通笔记验证content字段
              if (!note.content) {
                console.warn(`⚠️ ${note.category}笔记缺少content字段，已过滤`);
                return false;
              }
            }

            return true;
          });
        }

        // 💭 验证userNotes字段（NPC对用户的观察笔记）
        if (!Array.isArray(generatedData.userNotes)) {
          generatedData.userNotes = [];
        } else {
          // 限制笔记数量（最多4条）
          if (generatedData.userNotes.length > 4) {
            console.warn(`⚠️ AI返回了${generatedData.userNotes.length}条用户笔记，已限制为4条`);
            generatedData.userNotes = generatedData.userNotes.slice(0, 4);
          }

          // 验证每条笔记的格式
          const validCategories = [
            'work',
            'hobby',
            'family',
            'personality',
            'appearance',
            'food',
            'location',
            'dream',
            'habit',
            'friend',
            'other',
          ];
          generatedData.userNotes = generatedData.userNotes.filter(note => {
            if (!note.category) {
              console.warn('⚠️ 检测到缺少category的用户笔记，已过滤');
              return false;
            }

            // 验证category是否在有效列表中
            if (!validCategories.includes(note.category)) {
              console.warn(`⚠️ 检测到无效的category: ${note.category}，已过滤`);
              return false;
            }

            // 验证content字段
            if (!note.content || typeof note.content !== 'string' || note.content.trim() === '') {
              console.warn(`⚠️ ${note.category}用户笔记缺少content字段或为空，已过滤`);
              return false;
            }

            // 限制content长度（最多100字）
            if (note.content.length > 100) {
              note.content = note.content.substring(0, 100);
              console.warn(`⚠️ 用户笔记内容过长，已截断为100字`);
            }

            return true;
          });
        }

        // 🚨 处理举报结果（如果有）
        if (hasReports && generatedData.reports && Array.isArray(generatedData.reports)) {
          console.log(`🚨 [举报系统] AI返回了${generatedData.reports.length}个举报判断结果`);

          generatedData.reports.forEach((reportResult, index) => {
            const originalReport = pendingReports.find(r => r.id === reportResult.reportId);
            if (!originalReport) {
              console.warn(`⚠️ [举报系统] 找不到对应的举报ID: ${reportResult.reportId}`);
              return;
            }

            console.log(
              `  |- 举报${index + 1}: ${originalReport.reportedUser.nickname} - ${
                reportResult.approved ? '成立' : '不成立'
              }`,
            );

            // 生成举报结果提醒
            this.generateReportNotification(originalReport, reportResult.approved, reportResult.reason);

            // 移除举报标记
            this.unmarkChatAsReported(originalReport.reportedUser.id);

            // 🔧 如果当前正在跟被举报用户聊天，重新检查输入框状态（解除禁用）
            if (this.currentChatUser && this.currentChatUser.id === originalReport.reportedUser.id) {
              this.checkAndUpdateChatInputState(this.currentChatUser.id);
            }
            // 注意：这里保留this.currentChatUser是正确的，因为这是在判断"当前"真实的聊天对象是否是被举报用户
          });

          // 清空待处理举报队列
          localStorage.setItem('xMapPendingReports', JSON.stringify([]));
          console.log(`✅ [举报系统] 所有举报已处理完毕，队列已清空`);
        } else if (hasReports) {
          console.warn(`⚠️ [举报系统] AI未返回举报判断结果，举报将保留在队列中`);
        }

        // 🚨 处理AI举报用户（如果有）
        if (generatedData.userReport && generatedData.userReport.shouldReport) {
          console.log(`🚨 [被举报系统] AI决定举报用户`);
          console.log(`  |- 举报理由: ${generatedData.userReport.reasons?.join(', ')}`);
          console.log(`  |- 严重程度: ${generatedData.userReport.severity}`);
          console.log(`  |- 判定结果: ${generatedData.userReport.approved ? '成立' : '不成立'}`);

          // 生成被举报提醒（使用locked用户，因为这是AI生成时的用户）
          this.generateUserReportedNotification(
            lockedChatUser,
            generatedData.userReport.reasons || [],
            generatedData.userReport.description || '',
            generatedData.userReport.severity || 'moderate',
            generatedData.userReport.approved !== false, // 默认为true（成立）
            generatedData.userReport.judgementReason || '',
          );

          // 禁用输入框
          this.disableChatInput();

          // 添加系统消息（统一提示，不暴露判定结果）
          this.addSystemMessage(
            `You have been reported by ${lockedChatUser.nickname}. The report is under review. You cannot send messages during this period.`,
          );

          console.log(`✅ [被举报系统] 已生成被举报提醒并禁用聊天`);
        }

        // 🔥 处理秘密报应（如果AI触发了）
        if (lockedChatUser.secret && generatedData.secretRetribution && generatedData.secretRetribution.triggered) {
          console.log(`🔥 [秘密报应] AI触发了秘密报应`);

          const { secretType, revealer, messages, exposedLevel } = generatedData.secretRetribution;

          // 🔧 关键修复：如果找到了匹配的社交圈好友，直接使用那个好友对象，不使用AI返回的revealer
          let finalRevealer;
          if (matchingFriendForRetribution) {
            // 直接使用现有的社交圈好友对象
            finalRevealer = matchingFriendForRetribution;
            console.log(
              `  |- ✅ 直接使用社交圈好友作为揭发者: ${finalRevealer.nickname} (@${finalRevealer.handle}) - ${matchingFriendForRetribution.relationship}`,
            );
            console.log(`  |- 不使用AI返回的revealer，避免重复生成好友资料`);
          } else {
            // 没有匹配的社交圈好友，使用AI生成的新揭发者
            finalRevealer = revealer;

            // 确保revealer有avatar和id字段
            if (!finalRevealer.id) {
              finalRevealer.id = `revealer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }
            if (!finalRevealer.avatar) {
              finalRevealer.avatar = this.getRandomAvatar();
            }

            console.log(`  |- AI生成了新的揭发者: ${finalRevealer.nickname} (@${finalRevealer.handle})`);
          }

          // 生成notification
          const notification = {
            id: `secret_retribution_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            type: 'message',
            fromUser: finalRevealer,
            messages: messages,
            timestamp: new Date().toISOString(),
            isRead: false,
            isAccepted: true, // 🔧 秘密报应消息直接打开聊天窗口
          };

          // 保存到数据库
          try {
            const mapDataId = `mapDatingData_${window.currentAccountId || 'main'}`;
            const mapDatingData = await xDb.xMapDatingData.get(mapDataId);

            if (mapDatingData) {
              if (!mapDatingData.notifications) {
                mapDatingData.notifications = [];
              }
              mapDatingData.notifications.unshift(notification);
              await xDb.xMapDatingData.put(mapDatingData);
              console.log(`✅ [秘密报应] 已添加揭发消息到notifications`);

              // 🔧 更新提醒徽章
              await this.updateNotificationBadge();
              console.log(`✅ [秘密报应] 提醒徽章已更新`);

              // 显示phone notification
              showPhoneNotification({
                title: `New Message from ${finalRevealer.nickname}`,
                message: messages[0].substring(0, 50) + (messages[0].length > 50 ? '...' : ''),
                avatar: window.userProfileData?.avatar,
                leftIcon: 'x',
                duration: 5000,
              });

              console.log(`  |- 秘密类型: ${secretType}`);
              console.log(`  |- 揭发者: ${finalRevealer.nickname} (@${finalRevealer.handle})`);
              console.log(`  |- 揭发程度: ${exposedLevel}`);
              console.log(`  |- 揭发消息数: ${messages.length}条`);

              // 🔧 记录秘密报应历史（限制次数和好友重复）
              if (!lockedChatUser.secretRetributionHistory) {
                lockedChatUser.secretRetributionHistory = [];
              }
              lockedChatUser.secretRetributionHistory.push({
                friendId: finalRevealer.id,
                friendNickname: finalRevealer.nickname,
                friendHandle: finalRevealer.handle,
                secretType: secretType,
                exposedLevel: exposedLevel,
                timestamp: new Date().toISOString(),
                revealerId: finalRevealer.id,
                isFromSocialCircle: !!matchingFriendForRetribution,
              });
              console.log(
                `  |- 已记录秘密报应历史 (${lockedChatUser.secretRetributionHistory.length}/4)`,
              );

              // 🔧 同步更新数据库中的用户数据
              const npcIndex = mapDatingData.data.nearbyUsers.findIndex(u => u.id === lockedChatUserId);
              if (npcIndex !== -1) {
                mapDatingData.data.nearbyUsers[npcIndex].secretRetributionHistory =
                  lockedChatUser.secretRetributionHistory;
                await xDb.xMapDatingData.put(mapDatingData);
                console.log(`  |- 已同步秘密报应历史到数据库`);
              }
            }
          } catch (error) {
            console.error('❌ [秘密报应] 保存notification失败:', error);
          }
        }

        // 👥 处理社交圈好友生成（如果AI生成了）
        if (generatedData.socialCircle && generatedData.socialCircle.generated) {
          console.log(`👥 [社交圈] AI生成了一个社交圈好友`);

          const { friend, relationship } = generatedData.socialCircle;

          // 为好友生成ID和avatar（使用locked用户ID）
          friend.id = `friend_${lockedChatUserId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          friend.avatar = this.getRandomAvatar();
          friend.relationship = relationship; // 保存关系类型

          // 🔧 修复AI错误输出：确保avatarBubble是字符串，不是对象
          if (friend.avatarBubble && typeof friend.avatarBubble === 'object') {
            // AI错误地生成了对象 {backgroundColor: "#FFC0CB", emoji: "💖"}，提取emoji字符串
            const randomEmojis = ['💖', '😊', '✨', '🎮', '📷', '🎨', '💤', '🌸', '🎵', '☕'];
            friend.avatarBubble =
              friend.avatarBubble.emoji || randomEmojis[Math.floor(Math.random() * randomEmojis.length)];
            console.warn(`⚠️ [社交圈] AI错误生成avatarBubble对象，已修正为: ${friend.avatarBubble}`);
          }

          // 🔧 如果avatarBubble缺失或为空字符串，随机生成一个
          if (!friend.avatarBubble || friend.avatarBubble === '') {
            const randomEmojis = ['💖', '😊', '✨', '🎮', '📷', '🎨', '💤', '🌸', '🎵', '☕'];
            friend.avatarBubble = randomEmojis[Math.floor(Math.random() * randomEmojis.length)];
            console.warn(`⚠️ [社交圈] avatarBubble缺失，已生成随机emoji: ${friend.avatarBubble}`);
          }

          // 🔧 确保avatar是URL字符串，不是对象（防止AI不按规矩生成avatar字段）
          if (typeof friend.avatar === 'object') {
            console.warn(`⚠️ [社交圈] friend.avatar是对象，重新生成URL`);
            friend.avatar = this.getRandomAvatar();
          }

          // 🔧 修复AI错误的reviews字段名：将 reviewer -> reviewerName, comment -> content
          if (friend.reviews && Array.isArray(friend.reviews)) {
            friend.reviews = friend.reviews.map(review => {
              const fixedReview = { ...review };

              // 修正字段名
              if (review.reviewer && !review.reviewerName) {
                fixedReview.reviewerName = review.reviewer;
                delete fixedReview.reviewer;
                console.warn(`⚠️ [社交圈] 修正reviews字段名: reviewer -> reviewerName`);
              }
              if (review.comment && !review.content) {
                fixedReview.content = review.comment;
                delete fixedReview.comment;
                console.warn(`⚠️ [社交圈] 修正reviews字段名: comment -> content`);
              }

              // 补充缺失字段的默认值
              if (!fixedReview.likes) fixedReview.likes = Math.floor(Math.random() * 100);
              if (!fixedReview.comments) fixedReview.comments = Math.floor(Math.random() * 20);
              if (!fixedReview.timestamp) {
                // 生成最近1-30天内的随机时间戳
                const daysAgo = Math.floor(Math.random() * 30) + 1;
                const date = new Date();
                date.setDate(date.getDate() - daysAgo);
                fixedReview.timestamp = date.toISOString();
              }
              if (fixedReview.isAnonymous === undefined) {
                fixedReview.isAnonymous = Math.random() < 0.3;
              }

              // 为评价者分配头像（如果缺失）
              if (!fixedReview.reviewerAvatar) {
                const reviewerGender = ['male', 'female', 'unisex'][Math.floor(Math.random() * 3)];
                fixedReview.reviewerAvatar = this.getRandomAvatar(reviewerGender);
              }

              return fixedReview;
            });
          }

          // 保存到当前NPC的socialCircle数组（使用locked用户）
          if (!lockedChatUser.socialCircle) {
            lockedChatUser.socialCircle = [];
          }
          // 🔧 严格检查是否已存在（避免重复）：nickname和handle都不能重复
          const existsByHandle = lockedChatUser.socialCircle.find(f => f.handle === friend.handle);
          const existsByNickname = lockedChatUser.socialCircle.find(f => f.nickname === friend.nickname);
          if (existsByHandle || existsByNickname) {
            // AI不听话生成了重复好友，记录警告并丢弃
            console.error(`❌ [社交圈] AI生成了重复好友，已丢弃：`);
            console.error(`  |- 生成的好友: ${friend.nickname} (@${friend.handle})`);
            if (existsByHandle) {
              console.error(`  |- handle重复: @${friend.handle} 已存在于好友 ${existsByHandle.nickname}`);
            }
            if (existsByNickname) {
              console.error(`  |- nickname重复: ${friend.nickname} 已存在于好友 @${existsByNickname.handle}`);
            }
            console.error(`  |- 请检查AI提示词是否正确传递了现有好友列表`);
          } else if (lockedChatUser.socialCircle.length >= 5) {
            console.error(`❌ [社交圈] 社交圈已满（${lockedChatUser.socialCircle.length}/5），无法添加新好友`);
          } else {
            // 通过所有检查，保存好友
            lockedChatUser.socialCircle.push(friend);

            // 更新数据库中的NPC数据
            try {
              const mapDataId = `mapDatingData_${window.currentAccountId || 'main'}`;
              const mapDatingData = await xDb.xMapDatingData.get(mapDataId);

              // 🔧 修复：正确访问数据格式 mapDatingData.data.nearbyUsers
              if (mapDatingData && mapDatingData.data && mapDatingData.data.nearbyUsers) {
                const npcIndex = mapDatingData.data.nearbyUsers.findIndex(u => u.id === lockedChatUserId);
                if (npcIndex !== -1) {
                  if (!mapDatingData.data.nearbyUsers[npcIndex].socialCircle) {
                    mapDatingData.data.nearbyUsers[npcIndex].socialCircle = [];
                  }
                  mapDatingData.data.nearbyUsers[npcIndex].socialCircle.push(friend);

                  // 🔄 反向同步：将A添加到B的社交圈中
                  console.log(
                    `🔄 [社交圈反向同步] 开始将 ${lockedChatUser.nickname} 添加到 ${friend.nickname} 的社交圈`,
                  );

                  // 检查好友B是否已经在nearbyUsers中
                  let friendIndex = mapDatingData.data.nearbyUsers.findIndex(u => u.handle === friend.handle);

                  if (friendIndex === -1) {
                    // 好友B不在地图上，需要先添加到nearbyUsers
                    console.log(`  |- 好友B不在地图上，先添加到nearbyUsers`);

                    // 为好友B生成位置信息（在A附近随机位置）
                    const aPosition = mapDatingData.data.nearbyUsers[npcIndex].position;

                    // 🔧 检查A的位置是否存在，如果不存在使用默认位置
                    if (!aPosition || typeof aPosition.lat !== 'number' || typeof aPosition.lng !== 'number') {
                      console.warn(
                        `⚠️ [社交圈反向同步] A（${lockedChatUser.nickname}）的位置信息缺失，使用默认位置`,
                      );
                      // 使用默认位置（北京）
                      friend.position = {
                        lat: 39.9042 + (Math.random() - 0.5) * 0.1,
                        lng: 116.4074 + (Math.random() - 0.5) * 0.1,
                      };
                    } else {
                      const randomAngle = Math.random() * Math.PI * 2;
                      const randomDistance = Math.random() * 5 + 2; // 2-7km范围内

                      friend.position = {
                        lat: aPosition.lat + (randomDistance / 111) * Math.cos(randomAngle),
                        lng:
                          aPosition.lng +
                          ((randomDistance / 111) * Math.sin(randomAngle)) /
                            Math.cos((aPosition.lat * Math.PI) / 180),
                      };

                      // 更新距离信息（基于随机位置）
                      friend.distance = randomDistance;
                    }

                    // 初始化好友B的socialCircle
                    if (!friend.socialCircle) {
                      friend.socialCircle = [];
                    }

                    // 将好友B添加到nearbyUsers
                    mapDatingData.data.nearbyUsers.push(friend);
                    friendIndex = mapDatingData.data.nearbyUsers.length - 1;
                    console.log(
                      `  |- 已添加好友B到地图，位置: [${friend.position.lat.toFixed(6)}, ${friend.position.lng.toFixed(
                        6,
                      )}]，距离: ${friend.distance.toFixed(1)}km`,
                    );
                  } else {
                    // 好友B已在地图上
                    console.log(`  |- 好友B已在地图上，索引: ${friendIndex}`);
                    if (!mapDatingData.data.nearbyUsers[friendIndex].socialCircle) {
                      mapDatingData.data.nearbyUsers[friendIndex].socialCircle = [];
                    }
                  }

                  // 检查B的社交圈是否已满
                  const bSocialCircle = mapDatingData.data.nearbyUsers[friendIndex].socialCircle || [];
                  if (bSocialCircle.length < 5) {
                    // 检查A是否已经在B的社交圈中
                    const aExistsInB = bSocialCircle.find(f => f.id === lockedChatUserId);

                    if (!aExistsInB) {
                      // 创建A的副本（作为B的社交圈好友）（使用locked用户）
                      const currentUserForFriend = {
                        id: lockedChatUser.id,
                        nickname: lockedChatUser.nickname,
                        handle: lockedChatUser.handle,
                        avatar: lockedChatUser.avatar,
                        avatarBubble: lockedChatUser.avatarBubble,
                        gender: lockedChatUser.gender,
                        distance: friend.distance, // 使用相同的距离
                        online: lockedChatUser.online,
                        status: lockedChatUser.status,
                        bio: lockedChatUser.bio,
                        publicPersonality: lockedChatUser.publicPersonality,
                        realPersonality: lockedChatUser.realPersonality,
                        appearance: lockedChatUser.appearance,
                        tags: lockedChatUser.tags,
                        followers: lockedChatUser.followers,
                        likes: lockedChatUser.likes,
                        avgRating: lockedChatUser.avgRating,
                        reviews: lockedChatUser.reviews || [],
                        position: lockedChatUser.position,
                        relationship: relationship, // 保持相同的关系类型
                        secret: lockedChatUser.secret, // 如果A有秘密，也包含进去
                      };

                      // 将A添加到B的socialCircle
                      mapDatingData.data.nearbyUsers[friendIndex].socialCircle.push(currentUserForFriend);
                      console.log(`  |- ✅ 已将 ${lockedChatUser.nickname} 添加到 ${friend.nickname} 的社交圈`);
                      console.log(`  |- 关系类型: ${relationship}`);
                      console.log(
                        `  |- ${friend.nickname} 的社交圈人数: ${mapDatingData.data.nearbyUsers[friendIndex].socialCircle.length}/5`,
                      );
                    } else {
                      console.log(`  |- ⚠️ ${lockedChatUser.nickname} 已在 ${friend.nickname} 的社交圈中，跳过添加`);
                    }
                  } else {
                    console.log(`  |- ⚠️ ${friend.nickname} 的社交圈已满（5/5），无法添加 ${lockedChatUser.nickname}`);
                  }

                  await xDb.xMapDatingData.put(mapDatingData);

                  // 🔄 立即同步更新allUsers和currentUsers（确保社交圈好友B可以被查看）
                  this.allUsers = mapDatingData.data.nearbyUsers;
                  this.currentUsers = [...mapDatingData.data.nearbyUsers];
                  console.log(`🔄 [社交圈] 已同步更新allUsers和currentUsers，确保好友B可被查看`);

                  // 🗺️ 刷新地图和用户列表（让好友B显示在地图上）
                  // 注意：不在这里调用renderMap，因为this上下文可能不对
                  // 地图会在下次打开时自动刷新，或者通过事件触发刷新
                  console.log(`🗺️ [社交圈] 已保存到数据库，地图将在下次刷新时显示好友B`);

                  console.log(`✅ [社交圈] 已保存社交圈好友到数据库（包含反向同步）`);
                }
              }
            } catch (error) {
              console.error('❌ [社交圈] 保存社交圈好友失败:', error);
            }

            console.log(`  |- 好友昵称: ${friend.nickname} (@${friend.handle})`);
            console.log(`  |- 关系类型: ${relationship}`);
            console.log(`  |- 当前社交圈人数: ${lockedChatUser.socialCircle.length}/5`);
          }
          // 注意：重复检查和已满检查已经在上面的if-else分支中处理
        }

        // 📝 处理新评价生成（如果AI生成了）
        if (generatedData.newReview && generatedData.newReview.generated) {
          console.log(`📝 [新评价] AI生成了一条新评价`);

          const { review } = generatedData.newReview;

          // 🔧 修复AI错误的字段名：将 reviewer -> reviewerName, comment -> content
          if (review.reviewer && !review.reviewerName) {
            review.reviewerName = review.reviewer;
            delete review.reviewer;
            console.warn(`⚠️ [新评价] 修正字段名: reviewer -> reviewerName`);
          }
          if (review.comment && !review.content) {
            review.content = review.comment;
            delete review.comment;
            console.warn(`⚠️ [新评价] 修正字段名: comment -> content`);
          }

          // 补充缺失字段的默认值
          if (!review.likes) review.likes = Math.floor(Math.random() * 100);
          if (!review.comments) review.comments = Math.floor(Math.random() * 20);
          if (!review.timestamp) {
            review.timestamp = new Date().toISOString(); // 使用当前时间
          }
          if (review.isAnonymous === undefined) {
            review.isAnonymous = Math.random() < 0.3;
          }

          // 为评价者分配头像（如果缺失）
          if (!review.reviewerAvatar) {
            const reviewerGender = ['male', 'female', 'unisex'][Math.floor(Math.random() * 3)];
            review.reviewerAvatar = this.getRandomAvatar(reviewerGender);
          }

          // 🔧 标记为新评价
          review.isNewReview = true;

          // 保存到当前NPC的reviews数组（使用locked用户）
          if (!lockedChatUser.reviews) {
            lockedChatUser.reviews = [];
          }
          lockedChatUser.reviews.push(review);

          // 🔧 重新计算平均评分
          const totalRating = lockedChatUser.reviews.reduce((sum, r) => sum + (r.rating || 0), 0);
          lockedChatUser.avgRating = (totalRating / lockedChatUser.reviews.length).toFixed(1);

          // 更新数据库中的NPC数据
          try {
            const mapDataId = `mapDatingData_${window.currentAccountId || 'main'}`;
            const mapDatingData = await xDb.xMapDatingData.get(mapDataId);

            // 🔧 修复：正确访问数据格式 mapDatingData.data.nearbyUsers
            if (mapDatingData && mapDatingData.data && mapDatingData.data.nearbyUsers) {
              const npcIndex = mapDatingData.data.nearbyUsers.findIndex(u => u.id === lockedChatUserId);
              if (npcIndex !== -1) {
                if (!mapDatingData.data.nearbyUsers[npcIndex].reviews) {
                  mapDatingData.data.nearbyUsers[npcIndex].reviews = [];
                }
                mapDatingData.data.nearbyUsers[npcIndex].reviews.push(review);

                // 更新平均评分
                mapDatingData.data.nearbyUsers[npcIndex].avgRating = lockedChatUser.avgRating;

                await xDb.xMapDatingData.put(mapDatingData);

                // 🔄 立即同步更新allUsers和currentUsers
                this.allUsers = mapDatingData.data.nearbyUsers;
                this.currentUsers = [...mapDatingData.data.nearbyUsers];
                console.log(`🔄 [新评价] 已同步更新allUsers和currentUsers`);

                console.log(`✅ [新评价] 已保存新评价到数据库`);
              }
            }
          } catch (error) {
            console.error('❌ [新评价] 保存新评价失败:', error);
          }

          console.log(`  |- 评价者: ${review.reviewerName}`);
          console.log(`  |- 评分: ${review.rating}`);
          console.log(`  |- 内容: ${review.content.substring(0, 30)}...`);
          console.log(`  |- 当前评价总数: ${lockedChatUser.reviews.length}条 (新评价: ${newReviewsCount + 1}/7)`);
          console.log(`  |- 更新后平均评分: ${lockedChatUser.avgRating}`);
        }

        // 📸 处理新动态生成（如果AI生成了）
        if (generatedData.newMoment && generatedData.newMoment.generated) {
          console.log(`📸 [新动态] AI生成了一条新动态`);

          const { moment } = generatedData.newMoment;

          // 🔧 只随机生成统计数据（点赞、评论、转发数值）
          moment.likes = Math.floor(Math.random() * 2000) + Math.floor(Math.random() * 500);
          moment.comments = Math.floor(Math.random() * 100) + Math.floor(Math.random() * 20);
          moment.shares = Math.floor(Math.random() * 50) + Math.floor(Math.random() * 10);

          // 🔧 使用AI生成的时间（AI已在提示词中生成）
          // moment.time 已由AI生成，格式："2h ago" / "1d ago" 等

          // 🔧 使用当前NPC的用户信息
          moment.userName = lockedChatUser.nickname;
          moment.userAvatar = lockedChatUser.avatar;
          moment.id = Date.now();
          moment.isGenerated = true; // 标记为AI生成的动态

          console.log(`🎨 [新动态生成] 动态发布者信息:`, {
            nickname: lockedChatUser.nickname,
            avatar: lockedChatUser.avatar,
            momentUserName: moment.userName,
            momentUserAvatar: moment.userAvatar
          });

          // 🔧 为AI生成的评论列表中的每条评论分配随机头像
          // commentsList 已由AI生成（包含commenterId, commenterName, commentText, commentTime）
          // 只需为每条评论添加随机头像
          if (moment.commentsList && Array.isArray(moment.commentsList)) {
            moment.commentsList.forEach(comment => {
              // 为评论者分配随机头像（从头像库随机选择）
              const randomGender = ['male', 'female', 'unisex'][Math.floor(Math.random() * 3)];
              comment.avatar = this.getRandomAvatar(randomGender);

              // 将commenterId/commenterName映射为前端所需的user字段
              if (!comment.user && comment.commenterName) {
                comment.user = comment.commenterName;
              }
              // 将commentText映射为前端所需的text字段
              if (!comment.text && comment.commentText) {
                comment.text = comment.commentText;
              }
              // commentTime保持不变（AI已生成）
            });
          }

          // 🔧 保存到当前NPC的moments数组
          if (!lockedChatUser.moments) {
            lockedChatUser.moments = [];
          }
          lockedChatUser.moments.push(moment);

          // 🔧 更新分段触发计数
          if (currentSegment > 0) {
            lockedChatUser.momentsGenerationHistory[currentSegment]++;
          }

          // 🔧 更新数据库中的NPC数据
          try {
            const mapDataId = `mapDatingData_${window.currentAccountId || 'main'}`;
            const mapDatingData = await xDb.xMapDatingData.get(mapDataId);

            if (mapDatingData && mapDatingData.data && mapDatingData.data.nearbyUsers) {
              const npcIndex = mapDatingData.data.nearbyUsers.findIndex(u => u.id === lockedChatUserId);
              if (npcIndex !== -1) {
                // 初始化moments数组
                if (!mapDatingData.data.nearbyUsers[npcIndex].moments) {
                  mapDatingData.data.nearbyUsers[npcIndex].moments = [];
                }
                // 添加新动态
                mapDatingData.data.nearbyUsers[npcIndex].moments.push(moment);

                // 更新分段触发计数
                if (!mapDatingData.data.nearbyUsers[npcIndex].momentsGenerationHistory) {
                  mapDatingData.data.nearbyUsers[npcIndex].momentsGenerationHistory = {
                    20: 0,
                    40: 0,
                    60: 0,
                    80: 0,
                    100: 0
                  };
                }
                if (currentSegment > 0) {
                  mapDatingData.data.nearbyUsers[npcIndex].momentsGenerationHistory[currentSegment]++;
                }

                // 保存到数据库
                await xDb.xMapDatingData.put(mapDatingData);

                // 🔄 立即同步更新allUsers和currentUsers
                this.allUsers = mapDatingData.data.nearbyUsers;
                this.currentUsers = [...mapDatingData.data.nearbyUsers];
                console.log(`🔄 [新动态] 已同步更新allUsers和currentUsers`);

                console.log(`✅ [新动态] 已保存新动态到数据库`);
              }
            }
          } catch (error) {
            console.error('❌ [新动态] 保存新动态失败:', error);
          }

          // 📊 输出新动态信息
          const generatedMomentsCountAfter = lockedChatUser.moments.filter(m => m.isGenerated).length;
          console.log(`  |- 动态用户: ${moment.userName}`);
          console.log(`  |- 动态内容: ${moment.text.substring(0, 30)}...`);
          console.log(`  |- 配图描述: ${moment.imageDescription || '无'}`);
          console.log(`  |- 心情标签: ${moment.mood || '无'}`);
          console.log(`  |- 点赞: ${moment.likes}, 评论: ${moment.comments}, 转发: ${moment.shares}`);
          console.log(`  |- 发布时间: ${moment.time}`);
          console.log(
            `  |- 当前动态总数: ${lockedChatUser.moments.length}条 (AI生成: ${generatedMomentsCountAfter}/10)`,
          );
          console.log(
            `  |- 分段${currentSegment}触发计数: ${lockedChatUser.momentsGenerationHistory[currentSegment]}/2`,
          );

          // 📢 在聊天窗口显示系统提示：对方发布了新动态
          this.addSystemMessage(`📸 ${lockedChatUser.nickname} posted a new moment. Check their profile to view it!`);
        }

        console.log(`✅ [第十六个情景] AI生成对话完成，共${generatedData.messages.length}条消息`);
        console.log(`  |- 对话对象: ${lockedChatUser.nickname} (@${lockedChatUser.handle})`);
        console.log(`  |- 消息类型分布: ${generatedData.messages.map(m => m.type).join(', ')}`);
        console.log(
          `  |- 💖 AI决策的好感度变化: ${generatedData.affectionChange > 0 ? '+' : ''}${generatedData.affectionChange}`,
        );
        console.log(`  |- 📝 AI记录的笔记数量: ${generatedData.notes.length}条`);
        console.log(`  |- 💭 AI记录的用户笔记数量: ${generatedData.userNotes.length}条`);
        if (hasReports) {
          console.log(`  |- 🚨 处理举报数量: ${generatedData.reports?.length || 0}个`);
        }

        return generatedData;
      } catch (error) {
        console.error('❌ [第十六个情景] 附近私信对话生成失败:', error);
        return null;
      }
    },
    // ▲▲▲ 【第十六个情景】附近私信弹窗AI对话生成器 ▲▲▲

    // 保存聊天记录到数据库
    async saveChatToDatabase(targetUserId = null) {
      try {
        // 🔧 修复：支持传入userId，解决切换窗口后消息丢失问题
        // 优先使用传入的targetUserId，如果没有则使用currentChatUser
        let userId, userName, userHandle;

        if (targetUserId) {
          // 使用传入的userId，从allUsers或currentUsers中查找用户信息
          const targetUser =
            this.allUsers.find(u => u.id === targetUserId) || this.currentUsers.find(u => u.id === targetUserId);

          if (!targetUser) {
            console.warn(`⚠️ [聊天记录保存] 未找到用户 ${targetUserId}，跳过保存`);
            return;
          }

          userId = targetUser.id;
          userName = targetUser.nickname;
          userHandle = targetUser.handle;
          console.log(`💾 [聊天记录保存] 使用传入的userId保存: ${userName} (${userId})`);
        } else if (this.currentChatUser) {
          // 向后兼容：没有传入userId时使用currentChatUser
          userId = this.currentChatUser.id;
          userName = this.currentChatUser.nickname;
          userHandle = this.currentChatUser.handle;
        } else {
          console.warn('⚠️ [聊天记录保存] 没有当前聊天对象且未传入userId，跳过保存');
          return;
        }

        const xDb = getXDB();
        if (!xDb) {
          console.error('❌ [聊天记录保存] 无法获取数据库');
          return;
        }

        const chatId = `mapChat_${userId}_${currentAccountId || 'main'}`;
        const chatRecord = {
          id: chatId,
          accountId: currentAccountId || 'main',
          userId: userId,
          userName: userName,
          userHandle: userHandle,
          messages: this.chatMessages[userId] || [],
          affectionData: this.chatAffectionData[userId] || null, // 💖 保存好感度数据
          notes: this.chatNotes[userId] || {}, // 📝 保存AI笔记数据（NPC的人设）
          userMarkedNotes: this.userMarkedNotes[userId] || [], // 📌 保存用户标记的笔记
          npcNotesAboutUser: this.npcNotesAboutUser[userId] || [], // 💭 保存NPC对用户的观察笔记
          lastUpdated: new Date().toISOString(),
        };

        await xDb.xMapChats.put(chatRecord);
        console.log(`✅ [聊天记录保存] 已保存与 ${userName} 的聊天记录`);
        console.log(`  |- 聊天ID: ${chatId}`);
        console.log(`  |- 消息数量: ${chatRecord.messages.length}`);

        // 💖 显示好感度信息
        if (this.chatAffectionData[userId]) {
          const affection = this.chatAffectionData[userId];
          console.log(
            `  |- 好感度: ${affection.affection.toFixed(1)}/100 (阈值: ${
              affection.threshold
            }, 增长率: ${affection.growthRate.toFixed(2)}x)`,
          );
        }

        // 📝 显示AI笔记信息
        // 🔧 修复：使用userId而不是this.currentChatUser.id，避免切换窗口后报错
        if (this.chatNotes[userId]) {
          const notes = this.chatNotes[userId];
          const notesCount = Object.keys(notes).length;
          if (notesCount > 0) {
            console.log(`  |- 📝 AI笔记数量: ${notesCount}条 (${Object.keys(notes).join('、')})`);
          }
        }

        // 📌 显示用户标记笔记信息
        if (this.userMarkedNotes[userId]) {
          const userNotes = this.userMarkedNotes[userId];
          if (userNotes.length > 0) {
            console.log(`  |- 📌 用户标记笔记数量: ${userNotes.length}条`);
          }
        }

        // 💭 显示NPC对用户的观察笔记信息
        if (this.npcNotesAboutUser[userId]) {
          const npcUserNotes = this.npcNotesAboutUser[userId];
          if (npcUserNotes.length > 0) {
            console.log(`  |- 💭 NPC观察笔记数量: ${npcUserNotes.length}条`);
          }
        }
      } catch (error) {
        console.error('❌ [聊天记录保存] 保存失败:', error);
      }
    },

    // 生成模拟聊天消息（首次打开时）
    generateMockMessages(user) {
      const now = new Date();
      const mockMessages = [
        {
          type: 'received',
          text: `Heya himanshi`,
          timestamp: new Date(now - 5 * 60 * 60 * 1000).toISOString(), // 5小时前
        },
        {
          type: 'received',
          text: `Couldn't stop myself from texting coz you're just so pretty`,
          timestamp: new Date(now - 5 * 60 * 60 * 1000 + 10000).toISOString(),
        },
        {
          type: 'sent',
          text: `Thankyouu so much!!`,
          timestamp: new Date(now - 2 * 60 * 60 * 1000).toISOString(), // 2小时前
        },
        {
          type: 'received',
          text: `You're wlcm bbg`,
          timestamp: new Date(now - 48 * 60 * 1000).toISOString(), // 48分钟前
        },
        {
          type: 'received',
          text: `Idk why I ain't getting notifications`,
          timestamp: new Date(now - 48 * 60 * 1000 + 10000).toISOString(),
        },
        {
          type: 'received',
          text: `How old are uh?`,
          timestamp: new Date(now - 48 * 60 * 1000 + 20000).toISOString(),
        },
        {
          type: 'received',
          text: `Should I guess?`,
          timestamp: new Date(now - 30 * 60 * 1000).toISOString(), // 30分钟前
        },
        {
          type: 'sent',
          text: `U should guess`,
          timestamp: new Date(now - 5 * 60 * 1000).toISOString(), // 5分钟前
        },
        {
          type: 'sent',
          text: `I think`,
          timestamp: new Date(now - 5 * 60 * 1000 + 5000).toISOString(),
        },
      ];

      return mockMessages;
    },

    // 格式化聊天时间
    formatChatTime(date) {
      const now = new Date();
      const diff = now - date;

      // 今天
      if (diff < 24 * 60 * 60 * 1000) {
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const ampm = hours >= 12 ? 'pm' : 'am';
        const displayHours = hours % 12 || 12;
        return `Today, ${displayHours}:${minutes.toString().padStart(2, '0')} ${ampm}`;
      }

      // 昨天
      if (diff < 48 * 60 * 60 * 1000) {
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const ampm = hours >= 12 ? 'pm' : 'am';
        const displayHours = hours % 12 || 12;
        return `Yesterday, ${displayHours}:${minutes.toString().padStart(2, '0')} ${ampm}`;
      }

      // 其他日期
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const month = months[date.getMonth()];
      const day = date.getDate();
      const hours = date.getHours();
      const minutes = date.getMinutes();
      const ampm = hours >= 12 ? 'pm' : 'am';
      const displayHours = hours % 12 || 12;
      return `${month} ${day}, ${displayHours}:${minutes.toString().padStart(2, '0')} ${ampm}`;
    },

    // 刷新附近的人
    async refreshNearbyUsers() {
      try {
        // 获取刷新按钮元素
        const refreshBtn = document.getElementById('mapRefreshBtn');
        if (!refreshBtn) return;

        // 检查是否正在刷新中
        if (refreshBtn.classList.contains('refreshing')) {
          console.log('⚠️ 正在刷新中，请勿重复点击');
          return;
        }

        // 添加刷新动画
        refreshBtn.classList.add('refreshing');
        console.log('🔄 [刷新开始] 开始刷新附近的人...');

        // 调用 AI 生成新的用户数据（只生成用户，不生成地图和地标）
        console.log('🤖 [AI调用] 正在调用AI生成新用户数据，请耐心等待...');
        const newData = await this.generateMapDatingData(true);
        console.log('🤖 [AI返回] AI调用完成，返回数据:', newData ? '成功' : '失败');

        if (newData && newData.nearbyUsers) {
          console.log(`📊 [数据处理] 开始处理 ${newData.nearbyUsers.length} 个用户数据...`);

          // 更新当前用户列表
          this.allUsers = newData.nearbyUsers;
          this.currentUsers = [...this.allUsers];
          console.log('✅ [数据更新] 用户列表已更新');

          // 关闭当前打开的用户详情卡（如果有）
          this.closeDetailCard();

          // 重新渲染用户列表和地图标记
          try {
            console.log('🎨 [UI渲染] 开始渲染用户列表...');
            this.renderUserList();
            console.log('✅ [UI渲染] 用户列表渲染完成');
          } catch (renderError) {
            console.error('❌ [UI渲染] 渲染用户列表失败:', renderError);
          }

          try {
            console.log('🗺️ [地图渲染] 开始渲染地图标记...');
            this.renderMapMarkers();
            console.log('✅ [地图渲染] 地图标记渲染完成');
          } catch (renderError) {
            console.error('❌ [地图渲染] 渲染地图标记失败:', renderError);
          }

          // 🔔 更新提醒徽章（刷新后可能有新的提醒）
          try {
            console.log('🔔 [提醒徽章] 开始更新提醒徽章...');
            await this.updateNotificationBadge();
            console.log('✅ [提醒徽章] 提醒徽章更新完成');
          } catch (badgeError) {
            console.error('❌ [提醒徽章] 更新提醒徽章失败:', badgeError);
          }

          console.log(`✅✅✅ [刷新完成] 已成功更新 ${newData.nearbyUsers.length} 个附近的人`);
          console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
        } else {
          console.error('❌ [刷新失败] 未获取到新的用户数据，newData:', newData);
          alert('刷新失败，请重试');
        }
      } catch (error) {
        console.error('❌❌❌ [致命错误] 刷新附近的人失败:', error);
        console.error('错误堆栈:', error.stack);
        alert('刷新失败，请重试');
      } finally {
        // 移除刷新动画
        console.log('🔧 [清理] 移除刷新动画...');
        const refreshBtn = document.getElementById('mapRefreshBtn');
        if (refreshBtn) {
          refreshBtn.classList.remove('refreshing');
          console.log('✅ [清理] 刷新动画已移除');
        }
      }
    },

    // ==================== 地图设置功能 ====================

    // 打开地图设置弹窗
    openMapSettings() {
      // 只有查看自己资料时才能打开设置
      if (!this.isShowingUserProfile) {
        return;
      }

      if (!this.userMapProfile) {
        console.warn('⚠️ 用户资料未初始化');
        return;
      }

      const modal = document.getElementById('mapSettingsModal');
      if (!modal) return;

      // 加载当前设置到表单
      this.loadMapSettingsToForm();

      // 显示弹窗
      modal.style.display = 'flex';
    },

    // 关闭地图设置弹窗
    closeMapSettings() {
      const modal = document.getElementById('mapSettingsModal');
      if (modal) {
        modal.style.display = 'none';
      }
    },

    // 加载设置到表单
    loadMapSettingsToForm() {
      const profile = this.userMapProfile;

      // 基本资料字段
      const nicknameInput = document.getElementById('mapSettingsNickname');
      const handleInput = document.getElementById('mapSettingsHandle');
      const followersInput = document.getElementById('mapSettingsFollowers');
      const likesInput = document.getElementById('mapSettingsLikes');

      if (nicknameInput) nicknameInput.value = profile.nickname || '';
      if (handleInput) handleInput.value = profile.handle || '';
      if (followersInput) followersInput.value = profile.followers || 1000;
      if (likesInput) likesInput.value = profile.likes || 15000;

      // 头像气泡设置
      const avatarBubbleEnabled = document.getElementById('mapSettingsAvatarBubbleEnabled');
      const avatarBubbleText = document.getElementById('mapSettingsAvatarBubbleText');
      const avatarBubbleTextSection = document.getElementById('mapSettingsAvatarBubbleTextSection');

      if (avatarBubbleEnabled && avatarBubbleText) {
        // 判断是否启用（有内容且不为空）
        const isEnabled = profile.avatarBubble && profile.avatarBubble.trim() !== '';
        avatarBubbleEnabled.checked = isEnabled;
        avatarBubbleText.value = profile.avatarBubble || '';

        // 根据启用状态显示/隐藏文本输入
        if (avatarBubbleTextSection) {
          avatarBubbleTextSection.style.display = isEnabled ? 'flex' : 'none';
        }

        // 监听开关变化
        avatarBubbleEnabled.onchange = () => {
          if (avatarBubbleTextSection) {
            avatarBubbleTextSection.style.display = avatarBubbleEnabled.checked ? 'flex' : 'none';
          }
        };
      }

      // 状态气泡设置
      const statusEnabled = document.getElementById('mapSettingsStatusEnabled');
      const statusText = document.getElementById('mapSettingsStatusText');
      const statusTextSection = document.getElementById('mapSettingsStatusTextSection');

      if (statusEnabled && statusText) {
        // 判断是否启用（有内容且不为空）
        const isEnabled = profile.status && profile.status.trim() !== '';
        statusEnabled.checked = isEnabled;
        statusText.value = profile.status || '';

        // 根据启用状态显示/隐藏文本输入
        if (statusTextSection) {
          statusTextSection.style.display = isEnabled ? 'flex' : 'none';
        }

        // 监听开关变化
        statusEnabled.onchange = () => {
          if (statusTextSection) {
            statusTextSection.style.display = statusEnabled.checked ? 'flex' : 'none';
          }
        };
      }

      // 标签设置
      this.renderSettingsTags();
    },

    // 渲染设置弹窗中的标签
    renderSettingsTags() {
      const tagsContainer = document.getElementById('mapSettingsTagsContainer');
      if (!tagsContainer || !this.userMapProfile) return;

      const tags = this.userMapProfile.tags || [];

      tagsContainer.innerHTML = tags
        .map(
          (tag, index) => `
        <div class="map-settings-tag" data-tag-index="${index}">
          ${tag}
          <div class="map-settings-tag-remove" onclick="MapDatingController.removeTag(${index})">
            <svg viewBox="0 0 24 24">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </div>
        </div>
      `,
        )
        .join('');
    },

    // 添加新标签
    addNewTag() {
      if (!this.userMapProfile) return;

      const newTag = prompt('请输入新标签内容:');
      if (!newTag || newTag.trim() === '') return;

      // 检查标签数量限制（最多6个）
      if (this.userMapProfile.tags.length >= 6) {
        alert('标签数量已达上限（最多6个）');
        return;
      }

      // 检查是否已存在
      if (this.userMapProfile.tags.includes(newTag.trim())) {
        alert('该标签已存在');
        return;
      }

      // 添加标签
      this.userMapProfile.tags.push(newTag.trim());

      // 重新渲染
      this.renderSettingsTags();
    },

    // 删除标签
    removeTag(index) {
      if (!this.userMapProfile) return;

      if (confirm('确定要删除这个标签吗？')) {
        this.userMapProfile.tags.splice(index, 1);
        this.renderSettingsTags();
      }
    },

    // 保存地图设置
    async saveMapSettings() {
      if (!this.userMapProfile) return;

      // 获取表单数据 - 基本资料
      const nicknameInput = document.getElementById('mapSettingsNickname');
      const handleInput = document.getElementById('mapSettingsHandle');
      const followersInput = document.getElementById('mapSettingsFollowers');
      const likesInput = document.getElementById('mapSettingsLikes');

      // 验证并更新基本资料
      if (nicknameInput) {
        const nickname = nicknameInput.value.trim();
        if (nickname) {
          this.userMapProfile.nickname = nickname;
        } else {
          alert('昵称不能为空！');
          return;
        }
      }

      if (handleInput) {
        const handle = handleInput.value.trim();
        // 验证句柄格式：纯英文小写+数字+下划线
        const handleRegex = /^[a-z0-9_]{1,15}$/;
        if (handle && handleRegex.test(handle)) {
          this.userMapProfile.handle = handle;
        } else if (handle) {
          alert('句柄格式不正确！必须是纯英文小写+数字+下划线，1-15个字符');
          return;
        }
      }

      if (followersInput) {
        const followers = parseInt(followersInput.value);
        if (followers >= 100 && followers <= 50000) {
          this.userMapProfile.followers = followers;
        } else {
          alert('粉丝数必须在100-50000之间！');
          return;
        }
      }

      if (likesInput) {
        const likes = parseInt(likesInput.value);
        if (likes >= 1000 && likes <= 2500000) {
          this.userMapProfile.likes = likes;
        } else {
          alert('获赞数必须在1000-2500000之间！');
          return;
        }
      }

      // 获取表单数据 - 其他设置
      const avatarBubbleEnabled = document.getElementById('mapSettingsAvatarBubbleEnabled');
      const avatarBubbleText = document.getElementById('mapSettingsAvatarBubbleText');
      const statusEnabled = document.getElementById('mapSettingsStatusEnabled');
      const statusText = document.getElementById('mapSettingsStatusText');

      // 更新头像气泡
      if (avatarBubbleEnabled && avatarBubbleText) {
        this.userMapProfile.avatarBubble = avatarBubbleEnabled.checked ? avatarBubbleText.value.trim() : '';
      }

      // 更新状态气泡
      if (statusEnabled && statusText) {
        this.userMapProfile.status = statusEnabled.checked ? statusText.value.trim() : '';
      }

      // 保存到数据库
      await this.saveUserMapProfile();

      // 刷新显示
      this.renderCurrentUserMarker();

      // 如果当前打开的是用户自己的资料卡，更新显示
      if (document.getElementById('mapUserDetailCard').style.display !== 'none') {
        const profile = this.userMapProfile;

        // 更新基本资料显示
        const mapCardNickname = document.getElementById('mapCardNickname');
        const mapCardHandle = document.getElementById('mapCardHandle');
        const mapCardFollowersCount = document.getElementById('mapCardFollowersCount');
        const mapCardLikesCount = document.getElementById('mapCardLikesCount');

        if (mapCardNickname) mapCardNickname.textContent = profile.nickname || '未命名用户';
        if (mapCardHandle) mapCardHandle.textContent = `@${profile.handle || 'unknown'}`;
        if (mapCardFollowersCount) mapCardFollowersCount.textContent = this.formatNumber(profile.followers || 0);
        if (mapCardLikesCount) mapCardLikesCount.textContent = this.formatNumber(profile.likes || 0);

        // 更新头像气泡
        const mapCardAvatarBubble = document.getElementById('mapCardAvatarBubble');
        if (mapCardAvatarBubble) {
          mapCardAvatarBubble.textContent = profile.avatarBubble || '';
          mapCardAvatarBubble.style.display = profile.avatarBubble ? 'flex' : 'none';
        }

        // 更新标签显示
        this.refreshTagsDisplay();
      }

      // 关闭设置弹窗
      this.closeMapSettings();

      console.log('✅ [地图设置] 设置已保存');
    },

    // 关闭地图页面
    closeMapPage() {
      closeMapPage();
    },
  };

  // ==========================================
  // 第五部分：对外接口
  // ==========================================

  // 打开地图约会页面
  function openMapPage() {
    // 🔒 地图约会功能权限验证：需要社交密钥
    if (typeof window.xSocialAuth !== 'undefined' && !window.xSocialAuth.hasAccess()) {
      console.log(`🔒 访问地图约会功能需要社交功能权限`);
      window.xSocialAuth.requestAccess();
      return; // 阻止打开地图
    }
    // 注入样式
    injectMapStyles();

    // 获取容器，如果有通用容器就用，否则创建一个
    let container = document.getElementById('x-map-container');
    if (!container) {
      container = document.createElement('div');
      container.id = 'x-map-container';
      container.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 9999;
        background: #000;
      `;
      document.body.appendChild(container);
    }

    // 生成并插入HTML
    container.innerHTML = generateMapHTML();
    container.style.display = 'block';

    // 初始化控制器
    MapDatingController.init();
  }

  // 关闭地图约会页面
  function closeMapPage() {
    const container = document.getElementById('x-map-container');
    if (container) {
      container.style.display = 'none';
      container.innerHTML = '';
    }
  }

  // 重新生成地图约会数据（第十五个情景）
  async function regenerateMapDatingData() {
    try {
      console.log('🔄 [第十五个情景] 开始重新生成地图约会数据...');

      // 合并后所有模块都在同一个IIFE作用域内，直接访问 getXDB 和 currentAccountId
      const xDb = getXDB();
      if (!xDb) {
        console.error('❌ 无法获取数据库');
        return;
      }

      // 删除旧数据（使用正确的ID格式 - 不带x前缀）
      const dataId = `mapDatingData_${currentAccountId || 'main'}`;
      await xDb.xMapDatingData.delete(dataId);
      console.log('✅ [第十五个情景] 已删除旧数据');

      // 重置MapGenerator的landmarks
      if (window.MapGenerator) {
        window.MapGenerator.landmarks = [];
      }

      // 调用AI重新生成
      const newData = await MapDatingController.generateMapDatingData();

      if (newData) {
        console.log('✅ [第十五个情景] 重新生成完成，正在刷新页面...');

        // 关闭并重新打开地图页面以应用新数据
        closeMapPage();
        setTimeout(() => {
          openMapPage();
        }, 100);
      } else {
        console.error('❌ [第十五个情景] 重新生成失败');
      }
    } catch (error) {
      console.error('❌ [第十五个情景] 重新生成出错:', error);
    }
  }

  // 打开用户地图资料卡
  function openUserMapProfile() {
    MapDatingController.showUserProfileCard();
  }

  // 暴露到全局
  window.openMapPage = openMapPage;
  window.closeMapPage = closeMapPage;
  window.regenerateMapDatingData = regenerateMapDatingData; // 第十五个情景：重新生成数据
  window.openUserMapProfile = openUserMapProfile; // 打开用户地图资料
  window.MapDatingController = MapDatingController;
  window.MapGenerator = MapGenerator;

  // 第一部分：道具系统CSS样式注入
  // ============================================
  function injectToolStyles() {
    const styleId = 'x-tool-styles';

    // 删除旧的style标签（如果存在）
    const existingStyle = document.getElementById(styleId);
    if (existingStyle) {
      existingStyle.remove();
      console.log('🔄 已删除旧的CSS样式，重新注入');
    }

    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
/* ========== 道具系统主题变量 ========== */
#x-tool-modal {
  --tool-bg-primary: #1a1a1a;
  --tool-bg-secondary: #000;
  --tool-text-primary: #fff;
  --tool-text-secondary: rgba(255, 255, 255, 0.6);
  --tool-border-primary: rgba(255, 255, 255, 0.15);
  --tool-border-secondary: rgba(255, 255, 255, 0.08);
  --tool-card-bg: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.03) 100%);
  --tool-card-border: rgba(255, 255, 255, 0.12);
  --tool-shadow: rgba(0, 0, 0, 0.6);
  --tool-grid-line: rgba(255, 255, 255, 0.02);
}

/* 日间模式 */
#x-social-screen.x-theme-light #x-tool-modal {
  --tool-bg-primary: #e5e5e5;
  --tool-bg-secondary: #fff;
  --tool-text-primary: #333;
  --tool-text-secondary: rgba(0, 0, 0, 0.5);
  --tool-border-primary: rgba(0, 0, 0, 0.12);
  --tool-border-secondary: rgba(0, 0, 0, 0.08);
  --tool-card-bg: linear-gradient(135deg, rgba(0, 0, 0, 0.05) 0%, rgba(0, 0, 0, 0.02) 100%);
  --tool-card-border: rgba(0, 0, 0, 0.1);
  --tool-shadow: rgba(0, 0, 0, 0.2);
  --tool-grid-line: rgba(0, 0, 0, 0.03);
}

/* 道具弹窗遮罩 */
#x-tool-modal {
  display: none;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.85);
  z-index: 10000;
  backdrop-filter: blur(20px);
  align-items: center;
  justify-content: center;
  padding: 0;
  overflow: hidden;
}

#x-social-screen.x-theme-light #x-tool-modal {
  background: rgba(255, 255, 255, 0.85);
}

/* 背景网格纹理 */
#x-tool-modal::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image:
    linear-gradient(var(--tool-grid-line) 1px, transparent 1px),
    linear-gradient(90deg, var(--tool-grid-line) 1px, transparent 1px);
  background-size: 20px 20px;
  pointer-events: none;
}

/* ========== 开机画面 ========== */
.tool-boot-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--tool-bg-secondary);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10001;
  /* 🔧 移除自动淡出动画，改为JavaScript手动控制 */
}

@keyframes toolBootFadeOut {
  to {
    opacity: 0;
    visibility: hidden;
  }
}

.tool-boot-shell {
  width: 90%;
  max-width: 380px;
  background: rgba(0, 0, 0, 0.95);
  border: 3px solid var(--tool-border-primary);
  padding: 24px;
  position: relative;
  clip-path: polygon(
    16px 0,
    calc(100% - 8px) 0,
    100% 8px,
    100% calc(100% - 60px),
    calc(100% - 30px) calc(100% - 30px),
    calc(100% - 60px) 100%,
    0 100%,
    0 16px
  );
  box-shadow: 0 20px 60px var(--tool-shadow);
}

#x-social-screen.x-theme-light .tool-boot-shell {
  background: rgba(255, 255, 255, 0.95);
}

.tool-boot-logo {
  font-size: 32px;
  font-weight: 700;
  color: var(--tool-text-primary);
  letter-spacing: 8px;
  margin-bottom: 32px;
  animation: logoGlow 2s ease-in-out infinite;
  text-transform: uppercase;
  text-align: center;
}

@keyframes logoGlow {
  0%, 100% {
    opacity: 1;
    text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
  }
  50% {
    opacity: 0.7;
    text-shadow: 0 0 20px rgba(255, 255, 255, 0.6);
  }
}

.tool-boot-icon {
  font-size: 48px;
  margin-bottom: 24px;
  animation: iconPulse 1.5s ease-in-out infinite;
  text-align: center;
}

@keyframes iconPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

.tool-boot-info {
  font-size: 10px;
  color: var(--tool-text-secondary);
  margin-bottom: 24px;
  line-height: 1.6;
}

.tool-boot-info-item {
  display: flex;
  justify-content: space-between;
  padding: 4px 0;
  border-bottom: 1px solid var(--tool-border-secondary);
  margin-bottom: 4px;
}

.tool-boot-progress {
  margin-top: 32px;
  position: relative;
}

.tool-boot-progress-label {
  font-size: 9px;
  color: var(--tool-text-secondary);
  margin-bottom: 8px;
  letter-spacing: 2px;
  text-transform: uppercase;
}

.tool-boot-progress-bar {
  width: 100%;
  height: 12px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--tool-border-primary);
  position: relative;
  overflow: hidden;
  clip-path: polygon(6px 0, calc(100% - 6px) 0, 100% 6px, 100% 100%, 0 100%, 0 6px);
}

#x-social-screen.x-theme-light .tool-boot-progress-bar {
  background: rgba(0, 0, 0, 0.1);
}

.tool-boot-progress-fill {
  height: 100%;
  background: linear-gradient(90deg,
    rgba(255, 255, 255, 0.3) 0%,
    rgba(255, 255, 255, 0.5) 50%,
    rgba(255, 255, 255, 0.3) 100%);
  width: 0%;
  /* 🔧 移除CSS自动动画，改为JavaScript控制width */
  position: relative;
  transition: width 0.3s ease-out; /* 平滑过渡 */
}

#x-social-screen.x-theme-light .tool-boot-progress-fill {
  background: linear-gradient(90deg,
    rgba(0, 0, 0, 0.2) 0%,
    rgba(0, 0, 0, 0.3) 50%,
    rgba(0, 0, 0, 0.2) 100%);
}

/* 🔧 移除CSS自动进度条动画，改为JavaScript手动控制 */
/* @keyframes progressLoad 已禁用，进度条由JavaScript控制 */

.tool-boot-progress-fill::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: repeating-linear-gradient(
    90deg,
    transparent,
    transparent 4px,
    rgba(255, 255, 255, 0.1) 4px,
    rgba(255, 255, 255, 0.1) 8px
  );
}

.tool-boot-progress-percent {
  position: absolute;
  top: 50%;
  right: 8px;
  transform: translateY(-50%);
  font-size: 8px;
  font-weight: 700;
  color: var(--tool-text-primary);
  /* 🔧 移除百分比动画，改为JavaScript控制 */
}

/* 🔧 移除百分比淡入动画 */

.tool-boot-scanline {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 2px;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
  animation: scanMove 2s linear infinite;
}

#x-social-screen.x-theme-light .tool-boot-scanline {
  background: linear-gradient(90deg, transparent, rgba(0, 0, 0, 0.2), transparent);
}

@keyframes scanMove {
  from { transform: translateY(0); }
  to { transform: translateY(300px); }
}

/* ========== PSP掌机外壳 ========== */
.psp-shell {
  width: 100%;
  max-width: 380px;
  background: rgba(0, 0, 0, 0.85);
  border: 3px solid var(--tool-border-primary);
  padding: 12px;
  position: relative;
  backdrop-filter: blur(20px);
  box-shadow:
    0 25px 80px var(--tool-shadow),
    inset 0 1px 0 rgba(255, 255, 255, 0.1),
    inset 0 -1px 0 rgba(0, 0, 0, 0.5);
  clip-path: polygon(
    16px 0,
    calc(100% - 8px) 0,
    100% 8px,
    100% calc(100% - 60px),
    calc(100% - 30px) calc(100% - 30px),
    calc(100% - 60px) 100%,
    0 100%,
    0 16px
  );
  opacity: 1; /* 🔧 移除自动淡入动画，改为直接显示 */
}

/* 🔧 移除CSS自动淡入动画，PSP shell由JavaScript手动控制 */

#x-social-screen.x-theme-light .psp-shell {
  background: rgba(255, 255, 255, 0.85);
  box-shadow:
    0 25px 80px rgba(0, 0, 0, 0.2),
    inset 0 1px 0 rgba(255, 255, 255, 0.8),
    inset 0 -1px 0 rgba(0, 0, 0, 0.1);
}

.psp-shell::before,
.psp-shell::after {
  content: '';
  position: absolute;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1));
  border: 1px solid var(--tool-border-primary);
  box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.3);
}

#x-social-screen.x-theme-light .psp-shell::before,
#x-social-screen.x-theme-light .psp-shell::after {
  background: radial-gradient(circle at 30% 30%, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.08));
}

.psp-shell::before {
  top: 20px;
  left: 8px;
}

.psp-shell::after {
  top: 20px;
  right: 8px;
}

.psp-top {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  margin-bottom: 10px;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.06) 0%, rgba(255, 255, 255, 0.02) 100%);
  border: 1px solid var(--tool-border-secondary);
  clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
  position: relative;
}

#x-social-screen.x-theme-light .psp-top {
  background: linear-gradient(135deg, rgba(0, 0, 0, 0.04) 0%, rgba(0, 0, 0, 0.01) 100%);
}

.psp-top::before {
  content: '';
  position: absolute;
  bottom: 0;
  left: 20%;
  right: 20%;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
}

#x-social-screen.x-theme-light .psp-top::before {
  background: linear-gradient(90deg, transparent, rgba(0, 0, 0, 0.15), transparent);
}

.psp-logo {
  font-size: 10px;
  font-weight: 700;
  color: var(--tool-text-primary);
  letter-spacing: 2px;
  display: flex;
  align-items: center;
  gap: 4px;
}

.psp-leds {
  display: flex;
  gap: 6px;
  align-items: center;
}

.led {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.3);
  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.3);
  animation: blink 2s infinite;
}

#x-social-screen.x-theme-light .led {
  background: rgba(0, 0, 0, 0.15);
  border-color: rgba(0, 0, 0, 0.2);
}

.led:nth-child(1) { animation-delay: 0s; }
.led:nth-child(2) { animation-delay: 0.5s; }
.led:nth-child(3) { animation-delay: 1s; }

@keyframes blink {
  0%, 100% { opacity: 0.3; }
  50% {
    opacity: 1;
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.6), inset 0 1px 1px rgba(255, 255, 255, 0.3);
  }
}

.psp-screen {
  background: rgba(0, 0, 0, 0.7);
  border: 2px solid var(--tool-border-secondary);
  padding: 12px;
  position: relative;
  overflow: hidden;
  box-shadow:
    inset 0 2px 10px rgba(0, 0, 0, 0.6),
    inset 0 0 0 1px rgba(255, 255, 255, 0.05);
  clip-path: polygon(0 0, 100% 0, 100% calc(100% - 12px), calc(100% - 12px) 100%, 0 100%);
}

#x-social-screen.x-theme-light .psp-screen {
  background: rgba(255, 255, 255, 0.7);
  box-shadow:
    inset 0 2px 10px rgba(0, 0, 0, 0.1),
    inset 0 0 0 1px rgba(0, 0, 0, 0.05);
}

.screen-dots {
  position: absolute;
  top: 6px;
  left: 6px;
  display: flex;
  gap: 3px;
  z-index: 5;
}

.screen-dot {
  width: 3px;
  height: 3px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.2);
}

#x-social-screen.x-theme-light .screen-dot {
  background: rgba(0, 0, 0, 0.15);
}

.screen-scanline {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 100%;
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(255, 255, 255, 0.03) 2px,
    rgba(255, 255, 255, 0.03) 4px
  );
  pointer-events: none;
  z-index: 1;
}

#x-social-screen.x-theme-light .screen-scanline {
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0, 0, 0, 0.02) 2px,
    rgba(0, 0, 0, 0.02) 4px
  );
}

.tool-close-btn {
  position: absolute;
  top: 8px;
  right: 8px;
  width: 28px;
  height: 28px;
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid var(--tool-border-primary);
  border-radius: 50%;
  cursor: pointer;
  z-index: 10;
  transition: all 0.3s;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

#x-social-screen.x-theme-light .tool-close-btn {
  background: rgba(0, 0, 0, 0.05);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.tool-close-btn:hover {
  background: rgba(255, 255, 255, 0.15);
  transform: rotate(90deg);
}

#x-social-screen.x-theme-light .tool-close-btn:hover {
  background: rgba(0, 0, 0, 0.1);
}

.tool-close-btn:active {
  transform: rotate(90deg) scale(0.9);
}

.tool-close-btn::before,
.tool-close-btn::after {
  content: '';
  position: absolute;
  width: 12px;
  height: 2px;
  background: var(--tool-text-primary);
  border-radius: 1px;
}

.tool-close-btn::before { transform: rotate(45deg); }
.tool-close-btn::after { transform: rotate(-45deg); }

.screen-title {
  font-size: 11px;
  font-weight: 700;
  color: var(--tool-text-primary);
  letter-spacing: 3px;
  text-align: center;
  margin-bottom: 10px;
  text-transform: uppercase;
  position: relative;
  z-index: 2;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

#x-social-screen.x-theme-light .screen-title {
  text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
}

.content-split {
  display: grid;
  grid-template-columns: 1fr 110px;
  gap: 10px;
  position: relative;
  z-index: 2;
}

.cards-area {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 6px;
}

.item-card {
  aspect-ratio: 0.7;
  background: var(--tool-card-bg);
  border: 1px solid var(--tool-card-border);
  padding: 6px;
  cursor: pointer;
  position: relative;
  transition: all 0.3s;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}

.item-card:nth-child(6n+1) {
  clip-path: polygon(10px 0, 100% 0, 100% 100%, 0 100%, 0 10px);
}

.item-card:nth-child(6n+2) {
  clip-path: polygon(0 0, calc(100% - 10px) 0, 100% 10px, 100% 100%, 0 100%);
}

.item-card:nth-child(6n+3) {
  clip-path: polygon(0 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%);
}

.item-card:nth-child(6n+4) {
  clip-path: polygon(0 0, 100% 0, 100% 100%, 10px 100%, 0 calc(100% - 10px));
}

.item-card:nth-child(6n+5) {
  clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
}

.item-card:nth-child(6n+6) {
  clip-path: polygon(0 8px, 8px 0, calc(100% - 8px) 0, 100% 8px, 100% 100%, 0 100%);
}

.item-card:hover {
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.06) 100%);
  border-color: rgba(255, 255, 255, 0.25);
  transform: translateY(-3px) scale(1.02);
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
}

#x-social-screen.x-theme-light .item-card:hover {
  background: linear-gradient(135deg, rgba(0, 0, 0, 0.08) 0%, rgba(0, 0, 0, 0.04) 100%);
  border-color: rgba(0, 0, 0, 0.2);
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
}

.item-card.has {
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
}

#x-social-screen.x-theme-light .item-card.has {
  background: linear-gradient(135deg, rgba(0, 0, 0, 0.06) 0%, rgba(0, 0, 0, 0.03) 100%);
}

.envelope-line {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
  z-index: 1;
}

#x-social-screen.x-theme-light .envelope-line {
  background: linear-gradient(90deg, transparent, rgba(0, 0, 0, 0.1), transparent);
}

.envelope-line::before,
.envelope-line::after {
  content: '';
  position: absolute;
  top: 0;
  width: 1px;
  height: 20px;
  background: rgba(255, 255, 255, 0.1);
}

#x-social-screen.x-theme-light .envelope-line::before,
#x-social-screen.x-theme-light .envelope-line::after {
  background: rgba(0, 0, 0, 0.08);
}

.envelope-line::before { left: 30%; transform: rotate(25deg); }
.envelope-line::after { right: 30%; transform: rotate(-25deg); }

.card-corner-dots {
  position: absolute;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.card-corner-dots::before,
.card-corner-dots::after {
  content: '';
  position: absolute;
  width: 2px;
  height: 2px;
  background: rgba(255, 255, 255, 0.3);
  border-radius: 50%;
}

#x-social-screen.x-theme-light .card-corner-dots::before,
#x-social-screen.x-theme-light .card-corner-dots::after {
  background: rgba(0, 0, 0, 0.2);
}

.card-corner-dots::before {
  top: 3px;
  left: 3px;
}

.card-corner-dots::after {
  bottom: 3px;
  right: 3px;
}

.item-icon {
  font-size: 22px;
  margin-bottom: 4px;
  line-height: 1;
  position: relative;
  z-index: 2;
}

.item-name {
  font-size: 7px;
  color: var(--tool-text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  text-align: center;
  position: relative;
  z-index: 2;
}

.item-count {
  position: absolute;
  top: 3px;
  right: 3px;
  background: rgba(0, 0, 0, 0.7);
  color: #ffffff;
  font-size: 8px;
  padding: 2px 4px;
  border-radius: 3px;
  font-weight: 700;
  border: 1px solid rgba(255, 255, 255, 0.2);
  z-index: 3;
}

#x-social-screen.x-theme-light .item-count {
  background: rgba(0, 0, 0, 0.65);
  border-color: rgba(255, 255, 255, 0.3);
}

.rarity-corner {
  position: absolute;
  bottom: 3px;
  left: 3px;
  width: 5px;
  height: 5px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.3);
  border: 1px solid rgba(255, 255, 255, 0.2);
  z-index: 3;
}

#x-social-screen.x-theme-light .rarity-corner {
  background: rgba(0, 0, 0, 0.2);
  border-color: rgba(0, 0, 0, 0.15);
}

.item-card.rare .rarity-corner {
  background: rgba(255, 255, 255, 0.8);
  box-shadow: 0 0 6px rgba(255, 255, 255, 0.6);
  border-color: rgba(255, 255, 255, 0.5);
}

#x-social-screen.x-theme-light .item-card.rare .rarity-corner {
  background: rgba(0, 0, 0, 0.6);
  box-shadow: 0 0 6px rgba(0, 0, 0, 0.4);
  border-color: rgba(0, 0, 0, 0.4);
}

.gacha-machine {
  display: flex;
  flex-direction: column;
  gap: 8px;
  min-height: 400px;
}

.gacha-dome {
  aspect-ratio: 1;
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%);
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 50%;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  box-shadow:
    inset 0 -10px 20px rgba(0, 0, 0, 0.3),
    inset 0 2px 4px rgba(255, 255, 255, 0.1),
    0 4px 12px rgba(0, 0, 0, 0.2);
}

#x-social-screen.x-theme-light .gacha-dome {
  background: radial-gradient(circle at 30% 30%, rgba(0, 0, 0, 0.08) 0%, rgba(0, 0, 0, 0.03) 100%);
  border-color: rgba(0, 0, 0, 0.15);
  box-shadow:
    inset 0 -10px 20px rgba(0, 0, 0, 0.1),
    inset 0 2px 4px rgba(255, 255, 255, 0.3),
    0 4px 12px rgba(0, 0, 0, 0.1);
}

.gacha-dome::before {
  content: '';
  position: absolute;
  top: 15%;
  left: 20%;
  width: 40%;
  height: 30%;
  background: radial-gradient(ellipse, rgba(255, 255, 255, 0.3) 0%, transparent 70%);
  border-radius: 50%;
  filter: blur(8px);
}

#x-social-screen.x-theme-light .gacha-dome::before {
  background: radial-gradient(ellipse, rgba(255, 255, 255, 0.6) 0%, transparent 70%);
}

.gacha-dome::after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 20%;
  right: 20%;
  height: 8px;
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
  border: 1px solid var(--tool-border-primary);
  border-top: none;
  border-radius: 0 0 8px 8px;
}

#x-social-screen.x-theme-light .gacha-dome::after {
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.06) 0%, rgba(0, 0, 0, 0.03) 100%);
}

.gacha-ball {
  width: 50px;
  height: 50px;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.1) 100%);
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  position: relative;
  animation: float 3s ease-in-out infinite;
  cursor: pointer;
  box-shadow:
    0 4px 12px rgba(0, 0, 0, 0.3),
    inset 0 2px 4px rgba(255, 255, 255, 0.2);
}

#x-social-screen.x-theme-light .gacha-ball {
  background: linear-gradient(135deg, rgba(0, 0, 0, 0.12) 0%, rgba(0, 0, 0, 0.06) 100%);
  border-color: rgba(0, 0, 0, 0.2);
  box-shadow:
    0 4px 12px rgba(0, 0, 0, 0.2),
    inset 0 2px 4px rgba(255, 255, 255, 0.3);
}

.gacha-ball::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 0;
  right: 0;
  height: 2px;
  background: rgba(255, 255, 255, 0.3);
  transform: translateY(-50%);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

#x-social-screen.x-theme-light .gacha-ball::before {
  background: rgba(0, 0, 0, 0.2);
  box-shadow: 0 1px 2px rgba(255, 255, 255, 0.3);
}

.gacha-ball::after {
  content: '';
  position: absolute;
  top: 20%;
  left: 25%;
  width: 12px;
  height: 12px;
  background: rgba(255, 255, 255, 0.5);
  border-radius: 50%;
  filter: blur(3px);
}

#x-social-screen.x-theme-light .gacha-ball::after {
  background: rgba(255, 255, 255, 0.8);
}

@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-8px); }
}

.gacha-btns {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.gacha-btn {
  padding: 8px 6px;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
  border: 1px solid var(--tool-border-primary);
  color: var(--tool-text-primary);
  font-family: 'Courier New', monospace;
  font-size: 9px;
  font-weight: 700;
  letter-spacing: 1px;
  cursor: pointer;
  transition: all 0.3s;
  text-align: center;
  clip-path: polygon(6px 0, 100% 0, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0 100%, 0 6px);
  position: relative;
  overflow: hidden;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
}

#x-social-screen.x-theme-light .gacha-btn {
  background: linear-gradient(135deg, rgba(0, 0, 0, 0.06) 0%, rgba(0, 0, 0, 0.03) 100%);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
}

.gacha-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 50%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
  transition: left 0.5s;
}

.gacha-btn:hover::before {
  left: 100%;
}

.gacha-btn:hover {
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.08) 100%);
  border-color: rgba(255, 255, 255, 0.25);
  transform: translateY(-2px);
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
}

#x-social-screen.x-theme-light .gacha-btn:hover {
  background: linear-gradient(135deg, rgba(0, 0, 0, 0.1) 0%, rgba(0, 0, 0, 0.05) 100%);
  border-color: rgba(0, 0, 0, 0.2);
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
}

.gacha-btn:active {
  transform: translateY(0) scale(0.95);
}

.gacha-cost {
  font-size: 7px;
  opacity: 0.6;
  margin-top: 2px;
}

/* ========== 翻页控制器 ========== */
.pagination-control {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  padding: 8px;
  background: linear-gradient(0deg, rgba(255, 255, 255, 0.04) 0%, transparent 100%);
  border: 1px solid var(--tool-border-secondary);
  clip-path: polygon(0 6px, 6px 0, calc(100% - 6px) 0, 100% 6px, 100% 100%, 0 100%);
  position: relative;
  margin-top: auto;
  margin-bottom: 6px;
}

#x-social-screen.x-theme-light .pagination-control {
  background: linear-gradient(0deg, rgba(0, 0, 0, 0.03) 0%, transparent 100%);
}

.pagination-control::before {
  content: '';
  position: absolute;
  top: 0;
  left: 20%;
  right: 20%;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
}

#x-social-screen.x-theme-light .pagination-control::before {
  background: linear-gradient(90deg, transparent, rgba(0, 0, 0, 0.1), transparent);
}

.page-arrow {
  width: 28px;
  height: 28px;
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid var(--tool-border-primary);
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

#x-social-screen.x-theme-light .page-arrow {
  background: rgba(0, 0, 0, 0.05);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.page-arrow.left {
  clip-path: polygon(0 50%, 100% 0, 100% 100%);
}

.page-arrow.right {
  clip-path: polygon(0 0, 100% 50%, 0 100%);
}

.page-arrow:hover {
  background: rgba(255, 255, 255, 0.15);
  transform: scale(1.1);
}

#x-social-screen.x-theme-light .page-arrow:hover {
  background: rgba(0, 0, 0, 0.1);
}

.page-arrow:active {
  transform: scale(0.9);
}

.page-arrow.disabled {
  opacity: 0.3;
  cursor: not-allowed;
  pointer-events: none;
}

.page-arrow::before {
  content: '';
  position: absolute;
  width: 8px;
  height: 8px;
  border-left: 2px solid var(--tool-text-primary);
  border-bottom: 2px solid var(--tool-text-primary);
}

.page-arrow.left::before {
  transform: rotate(45deg);
  margin-left: 2px;
}

.page-arrow.right::before {
  transform: rotate(-135deg);
  margin-right: 2px;
}

.page-info {
  font-family: 'Courier New', monospace;
  font-size: 11px;
  font-weight: 700;
  color: var(--tool-text-primary);
  letter-spacing: 1px;
  min-width: 50px;
  text-align: center;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

#x-social-screen.x-theme-light .page-info {
  text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
}

/* ========== 商店和兑换按钮 ========== */
.utility-btns {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-top: 6px;
}

.utility-btn {
  padding: 8px 6px;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.06) 0%, rgba(255, 255, 255, 0.03) 100%);
  border: 1px solid var(--tool-border-primary);
  color: var(--tool-text-primary);
  font-family: 'Courier New', monospace;
  font-size: 8px;
  font-weight: 700;
  letter-spacing: 1px;
  cursor: pointer;
  transition: all 0.3s;
  text-align: center;
  clip-path: polygon(6px 0, 100% 0, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0 100%, 0 6px);
  position: relative;
  overflow: hidden;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
}

#x-social-screen.x-theme-light .utility-btn {
  background: linear-gradient(135deg, rgba(0, 0, 0, 0.04) 0%, rgba(0, 0, 0, 0.02) 100%);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
}

.utility-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 50%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
  transition: left 0.5s;
}

.utility-btn:hover::before {
  left: 100%;
}

.utility-btn:hover {
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
  border-color: rgba(255, 255, 255, 0.2);
  transform: translateY(-2px);
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
}

#x-social-screen.x-theme-light .utility-btn:hover {
  background: linear-gradient(135deg, rgba(0, 0, 0, 0.08) 0%, rgba(0, 0, 0, 0.04) 100%);
  border-color: rgba(0, 0, 0, 0.15);
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
}

.utility-btn:active {
  transform: translateY(0) scale(0.95);
}

.utility-btn svg {
  width: 10px;
  height: 10px;
  fill: var(--tool-text-primary);
}

.stats-bar {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 6px;
  margin-top: 10px;
  position: relative;
  z-index: 2;
}

.stat {
  padding: 6px;
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid var(--tool-border-secondary);
  text-align: center;
  clip-path: polygon(6px 0, calc(100% - 6px) 0, 100% 6px, 100% 100%, 0 100%, 0 6px);
  position: relative;
  box-shadow:
    inset 0 1px 0 rgba(255, 255, 255, 0.05),
    0 2px 4px rgba(0, 0, 0, 0.1);
}

#x-social-screen.x-theme-light .stat {
  background: rgba(0, 0, 0, 0.03);
  box-shadow:
    inset 0 1px 0 rgba(0, 0, 0, 0.05),
    0 2px 4px rgba(0, 0, 0, 0.05);
}

.stat::before {
  content: attr(data-icon);
  position: absolute;
  top: 50%;
  left: 8px;
  transform: translateY(-50%);
  font-size: 10px;
  opacity: 0.3;
}

.stat-val {
  font-size: 14px;
  font-weight: 700;
  color: var(--tool-text-primary);
  line-height: 1;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

#x-social-screen.x-theme-light .stat-val {
  text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
}

.psp-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 12px;
  padding: 10px 12px;
  background: linear-gradient(0deg, rgba(255, 255, 255, 0.04) 0%, transparent 100%);
  border: 1px solid var(--tool-border-secondary);
  clip-path: polygon(0 8px, 8px 0, calc(100% - 8px) 0, 100% 8px, 100% 100%, 0 100%);
  position: relative;
}

#x-social-screen.x-theme-light .psp-controls {
  background: linear-gradient(0deg, rgba(0, 0, 0, 0.03) 0%, transparent 100%);
}

.psp-controls::before {
  content: '';
  position: absolute;
  top: 0;
  left: 20%;
  right: 20%;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
}

#x-social-screen.x-theme-light .psp-controls::before {
  background: linear-gradient(90deg, transparent, rgba(0, 0, 0, 0.1), transparent);
}

.dpad {
  width: 50px;
  height: 50px;
  position: relative;
}

.dpad-btn {
  position: absolute;
  width: 16px;
  height: 16px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid var(--tool-border-primary);
  transition: all 0.2s;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

#x-social-screen.x-theme-light .dpad-btn {
  background: rgba(0, 0, 0, 0.06);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.dpad-btn:hover {
  background: rgba(255, 255, 255, 0.15);
  transform: scale(1.05);
}

#x-social-screen.x-theme-light .dpad-btn:hover {
  background: rgba(0, 0, 0, 0.1);
}

.dpad-btn.up {
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  clip-path: polygon(50% 0, 100% 100%, 0 100%);
}

.dpad-btn.down {
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  clip-path: polygon(0 0, 100% 0, 50% 100%);
}

.dpad-btn.left {
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  clip-path: polygon(0 50%, 100% 0, 100% 100%);
}

.dpad-btn.right {
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  clip-path: polygon(0 0, 100% 50%, 0 100%);
}

.action-btns {
  display: flex;
  gap: 8px;
}

@keyframes roll {
  0% { transform: rotate(0deg) scale(1); }
  50% { transform: rotate(180deg) scale(1.15); }
  100% { transform: rotate(360deg) scale(1); }
}

.gacha-ball.rolling {
  animation: roll 1s ease-in-out;
}

@keyframes cardPop {
  0% {
    transform: scale(0) rotate(-90deg);
    opacity: 0;
  }
  60% {
    transform: scale(1.15) rotate(5deg);
  }
  100% {
    transform: scale(1) rotate(0deg);
    opacity: 1;
  }
}

.item-card.new {
  animation: cardPop 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}

@media (max-width: 360px) {
  .cards-area {
    grid-template-columns: repeat(3, 1fr);
    gap: 5px;
  }

  .content-split {
    grid-template-columns: 1fr 100px;
    gap: 8px;
  }

  .item-icon {
    font-size: 20px;
  }

  .item-name {
    font-size: 6px;
  }
}
`;

    document.head.appendChild(style);
    console.log('✅ X Tool System: 样式已注入');
  }

  // ============================================
  // 第二部分：道具数据管理
  // ============================================

  // 道具数据数组
  let toolItems = [];

  // 金币数量
  let toolCoins = 1000;

  // 当前页码
  let currentPage = 1;

  // 每页显示的道具数量
  const ITEMS_PER_PAGE = 12;

  // 扭蛋池配置（默认值，会从数据库加载AI生成的扭蛋池）
  let gachaPool = [{ name: '默认道具', icon: '❓', rarity: 'common', weight: 10, category: '特殊道具' }];

  // 数据库schema已在x-core.js的getXDB中定义，此函数仅做日志记录
  async function ensureToolDatabaseSchema() {
    console.log('✅ 道具数据库表schema已在x-core.js中定义');
  }

  // ▼▼▼ 【主要！！！】第十七情景：道具系统初始化生成器 ▼▼▼
  async function generateToolScenario() {
    try {
      console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
      console.log('🎮 [第十七情景] 道具系统初始化生成器启动');
      console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');

      // Token计数器
      let tokenCount = 0;

      // 1. 使用统一的API配置加载工具
      console.log('📦 [第十七情景] 正在加载API配置和用户设置...');
      const { apiConfig, xSettings, xDb } = await APIUtils.loadConfigAndSettings();
      const { userPrompt, worldSetting } = xSettings;
      console.log('✅ [第十七情景] API配置加载完成');

      // 2. 获取用户X个人资料信息
      console.log('👤 [第十七情景] 正在读取用户个人资料...');
      const userProfileData = window.userProfileData || {};
      const publicIdentity = userProfileData.publicIdentity || '';
      const userName = userProfileData.name || '用户';
      const userHandle = userProfileData.handle || '@user';
      const userBio = userProfileData.bio || '';

      console.log('📋 [第十七情景] 用户信息:');
      console.log(`   - 用户名: ${userName}`);
      console.log(`   - 句柄: ${userHandle}`);
      console.log(`   - 公众身份: ${publicIdentity || '普通人'}`);
      console.log(`   - 个人简介: ${userBio ? userBio.substring(0, 50) + (userBio.length > 50 ? '...' : '') : '无'}`);

      // 3. 🔧 初始coins由AI根据用户身份和世界观智能判断，不再硬编码
      console.log('💰 [第十七情景] 初始coins将由AI根据用户身份智能分配');

      // 4. 构建系统提示词
      let systemPrompt = '';

      // 4.1 用户自定义提示词
      if (userPrompt.trim()) {
        systemPrompt += userPrompt.trim() + '\n\n';
        tokenCount = TokenUtils.logTokenUsage('道具系统初始化生成器', '用户自定义提示词', systemPrompt, tokenCount);
      }

      // 4.2 世界观设定
      const worldSettingStart = systemPrompt.length;
      systemPrompt += '【世界观设定约束】：\n';
      if (worldSetting.trim()) {
        systemPrompt += `${worldSetting.trim()}\n上述世界观设定是最高优先级的约束条件，必须严格遵守。\n\n`;
        console.log('🌍 [第十七情景] 已注入世界观设定');
      } else {
        systemPrompt += '无特殊世界观限制，但内容需健康正面，符合常识。\n\n';
        console.log('ℹ️ [第十七情景] 无自定义世界观设定，使用默认规则');
      }
      const worldSettingSection = systemPrompt.substring(worldSettingStart);
      tokenCount = TokenUtils.logTokenUsage('道具系统初始化生成器', '世界观设定约束', worldSettingSection, tokenCount);

      // 4.3 核心任务说明
      const coreTaskStart = systemPrompt.length;
      systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务：道具系统初始化生成器（第十七情景）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是道具系统的初始化生成器。你的任务是为用户生成完整的初始道具背包和扭蛋池数据库。

【用户信息】：
- 用户名：${userName}
- 用户句柄：${userHandle}
- 公众身份：${publicIdentity || '普通人'}
- 个人简介：${userBio || '无'}

【强制性生成要求】：

0️⃣ **初始金币（initialCoins）智能分配**（必须由你根据用户信息判断）：
   🚨 **硬性要求**：
   - 必须根据用户的公众身份、个人简介、世界观设定进行综合判断
   - 不要使用固定值，要根据实际情况灵活分配

   💰 **分配参考标准**（仅供参考，可灵活调整）：
   - 富豪/企业家/商人：4000-6000 coins
   - 明星/艺人/网红/博主：2000-4000 coins
   - 专业人士（医生/律师/教师/艺术家/作家）：1000-2000 coins
   - 普通白领/职员：500-1000 coins
   - 学生/实习生/新人：200-500 coins
   - 其他情况：根据具体身份和世界观合理判断

   📋 **判断依据**：
   - 优先根据公众身份判断社会地位和经济实力
   - 参考个人简介中的职业、成就、背景信息
   - 符合当前世界观设定（例如末世背景coins应该少，富裕时代coins可以多）
   - 确保分配合理，不要过高或过低

   ⚠️ **重要**：initialCoins必须是100-10000之间的整数（100的倍数最佳）

1️⃣ **初始道具背包**（必须生成6-10个道具）：
   🚨 **硬性要求**：
   - 最少6个，最多10个，建议8-10个
   - 每个道具必须100%符合用户的公众身份"${publicIdentity || '普通人'}"
   - 绝对不允许脱离人设（例如：学生不能有豪车、普通人不能有私人飞机）
   - 道具必须合理、实用、符合日常生活

   📋 **必需字段**（缺一不可）：
   - name: 中文名称，简短精确（2-6个汉字）
   - icon: 单个emoji或符号（如📱🔑💰）
   - count: 数量（1-10之间的整数）
   - rarity: 稀有度（"common" 或 "rare"，初始道具以common为主，rare不超过2个）
   - category: 中文分类（自由创造，符合道具特性即可）

2️⃣ **扭蛋池道具库**（必须生成100-300个道具）：
   🚨 **硬性要求**：
   - **最少100个，推荐150-300个** - 这是强制要求，不得少于100个！
   - 必须严格符合当前世界观设定（绝对禁止出现超越世界观的物品）
   - 道具名称要富有创意、有趣、多样化，避免重复和单调
   - 分类要多样化且有趣，可以自由创造新分类

   📊 **稀有度分布**（严格遵守）：
   - common（普通）：70-75%，权重范围 20-30
   - rare（稀有）：25-30%，权重范围 2-10
   - 示例：如果生成150个道具，则common约105-112个，rare约38-45个

   📋 **必需字段**（缺一不可）：
   - name: 中文名称，简短有趣（2-6个汉字）
   - icon: 单个emoji或符号
   - rarity: "common" 或 "rare"
   - weight: 整数权重（common: 20-30, rare: 2-10）
   - category: 中文分类（自由创造，符合道具特性即可）

3️⃣ **道具分类创造指南**（鼓励创意，以下仅为参考）：

   💡 **分类创造原则**（重要！）：
   - ✨ **自由发挥**：可以创造任何有趣的中文分类名称
   - 🎨 **富有创意**：鼓励使用有趣、新颖、贴切的分类名
   - 📝 **简短有力**：分类名称2-4个汉字最佳
   - 🌈 **多样化**：建议创造5-10个不同分类
   - 🎯 **符合世界观**：分类要贴合当前世界观和用户身份

   📚 **分类示例参考**（不强制使用，激发灵感用）：

   **常规分类**：
   - 日用品、装备、消耗品、收藏品、特殊道具

   **创意分类**（鼓励使用这类有趣的分类）：
   - 治愈系、青春记忆、奇幻小物、情感寄托、幸运物
   - 神秘物品、时光宝盒、心愿物语、温暖时刻、魔法碎片
   - 怀旧珍藏、惊喜盲盒、梦想碎片、回忆拼图、奇迹见证

   **根据世界观自创**：
   - 如果是现代都市：时尚单品、数码产品、潮流饰品、网红好物
   - 如果是古代背景：江湖奇物、文房四宝、古董珍玩、武林秘宝
   - 如果是校园青春：学习用品、社团装备、青春纪念、校园回忆

   **道具示例**（仅供参考）：
   - 手机、钥匙、钱包、背包、雨伞、充电宝、耳机、水杯
   - 帽子、围巾、手套、眼镜、手表、项链、戒指、耳环
   - 零食、饮料、水果、药品、糖果、咖啡、茶叶
   - 照片、明信片、纪念币、海报、手办、签名、卡片
   - 幸运符、许愿币、神秘钥匙、古董、限定版物品

【世界观一致性检查】：
${
  worldSetting
    ? `当前世界观：${worldSetting}\n   ⚠️ 所有道具必须100%符合上述世界观，禁止出现不符合时代/设定的物品！`
    : '⚠️ 现代都市背景，禁止出现科幻/魔法/古代/未来物品！'
}

【质量标准】：
✅ **必须做到**：
- 🎨 **创造性**：道具名称有创意、有趣、独特，避免千篇一律
- 🌟 **趣味性**：分类命名富有想象力，能让人会心一笑
- 🎯 **多样性**：道具类型丰富多彩，不要重复单调
- 💯 **符合性**：完美匹配用户身份和世界观设定
- 😊 **生动性**：emoji图标选择恰当、形象、有趣
- 🔥 **惊喜感**：让每个道具都有存在的意义和故事感

❌ **绝对禁止**：
- 重复的道具名称（每个道具都应该是独一无二的）
- 不符合世界观的物品（严格遵守设定）
- 脱离用户身份的奢侈品（除非用户是富豪/明星）
- 分类命名单调乏味（要有创意和趣味性！）
- 道具数量不足（扭蛋池少于100个）

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🚨🚨🚨 JSON格式强制规范 🚨🚨🚨
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

⚠️ **你必须严格遵守以下JSON格式要求，否则会导致系统崩溃！**

【返回内容规则】：
✅ **只能返回纯JSON对象**，从 { 开始，到 } 结束
❌ **绝对禁止**：
   - 不要任何解释、说明、注释文字
   - 不要 \`\`\`json 或 \`\`\` 代码块标记
   - 不要 "好的"、"明白"、"以下是" 等开头语
   - 不要 "完成"、"已生成" 等结尾语
   - 不要任何中文或英文的额外说明

【JSON格式规范】：
1. 使用标准JSON格式，所有字符串必须用双引号 "
2. 每个对象最后一个字段后面不要逗号
3. 数组最后一个元素后面不要逗号
4. 数字类型不要加引号（如 count: 1 而不是 "1"）
5. 字符串内容可以包含emoji表情符号

【完整JSON示例】（请严格参考此格式）：

{
  "initialCoins": 800,
  "initialItems": [
    {
      "name": "智能手机",
      "icon": "📱",
      "count": 1,
      "rarity": "common",
      "category": "数码产品"
    },
    {
      "name": "幸运手链",
      "icon": "💝",
      "count": 1,
      "rarity": "rare",
      "category": "情感寄托"
    },
    {
      "name": "背包",
      "icon": "🎒",
      "count": 1,
      "rarity": "common",
      "category": "日用品"
    },
    {
      "name": "钥匙串",
      "icon": "🔑",
      "count": 1,
      "rarity": "common",
      "category": "日用品"
    },
    {
      "name": "水杯",
      "icon": "🥤",
      "count": 1,
      "rarity": "common",
      "category": "日用品"
    },
    {
      "name": "耳机",
      "icon": "🎧",
      "count": 1,
      "rarity": "common",
      "category": "数码产品"
    }
  ],
  "gachaPool": [
    {
      "name": "四叶草书签",
      "icon": "🍀",
      "rarity": "rare",
      "weight": 5,
      "category": "幸运物"
    },
    {
      "name": "樱花糖果",
      "icon": "🌸",
      "rarity": "common",
      "weight": 25,
      "category": "治愈系"
    },
    {
      "name": "复古相机",
      "icon": "📷",
      "rarity": "rare",
      "weight": 8,
      "category": "青春记忆"
    },
    {
      "name": "星空明信片",
      "icon": "✉️",
      "rarity": "common",
      "weight": 22,
      "category": "情感寄托"
    },
    {
      "name": "幸运硬币",
      "icon": "🪙",
      "rarity": "rare",
      "weight": 6,
      "category": "幸运物"
    }
  ]
}

🔴 **错误示例**（绝对不要这样返回）：

错误1：带有说明文字
\`\`\`
好的，我为你生成了以下道具数据：
{"initialCoins": 800, ...}
已完成生成。
\`\`\`

错误2：使用代码块标记
\`\`\`json
{"initialCoins": 800, ...}
\`\`\`

错误3：多余逗号
{
  "initialCoins": 800,
  "initialItems": [...],  ← 最后一个字段后面有逗号，错误！
}

错误4：字符串没加引号
{
  name: "手机"  ← 错误！应该是 "name": "手机"
}

✅ **正确示例**（必须这样返回）：

{"initialCoins":800,"initialItems":[{"name":"智能手机","icon":"📱","count":1,"rarity":"common","category":"数码产品"}],"gachaPool":[{"name":"四叶草书签","icon":"🍀","rarity":"rare","weight":5,"category":"幸运物"}]}

或者格式化的（推荐）：

{
  "initialCoins": 800,
  "initialItems": [
    {"name": "智能手机", "icon": "📱", "count": 1, "rarity": "common", "category": "数码产品"}
  ],
  "gachaPool": [
    {"name": "四叶草书签", "icon": "🍀", "rarity": "rare", "weight": 5, "category": "幸运物"}
  ]
}

🚨 **再次强调**：
- 你的整个回复必须从 { 开始，以 } 结束
- 不要任何其他字符、说明、解释
- 直接返回JSON对象，其他什么都不要

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💡 **分类创意提示**：
- 不要只用"日用品"、"消耗品"等常规分类
- 可以用"治愈系"、"青春记忆"、"情感寄托"、"幸运物"等有趣分类
- 让每个分类都有故事感和情感共鸣

💡 **数量要求**：
- initialItems: 必须6-10个道具
- gachaPool: 必须100-300个道具（推荐150-300个）

🚨 **最终检查清单**：
在返回前，请逐项确认：
☑️ JSON格式100%正确：从{开始到}结束，不含任何额外文字
☑️ 没有代码块标记（不要\`\`\`json或\`\`\`）
☑️ 没有多余逗号（对象最后字段后、数组最后元素后）
☑️ 所有字符串使用双引号"
☑️ 数字类型不加引号（count、weight、initialCoins）
☑️ initialCoins 已根据用户身份智能判断（100-10000之间的整数）
☑️ initialItems 有 6-10 个道具
☑️ gachaPool 有 100-300 个道具（最少100个，推荐150-300个！）
☑️ 所有道具都符合用户身份"${publicIdentity || '普通人'}"
☑️ 所有道具都符合世界观设定
☑️ 所有字段都是中文（name, category）
☑️ 稀有度分布合理（70%普通 + 30%稀有）
☑️ 分类富有创意和趣味性（不要只用常规分类）
☑️ 道具名称独特有趣，没有重复
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
      const coreTaskSection = systemPrompt.substring(coreTaskStart);
      tokenCount = TokenUtils.logTokenUsage(
        '道具系统初始化生成器',
        '核心任务说明+用户信息+生成要求+JSON格式',
        coreTaskSection,
        tokenCount,
      );

      // 5. 调用AI生成道具数据
      const messages = [
        {
          role: 'user',
          content: '请为用户生成初始道具背包和扭蛋池数据',
        },
      ];

      // 最终统计
      TokenUtils.logFinalPrompt('道具系统初始化生成器', systemPrompt, messages[0].content);

      console.log('📤 [第十七情景] 正在向AI发送请求...');
      console.log(`   - Temperature: 0.8`);
      console.log(`   - 预期生成: 3-10个初始道具, 50-100个扭蛋池道具`);

      const aiResponseContent = await APIUtils.sendAIRequest({
        apiConfig,
        systemPrompt,
        messages,
        temperature: 0.8,
      });

      console.log('📥 [第十七情景] AI响应已接收');
      console.log(`   - 响应长度: ${aiResponseContent.length} 字符`);

      // 6. 解析AI响应
      console.log('🔍 [第十七情景] 正在解析JSON数据...');
      let toolData = APIUtils.parseJSONResponse(aiResponseContent);

      // 🔧 验证AI返回的数据格式（必须包含initialCoins、initialItems、gachaPool）
      if (!toolData.initialCoins || !toolData.initialItems || !toolData.gachaPool) {
        throw new Error('AI返回的数据格式不正确，缺少initialCoins、initialItems或gachaPool字段');
      }

      // 🔧 验证initialCoins的合理性
      if (typeof toolData.initialCoins !== 'number' || toolData.initialCoins < 100 || toolData.initialCoins > 10000) {
        console.warn(`⚠️ AI返回的initialCoins值不合理: ${toolData.initialCoins}，使用默认值500`);
        toolData.initialCoins = 500;
      }

      console.log('✅ [第十七情景] JSON解析成功');
      console.log(`   - AI分配的初始coins: ${toolData.initialCoins}`);
      console.log(`   - 初始道具数量: ${toolData.initialItems.length}个`);
      console.log(`   - 扭蛋池道具数量: ${toolData.gachaPool.length}个`);

      // 显示生成的道具示例
      if (toolData.initialItems.length > 0) {
        console.log('🎁 [第十七情景] 初始道具示例:');
        toolData.initialItems.slice(0, 3).forEach((item, idx) => {
          console.log(`   ${idx + 1}. ${item.icon} ${item.name} x${item.count} [${item.rarity}] (${item.category})`);
        });
        if (toolData.initialItems.length > 3) {
          console.log(`   ... 还有 ${toolData.initialItems.length - 3} 个道具`);
        }
      }

      if (toolData.gachaPool.length > 0) {
        console.log('🎰 [第十七情景] 扭蛋池道具示例:');
        toolData.gachaPool.slice(0, 5).forEach((item, idx) => {
          console.log(
            `   ${idx + 1}. ${item.icon} ${item.name} [${item.rarity}] 权重:${item.weight} (${item.category})`,
          );
        });
        if (toolData.gachaPool.length > 5) {
          console.log(`   ... 还有 ${toolData.gachaPool.length - 5} 个道具`);
        }
      }

      // 7. 保存数据到数据库并更新全局变量
      console.log('💾 [第十七情景] 正在保存数据到数据库...');
      const accountId = currentAccountId || 'main';
      const toolDataId = `tools_${accountId}`;

      // 🔧 更新全局变量（使用AI返回的initialCoins）
      toolItems = toolData.initialItems;
      toolCoins = toolData.initialCoins; // 🔧 从AI返回的数据中读取coins
      gachaPool = toolData.gachaPool; // 🔧 关键：更新全局扭蛋池

      await xDb.xTools.put({
        id: toolDataId,
        accountId: accountId,
        items: toolItems,
        coins: toolCoins,
        gachaPool: toolData.gachaPool,
        scenarioGenerated: true,
        generatedAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      });

      console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
      console.log('✅ [第十七情景] 道具系统初始化完成！');
      console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
      console.log(`📦 数据已保存到数据库 (ID: ${toolDataId})`);
      console.log(`🎁 初始道具: ${toolItems.length}个`);
      console.log(`🎰 扭蛋池: ${toolData.gachaPool.length}个道具`);
      console.log(`💰 初始coins: ${toolCoins}`);
      console.log(`🕐 生成时间: ${new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' })}`);
      console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');

      // 8. 🔧 AI生成完毕后，快速完成进度条动画，然后关闭开机画面
      console.log('⏱️ [第十七情景] AI生成完毕，准备完成开机动画...');

      // 步骤1：快速完成进度条（90% → 100%）
      finishBootAnimation();

      // 步骤2：等待1秒让用户看到100%完成状态，然后关闭开机画面
      setTimeout(() => {
        const bootScreen = document.querySelector('.tool-boot-screen');
        if (bootScreen) {
          bootScreen.style.animation = 'toolBootFadeOut 0.5s ease-out forwards';
        }
        console.log('🎬 [第十七情景] 开机画面已关闭');

        // 9. 在开机画面关闭后显示成功提示
        setTimeout(() => {
          showXToast(`道具系统初始化完成！获得 ${toolItems.length} 个初始道具和 ${toolCoins} coins`, 'success');
        }, 500); // 开机画面关闭动画后0.5秒显示提示
      }, 1500); // 等待1.5秒，让用户看到进度条完成
    } catch (error) {
      console.error('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
      console.error('❌ [第十七情景] 生成道具数据失败');
      console.error('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
      console.error('错误类型:', error.name);
      console.error('错误信息:', error.message);
      console.error('错误堆栈:', error.stack);
      console.error('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');

      showXToast('道具系统初始化失败: ' + error.message, 'error');

      // 🔧 清理开机动画interval
      if (bootAnimationInterval) {
        clearInterval(bootAnimationInterval);
        bootAnimationInterval = null;
      }

      // 发生错误也要关闭开机画面
      setTimeout(() => {
        const bootScreen = document.querySelector('.tool-boot-screen');
        if (bootScreen) {
          bootScreen.style.animation = 'toolBootFadeOut 0.5s ease-out forwards';
        }
        console.log('🎬 [第十七情景] 错误恢复：开机画面已关闭');
      }, 1000);
    }
  }
  // ▲▲▲ 【主要！！！】第十七情景：道具系统初始化生成器 ▲▲▲

  // 加载道具数据
  async function loadToolData() {
    try {
      const db = getXDB();
      const accountId = currentAccountId || 'main';
      const toolDataId = `tools_${accountId}`;

      const toolData = await db.xTools.get(toolDataId);

      if (toolData) {
        toolItems = toolData.items || [];
        toolCoins = toolData.coins || 0;

        // 🔧 关键：加载AI生成的扭蛋池
        if (toolData.gachaPool && toolData.gachaPool.length > 0) {
          gachaPool = toolData.gachaPool;
          console.log(
            '✅ 道具数据已加载:',
            toolItems.length,
            '个道具,',
            toolCoins,
            'coins,',
            gachaPool.length,
            '个扭蛋池道具',
          );
        } else {
          console.warn('⚠️ 扭蛋池数据缺失，使用默认扭蛋池');
        }
      } else {
        // 这种情况不应该发生，因为首次进入会触发第十七情景生成
        console.warn('⚠️ 未找到道具数据，应该先触发情景生成');
        toolItems = [];
        toolCoins = 0;
      }
    } catch (error) {
      console.error('❌ 加载道具数据失败:', error);
    }
  }

  // 保存道具数据
  async function saveToolData() {
    try {
      const db = getXDB();
      const accountId = currentAccountId || 'main';
      const toolDataId = `tools_${accountId}`;

      // 获取现有数据以保留gachaPool和其他字段
      const existingData = await db.xTools.get(toolDataId);

      await db.xTools.put({
        id: toolDataId,
        accountId: accountId,
        items: toolItems,
        coins: toolCoins,
        gachaPool: existingData?.gachaPool || gachaPool, // 🔧 保留扭蛋池数据
        scenarioGenerated: existingData?.scenarioGenerated || false,
        generatedAt: existingData?.generatedAt,
        updatedAt: new Date().toISOString(),
      });

      console.log('✅ 道具数据已保存');
    } catch (error) {
      console.error('❌ 保存道具数据失败:', error);
    }
  }

  // ============================================
  // 第三部分：扭蛋系统逻辑
  // ============================================

  // 按权重随机抽取道具
  function getRandomItem() {
    const totalWeight = gachaPool.reduce((sum, item) => sum + item.weight, 0);
    let random = Math.random() * totalWeight;

    for (const item of gachaPool) {
      random -= item.weight;
      if (random <= 0) {
        return { ...item };
      }
    }

    return { ...gachaPool[0] };
  }

  // 单抽
  async function rollOne() {
    if (toolCoins < 100) {
      showXToast('金币不足！需要100金币', 'error');
      return;
    }

    toolCoins -= 100;
    updateToolStats();

    const ball = document.getElementById('gacha-ball');
    if (ball) {
      ball.classList.add('rolling');
    }

    setTimeout(async () => {
      if (ball) {
        ball.classList.remove('rolling');
      }

      const newItem = getRandomItem();

      // 检查是否已有该道具
      const existingItem = toolItems.find(item => item.name === newItem.name);
      if (existingItem) {
        existingItem.count += 1;
      } else {
        toolItems.push({
          name: newItem.name,
          icon: newItem.icon,
          count: 1,
          rarity: newItem.rarity,
        });
      }

      await saveToolData();
      renderToolCards();

      // 添加弹出动画
      setTimeout(() => {
        const cards = document.querySelectorAll('.item-card.has');
        const targetCard = Array.from(cards).find(card => {
          const nameEl = card.querySelector('.item-name');
          return nameEl && nameEl.textContent === newItem.name;
        });

        if (targetCard) {
          targetCard.classList.add('new');
          setTimeout(() => targetCard.classList.remove('new'), 500);
        }
      }, 100);

      showXToast(`获得道具: ${newItem.icon} ${newItem.name} ${newItem.rarity === 'rare' ? '(稀有)' : ''}`, 'success');
    }, 1000);
  }

  // 十连抽
  async function rollTen() {
    if (toolCoins < 900) {
      showXToast('金币不足！需要900金币', 'error');
      return;
    }

    toolCoins -= 900;
    updateToolStats();

    const ball = document.getElementById('gacha-ball');
    if (ball) {
      ball.classList.add('rolling');
    }

    setTimeout(async () => {
      if (ball) {
        ball.classList.remove('rolling');
      }

      const results = [];
      for (let i = 0; i < 10; i++) {
        const item = getRandomItem();
        results.push(item);

        const existingItem = toolItems.find(t => t.name === item.name);
        if (existingItem) {
          existingItem.count += 1;
        } else {
          toolItems.push({
            name: item.name,
            icon: item.icon,
            count: 1,
            rarity: item.rarity,
          });
        }
      }

      await saveToolData();
      renderToolCards();

      const rareCount = results.filter(r => r.rarity === 'rare').length;
      showXToast(`十连抽完成！获得 ${results.length} 个道具 (${rareCount} 稀有)`, 'success');
    }, 1000);
  }

  // 摇晃扭蛋球
  function shakeBall() {
    const ball = document.getElementById('gacha-ball');
    if (ball) {
      ball.style.animation = 'none';
      setTimeout(() => {
        ball.style.animation = 'float 3s ease-in-out infinite';
      }, 10);
    }
  }

  // ============================================
  // 第四部分：UI渲染函数
  // ============================================

  // 计算总页数
  function getTotalPages() {
    return Math.max(1, Math.ceil(toolItems.length / ITEMS_PER_PAGE));
  }

  // 上一页
  function previousPage() {
    if (currentPage > 1) {
      currentPage--;
      renderToolCards();
      updatePaginationUI();
    }
  }

  // 下一页
  function nextPage() {
    const totalPages = getTotalPages();
    if (currentPage < totalPages) {
      currentPage++;
      renderToolCards();
      updatePaginationUI();
    }
  }

  // 更新翻页UI状态
  function updatePaginationUI() {
    const pageInfo = document.getElementById('page-info');
    const prevBtn = document.getElementById('page-prev');
    const nextBtn = document.getElementById('page-next');
    const totalPages = getTotalPages();

    if (pageInfo) {
      pageInfo.textContent = `${currentPage}/${totalPages}`;
    }

    if (prevBtn) {
      if (currentPage === 1) {
        prevBtn.classList.add('disabled');
        prevBtn.style.opacity = '0.3';
        prevBtn.style.cursor = 'not-allowed';
      } else {
        prevBtn.classList.remove('disabled');
        prevBtn.style.opacity = '1';
        prevBtn.style.cursor = 'pointer';
      }
    }

    if (nextBtn) {
      if (currentPage >= totalPages) {
        nextBtn.classList.add('disabled');
        nextBtn.style.opacity = '0.3';
        nextBtn.style.cursor = 'not-allowed';
      } else {
        nextBtn.classList.remove('disabled');
        nextBtn.style.opacity = '1';
        nextBtn.style.cursor = 'pointer';
      }
    }
  }

  // 打开金币兑换
  async function openCoinExchange() {
    try {
      // 🔧 加载钱包数据
      if (typeof loadWalletData === 'function') {
        await loadWalletData();
      } else {
        showXToast('钱包系统未加载，请刷新页面重试', 'error');
        return;
      }

      // 🔧 检查钱包是否激活
      if (!walletData || !walletData.isActivated) {
        showXToast('请先激活钱包才能使用兑换功能', 'error');
        return;
      }

      // 🔧 显示兑换弹窗
      showExchangeModal();
    } catch (error) {
      console.error('❌ 打开兑换弹窗失败:', error);
      showXToast('打开兑换功能失败: ' + error.message, 'error');
    }
  }

  // 显示兑换弹窗
  function showExchangeModal() {
    // 检查主题模式
    const xSocialScreen = document.getElementById('x-social-screen');
    const isLightMode = xSocialScreen && xSocialScreen.classList.contains('x-theme-light');

    // 创建弹窗遮罩（参考x-tool-modal的设计）
    const modal = document.createElement('div');
    modal.id = 'exchange-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: ${isLightMode ? 'rgba(255, 255, 255, 0.85)' : 'rgba(0, 0, 0, 0.85)'};
      backdrop-filter: blur(20px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 28;
      animation: fadeIn 0.2s ease-out;
    `;

    // 创建弹窗内容
    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
      width: 90%;
      max-width: 380px;
      background: ${isLightMode ? 'rgba(255, 255, 255, 0.95)' : 'rgba(0, 0, 0, 0.95)'};
      border: 3px solid ${isLightMode ? 'rgba(0, 0, 0, 0.12)' : 'rgba(255, 255, 255, 0.15)'};
      padding: 16px;
      position: relative;
      backdrop-filter: blur(20px);
      box-shadow: ${
        isLightMode
          ? '0 25px 80px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.8), inset 0 -1px 0 rgba(0, 0, 0, 0.1)'
          : '0 25px 80px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.1), inset 0 -1px 0 rgba(0, 0, 0, 0.5)'
      };
      clip-path: polygon(
        16px 0,
        calc(100% - 8px) 0,
        100% 8px,
        100% calc(100% - 40px),
        calc(100% - 20px) calc(100% - 20px),
        calc(100% - 40px) 100%,
        0 100%,
        0 16px
      );
    `;

    modalContent.innerHTML = `
      <style>
        @keyframes exchangeFadeIn {
          from { opacity: 0; transform: scale(0.95); }
          to { opacity: 1; transform: scale(1); }
        }
        @keyframes exchangeScanMove {
          from { transform: translateY(0); }
          to { transform: translateY(400px); }
        }
        @keyframes exchangePulse {
          0%, 100% { opacity: 0.3; }
          50% { opacity: 1; box-shadow: 0 0 8px ${isLightMode ? 'rgba(0, 0, 0, 0.6)' : 'rgba(255, 255, 255, 0.6)'}; }
        }
        @keyframes exchangeFloat {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(-6px); }
        }
        #exchange-modal-content {
          animation: exchangeFadeIn 0.3s ease-out;
        }
      </style>

      <!-- 装饰螺丝钉 -->
      <div style="
        position: absolute;
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: ${
          isLightMode
            ? 'radial-gradient(circle at 30% 30%, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.08))'
            : 'radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1))'
        };
        border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.15)'};
        box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.3);
        top: 20px;
        left: 8px;
      "></div>
      <div style="
        position: absolute;
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: ${
          isLightMode
            ? 'radial-gradient(circle at 30% 30%, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.08))'
            : 'radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1))'
        };
        border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.15)'};
        box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.3);
        top: 20px;
        right: 8px;
      "></div>

      <!-- 顶部标题栏 -->
      <div style="
        padding: 8px 12px;
        margin-bottom: 12px;
        background: linear-gradient(135deg, ${isLightMode ? 'rgba(0, 0, 0, 0.04)' : 'rgba(255, 255, 255, 0.06)'} 0%, ${
      isLightMode ? 'rgba(0, 0, 0, 0.01)' : 'rgba(255, 255, 255, 0.02)'
    } 100%);
        border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.08)'};
        clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
        position: relative;
        display: flex;
        align-items: center;
        justify-content: space-between;
      ">
        <div style="
          position: absolute;
          bottom: 0;
          left: 20%;
          right: 20%;
          height: 1px;
          background: linear-gradient(90deg, transparent, ${
            isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.2)'
          }, transparent);
        "></div>

        <div style="
          font-size: 10px;
          font-weight: 700;
          color: var(--text-primary);
          letter-spacing: 2px;
          display: flex;
          align-items: center;
          gap: 4px;
        ">
          <span style="opacity: 0.5;">◆</span>
          EXCHANGE
        </div>

        <div style="display: flex; gap: 6px; align-items: center;">
          <div style="
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: ${isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.2)'};
            border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.3)'};
            animation: exchangePulse 2s infinite;
          "></div>
          <div style="
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: ${isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.2)'};
            border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.3)'};
            animation: exchangePulse 2s infinite 0.5s;
          "></div>
          <div style="
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: ${isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.2)'};
            border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.2)' : 'rgba(255, 255, 255, 0.3)'};
            animation: exchangePulse 2s infinite 1s;
          "></div>
        </div>
      </div>

      <!-- 主屏幕区域 -->
      <div style="
        background: ${isLightMode ? 'rgba(255, 255, 255, 0.7)' : 'rgba(0, 0, 0, 0.7)'};
        border: 2px solid ${isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.08)'};
        padding: 14px;
        position: relative;
        overflow: hidden;
        box-shadow: ${
          isLightMode
            ? 'inset 0 2px 10px rgba(0, 0, 0, 0.1), inset 0 0 0 1px rgba(0, 0, 0, 0.05)'
            : 'inset 0 2px 10px rgba(0, 0, 0, 0.6), inset 0 0 0 1px rgba(255, 255, 255, 0.05)'
        };
        clip-path: polygon(0 0, 100% 0, 100% calc(100% - 12px), calc(100% - 12px) 100%, 0 100%);
      ">
        <!-- 扫描线 -->
        <div style="
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          height: 100%;
          background: repeating-linear-gradient(
            0deg,
            transparent,
            transparent 2px,
            ${isLightMode ? 'rgba(0, 0, 0, 0.02)' : 'rgba(255, 255, 255, 0.03)'} 2px,
            ${isLightMode ? 'rgba(0, 0, 0, 0.02)' : 'rgba(255, 255, 255, 0.03)'} 4px
          );
          pointer-events: none;
          z-index: 1;
        "></div>

        <!-- 装饰点 -->
        <div style="
          position: absolute;
          top: 6px;
          left: 6px;
          display: flex;
          gap: 3px;
          z-index: 5;
        ">
          <div style="width: 3px; height: 3px; border-radius: 50%; background: ${
            isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.2)'
          };"></div>
          <div style="width: 3px; height: 3px; border-radius: 50%; background: ${
            isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.2)'
          };"></div>
          <div style="width: 3px; height: 3px; border-radius: 50%; background: ${
            isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.2)'
          };"></div>
        </div>

        <!-- 关闭按钮 -->
        <div onclick="document.getElementById('exchange-modal').remove();" style="
          position: absolute;
          top: 8px;
          right: 8px;
          width: 28px;
          height: 28px;
          background: ${isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.08)'};
          border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.12)' : 'rgba(255, 255, 255, 0.15)'};
          border-radius: 50%;
          cursor: pointer;
          z-index: 10;
          transition: all 0.3s;
          display: flex;
          align-items: center;
          justify-content: center;
          box-shadow: 0 2px 8px ${isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(0, 0, 0, 0.2)'};
        " onmouseover="this.style.background='${
          isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.15)'
        }'; this.style.transform='rotate(90deg)';" onmouseout="this.style.background='${
      isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.08)'
    }'; this.style.transform='rotate(0deg)';">
          <div style="position: relative; width: 100%; height: 100%;">
            <div style="
              position: absolute;
              top: 50%;
              left: 50%;
              width: 12px;
              height: 2px;
              background: var(--text-primary);
              border-radius: 1px;
              transform: translate(-50%, -50%) rotate(45deg);
            "></div>
            <div style="
              position: absolute;
              top: 50%;
              left: 50%;
              width: 12px;
              height: 2px;
              background: var(--text-primary);
              border-radius: 1px;
              transform: translate(-50%, -50%) rotate(-45deg);
            "></div>
          </div>
        </div>

        <!-- 标题 -->
        <div style="
          font-size: 11px;
          font-weight: 700;
          color: var(--text-primary);
          letter-spacing: 3px;
          text-align: center;
          margin-bottom: 14px;
          text-transform: uppercase;
          position: relative;
          z-index: 2;
          text-shadow: 0 1px 2px ${isLightMode ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.3)'};
        ">▪ COIN EXCHANGE ▪</div>

        <!-- 余额和币显示 -->
        <div style="
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 8px;
          margin-bottom: 12px;
          position: relative;
          z-index: 2;
        ">
          <div style="
            padding: 10px;
            background: ${isLightMode ? 'rgba(0, 0, 0, 0.04)' : 'rgba(255, 255, 255, 0.04)'};
            border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.08)'};
            clip-path: polygon(8px 0, calc(100% - 8px) 0, 100% 8px, 100% 100%, 0 100%, 0 8px);
            position: relative;
            box-shadow: ${
              isLightMode
                ? 'inset 0 1px 0 rgba(0, 0, 0, 0.05), 0 2px 4px rgba(0, 0, 0, 0.05)'
                : 'inset 0 1px 0 rgba(255, 255, 255, 0.05), 0 2px 4px rgba(0, 0, 0, 0.1)'
            };
          ">
            <div style="
              position: absolute;
              top: 50%;
              left: 6px;
              transform: translateY(-50%);
              font-size: 12px;
              opacity: 0.3;
            ">$</div>
            <div style="
              font-size: 8px;
              color: ${isLightMode ? 'rgba(0, 0, 0, 0.5)' : 'rgba(255, 255, 255, 0.6)'};
              text-transform: uppercase;
              letter-spacing: 1px;
              margin-bottom: 4px;
              text-align: center;
            ">WALLET</div>
            <div style="
              font-size: 16px;
              font-weight: 700;
              color: var(--text-primary);
              font-family: 'Courier New', monospace;
              text-align: center;
              text-shadow: 0 1px 2px ${isLightMode ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.3)'};
            ">${walletData.balance.toFixed(2)}</div>
          </div>

          <div style="
            padding: 10px;
            background: ${isLightMode ? 'rgba(0, 0, 0, 0.04)' : 'rgba(255, 255, 255, 0.04)'};
            border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.08)'};
            clip-path: polygon(8px 0, calc(100% - 8px) 0, 100% 8px, 100% 100%, 0 100%, 0 8px);
            position: relative;
            box-shadow: ${
              isLightMode
                ? 'inset 0 1px 0 rgba(0, 0, 0, 0.05), 0 2px 4px rgba(0, 0, 0, 0.05)'
                : 'inset 0 1px 0 rgba(255, 255, 255, 0.05), 0 2px 4px rgba(0, 0, 0, 0.1)'
            };
          ">
            <div style="
              position: absolute;
              top: 50%;
              left: 6px;
              transform: translateY(-50%);
              font-size: 12px;
              opacity: 0.3;
            ">●</div>
            <div style="
              font-size: 8px;
              color: ${isLightMode ? 'rgba(0, 0, 0, 0.5)' : 'rgba(255, 255, 255, 0.6)'};
              text-transform: uppercase;
              letter-spacing: 1px;
              margin-bottom: 4px;
              text-align: center;
            ">COINS</div>
            <div style="
              font-size: 16px;
              font-weight: 700;
              color: var(--text-primary);
              font-family: 'Courier New', monospace;
              text-align: center;
              text-shadow: 0 1px 2px ${isLightMode ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.3)'};
            ">${toolCoins}</div>
          </div>
        </div>

        <!-- 兑换率说明 -->
        <div style="
          padding: 8px 10px;
          background: ${isLightMode ? 'rgba(0, 0, 0, 0.03)' : 'rgba(255, 255, 255, 0.04)'};
          border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.06)' : 'rgba(255, 255, 255, 0.06)'};
          margin-bottom: 12px;
          position: relative;
          z-index: 2;
          clip-path: polygon(6px 0, calc(100% - 6px) 0, 100% 6px, 100% 100%, 0 100%, 0 6px);
        ">
          <div style="
            font-size: 9px;
            color: ${isLightMode ? 'rgba(0, 0, 0, 0.5)' : 'rgba(255, 255, 255, 0.6)'};
            text-align: center;
            font-family: 'Courier New', monospace;
            letter-spacing: 0.5px;
          ">RATE: $100 = 1 COIN</div>
        </div>

        <!-- 输入区域 -->
        <div style="margin-bottom: 12px; position: relative; z-index: 2;">
          <label style="
            display: block;
            font-size: 8px;
            color: ${isLightMode ? 'rgba(0, 0, 0, 0.5)' : 'rgba(255, 255, 255, 0.6)'};
            margin-bottom: 6px;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
          ">AMOUNT ($)</label>
          <input
            type="number"
            id="exchange-amount-input"
            placeholder="0.00"
            min="0"
            step="0.01"
            style="
              width: 100%;
              padding: 10px 12px;
              background: ${isLightMode ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.4)'};
              border: 2px solid ${isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.15)'};
              font-size: 16px;
              color: var(--text-primary);
              font-family: 'Courier New', monospace;
              font-weight: 700;
              transition: all 0.2s;
              box-sizing: border-box;
              clip-path: polygon(6px 0, calc(100% - 6px) 0, 100% 6px, 100% calc(100% - 6px), calc(100% - 6px) 100%, 6px 100%, 0 calc(100% - 6px), 0 6px);
              box-shadow: ${
                isLightMode
                  ? 'inset 0 2px 4px rgba(0, 0, 0, 0.08), 0 2px 4px rgba(0, 0, 0, 0.05)'
                  : 'inset 0 2px 4px rgba(0, 0, 0, 0.4), 0 2px 4px rgba(0, 0, 0, 0.1)'
              };
            "
            oninput="updateExchangePreview()"
            onfocus="this.style.borderColor='${
              isLightMode ? 'rgba(0, 0, 0, 0.25)' : 'rgba(255, 255, 255, 0.3)'
            }'; this.style.background='${isLightMode ? 'rgba(255, 255, 255, 1)' : 'rgba(0, 0, 0, 0.6)'}'"
            onblur="this.style.borderColor='${
              isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.15)'
            }'; this.style.background='${isLightMode ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.4)'}'"
          />
        </div>

        <!-- 预览区域 -->
        <div id="exchange-preview" style="
          padding: 14px;
          background: ${isLightMode ? 'rgba(0, 0, 0, 0.04)' : 'rgba(255, 255, 255, 0.06)'};
          border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.08)'};
          margin-bottom: 12px;
          min-height: 60px;
          display: flex;
          align-items: center;
          justify-content: center;
          position: relative;
          z-index: 2;
          clip-path: polygon(0 6px, 6px 0, calc(100% - 6px) 0, 100% 6px, 100% calc(100% - 6px), calc(100% - 6px) 100%, 6px 100%, 0 calc(100% - 6px));
          box-shadow: ${isLightMode ? 'inset 0 2px 6px rgba(0, 0, 0, 0.06)' : 'inset 0 2px 6px rgba(0, 0, 0, 0.3)'};
        ">
          <div style="
            font-size: 10px;
            color: ${isLightMode ? 'rgba(0, 0, 0, 0.4)' : 'rgba(255, 255, 255, 0.4)'};
            text-align: center;
            font-family: 'Courier New', monospace;
            letter-spacing: 0.5px;
          ">ENTER AMOUNT</div>
        </div>

        <!-- 按钮组 -->
        <div style="display: flex; gap: 8px; position: relative; z-index: 2;">
          <button onclick="document.getElementById('exchange-modal').remove();" style="
            flex: 1;
            padding: 10px 6px;
            background: linear-gradient(135deg, ${
              isLightMode ? 'rgba(0, 0, 0, 0.06)' : 'rgba(255, 255, 255, 0.06)'
            } 0%, ${isLightMode ? 'rgba(0, 0, 0, 0.03)' : 'rgba(255, 255, 255, 0.03)'} 100%);
            border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.12)' : 'rgba(255, 255, 255, 0.15)'};
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            clip-path: polygon(6px 0, 100% 0, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0 100%, 0 6px);
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 6px ${isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(0, 0, 0, 0.2)'};
          " onmouseover="this.style.background='linear-gradient(135deg, ${
            isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)'
          } 0%, ${
      isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)'
    } 100%)'; this.style.transform='translateY(-2px)';" onmouseout="this.style.background='linear-gradient(135deg, ${
      isLightMode ? 'rgba(0, 0, 0, 0.06)' : 'rgba(255, 255, 255, 0.06)'
    } 0%, ${
      isLightMode ? 'rgba(0, 0, 0, 0.03)' : 'rgba(255, 255, 255, 0.03)'
    } 100%)'; this.style.transform='translateY(0)';">
            CANCEL
          </button>

          <button onclick="confirmExchange()" style="
            flex: 1;
            padding: 10px 6px;
            background: linear-gradient(135deg, ${
              isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)'
            } 0%, ${isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)'} 100%);
            border: 1px solid ${isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.15)'};
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            clip-path: polygon(6px 0, 100% 0, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0 100%, 0 6px);
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 6px ${isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(0, 0, 0, 0.2)'};
          " onmouseover="this.style.background='linear-gradient(135deg, ${
            isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.15)'
          } 0%, ${
      isLightMode ? 'rgba(0, 0, 0, 0.08)' : 'rgba(255, 255, 255, 0.08)'
    } 100%)'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 10px ${
      isLightMode ? 'rgba(0, 0, 0, 0.15)' : 'rgba(0, 0, 0, 0.3)'
    }'" onmouseout="this.style.background='linear-gradient(135deg, ${
      isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)'
    } 0%, ${
      isLightMode ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)'
    } 100%)'; this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 6px ${
      isLightMode ? 'rgba(0, 0, 0, 0.1)' : 'rgba(0, 0, 0, 0.2)'
    }'">
            CONFIRM
          </button>
        </div>
      </div>
    `;

    modal.appendChild(modalContent);
    document.body.appendChild(modal);

    // 点击遮罩关闭
    modal.addEventListener('click', function (e) {
      if (e.target === modal) {
        modal.remove();
      }
    });

    // 聚焦输入框
    setTimeout(() => {
      const input = document.getElementById('exchange-amount-input');
      if (input) input.focus();
    }, 100);
  }

  // 更新兑换预览
  function updateExchangePreview() {
    const input = document.getElementById('exchange-amount-input');
    const preview = document.getElementById('exchange-preview');

    if (!input || !preview) return;

    const amount = parseFloat(input.value) || 0;
    const xSocialScreen = document.getElementById('x-social-screen');
    const isLightMode = xSocialScreen && xSocialScreen.classList.contains('x-theme-light');

    if (amount <= 0) {
      preview.innerHTML = `
        <div style="
          font-size: 10px;
          color: ${isLightMode ? 'rgba(0, 0, 0, 0.4)' : 'rgba(255, 255, 255, 0.4)'};
          text-align: center;
          font-family: 'Courier New', monospace;
          letter-spacing: 0.5px;
        ">ENTER AMOUNT</div>
      `;
      return;
    }

    const coinsToGet = Math.floor(amount / 100);

    if (coinsToGet === 0) {
      preview.innerHTML = `
        <div style="
          font-size: 9px;
          color: ${isLightMode ? 'rgba(0, 0, 0, 0.5)' : 'rgba(255, 255, 255, 0.5)'};
          text-align: center;
          font-family: 'Courier New', monospace;
          letter-spacing: 0.5px;
          line-height: 1.4;
        ">MIN: $100<br>FOR 1 COIN</div>
      `;
    } else {
      preview.innerHTML = `
        <div style="text-align: center;">
          <div style="
            font-size: 8px;
            color: ${isLightMode ? 'rgba(0, 0, 0, 0.5)' : 'rgba(255, 255, 255, 0.6)'};
            margin-bottom: 6px;
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
            text-transform: uppercase;
          ">YOU WILL GET</div>
          <div style="
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
            text-shadow: 0 1px 2px ${isLightMode ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.3)'};
          ">+${coinsToGet} COIN${coinsToGet > 1 ? 'S' : ''}</div>
          ${
            amount % 100 !== 0
              ? `
            <div style="
              font-size: 7px;
              color: ${isLightMode ? 'rgba(0, 0, 0, 0.4)' : 'rgba(255, 255, 255, 0.4)'};
              margin-top: 6px;
              font-family: 'Courier New', monospace;
              letter-spacing: 0.5px;
            ">REMAIN: $${(amount % 100).toFixed(2)}</div>
          `
              : ''
          }
        </div>
      `;
    }
  }

  // 确认兑换
  async function confirmExchange() {
    const input = document.getElementById('exchange-amount-input');
    if (!input) return;

    const amount = parseFloat(input.value) || 0;

    // 验证输入
    if (amount <= 0) {
      showXToast('请输入有效的兑换金额', 'error');
      return;
    }

    if (amount < 100) {
      showXToast('最少需要 $100 才能兑换', 'error');
      return;
    }

    // 计算能兑换的coins（向下取整）
    const coinsToAdd = Math.floor(amount / 100);
    const actualCost = coinsToAdd * 100;

    // 检查余额
    if (walletData.balance < actualCost) {
      showXToast(`余额不足！需要 $${actualCost.toFixed(2)}，当前余额 $${walletData.balance.toFixed(2)}`, 'error');
      return;
    }

    try {
      // 扣除钱包金额
      walletData.balance -= actualCost;

      // 增加 toolCoins
      toolCoins += coinsToAdd;

      // 创建交易记录
      const transaction = {
        id: 'coin_exchange_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        description: `Exchange to ${coinsToAdd} Coin${coinsToAdd > 1 ? 's' : ''}`,
        amount: -actualCost,
        timestamp: new Date().toISOString(),
        type: 'coin_exchange',
      };
      walletData.transactions.unshift(transaction);

      // 保存钱包数据
      if (typeof saveWalletData === 'function') {
        await saveWalletData();
      }

      // 保存道具数据
      await saveToolData();

      // 更新UI
      updateToolStats();

      // 关闭弹窗
      const modal = document.getElementById('exchange-modal');
      if (modal) modal.remove();

      // 显示成功提示
      showXToast(`兑换成功！获得 ${coinsToAdd} Coin${coinsToAdd > 1 ? 's' : ''}`, 'success');

      console.log(`✅ 兑换成功: $${actualCost} → ${coinsToAdd} Coins`);
    } catch (error) {
      console.error('❌ 兑换失败:', error);
      showXToast('兑换失败: ' + error.message, 'error');

      // 回滚数据
      walletData.balance += actualCost;
      toolCoins -= coinsToAdd;
    }
  }

  // 渲染道具卡片（支持分页）
  function renderToolCards() {
    const grid = document.getElementById('tool-cards-grid');
    if (!grid) return;

    grid.innerHTML = '';

    // 计算当前页的道具范围
    const startIdx = (currentPage - 1) * ITEMS_PER_PAGE;
    const endIdx = startIdx + ITEMS_PER_PAGE;
    const pageItems = toolItems.slice(startIdx, endIdx);

    // 渲染当前页的12个卡片槽位
    for (let i = 0; i < ITEMS_PER_PAGE; i++) {
      const card = document.createElement('div');
      card.className = 'item-card';

      if (i < pageItems.length) {
        const item = pageItems[i];
        card.classList.add('has');
        if (item.rarity === 'rare') card.classList.add('rare');

        card.innerHTML = `
          <div class="envelope-line"></div>
          <div class="card-corner-dots"></div>
          <div class="item-icon">${item.icon}</div>
          <div class="item-name">${item.name}</div>
          <div class="item-count">${item.count}</div>
          <div class="rarity-corner"></div>
        `;
      }

      grid.appendChild(card);
    }

    updatePaginationUI();
    updateToolStats();
  }

  // 更新统计数据
  function updateToolStats() {
    const totalEl = document.getElementById('tool-total');
    const typesEl = document.getElementById('tool-types');
    const coinsEl = document.getElementById('tool-coins');

    if (totalEl) {
      const total = toolItems.reduce((sum, item) => sum + item.count, 0);
      totalEl.textContent = total;
    }

    if (typesEl) {
      typesEl.textContent = toolItems.length;
    }

    if (coinsEl) {
      coinsEl.textContent = toolCoins;
    }
  }

  // 开机进度条动画（全局引用，用于AI生成完毕后控制）
  let bootAnimationInterval = null;
  let bootAnimationPercent = 0;

  // 开机进度条动画
  function startBootAnimation() {
    bootAnimationPercent = 0;
    const percentEl = document.getElementById('tool-boot-percent');
    const fillEl = document.querySelector('.tool-boot-progress-fill'); // 🔧 获取进度条fill元素

    console.log('🎬 [开机动画] 启动缓慢的开机进度条...');

    // 🔧 非常缓慢的进度条：每次增加0.5%，间隔300ms
    // 到达90%需要：(90/0.5) * 300ms = 54秒
    // 这样即使AI生成很慢，进度条也不会先跑完
    bootAnimationInterval = setInterval(() => {
      if (bootAnimationPercent < 90) {
        bootAnimationPercent += 0.5;
        if (percentEl) {
          percentEl.textContent = Math.floor(bootAnimationPercent) + '%';
        }
        // 🔧 手动控制进度条宽度（CSS自动动画已禁用）
        if (fillEl) {
          fillEl.style.width = bootAnimationPercent + '%';
        }
      } else {
        // 到达90%后暂停，等待AI生成完毕
        if (bootAnimationPercent === 90 || bootAnimationPercent === 90.5) {
          console.log('⏸️ [开机动画] 进度条到达90%，等待AI生成完毕...');
        }
      }
    }, 300); // 每300ms增加0.5%
  }

  // 完成开机动画（AI生成完毕后调用）
  function finishBootAnimation() {
    const percentEl = document.getElementById('tool-boot-percent');
    const fillEl = document.querySelector('.tool-boot-progress-fill'); // 🔧 获取进度条fill元素

    console.log('🚀 [开机动画] AI生成完毕，快速完成进度条...');

    // 清除原有的慢速interval
    if (bootAnimationInterval) {
      clearInterval(bootAnimationInterval);
      bootAnimationInterval = null;
    }

    // 快速从当前进度跑到100%
    const fastInterval = setInterval(() => {
      if (bootAnimationPercent < 100) {
        bootAnimationPercent += 5; // 快速增加5%
        if (percentEl) {
          percentEl.textContent = Math.floor(bootAnimationPercent) + '%';
        }
        // 🔧 手动控制进度条宽度（CSS自动动画已禁用）
        if (fillEl) {
          fillEl.style.width = bootAnimationPercent + '%';
        }
      } else {
        clearInterval(fastInterval);
        console.log('✅ [开机动画] 进度条已完成100%');
      }
    }, 50); // 每50ms增加5%，快速完成
  }

  // ============================================
  // 第五部分：弹窗创建和控制
  // ============================================

  // 创建道具弹窗HTML
  function createToolModal() {
    const existingModal = document.getElementById('x-tool-modal');
    if (existingModal) {
      console.log('⚠️ 道具弹窗已存在，跳过创建');
      return;
    }

    const modalContainer = document.createElement('div');
    modalContainer.id = 'x-tool-modal';
    modalContainer.innerHTML = `
      <!-- 开机画面 -->
      <div class="tool-boot-screen" id="tool-boot-screen">
        <div class="tool-boot-shell">
          <div class="tool-boot-scanline"></div>
          <div class="tool-boot-content">
            <div class="tool-boot-icon">◆</div>
            <div class="tool-boot-logo">INVENTORY</div>
            <div class="tool-boot-info">
              <div class="tool-boot-info-item">
                <span>SYSTEM</span>
                <span>v3.0.1</span>
              </div>
              <div class="tool-boot-info-item">
                <span>BUILD</span>
                <span>20250129</span>
              </div>
              <div class="tool-boot-info-item">
                <span>MODE</span>
                <span>STANDARD</span>
              </div>
            </div>
            <div class="tool-boot-progress">
              <div class="tool-boot-progress-label">Loading Assets...</div>
              <div class="tool-boot-progress-bar">
                <div class="tool-boot-progress-fill"></div>
                <div class="tool-boot-progress-percent" id="tool-boot-percent">0%</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- PSP掌机外壳 -->
      <div class="psp-shell">
        <div class="psp-top">
          <div class="psp-logo">
            <span>◆</span>
            INVENTORY
          </div>
          <div class="psp-leds">
            <div class="led"></div>
            <div class="led"></div>
            <div class="led"></div>
          </div>
        </div>

        <div class="psp-screen">
          <div class="screen-scanline"></div>
          <div class="screen-dots">
            <div class="screen-dot"></div>
            <div class="screen-dot"></div>
            <div class="screen-dot"></div>
          </div>
          <div class="tool-close-btn" onclick="closeToolModal()"></div>

          <div class="screen-title">▪ ITEMS ▪</div>

          <div class="content-split">
            <div class="cards-area" id="tool-cards-grid"></div>

            <div class="gacha-machine">
              <div class="gacha-dome">
                <div class="gacha-ball" id="gacha-ball" onclick="shakeBall()"></div>
              </div>
              <div class="gacha-btns">
                <button class="gacha-btn" onclick="rollOne()">
                  ROLL 1
                  <div class="gacha-cost">-100</div>
                </button>
                <button class="gacha-btn" onclick="rollTen()">
                  ROLL 10
                  <div class="gacha-cost">-900</div>
                </button>
              </div>
              <div class="utility-btns">
                <button class="utility-btn" onclick="openToolShop()">
                  <svg viewBox="0 0 24 24">
                    <path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zM1 2v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1H5.21l-.94-2H1zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2z"/>
                  </svg>
                  SHOP
                </button>
                <button class="utility-btn" onclick="openCoinExchange()">
                  <svg viewBox="0 0 24 24">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"/>
                    <path d="M7.41 8.59L6 10l6 6 6-6-1.41-1.41L12 13.17z" transform="rotate(180 12 12)"/>
                  </svg>
                  EXCHANGE
                </button>
              </div>

              <div class="pagination-control">
                <div class="page-arrow left" id="page-prev" onclick="previousPage()"></div>
                <div class="page-info" id="page-info">1/1</div>
                <div class="page-arrow right" id="page-next" onclick="nextPage()"></div>
              </div>
            </div>
          </div>

          <div class="stats-bar">
            <div class="stat" data-icon="■">
              <div class="stat-val" id="tool-total">0</div>
              <div class="shop-stat-label">Total</div>
            </div>
            <div class="stat" data-icon="◆">
              <div class="stat-val" id="tool-types">0</div>
              <div class="shop-stat-label">Types</div>
            </div>
            <div class="stat" data-icon="●">
              <div class="stat-val" id="tool-coins">1000</div>
              <div class="shop-stat-label">Coins</div>
            </div>
          </div>
        </div>

        <div class="psp-controls">
          <div class="dpad">
            <div class="dpad-btn up"></div>
            <div class="dpad-btn down"></div>
            <div class="dpad-btn left"></div>
            <div class="dpad-btn right"></div>
          </div>
          <div class="action-btns">
            <div class="shop-action-btn">×</div>
            <div class="shop-action-btn">○</div>
            <div class="shop-action-btn">□</div>
            <div class="shop-action-btn">△</div>
          </div>
        </div>
      </div>
    `;

    // 添加到#x-social-screen容器内，确保主题样式生效
    const xSocialScreen = document.getElementById('x-social-screen');
    if (xSocialScreen) {
      xSocialScreen.appendChild(modalContainer);
      console.log('✅ 道具弹窗HTML已创建（已添加到x-social-screen内）');
    } else {
      document.body.appendChild(modalContainer);
      console.log('⚠️ 道具弹窗HTML已创建（降级到body）');
    }
  }

  // 打开道具弹窗
  async function openToolModal() {
    try {
      // 确保数据库表存在
      await ensureToolDatabaseSchema();

      // 确保样式已注入
      injectToolStyles();

      // 确保弹窗HTML已创建
      createToolModal();

      // 显示弹窗
      const modal = document.getElementById('x-tool-modal');
      if (modal) {
        modal.style.display = 'flex';
      }

      // 启动开机动画
      startBootAnimation();

      // 检查是否首次进入（触发第十七情景）
      const db = getXDB();
      const accountId = currentAccountId || 'main';
      const toolDataId = `tools_${accountId}`;
      const existingData = await db.xTools.get(toolDataId);

      if (!existingData || !existingData.scenarioGenerated) {
        // 首次进入，触发第十七情景生成
        console.log('🎮 [第十七情景] 首次进入道具系统，开始生成初始化数据...');
        await generateToolScenario();
      } else {
        // 非首次进入，直接加载数据
        console.log('📦 [道具系统] 非首次进入，快速加载数据...');
        await loadToolData();

        // 🔧 数据加载完毕后，快速完成进度条并关闭开机画面
        finishBootAnimation();

        setTimeout(() => {
          const bootScreen = document.querySelector('.tool-boot-screen');
          if (bootScreen) {
            bootScreen.style.animation = 'toolBootFadeOut 0.5s ease-out forwards';
          }
          console.log('🎬 [道具系统] 开机画面已关闭（非首次进入）');
        }, 1500); // 等待进度条完成
      }

      // 渲染道具卡片
      renderToolCards();

      console.log('✅ 道具弹窗已打开');
    } catch (error) {
      console.error('❌ 打开道具弹窗失败:', error);
      showXToast('打开道具系统失败: ' + error.message, 'error');
    }
  }

  // 关闭道具弹窗
  function closeToolModal() {
    const modal = document.getElementById('x-tool-modal');
    if (modal) {
      modal.style.display = 'none';
    }
    console.log('✅ 道具弹窗已关闭');
  }

  // ============================================
  // 第六部分：初始化
  // ============================================

  // 将函数暴露到全局（供HTML onclick调用）
  window.openToolModal = openToolModal;
  window.closeToolModal = closeToolModal;
  window.rollOne = rollOne;
  window.rollTen = rollTen;
  window.shakeBall = shakeBall;
  window.updateExchangePreview = updateExchangePreview;
  window.confirmExchange = confirmExchange;

  console.log('📦 X Tool System 模块已加载');

  // 第四部分: 初始化和对外接口
  // ============================================
  // 初始化X社交应用
  async function initXSocialApp() {
    try {
      console.log("🚀 初始化 X Social App..."); // 0. 清理之前的定时器和状态（防止重复初始化导致的问题）
      if (chatHistoryDetectionTimer) {
        clearInterval(chatHistoryDetectionTimer);
        chatHistoryDetectionTimer = null;
      }
      if (autoRefreshFeedTimer) {
        clearInterval(autoRefreshFeedTimer);
        autoRefreshFeedTimer = null;
      }
      // 重置启用状态（将由恢复函数根据保存的设置决定）
      chatHistoryDetectionEnabled = false;
      autoRefreshFeedEnabled = false; // 1. 注入样式
      injectStyles(); // 2. 创建HTML结构
      createXSocialHTML(); // 3. 加载活跃账号（必须在加载用户资料之前）
      await loadActiveAccount();
      console.log(
        "📌 当前活跃账户:",
        currentAccountId,
        "(window.currentAccountId:",
        window.currentAccountId + ")"
      ); // 4. 加载用户资料（必须在初始化推文之前，因为推文渲染需要userProfileData）
      await loadUserProfile(); // 5. 初始化X设置（按账号加载）
      await initializeXSettings();

      // 🔧 强制重置：确保世界运转大事件默认关闭（仅允许用户手动开启）
      try {
        const xDb = getXDB();
        const worldEventsDataId = `worldEvents_${currentAccountId || "main"}`;
        const worldEventsData = await xDb.xWorldEvents.get(worldEventsDataId);
        if (worldEventsData && worldEventsData.enabled) {
          worldEventsData.enabled = false;
          await xDb.xWorldEvents.put(worldEventsData);
          console.log(
            "🔴 [世界大事件] 已强制重置为关闭状态（仅允许用户手动开启）"
          );
        }
        const settingsId = `xSettings_${currentAccountId || "main"}`;
        let settings = await xDb.xSettings.get(settingsId);
        if (settings && settings.worldEventsEnabled) {
          settings.worldEventsEnabled = false;
          await xDb.xSettings.put(settings);
          console.log("🔴 [设置] 已强制重置世界大事件开关为关闭");
        }
      } catch (error) {
        console.error("强制重置世界大事件状态失败:", error);
      }

      // 6. 初始化推文数据（依赖userProfileData，必须在loadUserProfile之后）
      await initializeTweets(); // 7. 绑定所有事件处理器
      bindEventHandlers(); // 8. 更新UI显示（确保用户资料正确显示）
      loadUserProfileToUI(); // 9. 加载主题偏好
      await loadXThemePreference(); // 10. 加载主题色偏好
      await loadAccentColorPreference(); // 11. 启动后台自动发消息系统（如果有角色启用了该功能）
      setTimeout(() => {
        if (typeof startAutoMessageSystem === "function") {
          startAutoMessageSystem();
        }
      }, 120000); // 延迟2分钟启动，确保所有数据已加载
      // 11.5. 启动粉丝数动态浮动系统
      setTimeout(() => {
        if (typeof startFollowersFluctuationSystem === "function") {
          startFollowersFluctuationSystem();
        }
      }, 120000); // 延迟2分钟启动，确保所有数据已加载
      // 12. 🔧 已移除智能刷新主页状态的自动恢复功能（改为用户手动开启）
      // setTimeout(() => {
      // restoreAutoRefreshFeedState(); // }, 120000); // 13. 🔧 已移除聊天记忆检测状态的自动恢复功能（改为用户手动开启）
      // setTimeout(() => {
      // restoreChatHistoryDetectionState();
      // }, 120000);

      // 14. 🔧 修复：已移除世界运转大事件状态的自动恢复功能（改为用户手动开启）
      // setTimeout(() => {
      //   if (typeof restoreWorldEventsState === "function") {
      //     restoreWorldEventsState();
      //   }
      // }, 1000); // 延迟1秒，确保UI已加载

      // 15. 显示一次性欢迎弹窗
      await showWelcomePopup();

      console.log("✅ X Social App 初始化完成");
      console.log("💡 [提示] 智能刷新和智能检测需要手动开启");
    } catch (error) {
      console.error("❌ X Social App 初始化失败:", error);
      showXToast("应用初始化失败: " + error.message, "error");
    }
  }

  // ============================================
  // 一次性欢迎弹窗功能
  // ============================================

  // 显示一次性欢迎弹窗
  async function showWelcomePopup() {
    try {
      // 🆕 定义当前弹窗内容版本（内容变化时修改此版本号）
      const currentPopupVersion = "v2.7"; // 修改版本号以触发重新显示
      const currentPopupContent = `地图更新+道具更新
+城市日报和地标事件+道具系统的一部分简陋内容
+乘车功能未完善请不要使用！！`;

      // 检查是否已经显示过此版本的弹窗
      const lastShownVersion = localStorage.getItem(
        "x-app-welcome-popup-version"
      );
      if (lastShownVersion === currentPopupVersion) {
        console.log("🎉 当前版本弹窗已显示过，跳过");
        return;
      }

      console.log("🎉 显示欢迎弹窗 (版本:", currentPopupVersion + ")");

      // 注入像素字体样式
      const fontStyle = document.createElement("style");
      fontStyle.id = "pixel-font-style";
      fontStyle.textContent = `
 @import url("https://fontsapi.zeoseven.com/569/main/result.css");

 .pixel-font {
 font-family: "Fusion Pixel 10px P zh_hans", monospace;
 font-weight: normal;
 }
 `;
      document.head.appendChild(fontStyle);

      // 创建弹窗
      const popup = document.createElement("div");
      popup.id = "welcome-popup";
      popup.style.cssText = `
 position: fixed;
 top: 0;
 left: 0;
 width: 100vw;
 height: 100vh;
 background: rgba(0, 0, 0, 0.5);
 display: flex;
 align-items: center;
 justify-content: center;
 z-index: 99999;
 font-family: "Fusion Pixel 10px P zh_hans", monospace;
 `;

      popup.innerHTML = `
 <div style="
 background: #c0c0c0;
 border: 3px outset #c0c0c0;
 border-image: none;
 width: 400px;
 max-width: 90%;
 box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.5);
 font-family: 'Fusion Pixel 10px P zh_hans', monospace;
 ">
 <!-- 标题栏 -->
 <div style="
 background: linear-gradient(90deg, #0000ff 0%, #000080 100%);
 color: white;
 padding: 2px 4px;
 font-size: 11px;
 display: flex;
 align-items: center;
 justify-content: space-between;
 font-family: 'Fusion Pixel 10px P zh_hans', monospace;
 ">
 <span style="font-weight: bold;">吃点羊提醒您</span>
 <button id="welcome-popup-close" style="
 background: #c0c0c0;
 border: 1px outset #c0c0c0;
 color: black;
 font-size: 10px;
 width: 16px;
 height: 14px;
 padding: 0;
 cursor: pointer;
 font-family: 'Fusion Pixel 10px P zh_hans', monospace;
 font-weight: bold;
 ">×</button>
 </div>

 <!-- 内容区域 -->
 <div style="
 padding: 16px;
 background: #c0c0c0;
 font-family: 'Fusion Pixel 10px P zh_hans', monospace;
 ">
 <div style="
 display: flex;
 align-items: flex-start;
 gap: 12px;
 margin-bottom: 12px;
 ">
 <!-- 图标 -->
 <div style="
 width: 32px;
 height: 32px;
 background: #ffff00;
 border: 2px inset #c0c0c0;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 16px;
 flex-shrink: 0;
 ">💡</div>

 <!-- 消息内容 -->
 <div style="
 flex: 1;
 font-size: 11px;
 line-height: 1.4;
 color: #000;
 font-family: 'Fusion Pixel 10px P zh_hans', monospace;
 ">
 <div style="font-weight: bold; margin-bottom: 6px;">吃点羊提醒您：</div>
            <div style="font-weight: bold; margin-bottom: 8px;">地图更新+道具更新</div>
            <div style="margin-bottom: 4px;">+城市日报和地标事件+道具系统的一部分简陋内容</div>
            <div style="margin-bottom: 4px;">+乘车功能未完善请不要使用！！</div>
            <div>+一些小彩蛋</div>
 </div>
 </div>

 <!-- 按钮区域 -->
 <div style="
 display: flex;
 justify-content: center;
 gap: 8px;
 margin-top: 16px;
 ">
 <button id="welcome-popup-ok" style="
 background: #c0c0c0;
 border: 2px outset #c0c0c0;
 color: black;
 font-size: 11px;
 padding: 4px 16px;
 cursor: pointer;
 font-family: 'Fusion Pixel 10px P zh_hans', monospace;
 min-width: 60px;
 ">确定</button>
 </div>
 </div>
 </div>
 `;

      // 添加到x-social-screen容器或body
      const xSocialScreen = document.getElementById("x-social-screen");
      if (xSocialScreen) {
        xSocialScreen.appendChild(popup);
      } else {
        document.body.appendChild(popup);
      }

      // 绑定关闭事件
      const closeBtn = document.getElementById("welcome-popup-close");
      const okBtn = document.getElementById("welcome-popup-ok");

      const closePopup = () => {
        popup.remove();
        // 🆕 保存当前版本号而不是简单的true标记
        localStorage.setItem(
          "x-app-welcome-popup-version",
          currentPopupVersion
        );
        console.log("✅ 欢迎弹窗已关闭，当前版本:", currentPopupVersion);
      };

      closeBtn.onclick = closePopup;
      okBtn.onclick = closePopup;

      // 点击背景关闭
      popup.onclick = (e) => {
        if (e.target === popup) {
          closePopup();
        }
      };

      // 添加按钮hover效果
      [closeBtn, okBtn].forEach((btn) => {
        btn.onmouseenter = () => {
          btn.style.border = "2px inset #c0c0c0";
        };
        btn.onmouseleave = () => {
          btn.style.border =
            btn === closeBtn ? "1px outset #c0c0c0" : "2px outset #c0c0c0";
        };
        btn.onmousedown = () => {
          btn.style.border = "2px inset #c0c0c0";
        };
        btn.onmouseup = () => {
          btn.style.border =
            btn === closeBtn ? "1px outset #c0c0c0" : "2px outset #c0c0c0";
        };
      });
    } catch (error) {
      console.error("❌ 显示欢迎弹窗失败:", error);
    }
  }

  // 渲染X社交页面 - 兼容现有HTML的调用方式
  function renderXSocialScreen() {
    console.log("🎬 渲染X社交页面"); // 如果还未初始化，先初始化
    const xScreen = document.getElementById("x-social-screen");
    if (!xScreen) {
      console.log("⚠️ X社交页面未创建，开始初始化...");
      initXSocialApp().then(() => {
        console.log("✅ 初始化完成，显示主页");
        const screen = document.getElementById("x-social-screen");
        if (screen) {
          screen.style.display = "flex";
          switchXPage("home");
        }
      });
    } else {
      console.log("✅ X社交页面已存在，直接显示"); // 确保页面可见
      xScreen.style.display = "flex";
      switchXPage("home");
    }
  }
  // 获取默认用户资料配置（统一管理）
  function getDefaultUserProfile(accountId = "main") {
    return {
      id: accountId,
      name: accountId === "main" ? "我" : "新用户",
      handle:
        accountId === "main"
          ? "@me"
          : "@newuser_" + Date.now().toString().slice(-6),
      avatar: "https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg",
      coverImage: "https://i.postimg.cc/qRzMB6nQ/default-cover.jpg",
      verified: false,
      verificationType: "none",
      bio: "欢迎来到我的X主页！",
      publicIdentity: "",
      showRealName: false,
      realName: "",
      customTag1: "科技爱好者",
      customTag1Icon: "✨",
      customTag1Color: "#71767b",
      customTag2: "2024年加入",
      customTag2Icon: "📅",
      customTag2Color: "#71767b",
      followingCount: accountId === "main" ? "156" : "0",
      followersCount: accountId === "main" ? "89" : "0",
      knownIdentityCharacters: [],
      coupleCharacterId: "",
      coupleCharacterName: "",
      lastUpdated: new Date().toISOString(),
    };
  }
  // 加载用户资料（初始化专用 - 简化版）
  async function loadUserProfile() {
    try {
      const db = getXDB();
      const accountId = currentAccountId || "main";
      const profile = await db.xUserProfile.get(accountId);
      if (profile) {
        // 更新现有对象的属性，而不是替换整个对象（保持引用一致）
        Object.assign(window.userProfileData, profile);
      } else {
        // 使用默认用户资料并保存到数据库（仅在首次初始化时）
        const defaultProfile = getDefaultUserProfile(accountId);
        Object.assign(window.userProfileData, defaultProfile);
        await db.xUserProfile.put(window.userProfileData);
        console.log("📝 已创建默认用户资料:", accountId);
      }
      // 确保必要字段存在（兼容旧数据）
      ensureProfileFields(window.userProfileData);
      console.log(
        "✅ 用户资料已加载:",
        window.userProfileData.name,
        "(账户:",
        accountId + ")"
      );
      console.log("🔍 用户资料详情:", {
        认证类型: window.userProfileData.verificationType,
        情侣角色: window.userProfileData.coupleCharacterName,
        已知身份角色数:
          window.userProfileData.knownIdentityCharacters?.length || 0,
      });
    } catch (error) {
      console.error("❌ 加载用户资料失败:", error); // 即使失败也使用默认值
      const defaultProfile = getDefaultUserProfile("main");
      Object.assign(window.userProfileData, defaultProfile);
    }
  }
  // 确保用户资料包含所有必要字段（用于数据兼容）
  function ensureProfileFields(profile) {
    if (!profile.knownIdentityCharacters) profile.knownIdentityCharacters = [];
    if (!profile.verificationType) profile.verificationType = "none";
    if (!profile.coupleCharacterId) profile.coupleCharacterId = "";
    if (!profile.coupleCharacterName) profile.coupleCharacterName = "";
    if (profile.publicIdentity === undefined) profile.publicIdentity = "";
    if (profile.showRealName === undefined) profile.showRealName = false;
    if (profile.realName === undefined) profile.realName = "";
    if (!profile.customTag1Color) profile.customTag1Color = "#71767b";
    if (!profile.customTag2Color) profile.customTag2Color = "#71767b";
  }
  // 绑定事件处理器
  function bindEventHandlers() {
    // 因为HTML是动态创建的，需要在创建后绑定所有事件
    // 绑定角色X资料表单事件
    const characterXProfileForm = document.getElementById(
      "character-x-profile-form"
    );
    if (characterXProfileForm) {
      characterXProfileForm.addEventListener("submit", saveCharacterXProfile);
      console.log("✅ 已绑定角色X资料表单提交事件");
    }
    // 绑定简介字符计数事件
    const characterXBio = document.getElementById("character-x-bio");
    if (characterXBio) {
      characterXBio.addEventListener("input", updateCharacterBioCount);
    }
    // 绑定关系表单事件
    const relationshipForm = document.getElementById("relationship-form");
    if (relationshipForm) {
      relationshipForm.addEventListener("submit", saveRelationshipForm);
      console.log("✅ 已绑定关系表单提交事件");
    }
    // 绑定关系描述字符计数事件
    const relationshipDesc = document.getElementById(
      "relationship-description"
    );
    if (relationshipDesc) {
      relationshipDesc.addEventListener("input", updateRelationshipDescCount);
    }
    // 绑定角色真实姓名字符计数事件
    const characterRealName = document.getElementById("character-real-name");
    if (characterRealName) {
      characterRealName.addEventListener(
        "input",
        updateCharacterXProfileCounts
      );
    }
    console.log("✅ 所有事件处理器已绑定");
  }
  // ============================================
  // 提问箱功能
  // ============================================
  // 提问箱数据（临时存储，后续可持久化到数据库）
  let askboxData = {
    avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
    nickname: "= =",
    prompt: "请向我匿名提问!waiting...",
    background: "https://i.postimg.cc/7LqVqxt4/mmexport1759588659314.jpg",
    answeredQuestions: [],
  }; // 提问箱多选删除相关变量
  let isAskboxMultiSelectMode = false;
  let selectedQuestions = new Set();
  let questionLongPressTimer = null; // 从数据库加载提问箱数据
  async function loadAskboxDataFromDB() {
    try {
      const xDb = getXDB();
      const accountId = currentAccountId || "main";
      const askboxId = `askbox_${accountId}`;
      const savedData = await xDb.xAskbox.get(askboxId);
      if (savedData) {
        // 从数据库加载 - 完全替换askboxData对象，避免旧数据残留
        askboxData.id = savedData.id;
        askboxData.avatar = savedData.avatar;
        askboxData.nickname = savedData.nickname;
        askboxData.prompt = savedData.prompt;
        askboxData.background = savedData.background;
        askboxData.answeredQuestions = savedData.answeredQuestions || [];
        console.log(
          "✅ 提问箱数据已从数据库加载:",
          accountId,
          "提问数:",
          askboxData.answeredQuestions.length
        );
      } else {
        // 使用默认数据并保存到数据库（为新账户创建空的提问箱）
        askboxData.id = askboxId;
        askboxData.avatar =
          "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg";
        askboxData.nickname = "= =";
        askboxData.prompt = "请向我匿名提问!waiting...";
        askboxData.background =
          "https://i.postimg.cc/7LqVqxt4/mmexport1759588659314.jpg";
        askboxData.answeredQuestions = []; // 新账户从空列表开始
        // 保存到数据库
        await xDb.xAskbox.put({
          id: askboxId,
          avatar: askboxData.avatar,
          nickname: askboxData.nickname,
          prompt: askboxData.prompt,
          background: askboxData.background,
          answeredQuestions: [],
        });
        console.log("✅ 已为新账户创建默认提问箱数据:", accountId, "提问数: 0");
      }
    } catch (error) {
      console.error("❌ 加载提问箱数据失败:", error);
    }
  }
  // 保存提问箱数据到数据库
  async function saveAskboxDataToDB() {
    try {
      const xDb = getXDB();
      const accountId = currentAccountId || "main";
      const askboxId = `askbox_${accountId}`;
      askboxData.id = askboxId;
      await xDb.xAskbox.put(askboxData);
      console.log("✅ 提问箱数据已保存到数据库:", accountId);
    } catch (error) {
      console.error("❌ 保存提问箱数据失败:", error);
    }
  }
  // 加载提问箱数据到UI
  async function loadAskboxData() {
    // 从数据库加载
    await loadAskboxDataFromDB(); // 更新UI
    const avatarEl = document.getElementById("askbox-avatar");
    const nicknameEl = document.getElementById("askbox-nickname");
    const promptEl = document.getElementById("askbox-prompt");
    const backgroundEl = document.getElementById("askbox-background");
    if (avatarEl) avatarEl.src = askboxData.avatar;
    if (nicknameEl) nicknameEl.textContent = askboxData.nickname;
    if (promptEl) promptEl.textContent = askboxData.prompt;
    if (backgroundEl)
      backgroundEl.style.backgroundImage = `url('${askboxData.background}')`; // 渲染已回答的提问列表
    renderAnsweredQuestions();
  }
  // 修改提问箱头像
  async function changeAskboxAvatar() {
    const newAvatar = prompt("请输入新的头像URL:", askboxData.avatar);
    if (newAvatar && newAvatar.trim()) {
      askboxData.avatar = newAvatar.trim();
      const avatarEl = document.getElementById("askbox-avatar");
      if (avatarEl) avatarEl.src = askboxData.avatar; // 保存到数据库
      await saveAskboxDataToDB();
      showXToast("头像已更新并保存", "success");
    }
  }
  // 保存提问箱昵称（原处编辑）
  async function saveAskboxNickname() {
    const nicknameEl = document.getElementById("askbox-nickname");
    if (!nicknameEl) return;
    const newNickname = nicknameEl.textContent.trim();
    if (newNickname && newNickname !== askboxData.nickname) {
      askboxData.nickname = newNickname;
      await saveAskboxDataToDB();
      console.log("✅ 昵称已自动保存:", newNickname);
    }
  }
  // 保存提问卡片文字（原处编辑）
  async function saveAskboxPrompt() {
    const promptEl = document.getElementById("askbox-prompt");
    if (!promptEl) return;
    const newPrompt = promptEl.textContent.trim();
    if (newPrompt && newPrompt !== askboxData.prompt) {
      askboxData.prompt = newPrompt;
      await saveAskboxDataToDB();
      console.log("✅ 提示文字已自动保存:", newPrompt);
    }
  }
  // 打开提问箱设置
  function openAskboxSettings() {
    const newBackground = prompt("请输入新的背景图URL:", askboxData.background);
    if (newBackground && newBackground.trim()) {
      askboxData.background = newBackground.trim();
      const backgroundEl = document.getElementById("askbox-background");
      if (backgroundEl)
        backgroundEl.style.backgroundImage = `url('${askboxData.background}')`; // 保存到数据库
      saveAskboxDataToDB();
      showXToast("背景图已更新并保存", "success");
    }
  }
  // 获取新的提问（第四个情景：提问箱AI生成）
  async function getNewQuestion() {
    try {
      showXToast("正在生成新的提问...", "info"); // 🔧 使用统一的API配置加载工具
      const { apiConfig, xSettings, xDb } =
        await APIUtils.loadConfigAndSettings();
      const { userPrompt, worldSetting, boundCharacters } = xSettings; // 使用工具函数构建用户X个人资料信息
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(
        window.userProfileData
      ); // 读取用户已发布的推文（最近5条）
      const userTweetsId = `userTweets_${currentAccountId || "main"}`;
      const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
      const userTweets = userTweetsData?.tweets || [];
      const recentUserTweets = userTweets.slice(0, 5); // 最近5条推文
      // 获取情侣角色的X资料
      let coupleCharacterInfo = "";
      if (
        userXProfileInfo.verificationType === "couple" &&
        userXProfileInfo.coupleCharacterId
      ) {
        const coupleCharacterProfile = await xDb.xCharacterProfiles
          .where("characterId")
          .equals(userXProfileInfo.coupleCharacterId)
          .first();
        if (coupleCharacterProfile) {
          coupleCharacterInfo = `
【情侣角色信息】：
- X姓名：${coupleCharacterProfile.xName}
- X句柄：${coupleCharacterProfile.xHandle}
- X简介：${coupleCharacterProfile.xBio || "无"}
- 公众身份：${coupleCharacterProfile.publicIdentity || "无"}
- 真实姓名：${
            coupleCharacterProfile.showRealName &&
            coupleCharacterProfile.realName
              ? coupleCharacterProfile.realName
              : "未公开"
          }
`;
        }
      }
      // 获取绑定角色信息（用于匿名提问）
      let boundCharactersInfo = "";
      if (boundCharacters.length > 0) {
        const mainDB = getDB();
        const allChats = await mainDB.chats.toArray();
        const boundCharsData = allChats.filter(
          (chat) => !chat.isGroup && boundCharacters.includes(chat.id)
        );
        const allXProfiles = await xDb.xCharacterProfiles.toArray();
        const xProfileMap = new Map();
        allXProfiles.forEach((profile) => {
          xProfileMap.set(profile.characterId, profile);
        });
        if (boundCharsData.length > 0) {
          boundCharactersInfo =
            "\n【绑定角色信息（可匿名提问）】：\n以下角色可以作为匿名提问者：\n";
          for (const char of boundCharsData) {
            const xProfile = xProfileMap.get(char.id);
            if (xProfile) {
              boundCharactersInfo += `\n- ${xProfile.xName}（${
                xProfile.xHandle
              }）: ${char.settings.aiPersona?.substring(0, 100) || ""}`;
            }
          }
        }
      }
      // 收集已回复的提问（作为对话历史）
      const answeredQuestionsContext = askboxData.answeredQuestions
        .filter((q) => q.answer && q.answer.trim())
        .slice(0, 5) // 最近5个已回复的提问
        .map((q) => `Q: ${q.question}\nA: ${q.answer}`)
        .join("\n\n"); // Token计数器
      let tokenCount = 0; // 构建提问箱专用系统提示词
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage(
        "提问箱生成器",
        "基础系统提示词",
        systemPrompt,
        tokenCount
      );
      systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务说明 - 匿名提问箱 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是一个匿名提问箱系统。请为用户生成一个有趣的、适合他们身份的匿名提问。
【用户身份信息】：
- 用户名：${userXProfileInfo.name}
- X句柄：${userXProfileInfo.handle}
- 简介：${userXProfileInfo.bio || "无"}
- 公众身份：${userXProfileInfo.publicIdentity || "无"}
- 认证类型：${StringBuilders.getUserVerificationTypeDescription(
        userXProfileInfo
      )}
${
  userXProfileInfo.verificationType === "couple" &&
  userXProfileInfo.coupleCharacterName
    ? `- 情侣关系：与${userXProfileInfo.coupleCharacterName}是公开情侣`
    : ""
}
${coupleCharacterInfo}
【用户最近发布的推文】：
${
  recentUserTweets.length > 0
    ? recentUserTweets
        .map((tweet, i) => {
          let tweetText = `${i + 1}. ${tweet.content}${
            tweet.time ? ` (${tweet.time})` : ""
          }`; // 添加图片信息
          if (tweet.image) {
            if (tweet.image.type === "description") {
              tweetText += `\n [图片描述: ${tweet.image.content}]`;
            } else if (tweet.image.type === "upload") {
              tweetText += `\n [包含上传的图片]`;
            }
          }
          return tweetText;
        })
        .join("\n")
    : "暂无推文"
}
${boundCharactersInfo}
${
  answeredQuestionsContext
    ? `【之前的提问与回复历史】：\n${answeredQuestionsContext}\n\n【继续性要求】：新提问可以延续之前的话题，也可以开启新话题，保持自然。`
    : ""
}
【提问生成要求】：
1. 提问要自然、真实，像是真实的匿名用户提出的
2. 提问内容要与用户的身份、简介、公众身份、最近发布的推文相关
3. 如果有绑定角色，可以让角色以匿名身份提问，提问内容要符合角色的人设和性格
4. 如果有之前的提问历史，可以延续话题，也可以提出新话题
5. 提问可以是：
- 关于最近推文内容的追问或评论
- 关于生活经验、情感态度的询问
- 关于兴趣爱好、专业技能的请教
- 关于日常趣事、特殊经历的好奇
- 轻松幽默或深度思考的话题
6. 提问长度适中（10-50字），不要太长或太短
7. 语气可以是：好奇的、调侃的、真诚的、幽默的
8. 避免过于私密、冒犯或不适当的问题
【返回格式】：
每行一个提问，用换行符分隔，不需要序号、引号或其他格式
每个提问独立成行，直接输出提问内容
示例格式：
看到你最近发的推文，感觉心情不错呀？
最近有遇到什么让你特别开心的事吗？
如果可以拥有一个超能力，你会选什么？
你觉得最重要的人生品质是什么？
现在，请为用户生成3-10个匿名提问（每行一个）：`;
      const userInfoSection = systemPrompt.substring(
        systemPrompt.indexOf("【用户身份信息】")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "提问箱生成器",
        "用户信息与要求",
        userInfoSection,
        tokenCount
      );
      const messages = [
        { role: "user", content: "请生成3-10个匿名提问，每行一个" },
      ]; // 最终统计
      TokenUtils.logFinalPrompt(
        "提问箱生成器",
        systemPrompt,
        messages[0].content
      ); // 🔧 使用统一的API请求工具
      const aiResponseContent = await APIUtils.sendAIRequest({
        apiConfig,
        systemPrompt,
        messages,
        temperature: 0.9,
      }); // 按行分割提问内容
      const questions = aiResponseContent
        .split("\n")
        .map((line) => line.trim())
        .filter((line) => line.length > 0)
        .map((line) => {
          // 清理每行：去除序号（如 "1. "、"- "等）、引号
          return line
            .replace(/^\d+[\.\)、]\s*/, "") // 去除数字序号
            .replace(/^[-•]\s*/, "") // 去除短横线或项目符号
            .replace(/^["「『]|["」』]$/g, "") // 去除引号
            .trim();
        })
        .filter((q) => q.length > 0); // 再次过滤空行
      if (questions.length === 0) {
        throw new Error("AI返回了空的提问内容");
      }
      console.log(`✅ 解析到 ${questions.length} 个提问:`, questions); // 为每个提问创建对象并添加到数组
      const newQuestions = questions.map((question, index) => ({
        id: `q_${Date.now()}_${index}_${Math.random()
          .toString(36)
          .substr(2, 9)}`,
        question: question,
        answer: "", // 初始为空，用户可以编辑回复
        date: new Date().toISOString(),
      })); // 批量添加到最前面
      askboxData.answeredQuestions.unshift(...newQuestions); // 保存到数据库
      await saveAskboxDataToDB(); // 重新渲染提问列表
      renderAnsweredQuestions();
      showXToast(`你有 ${newQuestions.length} 个新的提问请查收`, "success");
    } catch (error) {
      console.error("生成提问失败:", error);
      showXToast(`生成失败: ${error.message}`, "error");
    }
  }
  // 渲染已回答的提问列表
  function renderAnsweredQuestions() {
    const container = document.getElementById("answered-questions-list");
    const titleEl = document.getElementById("answered-questions-title");
    if (!container) return;
    if (askboxData.answeredQuestions.length === 0) {
      // 隐藏标题
      if (titleEl) titleEl.style.display = "none";
      container.innerHTML = `
 <div style="text-align: center; color: rgba(255,255,255,0.6); font-size: 14px; padding: 40px 20px; ">
 暂无提问
 </div>
 `;
      return;
    }
    // 显示标题
    if (titleEl) titleEl.style.display = "block";
    container.innerHTML = askboxData.answeredQuestions
      .map((q, index) => {
        const date = new Date(q.date);
        const dateStr = date.toLocaleDateString("zh-CN", {
          month: "short",
          day: "numeric",
        });
        const isSelected = selectedQuestions.has(q.id);
        return `
 <div
 class="askbox-question-item"
 data-question-id="${q.id}"
 style="background-color: rgba(255,255,255,0.9); backdrop-filter: blur(10px); border-radius: 16px; overflow: hidden; margin-bottom: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); transition: all 0.2s; ${
   isSelected
     ? "border: 3px solid var(--x-accent); background-color: color-mix(in srgb, var(--x-accent) , 0.1);"
     : ""
 }
 ${isAskboxMultiSelectMode ? "border-left: 3px solid var(--x-accent);" : ""}
 "
 onmouseover="if(!${isAskboxMultiSelectMode}){this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(0,0,0,0.2)';}"
 onmouseout="if(!${isAskboxMultiSelectMode}){this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)';}"
 onmousedown="startQuestionLongPress('${q.id}')"
 onmouseup="endQuestionLongPress()"
 onmouseleave="endQuestionLongPress()"
 ontouchstart="startQuestionLongPress('${q.id}')"
 ontouchend="endQuestionLongPress()"
 onclick="if(${isAskboxMultiSelectMode}){toggleQuestionSelection('${
          q.id
        }');event.stopPropagation();}"
 >

 <div style="background: linear-gradient(135deg, #3a3a3a 0%, #2a2a2a 100%); padding: 20px; color: #fff; ">
 <div style="font-size: 15px; line-height: 1.6; word-break: break-word;">
 ${q.question}
 </div>
 </div>

 <div style="background-color:#fff; padding: 20px; min-height: 60px; color: #333; ">
 <div id="answer-${q.id}"
 contenteditable="true"
 data-question-id="${q.id}"
 style="font-size: 14px; line-height: 1.6; word-break: break-word; outline: none; cursor: text; min-height: 20px; ${
   q.answer ? "" : "color: #999; text-align: center;"
 }
 "
 onblur="saveQuestionAnswer('${q.id}')"
 onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();this.blur();}"
 onfocus="if(this.textContent==='点击此处回复...'){this.textContent='';this.style.color='#333';this.style.textAlign='left';}">${
   q.answer || "点击此处回复..."
 }</div>
 </div>

 <div style="background-color: #f5f5f5; padding: 8px 20px; color: #999; font-size: 12px; text-align: right; ">
 ${dateStr}
 </div>
 </div>
`;
      })
      .join("");
  }
  // 保存提问回复（原处编辑）
  async function saveQuestionAnswer(questionId) {
    const answerEl = document.getElementById(`answer-${questionId}`);
    if (!answerEl) return;
    const question = askboxData.answeredQuestions.find(
      (q) => q.id === questionId
    );
    if (!question) return;
    let newAnswer = answerEl.textContent.trim(); // 如果是占位符文本，则清空
    if (newAnswer === "点击此处回复...") {
      newAnswer = "";
    }
    if (newAnswer !== question.answer) {
      question.answer = newAnswer;
      await saveAskboxDataToDB();
      console.log("✅ 回复已自动保存:", questionId);
    }
  }
  // ============================================
  // 提问箱多选删除功能
  // ============================================
  // 开始长按提问卡片
  function startQuestionLongPress(questionId) {
    if (isAskboxMultiSelectMode) return; // 已经在多选模式，不需要长按
    questionLongPressTimer = setTimeout(() => {
      enterAskboxMultiSelectMode();
      toggleQuestionSelection(questionId);
    }, 500); // 长按500ms触发
  }
  // 结束长按
  function endQuestionLongPress() {
    if (questionLongPressTimer) {
      clearTimeout(questionLongPressTimer);
      questionLongPressTimer = null;
    }
  }
  // 切换提问选择状态
  function toggleQuestionSelection(questionId) {
    if (!isAskboxMultiSelectMode) {
      enterAskboxMultiSelectMode();
    }
    const questionEl = document.querySelector(
      `.askbox-question-item[data-question-id="${questionId}"]`
    );
    if (!questionEl) return;
    if (selectedQuestions.has(questionId)) {
      selectedQuestions.delete(questionId);
      questionEl.style.border = "";
      questionEl.style.backgroundColor = "rgba(255,255,255,0.9)";
    } else {
      selectedQuestions.add(questionId);
      questionEl.style.border = "3px solid var(--x-accent)";
      questionEl.style.backgroundColor =
        "color-mix(in srgb, var(--x-accent) , 0.1)";
    }
    updateAskboxDeleteUI();
  }
  // 进入提问箱多选模式
  function enterAskboxMultiSelectMode() {
    isAskboxMultiSelectMode = true; // 显示删除工具栏
    showAskboxDeleteToolbar(); // 改变所有提问卡片的样式
    document.querySelectorAll(".askbox-question-item").forEach((item) => {
      item.style.borderLeft = "3px solid var(--x-accent)";
    });
    console.log("✅ 已进入提问箱多选模式");
  }
  // 退出提问箱多选模式
  function exitAskboxMultiSelectMode() {
    isAskboxMultiSelectMode = false;
    selectedQuestions.clear(); // 隐藏删除工具栏
    hideAskboxDeleteToolbar(); // 恢复所有提问卡片的样式
    document.querySelectorAll(".askbox-question-item").forEach((item) => {
      item.style.border = "";
      item.style.borderLeft = "";
      item.style.backgroundColor = "rgba(255,255,255,0.9)";
    });
    console.log("✅ 已退出提问箱多选模式");
  }
  // 显示提问箱删除工具栏
  function showAskboxDeleteToolbar() {
    let toolbar = document.getElementById("askbox-delete-toolbar");
    if (!toolbar) {
      toolbar = document.createElement("div");
      toolbar.id = "askbox-delete-toolbar";
      toolbar.style.cssText = `
 position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.95); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); border-radius: 24px; padding: 12px 20px; display: flex; align-items: center; gap: 16px; z-index: 2000; box-shadow: 0 4px 20px rgba(0,0,0,0.5); `;
      toolbar.innerHTML = `
 <button onclick="selectAllQuestions()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#1a8cd8'" onmouseout="this.style.backgroundColor='var(--x-accent)'">
 全选
 </button>
 <span id="askbox-selected-count" style="color: #fff; font-size: 14px; font-weight: 500;">已选择 0 个</span>
 <button onclick="deleteSelectedQuestions()" style="background-color: #f91880; color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='#d0155f'" onmouseout="this.style.backgroundColor='#f91880'">
 删除
 </button>
 <button onclick="exitAskboxMultiSelectMode()" style="background-color: rgba(255,255,255,0.15); color: #fff; border: none; border-radius: 20px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='rgba(255,255,255,0.25)'" onmouseout="this.style.backgroundColor='rgba(255,255,255,0.15)'">
 取消
 </button>
 `;
      document.body.appendChild(toolbar);
    }
    toolbar.style.display = "flex";
  }
  // 隐藏提问箱删除工具栏
  function hideAskboxDeleteToolbar() {
    const toolbar = document.getElementById("askbox-delete-toolbar");
    if (toolbar) {
      toolbar.style.display = "none";
    }
  }
  // 更新提问箱删除UI
  function updateAskboxDeleteUI() {
    const countEl = document.getElementById("askbox-selected-count");
    if (countEl) {
      countEl.textContent = `已选择 ${selectedQuestions.size} 个`;
    }
  }
  // 全选提问
  function selectAllQuestions() {
    document.querySelectorAll(".askbox-question-item").forEach((item) => {
      const questionId = item.dataset.questionId;
      if (!selectedQuestions.has(questionId)) {
        selectedQuestions.add(questionId);
        item.style.border = "3px solid #1d9bf0";
        item.style.backgroundColor =
          "color-mix(in srgb, var(--x-accent) , 0.1)";
      }
    });
    updateAskboxDeleteUI();
  }
  // 删除选中的提问
  async function deleteSelectedQuestions() {
    if (selectedQuestions.size === 0) {
      showXToast("请先选择要删除的提问", "warning");
      return;
    }
    const confirmDelete = confirm(
      `确定要删除选中的 ${selectedQuestions.size} 个提问吗？删除后无法恢复。`
    );
    if (!confirmDelete) return;
    try {
      // 过滤掉选中的提问
      askboxData.answeredQuestions = askboxData.answeredQuestions.filter(
        (q) => !selectedQuestions.has(q.id)
      ); // 保存到数据库
      await saveAskboxDataToDB();
      showXToast(`已删除 ${selectedQuestions.size} 个提问`, "success"); // 退出多选模式并刷新显示
      exitAskboxMultiSelectMode();
      renderAnsweredQuestions();
    } catch (error) {
      console.error("删除提问失败:", error);
      showXToast("删除失败: " + error.message, "error");
    }
  }
  // ============================================
  // 通知页面功能
  // ============================================
  // ▼▼▼ 【已废弃】Mentions 通知生成器已合并到发帖生成器中 ▼▼▼
  // 原 generateMentionsForLatestTweet 函数已删除，现在Mentions通知在 generateAIResponseForTweet 中一起生成
  // 但保留渲染函数，因为它们用于显示Mentions通知
  // ▲▲▲ 【已废弃】Mentions 通知生成器（功能已合并到发帖生成器） ▲▲▲

  // 渲染点赞通知项
  function renderLikeMentionItem(mention) {
    const config = languageConfig[currentLanguage] || languageConfig.zh;
    const mentionEl = document.createElement("div");
    mentionEl.className = "mention-item";
    mentionEl.dataset.mentionId = mention.id;
    mentionEl.style.cssText = `
 display: flex; gap: 12px; padding: 16px; border-bottom: 1px solid var(--x-border-color); cursor: pointer; transition: background-color 0.2s; user-select: none; -webkit-user-select: none;
`; // 长按事件（移动端和桌面端）
    let touchMoved = false;
    const startLongPress = (e) => {
      if (mentionsDeleteMode) return;
      touchMoved = false;
      mentionsLongPressStarted = true;
      mentionsLongPressTimer = setTimeout(() => {
        if (mentionsLongPressStarted && !touchMoved) {
          enterMentionsDeleteMode(); // 自动选中被长按的项
          const checkbox = mentionEl.querySelector(".mention-checkbox");
          if (checkbox) {
            toggleMentionSelection(mention.id, checkbox);
          }
        }
      }, 500); // 500ms 长按触发
    };
    const cancelLongPress = () => {
      mentionsLongPressStarted = false;
      if (mentionsLongPressTimer) {
        clearTimeout(mentionsLongPressTimer);
        mentionsLongPressTimer = null;
      }
    };
    const handleTouchMove = () => {
      touchMoved = true;
      cancelLongPress();
    }; // 触摸事件
    mentionEl.addEventListener("touchstart", startLongPress, { passive: true });
    mentionEl.addEventListener("touchend", cancelLongPress);
    mentionEl.addEventListener("touchmove", handleTouchMove);
    mentionEl.addEventListener("touchcancel", cancelLongPress); // 鼠标事件（桌面端）
    mentionEl.addEventListener("mousedown", startLongPress);
    mentionEl.addEventListener("mouseup", cancelLongPress);
    mentionEl.addEventListener("mouseleave", cancelLongPress);
    mentionEl.onmouseover = () => {
      if (!mentionsDeleteMode) {
        mentionEl.style.backgroundColor = "var(--x-bg-hover)";
      }
    };
    mentionEl.onmouseout = () => {
      mentionEl.style.backgroundColor = "transparent";
    }; // 左侧图标区域
    const iconArea = document.createElement("div");
    iconArea.style.cssText =
      "width: 40px; display: flex; flex-direction: column; align-items: flex-end; flex-shrink: 0;";
    const iconColor = "var(--x-accent)";
    const iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M20.884 13.19c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>`;
    iconArea.innerHTML = iconSvg; // 右侧内容区域
    const contentArea = document.createElement("div");
    contentArea.style.cssText = "flex: 1; min-width: 0;"; // 用户头像区域（显示3个头像）
    let avatarsHtml =
      '<div style="display: flex; gap: 4px; margin-bottom: 8px;">';
    const displayUsers = mention.users.slice(0, 3);
    displayUsers.forEach((user) => {
      avatarsHtml += `<img src="${user.avatar}" alt="${user.name}" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid var(--x-bg-primary);">`;
    });
    avatarsHtml += "</div>"; // 构建通知文本
    const firstName = mention.users[0].name;
    const secondName = mention.users.length > 1 ? mention.users[1].name : "";
    const othersCount = mention.othersCount || 0;
    let notificationText = "";
    if (currentLanguage === "zh") {
      notificationText = `${firstName}${secondName ? ` ${secondName}` : ""}${
        othersCount > 0 ? ` 和其他 ${othersCount} 人` : ""
      } 喜欢了你的推文`;
    } else {
      notificationText = `${firstName}${secondName ? ` ${secondName}` : ""}${
        othersCount > 0 ? ` and ${othersCount} others` : ""
      } liked your post`;
    }
    // 推文内容
    let tweetContentHtml = "";
    if (mention.tweet) {
      tweetContentHtml = `
 <div style="margin-top: 12px; padding: 12px; border: 1px solid var(--x-border-color); border-radius: 12px;">
 <div style="color:var(--x-text-primary); font-size: 15px; line-height: 1.4; margin-bottom: ${
   mention.tweet.image ? "8px" : "0"
 };">
 ${mention.tweet.content}
 </div>
 ${
   mention.tweet.image
     ? `<div style="color:var(--x-text-secondary); font-size: 13px; margin-top: 8px;">[图片]</div>`
     : ""
 }
 </div>
 `;
    }
    // 🔧 动态计算时间显示（优先使用timestamp，否则使用静态time）
    const displayTime = mention.timestamp
      ? getRelativeTime(mention.timestamp)
      : mention.time;
    contentArea.innerHTML = `
 ${avatarsHtml}
 <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 4px;">
 ${notificationText}
 </div>
 <div style="color:var(--x-text-secondary); font-size: 14px;">
 ${displayTime}
 </div>
 ${tweetContentHtml}
`;
    mentionEl.appendChild(iconArea);
    mentionEl.appendChild(contentArea);
    return mentionEl;
  }
  // 渲染转帖通知项
  function renderRetweetMentionItem(mention) {
    const config = languageConfig[currentLanguage] || languageConfig.zh;
    const mentionEl = document.createElement("div");
    mentionEl.className = "mention-item";
    mentionEl.dataset.mentionId = mention.id;
    mentionEl.style.cssText = `
 display: flex; gap: 12px; padding: 16px; border-bottom: 1px solid var(--x-border-color); cursor: pointer; transition: background-color 0.2s; user-select: none; -webkit-user-select: none;
`; // 长按事件（移动端和桌面端）
    let touchMoved = false;
    let clickAllowed = true;
    const startLongPress = (e) => {
      if (mentionsDeleteMode) return;
      touchMoved = false;
      clickAllowed = true;
      mentionsLongPressStarted = true;
      mentionsLongPressTimer = setTimeout(() => {
        if (mentionsLongPressStarted && !touchMoved) {
          clickAllowed = false;
          enterMentionsDeleteMode(); // 自动选中被长按的项
          const checkbox = mentionEl.querySelector(".mention-checkbox");
          if (checkbox) {
            toggleMentionSelection(mention.id, checkbox);
          }
        }
      }, 500); // 500ms 长按触发
    };
    const cancelLongPress = () => {
      mentionsLongPressStarted = false;
      if (mentionsLongPressTimer) {
        clearTimeout(mentionsLongPressTimer);
        mentionsLongPressTimer = null;
      }
    };
    const handleTouchMove = () => {
      touchMoved = true;
      cancelLongPress();
    }; // 触摸事件
    mentionEl.addEventListener("touchstart", startLongPress, { passive: true });
    mentionEl.addEventListener("touchend", cancelLongPress);
    mentionEl.addEventListener("touchmove", handleTouchMove);
    mentionEl.addEventListener("touchcancel", cancelLongPress); // 鼠标事件（桌面端）
    mentionEl.addEventListener("mousedown", startLongPress);
    mentionEl.addEventListener("mouseup", cancelLongPress);
    mentionEl.addEventListener("mouseleave", cancelLongPress);
    mentionEl.onmouseover = () => {
      if (!mentionsDeleteMode) {
        mentionEl.style.backgroundColor = "var(--x-bg-hover)";
      }
    };
    mentionEl.onmouseout = () => {
      mentionEl.style.backgroundColor = "transparent";
    }; // 点击查看转帖详情（只有在非删除模式且非长按时才触发）
    mentionEl.onclick = () => {
      if (!mentionsDeleteMode && clickAllowed) {
        showRetweetDetail(mention);
      }
    }; // 左侧图标区域
    const iconArea = document.createElement("div");
    iconArea.style.cssText =
      "width: 40px; display: flex; flex-direction: column; align-items: flex-end; flex-shrink: 0;";
    const iconColor = "var(--x-accent)";
    const iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M4.75 3.79l4.603 4.3-1.706 1.82L6 8.38v7.37c0 .97.784 1.75 1.75 1.75H13V20H7.75c-2.347 0-4.25-1.9-4.25-4.25V8.38L1.853 9.91.147 8.09l4.603-4.3zm11.5 2.71H11V4h5.25c2.347 0 4.25 1.9 4.25 4.25v7.37l1.647-1.53 1.706 1.82-4.603 4.3-4.603-4.3 1.706-1.82L18 15.62V8.25c0-.97-.784-1.75-1.75-1.75z"></path></g></svg>`;
    iconArea.innerHTML = iconSvg; // 右侧内容区域
    const contentArea = document.createElement("div");
    contentArea.style.cssText = "flex: 1; min-width: 0;"; // 用户头像
    let avatarHtml = `<div style="margin-bottom: 8px;"><img src="${mention.user.avatar}" alt="${mention.user.name}" style="width: 32px; height: 32px; border-radius: 50%;"></div>`; // 构建通知文本
    let notificationText = "";
    if (currentLanguage === "zh") {
      notificationText = `${mention.user.name} 转推了你的推文`;
    } else {
      notificationText = `${mention.user.name} retweeted your post`;
    }
    contentArea.innerHTML = `
 ${avatarHtml}
 <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 4px;">
 ${notificationText}
 </div>
 <div style="color:var(--x-text-secondary); font-size: 14px; margin-bottom: 12px;">
 ${mention.time}
 </div>
 <div style="padding: 12px; border: 1px solid var(--x-border-color); border-radius: 12px;">
 <div style="color:var(--x-text-primary); font-size: 15px; line-height: 1.4; margin-bottom: 8px;">
 ${processContent(mention.retweetContent)}
 </div>
 <div style="padding: 12px; border-left: 3px solid var(--x-border-color); background-color:var(--x-bg-secondary); border-radius: 4px;">
 <div style="color:var(--x-text-secondary); font-size: 13px; margin-bottom: 4px;">
 ${mention.quotedTweet.user.name} ${mention.quotedTweet.user.handle}
 </div>
 <div style="color:var(--x-text-primary); font-size: 14px; line-height: 1.3;">
 ${mention.quotedTweet.content.substring(0, 100)}${
      mention.quotedTweet.content.length > 100 ? "..." : ""
    }
 </div>
 </div>
 </div>
`;
    mentionEl.appendChild(iconArea);
    mentionEl.appendChild(contentArea);
    return mentionEl;
  }
  // 显示转帖详情
  async function showRetweetDetail(mention) {
    try {
      // 构建转帖推文数据
      // 确保 stats 数据完整
      const ensureStats = (stats) => ({
        comments: stats?.comments || 0,
        retweets: stats?.retweets || 0,
        likes: stats?.likes || 0,
        views: stats?.views || 0,
      });
      const retweetData = {
        id: mention.id || `retweet_${Date.now()}`,
        user: mention.user || {
          name: "未知用户",
          handle: "@unknown",
          avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
          verified: false,
        },
        content: mention.retweetContent || "",
        time: mention.time || "刚刚",
        timestamp: mention.timestamp || Date.now(),
        stats: ensureStats(mention.stats),
        quotedTweet: {
          type: "tweet",
          user: mention.quotedTweet?.user || {
            name: "未知用户",
            handle: "@unknown",
            avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
            verified: false,
          },
          content: mention.quotedTweet?.content || "",
          time: mention.quotedTweet?.time || "刚刚",
          image: mention.quotedTweet?.image || null,
          stats: ensureStats(mention.quotedTweet?.stats),
        },
        comments: mention.comments || [], // 转帖的评论（从AI生成的数据中获取）
        _source: "retweet_mention", // 标记来源
      };
      console.log("📝 [转帖详情] 数据已准备:", retweetData); // 使用现有的推文详情显示函数
      await showTweetDetail(retweetData);
    } catch (error) {
      console.error("显示转帖详情失败:", error);
      showXToast("无法显示转帖详情", "error");
    }
  }
  // 显示 New Tweet 详情
  async function showNewTweetDetail(mention) {
    try {
      console.log("📝 [New Tweet详情] 准备显示推文详情:", mention); // 确保 stats 数据完整
      const ensureStats = (stats) => ({
        comments: stats?.comments || 0,
        retweets: stats?.retweets || 0,
        likes: stats?.likes || 0,
        views: stats?.views || 0,
      }); // 构建推文数据
      const tweetData = {
        id: mention.tweet.id || `newtweet_${Date.now()}`,
        user: mention.tweet.user ||
          mention.user || {
            name: "未知用户",
            handle: "@unknown",
            avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
            verified: false,
          },
        content: mention.tweet.content || "",
        time: mention.tweet.time || "刚刚",
        timestamp: mention.tweet.timestamp || mention.timestamp || Date.now(),
        image: mention.tweet.image || null,
        stats: ensureStats(mention.tweet.stats),
        comments: (mention.tweet.comments || []).map((comment) => ({
          ...comment,
          stats: ensureStats(comment.stats), // 确保评论的stats也完整
        })),
        _source: "newtweet_mention", // 标记来源
        _mentionId: mention.id, // 保存通知ID，用于更新数据库
      };
      console.log(
        "📝 [New Tweet详情] 数据已准备，包含 %d 条评论",
        tweetData.comments.length
      ); // 使用现有的推文详情显示函数
      await showTweetDetail(tweetData);
    } catch (error) {
      console.error("显示 New Tweet 详情失败:", error);
      showXToast("无法显示推文详情", "error");
    }
  }
  // ▲▲▲ 【已废弃】Mentions 通知生成器（功能已合并到发帖生成器） ▲▲▲
  // Mentions 删除模式状态
  let mentionsDeleteMode = false;
  let selectedMentions = new Set();
  let mentionsLongPressTimer = null;
  let mentionsLongPressStarted = false; // 切换通知标签 (All / Mentions)
  window.switchNotificationTab = function (tab) {
    const tabs = document.querySelectorAll(".notification-tab");
    const allContent = document.getElementById("notifications-all-content");
    const mentionsContent = document.getElementById(
      "notifications-mentions-content"
    );
    const refreshBtn = document.getElementById("refresh-messages-btn"); // 切换标签时退出删除模式
    if (mentionsDeleteMode) {
      exitMentionsDeleteMode();
    }
    tabs.forEach((tabEl) => {
      const isActive =
        (tab === "all" &&
          (tabEl.textContent.includes("全部") ||
            tabEl.textContent.includes("All"))) ||
        (tab === "mentions" &&
          (tabEl.textContent.includes("提及") ||
            tabEl.textContent.includes("Mentions")));
      if (isActive) {
        tabEl.classList.add("active");
        tabEl.style.color = "var(--x-text-primary)";
        tabEl.style.backgroundColor = "transparent";
        tabEl.querySelector(".tab-indicator").style.display = "block";
      } else {
        tabEl.classList.remove("active");
        tabEl.style.color = "var(--x-text-secondary)";
        tabEl.style.backgroundColor = "transparent";
        tabEl.querySelector(".tab-indicator").style.display = "none";
      }
    });
    if (tab === "all") {
      allContent.style.display = "flex";
      mentionsContent.style.display = "none";
      if (refreshBtn) refreshBtn.style.display = "flex";
    } else {
      allContent.style.display = "none";
      mentionsContent.style.display = "flex";
      if (refreshBtn) refreshBtn.style.display = "none";
    }
  }; // 进入删除模式
  function enterMentionsDeleteMode() {
    mentionsDeleteMode = true;
    selectedMentions.clear(); // 显示删除工具栏
    showMentionsDeleteToolbar(); // 更新所有通知项的样式
    const mentionItems = document.querySelectorAll(".mention-item");
    mentionItems.forEach((item) => {
      item.style.paddingLeft = "56px"; // 添加复选框
      const checkbox = document.createElement("div");
      checkbox.className = "mention-checkbox";
      checkbox.style.cssText = `
 position: absolute; left: 16px; top: 50%; transform: translateY(-50%); width: 24px; height: 24px; border: 2px solid var(--x-border-color); border-radius: 50%; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; `;
      item.style.position = "relative";
      item.insertBefore(checkbox, item.firstChild); // 点击复选框切换选中状态
      checkbox.onclick = (e) => {
        e.stopPropagation();
        const mentionId = item.dataset.mentionId;
        toggleMentionSelection(mentionId, checkbox);
      };
    });
    console.log("✅ 进入 Mentions 删除模式");
  }
  // 退出删除模式
  function exitMentionsDeleteMode() {
    mentionsDeleteMode = false;
    selectedMentions.clear(); // 隐藏删除工具栏
    hideMentionsDeleteToolbar(); // 移除所有复选框
    const checkboxes = document.querySelectorAll(".mention-checkbox");
    checkboxes.forEach((cb) => cb.remove()); // 恢复通知项样式
    const mentionItems = document.querySelectorAll(".mention-item");
    mentionItems.forEach((item) => {
      item.style.paddingLeft = "16px";
    });
    console.log("✅ 退出 Mentions 删除模式");
  }
  // 切换通知选中状态
  function toggleMentionSelection(mentionId, checkbox) {
    if (selectedMentions.has(mentionId)) {
      selectedMentions.delete(mentionId);
      checkbox.style.backgroundColor = "transparent";
      checkbox.innerHTML = "";
    } else {
      selectedMentions.add(mentionId);
      checkbox.style.backgroundColor = "var(--x-accent)";
      checkbox.style.borderColor = "var(--x-accent)";
      checkbox.innerHTML = `<svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: white;"><g><path d="M9 20l-7-7 1.41-1.41L9 17.17l11.59-11.58L22 7z"></path></g></svg>`;
    }
    updateDeleteToolbar();
  }
  // 显示删除工具栏
  function showMentionsDeleteToolbar() {
    const existingToolbar = document.getElementById("mentions-delete-toolbar");
    if (existingToolbar) {
      existingToolbar.remove();
    }
    const toolbar = document.createElement("div");
    toolbar.id = "mentions-delete-toolbar";
    toolbar.style.cssText = `
 position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background: var(--x-bg-primary); border: 1px solid var(--x-border-color); border-radius: 24px; padding: 12px 20px; display: flex; align-items: center; gap: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; animation: slideUp 0.3s ease;
`;
    toolbar.innerHTML = `
 <button id="mentions-select-all-btn" style="background: transparent; border: none; color: var(--x-accent); font-size: 15px; font-weight: 600; cursor: pointer; padding: 8px 12px; border-radius: 8px; transition: background-color 0.2s; ">全选</button>
 <div style="width: 1px; height: 24px; background: var(--x-border-color);"></div>
 <button id="mentions-delete-btn" style="background: transparent; border: none; color:var(--x-text-secondary); font-size: 15px; font-weight: 600; cursor: not-allowed; padding: 8px 12px; border-radius: 8px; transition: all 0.2s; ">删除 (0)</button>
 <div style="width: 1px; height: 24px; background: var(--x-border-color);"></div>
 <button id="mentions-cancel-btn" style="background: transparent; border: none; color:var(--x-text-primary); font-size: 15px; font-weight: 600; cursor: pointer; padding: 8px 12px; border-radius: 8px; transition: background-color 0.2s; ">取消</button>
`;
    document.body.appendChild(toolbar); // 绑定事件
    document.getElementById("mentions-select-all-btn").onclick =
      selectAllMentions;
    document.getElementById("mentions-delete-btn").onclick =
      confirmDeleteMentions;
    document.getElementById("mentions-cancel-btn").onclick =
      exitMentionsDeleteMode; // 添加按钮悬停效果
    const buttons = toolbar.querySelectorAll("button");
    buttons.forEach((btn) => {
      btn.onmouseover = () => {
        if (btn.id !== "mentions-delete-btn" || selectedMentions.size > 0) {
          btn.style.backgroundColor = "var(--x-bg-hover)";
        }
      };
      btn.onmouseout = () => {
        btn.style.backgroundColor = "transparent";
      };
    });
  }
  // 隐藏删除工具栏
  function hideMentionsDeleteToolbar() {
    const toolbar = document.getElementById("mentions-delete-toolbar");
    if (toolbar) {
      toolbar.remove();
    }
  }
  // 更新删除工具栏
  function updateDeleteToolbar() {
    const deleteBtn = document.getElementById("mentions-delete-btn");
    const selectAllBtn = document.getElementById("mentions-select-all-btn");
    if (deleteBtn) {
      const count = selectedMentions.size;
      deleteBtn.textContent = `删除 (${count})`;
      if (count > 0) {
        deleteBtn.style.color = "#f4212e";
        deleteBtn.style.cursor = "pointer";
      } else {
        deleteBtn.style.color = "var(--x-text-secondary)";
        deleteBtn.style.cursor = "not-allowed";
      }
    }
    if (selectAllBtn) {
      const allMentionItems = document.querySelectorAll(".mention-item");
      if (
        selectedMentions.size === allMentionItems.length &&
        allMentionItems.length > 0
      ) {
        selectAllBtn.textContent = "取消全选";
      } else {
        selectAllBtn.textContent = "全选";
      }
    }
  }
  // 全选/取消全选
  function selectAllMentions() {
    const allMentionItems = document.querySelectorAll(".mention-item");
    const selectAllBtn = document.getElementById("mentions-select-all-btn");
    if (selectedMentions.size === allMentionItems.length) {
      // 取消全选
      selectedMentions.clear();
      const checkboxes = document.querySelectorAll(".mention-checkbox");
      checkboxes.forEach((cb) => {
        cb.style.backgroundColor = "transparent";
        cb.style.borderColor = "var(--x-border-color)";
        cb.innerHTML = "";
      });
    } else {
      // 全选
      allMentionItems.forEach((item) => {
        const mentionId = item.dataset.mentionId;
        selectedMentions.add(mentionId);
        const checkbox = item.querySelector(".mention-checkbox");
        if (checkbox) {
          checkbox.style.backgroundColor = "var(--x-accent)";
          checkbox.style.borderColor = "var(--x-accent)";
          checkbox.innerHTML = `<svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: white;"><g><path d="M9 20l-7-7 1.41-1.41L9 17.17l11.59-11.58L22 7z"></path></g></svg>`;
        }
      });
    }
    updateDeleteToolbar();
  }
  // 确认删除
  function confirmDeleteMentions() {
    if (selectedMentions.size === 0) return;
    const count = selectedMentions.size;
    const message =
      currentLanguage === "zh"
        ? `确定要删除 ${count} 条通知吗？此操作不可恢复。`
        : `Delete ${count} notification${
            count > 1 ? "s" : ""
          }? This action cannot be undone.`;
    if (confirm(message)) {
      deleteMentions();
    }
  }
  // 执行删除
  async function deleteMentions() {
    try {
      const xDb = getXDB();
      const mentionsDataId = `mentions_${currentAccountId || "main"}`;
      const savedMentions = await xDb.xAccountProfiles.get(mentionsDataId);
      if (savedMentions && savedMentions.data) {
        // 过滤掉被选中的通知
        const idsToDelete = Array.from(selectedMentions);
        savedMentions.data = savedMentions.data.filter(
          (m) => !idsToDelete.includes(m.id)
        );
        await xDb.xAccountProfiles.put(savedMentions);
        console.log(`✅ 已删除 ${idsToDelete.length} 条 Mentions 通知`);
        showXToast(`已删除 ${idsToDelete.length} 条通知`, "success"); // 退出删除模式
        exitMentionsDeleteMode(); // 重新加载通知
        await loadNotifications();
      }
    } catch (error) {
      console.error("❌ 删除 Mentions 通知失败:", error);
      showXToast("删除失败: " + error.message, "error");
    }
  }
  // 陌生人私信数据（第八个情景）
  const strangerMessages = []; // 示例提及数据（通知）
  const sampleMentions = [
    {
      id: "mention_001",
      type: "newTweet", // newTweet | like | retweet | reply | follow
      users: [
        {
          name: "餵ぇあか",
          handle: "@weaka",
          avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
        },
        {
          name: "毎日抜雄",
          handle: "@nukio",
          avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
        },
        {
          name: "X",
          handle: "@X",
          avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
        },
      ],
      content: "New Tweet notifications for 餵ぇあか 毎日抜雄 and 3 others",
      time: "2小时前",
      tweet: null,
    },
    {
      id: "mention_002",
      type: "like",
      users: [
        {
          name: "Tenny and Sticks🧵",
          handle: "@tennysticks",
          avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
        },
      ],
      content: "liked your Tweet",
      time: "3小时前",
      tweet: {
        content:
          "Someone looks like ready to ask for Raiden Shogun......... https://t.co/GrRMlbtpeq",
        image: null,
      },
    },
    {
      id: "mention_003",
      type: "retweet",
      users: [
        {
          name: "Moona Hoshinova (ムーナ)🔮金沢ID",
          handle: "@moonahoshinova",
          avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
        },
        {
          name: "毎日抜雄",
          handle: "@nukio",
          avatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
        },
      ],
      content:
        "and 2 others Retweeted a photo from 鍵、毎日投稿 サトウ・ドア・アイガ！！",
      time: "5小时前",
      tweet: {
        content: "#GambaRisu\n#ioarts",
        image: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
      },
    },
  ]; // 渲染提及/通知项
  function renderMentionItem(mention) {
    const config = languageConfig[currentLanguage] || languageConfig.zh;
    const mentionEl = document.createElement("div");
    mentionEl.className = "mention-item";
    mentionEl.dataset.mentionId = mention.id;
    mentionEl.style.cssText = `
 display: flex; gap: 12px; padding: 16px; border-bottom: 1px solid var(--x-border-color); cursor: pointer; transition: background-color 0.2s;
`; // 添加长按事件监听（移动端和桌面端）
    let pressTimer = null;
    const startPress = (e) => {
      if (mentionsDeleteMode) return;
      pressTimer = setTimeout(() => {
        enterMentionsDeleteMode();
        const checkbox = mentionEl.querySelector(".mention-checkbox");
        if (checkbox) {
          toggleMentionSelection(mention.id, checkbox);
        }
        // 触觉反馈（如果支持）
        if (navigator.vibrate) {
          navigator.vibrate(50);
        }
      }, 500);
    };
    const endPress = () => {
      if (pressTimer) {
        clearTimeout(pressTimer);
        pressTimer = null;
      }
    }; // 移动端触摸事件
    mentionEl.addEventListener("touchstart", startPress);
    mentionEl.addEventListener("touchend", endPress);
    mentionEl.addEventListener("touchmove", endPress); // 桌面端鼠标事件
    mentionEl.addEventListener("mousedown", startPress);
    mentionEl.addEventListener("mouseup", endPress);
    mentionEl.addEventListener("mouseleave", endPress); // 为 newTweet 类型添加点击事件
    if (mention.type === "newTweet" && mention.tweet) {
      mentionEl.onclick = () => {
        if (!mentionsDeleteMode) {
          showNewTweetDetail(mention);
        }
      };
    }
    mentionEl.onmouseover = () => {
      mentionEl.style.backgroundColor = "var(--x-bg-hover)";
    };
    mentionEl.onmouseout = () => {
      mentionEl.style.backgroundColor = "transparent";
    }; // 左侧图标区域（根据类型显示不同图标）
    const iconArea = document.createElement("div");
    iconArea.style.cssText =
      "width: 40px; display: flex; flex-direction: column; align-items: flex-end; flex-shrink: 0;";
    let iconSvg = "";
    let iconColor = "";
    switch (mention.type) {
      case "newTweet":
        iconColor = "var(--x-accent)";
        iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"></path></g></svg>`;
        break;
      case "like":
        iconColor = "var(--x-accent)";
        iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M20.884 13.19c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z"></path></g></svg>`;
        break;
      case "retweet":
        iconColor = "var(--x-accent)";
        iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M4.75 3.79l4.603 4.3-1.706 1.82L6 8.38v7.37c0 .97.784 1.75 1.75 1.75H13V20H7.75c-2.347 0-4.25-1.9-4.25-4.25V8.38L1.853 9.91.147 8.09l4.603-4.3zm11.5 2.71H11V4h5.25c2.347 0 4.25 1.9 4.25 4.25v7.37l1.647-1.53 1.706 1.82-4.603 4.3-4.603-4.3 1.706-1.82L18 15.62V8.25c0-.97-.784-1.75-1.75-1.75z"></path></g></svg>`;
        break;
      case "reply":
        iconColor = "var(--x-accent)";
        iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g></svg>`;
        break;
      case "follow":
        iconColor = "var(--x-accent)";
        iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M17.863 13.44c1.477 1.58 2.366 3.8 2.632 6.46l.11 1.1H3.395l.11-1.1c.266-2.66 1.155-4.88 2.632-6.46C7.627 11.85 9.648 11 12 11s4.373.85 5.863 2.44zM12 2C9.791 2 8 3.79 8 6s1.791 4 4 4 4-1.79 4-4-1.791-4-4-4z"></path></g></svg>`;
        break;
    }
    iconArea.innerHTML = iconSvg; // 右侧内容区域
    const contentArea = document.createElement("div");
    contentArea.style.cssText = "flex: 1; min-width: 0;"; // 用户头像区域（对于newTweet显示多个头像）
    let avatarsHtml =
      '<div style="display: flex; gap: 4px; margin-bottom: 8px;">';
    if (mention.type === "newTweet") {
      // newTweet 类型使用 mention.user（单数）
      if (mention.user) {
        avatarsHtml += `<img src="${mention.user.avatar}" alt="${mention.user.name}" style="width: 32px; height: 32px; border-radius: 50%; border: 2px solid var(--x-bg-primary);">`;
      }
    } else {
      // 其他类型显示第一个用户头像
      if (mention.users && mention.users.length > 0) {
        avatarsHtml += `<img src="${mention.users[0].avatar}" alt="${mention.users[0].name}" style="width: 32px; height: 32px; border-radius: 50%;">`;
      }
    }
    avatarsHtml += "</div>"; // 构建通知文本
    let notificationText = "";
    if (mention.type === "newTweet") {
      // newTweet 类型使用 mention.user（单数）
      if (mention.user) {
        const userName = mention.user.name;
        if (currentLanguage === "zh") {
          notificationText = `${userName} 发布了新推文`;
        } else {
          notificationText = `New Tweet from ${userName}`;
        }
      }
    } else if (mention.users && mention.users.length > 0) {
      const firstName = mention.users[0].name;
      const secondName = mention.users.length > 1 ? mention.users[1].name : "";
      const othersCount =
        mention.users.length > 2 ? mention.users.length - 2 : 0;
      if (mention.type === "like") {
        notificationText =
          currentLanguage === "zh"
            ? `${firstName} 喜欢了你的推文`
            : `${firstName} ${config.notificationsLiked}`;
      } else if (mention.type === "retweet") {
        if (currentLanguage === "zh") {
          notificationText = `${firstName}${
            othersCount > 0 ? ` 和其他 ${othersCount} 人` : ""
          } 转推了推文`;
        } else {
          notificationText = `${firstName}${
            othersCount > 0 ? ` and ${othersCount} others` : ""
          } ${config.notificationsRetweeted}`;
        }
      } else if (mention.type === "reply") {
        notificationText =
          currentLanguage === "zh"
            ? `${firstName} 回复了你`
            : `${firstName} ${config.notificationsReplied}`;
      } else if (mention.type === "follow") {
        notificationText =
          currentLanguage === "zh"
            ? `${firstName} 关注了你`
            : `${firstName} ${config.notificationsFollowed}`;
      }
    }
    // 推文内容（如果有）
    let tweetContentHtml = "";
    if (mention.tweet) {
      // 处理图片（区分文字图和真实图）
      let imageHtml = "";
      if (mention.tweet.image) {
        if (
          typeof mention.tweet.image === "object" &&
          mention.tweet.image.type === "description"
        ) {
          // 文字图：使用与推文详情页相同的样式
          imageHtml = `
 <div style="margin-top: 8px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 12px; padding: 16px; box-sizing: border-box;">
 <div style="color:var(--x-text-primary); font-size: 15px; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; width: 100%; box-sizing: border-box;">${mention.tweet.image.content}</div>
 </div>
 `;
        } else {
          // 真实图：渲染为图片
          const imageUrl =
            typeof mention.tweet.image === "string"
              ? mention.tweet.image
              : mention.tweet.image.url;
          imageHtml = `<img src="${imageUrl}" style="width: 100%; border-radius: 12px; margin-top: 8px;">`;
        }
      }
      tweetContentHtml = `
 <div style="margin-top: 12px; padding: 12px; border: 1px solid var(--x-border-color); border-radius: 12px;">
 <div style="color:var(--x-text-primary); font-size: 15px; line-height: 1.4; margin-bottom: ${
   mention.tweet.image ? "8px" : "0"
 };">
 ${mention.tweet.content}
 </div>
 ${imageHtml}
 </div>
 `;
    }
    // 🔧 动态计算时间显示（优先使用timestamp，否则使用静态time）
    const displayTime = mention.timestamp
      ? getRelativeTime(mention.timestamp)
      : mention.time;
    contentArea.innerHTML = `
 ${avatarsHtml}
 <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 4px;">
 ${notificationText}
 </div>
 <div style="color:var(--x-text-secondary); font-size: 14px;">
 ${displayTime}
 </div>
 ${tweetContentHtml}
`;
    mentionEl.appendChild(iconArea);
    mentionEl.appendChild(contentArea);
    return mentionEl;
  }
  // 渲染陌生人私信项
  function renderStrangerMessageItem(message) {
    const config = languageConfig[currentLanguage] || languageConfig.zh; // 星星图标
    const iconColor = "var(--x-accent)";
    const iconSvg = `<svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: ${iconColor};"><g><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></g></svg>`;
    const messageEl = document.createElement("div");
    messageEl.className = "stranger-message-item";
    messageEl.style.cssText = `
 display: flex; gap: 12px; padding: 16px; border-bottom: 1px solid var(--x-border-color); cursor: pointer; transition: background-color 0.2s;
`;
    messageEl.onmouseover = () => {
      messageEl.style.backgroundColor = "var(--x-bg-hover)";
    };
    messageEl.onmouseout = () => {
      messageEl.style.backgroundColor = "transparent";
    }; // 点击打开私信详情
    messageEl.onclick = () => {
      openMessageDetail(message);
    }; // 左侧图标区域
    const iconArea = document.createElement("div");
    iconArea.style.cssText =
      "width: 40px; display: flex; align-items: flex-start; justify-content: flex-end; flex-shrink: 0;";
    iconArea.innerHTML = iconSvg; // 右侧内容区域
    const contentArea = document.createElement("div");
    contentArea.style.cssText = "flex: 1; min-width: 0;";
    let contentHtml = `
 <img src="${message.user.avatar}"
 alt="${message.user.name}"
 style="width: 32px; height: 32px; border-radius: 50%; margin-bottom: 8px;">
 <div style="color:var(--x-text-secondary); font-size: 15px; margin-bottom: 4px;">
 In case you missed <strong style="color:var(--x-text-primary);">${
   message.user.name
 }</strong>'s Message
 </div>
 <div style="color:var(--x-text-primary); font-size: 15px; line-height: 1.4; margin-bottom: 8px; font-weight: 500;">
 ${message.preview}
 </div>
 ${
   message.link
     ? `<div style="color: var(--x-accent); font-size: 15px; margin-bottom: 8px;">${message.link}</div>`
     : ""
 }
 ${
   message.attachment
     ? `<div style="color: var(--x-accent); font-size: 15px; margin-bottom: 8px;">${message.attachment}</div>`
     : ""
 }
 ${
   message.tweetLink
     ? `<div style="color: var(--x-accent); font-size: 15px;">${message.tweetLink}</div>`
     : ""
 }
`;
    contentArea.innerHTML = contentHtml;
    messageEl.appendChild(iconArea);
    messageEl.appendChild(contentArea);
    return messageEl;
  }
  // 加载陌生人私信列表
  async function loadNotifications() {
    const allList = document.getElementById("notifications-all-list");
    const mentionsList = document.getElementById("notifications-mentions-list");
    if (!allList) return;
    const config = languageConfig[currentLanguage] || languageConfig.zh; // 从数据库加载陌生人私信数据
    try {
      const xDb = getXDB();
      const dataId = `strangerMessages_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      if (savedData && savedData.data && Array.isArray(savedData.data)) {
        // 更新全局变量
        strangerMessages.length = 0;
        strangerMessages.push(...savedData.data);
        console.log(
          "✅ 从数据库加载了",
          strangerMessages.length,
          "条陌生人私信"
        );
      }
    } catch (error) {
      console.error("加载陌生人私信数据失败:", error);
    }
    // 清空现有内容
    allList.innerHTML = "";
    mentionsList.innerHTML = ""; // 渲染 All 标签的陌生人私信
    if (strangerMessages.length > 0) {
      strangerMessages.forEach((message) => {
        const messageEl = renderStrangerMessageItem(message);
        allList.appendChild(messageEl);
      });
    } else {
      // 显示空状态（点击羽毛笔生成私信）
      allList.innerHTML = `
 <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 32px; text-align: center;">
 <svg viewBox="0 0 24 24" style="width: 56px; height: 56px; fill: var(--x-text-secondary); margin-bottom: 16px;">
 <g><path d="M1.998 5.5c0-1.381 1.119-2.5 2.5-2.5h15c1.381 0 2.5 1.119 2.5 2.5v13c0 1.381-1.119 2.5-2.5 2.5h-15c-1.381 0-2.5-1.119-2.5-2.5v-13zm2.5-.5c-.276 0-.5.224-.5.5v2.764l8 3.638 8-3.636V5.5c0-.276-.224-.5-.5-.5h-15zm15.5 5.463l-8 3.636-8-3.638V18.5c0 .276.224.5.5.5h15c.276 0 .5-.224.5-.5v-8.037z"></path></g>
 </svg>
 <div style="font-size: 28px; font-weight: 700; color:var(--x-text-primary); margin-bottom: 8px;">暂无陌生人私信</div>
 <div style="font-size: 14px; color:var(--x-text-secondary); max-width: 320px;">点击右下角羽毛笔按钮生成新的陌生人私信</div>
 </div>
 `;
    }
    // 从数据库加载 Mentions 通知
    let allMentions = [];
    try {
      const xDb = getXDB();
      const mentionsDataId = `mentions_${currentAccountId || "main"}`;
      const savedMentions = await xDb.xAccountProfiles.get(mentionsDataId);
      if (
        savedMentions &&
        savedMentions.data &&
        Array.isArray(savedMentions.data)
      ) {
        allMentions = savedMentions.data;
        console.log("✅ 从数据库加载了", allMentions.length, "条Mentions通知");
      }
    } catch (error) {
      console.error("加载Mentions通知失败:", error);
    }
    // 渲染 Mentions 标签的通知
    if (allMentions.length > 0) {
      // 按时间戳排序（最新的在前面）
      allMentions.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
      allMentions.forEach((mention) => {
        let mentionEl;
        if (mention.type === "like") {
          mentionEl = renderLikeMentionItem(mention);
        } else if (mention.type === "retweet") {
          mentionEl = renderRetweetMentionItem(mention);
        } else {
          // 兼容旧的测试数据
          mentionEl = renderMentionItem(mention);
        }
        mentionsList.appendChild(mentionEl);
      });
    } else {
      // 空状态
      mentionsList.innerHTML = `
 <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 32px; text-align: center;">
 <svg viewBox="0 0 24 24" style="width: 56px; height: 56px; fill: var(--x-text-secondary); margin-bottom: 16px;">
 <g><path d="M1.751 10c0-4.42 3.584-8.005 8.005-8.005h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.005zm8.005-6.005c-3.317 0-6.005 2.69-6.005 6.005 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z"></path></g>
 </svg>
 <div style="font-size: 28px; font-weight: 700; color:var(--x-text-primary); margin-bottom: 8px;">${config.notificationsEmpty}</div>
 <div style="font-size: 14px; color:var(--x-text-secondary); max-width: 320px;">${config.notificationsEmptyDesc}</div>
 </div>
`;
    }
  }
  // 将函数暴露到全局
  window.loadNotifications = loadNotifications; // ▼▼▼ 【主要！！！】第八个情景：陌生人私信生成器▼▼▼
  async function refreshStrangerMessages() {
    const refreshBtn = document.getElementById("refresh-messages-btn"); // 添加旋转动画
    refreshBtn.style.animation = "spin 1s linear infinite";
    const spinStyle = document.createElement("style");
    spinStyle.textContent = `
 @keyframes spin {
 from {transform: rotate(0deg); }
 to {transform: rotate(360deg); }
 }
`;
    document.head.appendChild(spinStyle);
    try {
      // 🔧 使用统一的API配置加载工具
      const { apiConfig, xSettings, xDb } =
        await APIUtils.loadConfigAndSettings();
      const { userPrompt, worldSetting } = xSettings;
      // 使用工具函数构建用户X个人资料信息
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(
        window.userProfileData
      ); // 获取用户最新的5条推文
      const userTweetsId = `userTweets_${currentAccountId || "main"}`;
      const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
      const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || []; // Token计数器
      let tokenCount = 0; // 1. 提示词 + 世界书
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage(
        "陌生人私信生成器",
        "基础系统提示词",
        systemPrompt,
        tokenCount
      ); // 1.5. 获取适用的世界书内容（仅对陌生人私信界面）
      const worldBooksContent = await StringBuilders.getApplicableWorldBooks(
        "messages",
        {
          boundCharacters: [],
        }
      );
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage(
          "陌生人私信生成器",
          "世界书内容",
          worldBooksContent,
          tokenCount
        );
      }

      // 1.7. 🌍 读取世界运转大事件（如果启用）
      const worldEventsPrompt = await getWorldEventsPrompt("陌生人私信生成器", {
        usageRate: 0.2, // 20%的陌生人私信涉及大事件
        usageDescription: `**陌生人私信场景的大事件使用**：
1. **商务合作**：如果用户是高曝光人物，陌生人可能因为大事件找用户合作
   - 灾难事件："想邀请您参加XXX慈善活动"
   - 热点事件："能否请您就XXX事件发表看法？"
2. **粉丝留言**：粉丝可能提及大事件，询问用户看法
   - "看到最近的XXX事件，想知道您怎么看"
   - "希望您能为XXX发声！"
3. **推荐/分享**：陌生人可能因大事件而推荐内容
   - "最近XXX闹得挺大，给您推荐个相关资源"
4. **随机搭讪**：大事件可能成为搭讪话题
   - "今天XXX你看了吗？太震惊了"
5. **自然融入**：只有约20%的陌生人私信涉及大事件，其余是常规内容`,
      });

      if (worldEventsPrompt) {
        systemPrompt += worldEventsPrompt;
        tokenCount = TokenUtils.logTokenUsage(
          "陌生人私信生成器",
          "世界运转大事件",
          worldEventsPrompt,
          tokenCount
        );
      }

      // 2. 核心任务说明
      systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务说明 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的陌生人私信生成器。请生成3-8条来自陌生用户的私信消息。
**重要规则**：
- 这些私信来自陌生用户，不是用户的朋友或熟人
- 私信内容可以是：商务合作、粉丝留言、问询、推荐、随机搭讪等
- 私信发送者都是虚构的X平台用户
- 头像统一使用：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
      const coreTaskSection = systemPrompt.substring(
        systemPrompt.lastIndexOf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "陌生人私信生成器",
        "核心任务说明",
        coreTaskSection,
        tokenCount
      ); // 3. 用户资料
      const userConstraintsStart = systemPrompt.length;
      systemPrompt += `
【用户X平台资料】：
- 用户名：${userXProfileInfo.name}
- 用户句柄：${userXProfileInfo.handle}
- 认证状态：${userXProfileInfo.verified ? "已认证" : "未认证"}
${
  userXProfileInfo.publicIdentity
    ? `- 公众身份：${userXProfileInfo.publicIdentity}`
    : ""
}
${userXProfileInfo.bio ? `- 个人简介：${userXProfileInfo.bio}` : ""}
`; // 4. 用户最近推文
      if (recentUserTweets.length > 0) {
        systemPrompt += `
【用户最近推文】（供参考，陌生人可能看过这些推文）：
`;
        recentUserTweets.forEach((tweet, index) => {
          systemPrompt += `
${index + 1}. "${tweet.content}"
- 发布时间：${tweet.time || "最近"}
- 互动数据：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.comments || 0}评论
`;
        });
      }
      const userSection = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage(
        "陌生人私信生成器",
        "用户资料和推文",
        userSection,
        tokenCount
      );
      systemPrompt += `
【私信内容要求】：
- 私信类型多样化：商务邀请、粉丝留言、合作咨询、内容推荐、社交搭讪等
- 可以参考用户的推文内容或公众身份来设计私信话题
- 私信长度适中（20-100字）
- 部分私信可以附带链接、图片描述或推文链接
【JSON返回格式】：
\`\`\`json
{
"messages": [私信数组]
}
\`\`\`
私信对象结构：
- user: {name, handle, avatar, verified}
- preview: 私信预览内容（主要文本）
- link: 附带链接（可选，如个人网站、项目链接等）
- attachment: 附带的图片/文件描述（可选）
- tweetLink: 提及的推文链接（可选，如"你的这条推文xxx"）
关键规则：
1. verified字段必须是布尔值(true/false)，陌生人一般为false
2. user.avatar统一使用：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
3. 可选字段不使用时完全省略，不要设为null
4. 私信内容要真实自然，符合陌生人私信的特点
`;
      const formatSection = systemPrompt.substring(
        systemPrompt.lastIndexOf("【JSON返回格式】")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "陌生人私信生成器",
        "JSON格式要求",
        formatSection,
        tokenCount
      );
      const messages = [{ role: "user", content: "请生成新的陌生人私信数据" }]; // 最终统计
      TokenUtils.logFinalPrompt(
        "陌生人私信生成器",
        systemPrompt,
        messages[0].content
      );
      // 🔧 使用统一的API请求工具
      const aiResponseContent = await APIUtils.sendAIRequest({
        apiConfig,
        systemPrompt,
        messages,
        temperature: 0.8,
      });
      // 🔧 使用统一的JSON解析工具
      const messagesData = APIUtils.parseJSONResponse(aiResponseContent);
      // 验证数据格式
      if (!messagesData.messages || !Array.isArray(messagesData.messages)) {
        throw new Error("AI返回的数据格式不正确，缺少messages数组");
      }
      // 为私信添加ID
      const timestamp = Date.now();
      messagesData.messages.forEach((message, index) => {
        message.id = `sm_${timestamp}_${index}`;
      }); // 更新全局数据
      strangerMessages.length = 0;
      strangerMessages.push(...messagesData.messages); // 保存陌生人私信数据到数据库
      try {
        const xDb = getXDB();
        const dataId = `strangerMessages_${currentAccountId || "main"}`;
        await xDb.xAccountProfiles.put({
          handle: dataId,
          name: "strangerMessages",
          data: messagesData.messages,
          updatedAt: new Date().toISOString(),
        });
        console.log("✅ 陌生人私信数据已保存到数据库");
      } catch (saveError) {
        console.error("保存陌生人私信数据失败:", saveError);
      }
      // 重新渲染页面
      loadNotifications(); // 显示手机样式通知
      const isEnglish = currentLanguage === "en";
      const userAvatar =
        window.userProfileData?.avatar ||
        "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg";
      showPhoneNotification({
        title: "X",
        message: isEnglish
          ? "Stranger messages have been refreshed!"
          : "陌生人私信已刷新！",
        avatar: userAvatar,
        leftIcon: "x",
      });
    } catch (error) {
      console.error("刷新陌生人私信失败:", error);
      showXToast(`刷新失败: ${error.message}`, "error");
    } finally {
      // 停止旋转动画
      refreshBtn.style.animation = "";
      if (spinStyle && spinStyle.parentNode) {
        spinStyle.remove();
      }
    }
  }
  // 将函数暴露到全局
  window.refreshStrangerMessages = refreshStrangerMessages;
  // ▲▲▲ 【主要！！！】第八个情景：陌生人私信生成器 ▲▲▲
  // ▼▼▼ 【主要！！！】第九个情景：私信详情生成器▼▼▼
  async function generateMessageConversation(
    messageData,
    isContinueMode = false,
    options = {}
  ) {
    try {
      // options可以包含：isAutoMessage（自动发消息模式）、timeSinceLastMessage（距离上次消息的秒数）、isAskboxViewed（提问箱查看模式）、askboxContent（提问箱内容）、businessTaskEvaluation（商业任务评估）、isUnblockRequest（拉黑解除请求）、unblockContext（拉黑解除上下文）、liveUserData（从直播间进入的用户数据）、isStreamerContact（主播主动私联模式）、streamerContactData（主播私联上下文数据）
      const isAutoMessage = options.isAutoMessage || false;
      const timeSinceLastMessage = options.timeSinceLastMessage || 0;
      const isAskboxViewed = options.isAskboxViewed || false;
      const askboxContent = options.askboxContent || "";
      const businessTaskEvaluation = options.businessTaskEvaluation || null;
      const isUnblockRequest = options.isUnblockRequest || false;
      const unblockContext = options.unblockContext || null;
      const liveUserData = options.liveUserData || null; // 💎 直播间用户数据
      const isStreamerContact = options.isStreamerContact || false; // 🎤 主播主动私联模式
      const streamerContactData = options.streamerContactData || null; // 🎤 主播私联上下文
      // 🔧 使用统一的API配置加载工具
      const { apiConfig, xSettings, xDb } =
        await APIUtils.loadConfigAndSettings();
      // 判断私信类型
      let messageType = "stranger"; // stranger | character | account
      let characterId = null;
      let accountHandle = null;
      if (messageData.id) {
        if (messageData.id.startsWith("msg_account_")) {
          messageType = "account"; // 从currentViewingAccount获取账户句柄
          if (currentViewingAccount && currentViewingAccount.accountInfo) {
            accountHandle = currentViewingAccount.accountInfo.handle.replace(
              "@",
              ""
            );
          }
        } else if (
          messageData.id.startsWith("msg_") &&
          messageData.id !== "msg_001"
        ) {
          messageType = "character";
          characterId = messageData.id.replace("msg_", "");
        }
      }
      console.log(`📨 私信类型: ${messageType}`, {
        characterId,
        accountHandle,
      }); // 标准化 messageData 格式（确保有 user 对象）
      if (!messageData.user && messageData.userName) {
        messageData.user = {
          name: messageData.userName,
          handle: messageData.userHandle,
          avatar: messageData.userAvatar,
          verified: messageData.verified || false,
        };
      }
      // 如果是续写模式，读取现有对话上下文
      let existingMessages = [];
      if (isContinueMode) {
        // 🔧 多账户隔离：包含账户ID
        const conversationId = `messageConversation_${
          currentAccountId || "main"
        }_${messageData.id}`;
        const savedConversation = await xDb.xAccountProfiles.get(
          conversationId
        );
        if (
          savedConversation &&
          savedConversation.data &&
          savedConversation.data.messages
        ) {
          existingMessages = savedConversation.data.messages;
          console.log(
            `📖 [私信生成器] 读取到 ${existingMessages.length} 条现有对话记录`
          );
        } else {
          console.log(`📖 [私信生成器] 无现有对话记录（首次对话）`);
        }
      }
      // 💼 检查是否有进行中的商业转账任务
      let ongoingBusinessTransfer = null;
      if (isContinueMode && existingMessages.length > 0) {
        // 查找最近的进行中商业转账（倒序查找，取最新的）
        const transferMessages = existingMessages.filter(
          (msg) =>
            msg.type === "transfer" &&
            msg.isBusiness &&
            msg.taskStatus === "in_progress"
        );
        if (transferMessages.length > 0) {
          ongoingBusinessTransfer =
            transferMessages[transferMessages.length - 1]; // 最新的进行中任务
          console.log(
            `💼 [商业转账] 检测到进行中的任务，接收方: ${
              ongoingBusinessTransfer.isOwn ? "AI" : "用户"
            }`
          );
        }
      }
      // 使用从APIUtils获取的xSettings
      const { userPrompt, worldSetting } = xSettings;
      // 使用工具函数构建用户X个人资料信息
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(
        window.userProfileData
      ); // 获取用户最新的5条推文
      const userTweetsId = `userTweets_${currentAccountId || "main"}`;
      const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
      const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || []; // Token计数器
      let tokenCount = 0; // 1. 提示词 + 世界书
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage(
        "私信详情生成器",
        "基础系统提示词",
        systemPrompt,
        tokenCount
      ); // 1.5. 添加当前时间信息（北京时间）
      const now = new Date();
      const beijingTime = new Date(now.getTime() + 8 * 60 * 60 * 1000); // UTC+8
      const year = beijingTime.getUTCFullYear();
      const month = beijingTime.getUTCMonth() + 1;
      const day = beijingTime.getUTCDate();
      const hours = beijingTime.getUTCHours();
      const minutes = beijingTime.getUTCMinutes();
      const weekdays = [
        "星期日",
        "星期一",
        "星期二",
        "星期三",
        "星期四",
        "星期五",
        "星期六",
      ];
      const weekday = weekdays[beijingTime.getUTCDay()];
      let timeOfDay = "";
      if (hours >= 5 && hours < 9) {
        timeOfDay = "清晨";
      } else if (hours >= 9 && hours < 12) {
        timeOfDay = "上午";
      } else if (hours >= 12 && hours < 14) {
        timeOfDay = "中午";
      } else if (hours >= 14 && hours < 18) {
        timeOfDay = "下午";
      } else if (hours >= 18 && hours < 22) {
        timeOfDay = "晚上";
      } else {
        timeOfDay = "深夜";
      }
      systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⏰ 当前时间信息 ⏰
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
当前时间（北京时间）：${year}年${month}月${day}日 ${weekday} ${String(
        hours
      ).padStart(2, "0")}:${String(minutes).padStart(2, "0")}
时段：${timeOfDay}
**请根据当前时间生成符合时间情境的回复**：
- 如果是清晨或上午，可以问候早安、讨论早餐或一天的计划
- 如果是中午，可以讨论午餐或午休
- 如果是下午，可以讨论工作或下午茶
- 如果是晚上，可以问候晚安、讨论晚餐或晚间活动
- 如果是深夜，考虑为什么还没睡或深夜的话题
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
      tokenCount = TokenUtils.logTokenUsage(
        "私信详情生成器",
        "时间信息",
        systemPrompt.substring(systemPrompt.lastIndexOf("⏰ 当前时间信息")),
        tokenCount
      ); // 1.6. 获取适用的世界书内容（全局对话 + 仅角色对话 + 指定角色）
      const worldBooksOptions = { boundCharacters: [] };
      if (messageType === "character" && characterId) {
        // 角色私信：传入角色ID
        worldBooksOptions.boundCharacters = [characterId];
      } else if (messageType === "account") {
        // 账户私信：暂不传入角色（可以后续扩展）
        worldBooksOptions.boundCharacters = [];
      }
      // stranger 类型不传入角色，只有全局对话的世界书会生效
      const worldBooksContent = await StringBuilders.getApplicableWorldBooks(
        "messages",
        worldBooksOptions
      );
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage(
          "私信详情生成器",
          "世界书内容",
          worldBooksContent,
          tokenCount
        );
      }

      // 1.7. 🌍 读取世界运转大事件（如果启用）
      const worldEventsPrompt = await getWorldEventsPrompt("私信详情生成器", {
        usageRate: 0.15, // 15%的私信对话涉及大事件（私信更私密，不会过多讨论公共话题）
        usageDescription: `**私信对话场景的大事件使用**：
1. **话题引入**：角色可能在私信中提及最近的大事件，作为聊天话题
   - "你看到最近的XXX了吗？"
   - "今天XXX闹得挺大，你怎么看？"
2. **情绪影响**：大事件可能影响角色的情绪和状态
   - 如果是灾难事件，角色可能表现出担忧、悲伤
   - 如果是好事，角色可能表现出兴奋、开心
3. **生活影响**：大事件可能影响角色的日常生活
   - 天气事件影响出行计划
   - 政策事件影响工作安排
4. **轻度关联**：私信是私密对话，大事件只是背景话题，不会过分强调
5. **自然融入**：只有约15%的私信涉及大事件，保持对话的私密性和个人化`,
      });

      if (worldEventsPrompt) {
        systemPrompt += worldEventsPrompt;
        tokenCount = TokenUtils.logTokenUsage(
          "私信详情生成器",
          "世界运转大事件",
          worldEventsPrompt,
          tokenCount
        );
      }

      // 2. 核心任务说明
      if (isContinueMode) {
        // 续写模式 - 根据私信类型显示不同的任务说明
        if (messageType === "character") {
          // 角色私信
          if (isAskboxViewed) {
            // 提问箱查看模式
            systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务说明（提问箱查看模式 - 角色私信）🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的私信对话生成器。角色发现用户查看了自己的提问箱，现在主动发送私信。
**对话场景**：
- 📱 这是X社交平台（类似Twitter/X）的私信功能
- 🔍 角色${messageData.user.name}发现用户偷看了TA的提问箱
- 📝 用户刚刚查看了以下提问箱内容：
${askboxContent}
**角色信息**：
- 角色名：${messageData.user.name}
- 角色句柄：${messageData.user.handle}
- 这是一个已绑定的角色，有完整的人设、记忆和X平台资料
**重要规则**：
- 🚨 只生成角色${messageData.user.name}的主动消息，不要生成用户的消息
- ⚠️ **这是X平台的私信对话，不是手机短信或其他聊天软件**
- 📖 **必须参考下方的【X平台私信对话记录】**，了解你们之前的对话内容，保持对话的连贯性和一致性
- 角色知道用户查看了TA的提问箱，可以调侃、好奇或关心用户为什么要看
- 可以结合提问箱的内容展开话题，询问用户的想法或意见
- 生成1-8条符合角色性格的主动消息
- 回复要严格符合角色的性格、说话风格和与用户的关系
- 可以表现出：发现被偷看的惊讶、调皮、害羞、好奇等情绪（根据角色性格）
- 结合之前的X平台私信对话记录和提问箱内容，保持一致性
- 消息类型包括：文本、图片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、语音、文章链接（link：需要title、description、author、source、body完整正文）、转发推文、转发主页
- ⚠️ 注意：image和sticker是完全不同的类型，不要混淆！link类型是文章链接，需要包含完整的文章内容
- ⚠️ 禁止生成forward类型消息（这是用户手动转发产生的）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          } else if (isAutoMessage) {
            // 自动发消息模式
            const likedTweetContext = options.likedTweetContext;
            const hasLikedTweet =
              likedTweetContext && likedTweetContext.content;
            const isBusinessEvaluation =
              businessTaskEvaluation &&
              businessTaskEvaluation.isBusinessTaskEvaluation;
            if (isBusinessEvaluation) {
              // 商业任务评估模式
              const tweetData = businessTaskEvaluation.tweetData;
              const businessTransfer = businessTaskEvaluation.businessTransfer; // 计算推文数据
              const likes = tweetData.stats?.likes || 0;
              const retweets = tweetData.stats?.retweets || 0;
              const comments = tweetData.stats?.comments || 0;
              const views = tweetData.stats?.views || 0;
              systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💼 核心任务说明（商业任务评估模式 - 角色私信）💼
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的私信对话生成器。角色雇佣了用户完成商业推广任务，现在评估任务完成情况并决定付款。
**对话场景**：
- 📱 这是X社交平台（类似Twitter/X）的私信功能
- 💼 角色${messageData.user.name}之前发起了商业转账
- ✅ 用户已完成任务，发布了商业化推贴
- 🤖 角色现在要评估任务完成情况，并决定如何付款
**商业转账信息**：
- 总金额：$${parseFloat(businessTransfer.amount).toFixed(2)}
- 已支付定金：$${parseFloat(businessTransfer.depositAmount).toFixed(2)} (${
                businessTransfer.depositRatio
              }%)
- 待付尾款：$${parseFloat(businessTransfer.remainingAmount).toFixed(2)}
- 任务要求：${businessTransfer.taskDescription}
- 任务期限：${businessTransfer.taskDeadlineHours}小时
**用户完成的推贴内容**：
- 推文内容："${tweetData.content}"
${
  tweetData.image
    ? `- 包含图片：${
        tweetData.image.type === "description"
          ? tweetData.image.content
          : "已上传图片"
      }`
    : ""
}
${tweetData.location ? `- 位置：${tweetData.location}` : ""}
- 发布时间：${tweetData.time || "刚刚"}
**推文数据表现**：
- 👍 喜欢数：${likes}
- 🔄 转发数：${retweets}
- 💬 评论数：${comments}
- 👀 浏览量：${views}
**评论区反馈**：
${
  tweetData.comments && tweetData.comments.length > 0
    ? tweetData.comments
        .slice(0, 5)
        .map((c, i) => `${i + 1}. ${c.user.name}: "${c.content}"`)
        .join("\n")
    : "暂无评论"
}
**用户公众身份**：
- 用户名：${userXProfileInfo.name}
- 用户句柄：${userXProfileInfo.handle}
- 认证状态：${userXProfileInfo.verified ? "已认证" : "未认证"}
${
  userXProfileInfo.publicIdentity
    ? `- 公众身份：${userXProfileInfo.publicIdentity}`
    : ""
}
- 粉丝影响力：${userXProfileInfo.publicIdentity ? "有一定影响力" : "普通用户"}
**评估规则**：
🎯 你需要根据以下标准评估任务完成情况：
1. **内容质量**（40%）：
- 推文是否符合任务要求？
- 表达是否自然，不是生硬的广告？
- 是否包含了要求的关键信息？
2. **数据表现**（30%）：
- 推文的互动数据（喜欢、转发、评论、浏览量）如何？
- 与用户的粉丝基础相匹配吗？
- 评论区反馈是否正面？
3. **用户影响力**（30%）：
- 用户的公众身份和影响力如何？
- 认证状态是否增加可信度？
- 是否值得额外投资？
**付款决策**：
根据评估结果，你需要决定：
✅ **满意（80-100分）**：
- 支付全额尾款 + 额外10-30%奖励
- 示例：总额$200，定金$40，尾款$160，额外奖励$20-60
- 在回复中表达满意，感谢合作，期待下次合作
👍 **中规中矩（60-79分）**：
- 支付全额尾款，无额外奖励
- 示例：总额$200，定金$40，尾款$160
- 在回复中表示认可，指出可以改进的地方
😐 **不满意但可接受（40-59分）**：
- 支付50-80%的尾款
- 示例：总额$200，定金$40，尾款$160，实际支付$80-128
- 在回复中指出不足，表达轻微失望
❌ **非常不满意（<40分）**：
- 不支付尾款或仅支付20-40%
- 示例：总额$200，定金$40，尾款$160，实际支付$0-64
- 在回复中明确指出问题，表达不满
**重要规则**：
- 🚨 只生成角色${messageData.user.name}的评估消息，不要生成用户的消息
- ⚠️ **这是X平台的私信对话，不是手机短信或其他聊天软件**
- 💰 **必须发送转账消息支付尾款**（amount为尾款金额，note说明付款原因）
- 📖 参考下方的【X平台私信对话记录】，保持对话的连贯性
- 🎭 评估要符合角色性格，有的角色很大方，有的很挑剔
- 💬 生成1-3条文本消息说明评估结果，然后发送转账
- ⚠️ 转账消息的note要说明是尾款、奖励还是扣款
**消息示例结构**：
1. 文本消息：评估内容质量
2. 文本消息（可选）：评估数据表现
3. 转账消息：支付尾款（必须）
4. 文本消息（可选）：感谢或建议
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
            } else {
              // 普通自动发消息模式
              const isAwayReturn = options.isAwayReturn || false;
              systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务说明（自动发消息模式 - 角色私信）🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的私信对话生成器。角色主动发起私信（后台自动活动）。
**对话场景**：
- 📱 这是X社交平台（类似Twitter/X）的私信功能
${
  isAwayReturn
    ? `- 🔙 **特殊情况：离开后返回**
- 角色${messageData.user.name}之前因为有事暂时离开，现在忙完了，主动联系用户
- 距离上次对话已经过去了约 ${Math.round(timeSinceLastMessage / 60)} 分钟
- 🤖 角色应该解释自己去忙什么了，并对让用户等待表示歉意或说明情况
- 生成1-5条符合角色性格的主动消息，体现出刚忙完的状态`
    : hasLikedTweet
    ? `- 💖 用户刚刚喜欢了角色${messageData.user.name}的推文
- 📝 被喜欢的推文内容："${likedTweetContext.content}"
- 🤖 角色发现用户喜欢了TA的推文，现在主动发送私信`
    : `- ⏰ 距离上一次对话已经过去了 ${timeSinceLastMessage} 秒
- 🤖 角色${messageData.user.name}现在主动发送私信`
}
**角色信息**：
- 角色名：${messageData.user.name}
- 角色句柄：${messageData.user.handle}
- 这是一个已绑定的角色，有完整的人设、记忆和X平台资料
**重要规则**：
- 🚨 只生成角色${messageData.user.name}的主动消息，不要生成用户的消息
- ⚠️ **这是X平台的私信对话，不是手机短信或其他聊天软件**
${
  isAwayReturn
    ? `- 📖 **必须参考下方的【X平台私信对话记录】**，查看用户之前发送的消息
- 🔙 角色现在忙完了，应该回应用户之前的消息内容
- 可以先道歉/解释为什么离开了一段时间，然后回应用户的消息
- 消息风格要自然，符合角色性格（有的角色会认真道歉，有的随意说明）
- 根据角色性格和与用户的关系，调整道歉的正式程度
- 回复要严格符合角色的性格、说话风格和与用户的关系
- 参考角色的聊天记忆（包括X平台私信记忆和其他聊天记忆），保持一致性`
    : hasLikedTweet
    ? `- 📖 **必须参考下方的【X平台私信对话记录】**，了解你们之前的对话内容，保持对话的连贯性和一致性
- 💖 角色知道用户喜欢了TA的推文（上面显示的推文内容），可以表现出惊喜、开心、好奇等情绪
- 可以结合推文内容展开话题，询问用户的想法或感受
- 生成1-5条符合角色性格的主动消息，表现出看到自己的推文被喜欢的反应
- 回复要严格符合角色的性格、说话风格和与用户的关系
- 可以表现出：发现被关注的开心、想继续交流的期待等情绪（根据角色性格）
- 结合之前的X平台私信对话记录和推文内容，保持一致性`
    : `- 根据距离上次对话的时间，生成1-7条符合角色性格的主动消息
- 主动消息可以是：想念对方、分享近况、询问对方、提及X平台的推文等
- 回复要严格符合角色的性格、说话风格和与用户的关系
- 参考角色的聊天记忆（包括X平台私信记忆和其他聊天记忆），保持一致性
- 可以自然提及角色最近在X平台发布的推文或动态`
}
- 消息类型包括：文本、图片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、语音、文章链接（link：需要title、description、author、source、body完整正文）、转发推文、转发主页
- ⚠️ 注意：image和sticker是完全不同的类型，不要混淆！link类型是文章链接，需要包含完整的文章内容
- ⚠️ 禁止生成forward类型消息（这是用户手动转发产生的）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
            }
          } else if (isUnblockRequest) {
            // 拉黑解除请求模式
            const triggerSource = unblockContext?.triggerSource || "unknown";
            const triggerContent = unblockContext?.triggerContent || "";
            systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔓 核心任务说明（拉黑解除评估 - 角色私信）🔓
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的私信对话生成器。你之前拉黑了用户，但用户通过其他方式联系了你，现在需要评估是否解除拉黑。
**对话场景**：
- 📱 这是X社交平台（类似Twitter/X）的私信功能
- ⚠️ **你之前已经拉黑了用户，用户无法直接发送私信**
- 🔔 但用户通过${
              triggerSource === "mention" ? "在推文中@你" : "在评论区评论"
            }的方式联系了你
**角色信息**：
- 角色名：${messageData.user.name}
- 角色句柄：${messageData.user.handle}
- 这是一个已绑定的角色，有完整的人设、记忆和X平台资料
**用户的触发内容**：
${
  triggerSource === "mention" ? "用户在推文中@了你：" : "用户在评论区提到了你："
}
"${triggerContent}"
**重要规则**：
- 🚨 只生成角色${messageData.user.name}的回复消息，不要生成用户的消息
- 📖 **必须参考下方的【X平台私信对话记录】**，了解之前为什么拉黑用户
- 🤔 根据用户的触发内容，评估是否值得解除拉黑
**解除拉黑决策**：
你需要根据以下因素决定是否解除拉黑：
1️⃣ **解除拉黑（推荐）**：
- 用户的态度诚恳，有道歉或和解的意图
- 用户提到的内容让你觉得可以原谅
- 用户表现出改变或理解
- 之前的冲突不算特别严重
- **返回格式**：[解除拉黑系统提示] + 0-3条文本消息（可以是原谅的话、重新开始的话，或直接不发其他消息）
2️⃣ **继续拉黑**：
- 用户的态度依然恶劣或不真诚
- 用户的内容让你更生气
- 之前的冲突太严重，无法原谅
- **返回格式**：返回空数组[]（表示不回应，继续拉黑）
**解除拉黑系统提示格式**：
{
"type": "system",
"systemType": "unblocked",
"content": "对方已解除拉黑",
"time": "刚刚"
}
⚠️ 如果决定解除拉黑，系统提示后可以跟0-3条文本消息：
- 0条：直接解除，不说话（高冷风格）
- 1-2条：简单回应（"算了，原谅你了"、"看在你道歉的份上..."）
- 2-3条：详细回应（解释为什么原谅、提出要求等）
⚠️ 如果决定继续拉黑，返回空数组[]即可，不需要任何消息
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`;
          } else if (isStreamerContact) {
            // 🎤 主播主动私联模式
            const contactTrigger = streamerContactData?.trigger || "unknown"; // "giftRank" | "fanClub"
            const triggerDetails = streamerContactData?.details || {};

            // 📡 获取直播间详细资料信息（标题、简介、公告、互动历史）
            let liveRoomContext = "";
            if (typeof window !== "undefined" && window.currentLiveRoomData) {
              const liveData = window.currentLiveRoomData;
              const details = liveData.details || {};

              liveRoomContext = `

📺 **你的直播间资料**：
- 直播标题：${details.title || "未设置"}
- 直播简介：${details.description || "未设置"}
- 直播公告：${details.announcement || "无公告"}
- 直播状态：${liveData.isLive ? "正在直播" : "未直播"}
${details.streamType ? `- 直播分类：${details.streamType}` : ""}

🎭 **你的主播人设信息**：
${
  details.streamerPersonality
    ? `- 性格特点：${details.streamerPersonality}`
    : ""
}
${details.contentTheme ? `- 内容主题：${details.contentTheme}` : ""}
${details.targetAudience ? `- 目标观众：${details.targetAudience}` : ""}

💬 **你在直播间的最近发言**（最近50条，体现你的说话风格和当前状态）：
`;

              // 获取主播最近50条发言
              if (
                liveData.danmakuMessages &&
                liveData.danmakuMessages.length > 0
              ) {
                const streamerMessages = liveData.danmakuMessages
                  .filter((msg) => msg.isStreamer)
                  .slice(-50)
                  .reverse(); // 最新的在前

                if (streamerMessages.length > 0) {
                  streamerMessages.forEach((msg, index) => {
                    liveRoomContext += `  ${index + 1}. "${msg.text}"\n`;
                  });
                } else {
                  liveRoomContext += `  （暂无发言记录）\n`;
                }
              } else {
                liveRoomContext += `  （暂无发言记录）\n`;
              }

              liveRoomContext += `
💭 **直播间最近互动**（最近50条弹幕，了解直播间氛围）：
`;

              // 获取最近50条弹幕（包括用户和其他观众）
              if (
                liveData.danmakuMessages &&
                liveData.danmakuMessages.length > 0
              ) {
                const recentDanmaku = liveData.danmakuMessages
                  .slice(-50)
                  .reverse(); // 最新的在前

                recentDanmaku.forEach((msg, index) => {
                  const prefix = msg.isStreamer
                    ? "[你]"
                    : `[${msg.username || "观众"}]`;
                  liveRoomContext += `  ${index + 1}. ${prefix}: "${
                    msg.text
                  }"\n`;
                });
              } else {
                liveRoomContext += `  （暂无弹幕记录）\n`;
              }

              liveRoomContext += `
⚠️ **重要提示**：
- 以上是你在直播间的真实表现和说话风格，请在私信中保持一致
- 你可以参考自己最近说过的话来确定当前的心情、状态和话题
- 观察直播间氛围和观众互动，了解当前直播的情况
- 私信回复应该符合你在直播间展现的性格和状态
- **你主动私联是有目的的**：维护与高消费用户的关系，根据你的性格决定如何表达
`;
            }

            systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎤 核心任务说明（主播主动私联模式 - 角色私信）🎤
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的私信对话生成器。主播因为用户的特殊贡献，主动发起私信维护关系。

**对话场景**：
- 📱 这是X社交平台（类似Twitter/X）的私信功能
- 🎤 主播${messageData.user.name}主动联系用户，想要维护金钱关系
- ${
              contactTrigger === "giftRank"
                ? `💰 **触发原因：礼物榜排名**
  - 用户在直播间礼物榜排名第 ${triggerDetails.rank || "?"} 名
  - 累计送礼积分：${triggerDetails.totalPoints || 0}P
  - 主播注意到了这位土豪用户的慷慨支持`
                : `🌟 **触发原因：粉丝团等级**
  - 用户粉丝团等级：LV${triggerDetails.level || "?"} ${
                    triggerDetails.levelName || ""
                  }
  - 累计粉丝团积分：${triggerDetails.totalPoints || 0}P
  - 主播注意到了这位高等级粉丝的忠诚支持`
            }
${liveRoomContext}

**角色信息**：
- 角色名：${messageData.user.name}
- 角色句柄：${messageData.user.handle}
- 这是一个主播账户，在直播间与用户有互动历史

**重要规则**：
- 🚨 只生成主播${messageData.user.name}的主动私信消息，不要生成用户的消息
- ⚠️ **这是X平台的私信对话，不是手机短信或其他聊天软件**
- 💰 **这是主播主动私联，目的是维护与高消费用户的关系**
- 🎭 **主播的态度取决于其性格**：
  * 势利型：直白地表达感谢，暗示希望继续支持
  * 温柔型：真诚感谢，关心用户，建立情感连接
  * 高冷型：可能只是礼貌性问候，不会过于热情
  * 商业型：可能提及专属福利、私下优惠等
  * 傲娇型：表面不在意但实际很重视，委婉表达感激

**用户在直播间的行为数据**：
${
  contactTrigger === "giftRank" && triggerDetails.giftHistory
    ? `
💰 **送礼历史**（最近送的礼物）：
${triggerDetails.giftHistory
  .slice(0, 10)
  .map(
    (gift, i) =>
      `  ${i + 1}. 「${gift.name}」- ${gift.price}积分${
        gift.description ? ` (${gift.description})` : ""
      }`
  )
  .join("\n")}
${
  triggerDetails.giftHistory.length > 10
    ? `  ...还有${triggerDetails.giftHistory.length - 10}个礼物`
    : ""
}
`
    : ""
}
${
  triggerDetails.fanClubData
    ? `
🌟 **粉丝团状态**：
- ${
        triggerDetails.fanClubData.joined
          ? `✅ 已加入粉丝团 LV${triggerDetails.fanClubData.level} (${triggerDetails.fanClubData.points}积分)`
          : "❌ 未加入粉丝团"
      }
`
    : ""
}
${
  triggerDetails.danmakuHistory && triggerDetails.danmakuHistory.length > 0
    ? `
💬 **用户发送的弹幕**（最近${Math.min(
        triggerDetails.danmakuHistory.length,
        10
      )}条）：
${triggerDetails.danmakuHistory
  .slice(0, 10)
  .map((dm, i) => `  ${i + 1}. "${dm}"`)
  .join("\n")}
`
    : ""
}

**回复内容建议**：
- 生成1-5条符合主播性格的主动私信
- 可以包含：
  * 感谢用户的支持（必须）
  * 提及用户送的某个特别的礼物（如果有送礼历史）
  * 询问用户的直播体验
  * 提供专属福利或优惠
  * 建立私下联系（如私人号码、其他平台账号）
  * 分享一些不在直播间说的话
  * 邀请参加线下活动（如果合适）
  * 可以回应用户发的某条有趣的弹幕（如果有弹幕历史）
- 消息类型包括：文本、图片、表情包、语音、链接、转发推文、转发主页
- ⚠️ 注意：主播主动私联是有目的的行为，回复应体现出对高消费用户的重视
- ⚠️ 不要编造或猜测没有提到的信息，只基于上述提供的数据

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          } else {
            // 普通回复模式
            systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务说明（续写模式 - 角色私信）🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的私信对话生成器。用户刚刚发送了新的私信，请扮演已绑定的角色生成回复。
**对话场景**：
- 📱 这是X社交平台（类似Twitter/X）的私信功能
- ⚠️ **这是X平台的私信对话，不是手机短信或其他聊天软件**
**角色信息**：
- 角色名：${messageData.user.name}
- 角色句柄：${messageData.user.handle}
- 这是一个已绑定的角色，有完整的人设、记忆和X平台资料
**重要规则**：
- 🚨 只生成角色${messageData.user.name}的回复消息，不要生成用户的消息
**回复决策（你可以选择如何回应）**：
1️⃣ **正常回复**：生成1-10条符合角色人设的自然回复（最常见）
2️⃣ **不回复**：如果这是首次对话且用户的消息不吸引人、内容冒犯、或角色没有回复的理由，可以返回空数组[]
3️⃣ **拉黑用户**：如果发生严重冲突、用户持续骚扰、或对话已经恶化到无法继续，可以返回拉黑系统提示
4️⃣ **暂时离开**：如果角色临时有事无法回复（工作、上课、睡觉等），可以返回离开系统提示，稍后会主动联系用户
**正常回复要求**：
- 回复要严格符合角色的性格、说话风格和与用户的关系
- 参考角色的聊天记忆（包括X平台私信记忆和其他聊天记忆），保持一致性
- 可以适当提及角色最近在X平台发布的推文或动态
- 消息类型包括：文本、图片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、语音、文章链接（link：需要title、description、author、source、body完整正文）、转发推文、转发主页、系统提示（system）
- ⚠️ 注意：image和sticker是完全不同的类型，不要混淆！link类型是文章链接，需要包含完整的文章内容
- ⚠️ 禁止生成forward类型消息（这是用户手动转发产生的）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`; // 💼 添加商业任务上下文（如果有进行中的任务）
            if (ongoingBusinessTransfer) {
              const isAIReceiver = !ongoingBusinessTransfer.isOwn; // AI是接收方
              const isUserReceiver = ongoingBusinessTransfer.isOwn; // 用户是接收方
              const taskDesc = ongoingBusinessTransfer.taskDescription || "";
              const remainingAmount = parseFloat(
                ongoingBusinessTransfer.remainingAmount || 0
              ).toFixed(2); // 检测任务是否是发帖类型
              const postKeywords = [
                "发帖",
                "发推",
                "发推特",
                "发推文",
                "post",
                "tweet",
                "宣传",
                "推广",
              ];
              const isPostTask = postKeywords.some((kw) =>
                taskDesc.toLowerCase().includes(kw.toLowerCase())
              );
              if (isAIReceiver && !isPostTask) {
                // AI是接收方，且任务不是发帖类型
                systemPrompt += `
💼 **进行中的商业任务**（你是接收方）：
- 任务要求：${taskDesc}
- 任务期限：${ongoingBusinessTransfer.taskDeadlineHours}小时内完成
- 待付尾款：$${remainingAmount}
⚠️ **重要提示**：
- 你需要在对话中自然地发送**图片消息**（type: "image"）作为完成任务的证明
- 图片内容应该与任务要求相关，展示你完成了任务
- 发送图片后，用户会查看并决定是否支付尾款
- 在发送图片时，可以配合文本消息说明你完成了什么
- 不要刻意催促，自然地在对话中展示成果即可
`;
              } else if (isUserReceiver && !isPostTask) {
                // 用户是接收方，且任务不是发帖类型
                // 检查用户是否刚刚发送了图片
                const userMessages = options.userMessages || [];
                const hasUserImage = userMessages.some(
                  (msg) => msg.type === "image"
                );
                if (hasUserImage) {
                  systemPrompt += `
💼 **进行中的商业任务**（用户是接收方）：
- 任务要求：${taskDesc}
- 任务期限：${ongoingBusinessTransfer.taskDeadlineHours}小时内完成
- 待付尾款：$${remainingAmount}
⚠️ **重要提示**：
- 用户刚刚发送了图片，可能是完成任务的证明
- 请识别图片内容，判断用户是否完成了任务要求
- 如果你认为用户完成了任务：
1. 先发送1-2条文本消息表达认可和评价
2. 然后发送转账消息支付尾款（amount为${remainingAmount}，note说明是任务尾款，status为"pending"）
- 如果你认为用户未完成或不符合要求：
1. 礼貌地指出问题
2. 可以要求用户重新提交或补充
3. 不发送转账消息
- 根据完成质量，你可以：
* 支付全额尾款：$${remainingAmount}
* 支付部分尾款：$${(parseFloat(remainingAmount) * 0.5).toFixed(2)} - $${(
                    parseFloat(remainingAmount) * 0.8
                  ).toFixed(2)}（如果质量一般）
* 支付尾款+奖励：$${(parseFloat(remainingAmount) * 1.1).toFixed(2)} - $${(
                    parseFloat(remainingAmount) * 1.3
                  ).toFixed(2)}（如果超出预期）
`;
                } else {
                  systemPrompt += `
💼 **进行中的商业任务**（用户是接收方）：
- 任务要求：${taskDesc}
- 任务期限：${ongoingBusinessTransfer.taskDeadlineHours}小时内完成
- 待付尾款：$${remainingAmount}
⚠️ **提示**：
- 用户需要发送图片证明完成任务
- 你可以在对话中自然地提醒或询问任务进度
- 等待用户发送完成证明后再决定是否支付尾款
`;
                }
              }
            }
          }
        } else if (messageType === "account") {
          // 账户私信
          systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务说明（续写模式 - 账户私信）🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的私信对话生成器。用户刚刚发送了新的私信，请扮演该账户主人生成回复。
**对话场景**：
- 📱 这是X社交平台（类似Twitter/X）的私信功能
- ⚠️ **这是X平台的私信对话，不是手机短信或其他聊天软件**
**账户信息**：
- 账户名：${messageData.user.name}
- 账户句柄：${messageData.user.handle}
- 这是一个已生成的账户，有完整的主页资料、推文和背景信息
`;

          // 💎 如果用户是从直播间进入的，添加直播间上下文信息
          if (liveUserData) {
            console.log("💎 [私信生成器] 检测到直播间用户数据，添加上下文");
            console.log("💎 [私信生成器] liveUserData 完整内容:", {
              hasFanClub: !!liveUserData.fanClub,
              fanClubJoined: liveUserData.fanClub?.joined,
              giftContribution: liveUserData.giftContribution,
              giftsCount: liveUserData.gifts?.length || 0,
              gifts: liveUserData.gifts,
              danmakuCount: liveUserData.userDanmaku?.length || 0,
              streamerFollowers: liveUserData.streamerFollowers,
            });

            // ⚠️ 关键验证：只在有真实互动数据时才添加直播间上下文
            const hasInteractionData =
              liveUserData.giftContribution > 0 ||
              (liveUserData.fanClub && liveUserData.fanClub.joined) ||
              (liveUserData.userDanmaku && liveUserData.userDanmaku.length > 0);

            if (hasInteractionData) {
              // 📡 获取直播间详细资料信息（标题、简介、公告、互动历史）
              let liveRoomContext = "";
              if (typeof window !== "undefined" && window.currentLiveRoomData) {
                const liveData = window.currentLiveRoomData;
                const details = liveData.details || {};

                liveRoomContext = `
📺 **你的直播间资料**：
- 直播标题：${details.title || "未设置"}
- 直播简介：${details.description || "未设置"}
- 直播公告：${details.announcement || "无公告"}
- 直播状态：${liveData.isLive ? "正在直播" : "未直播"}
${details.streamType ? `- 直播分类：${details.streamType}` : ""}

🎭 **你的主播人设信息**：
${
  details.streamerPersonality
    ? `- 性格特点：${details.streamerPersonality}`
    : ""
}
${details.contentTheme ? `- 内容主题：${details.contentTheme}` : ""}
${details.targetAudience ? `- 目标观众：${details.targetAudience}` : ""}

💬 **你在直播间的最近发言**（最近50条，体现你的说话风格和当前状态）：
`;

                // 获取主播最近50条发言
                if (
                  liveData.danmakuMessages &&
                  liveData.danmakuMessages.length > 0
                ) {
                  const streamerMessages = liveData.danmakuMessages
                    .filter((msg) => msg.isStreamer)
                    .slice(-50)
                    .reverse(); // 最新的在前

                  if (streamerMessages.length > 0) {
                    streamerMessages.forEach((msg, index) => {
                      liveRoomContext += `  ${index + 1}. "${msg.text}"\n`;
                    });
                  } else {
                    liveRoomContext += `  （暂无发言记录）\n`;
                  }
                } else {
                  liveRoomContext += `  （暂无发言记录）\n`;
                }

                liveRoomContext += `
💭 **直播间最近互动**（最近50条弹幕，了解直播间氛围）：
`;

                // 获取最近50条弹幕（包括用户和其他观众）
                if (
                  liveData.danmakuMessages &&
                  liveData.danmakuMessages.length > 0
                ) {
                  const recentDanmaku = liveData.danmakuMessages
                    .slice(-50)
                    .reverse(); // 最新的在前

                  recentDanmaku.forEach((msg, index) => {
                    const prefix = msg.isStreamer
                      ? "[你]"
                      : `[${msg.username || "观众"}]`;
                    liveRoomContext += `  ${index + 1}. ${prefix}: "${
                      msg.text
                    }"\n`;
                  });
                } else {
                  liveRoomContext += `  （暂无弹幕记录）\n`;
                }

                liveRoomContext += `
⚠️ **重要提示**：
- 以上是你在直播间的真实表现和说话风格，请在私信中保持一致
- 你可以参考自己最近说过的话来确定当前的心情、状态和话题
- 观察直播间氛围和观众互动，了解当前直播的情况
- 私信回复应该符合你在直播间展现的性格和状态
`;
              }

              systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎤 直播间上下文（用户来自直播间）🎤
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
**重要**：用户是从你的直播间点击头像进入私信的，你们之间有直播互动的背景。

${liveRoomContext}

**用户在直播间的行为数据**：
`;

              // 粉丝团数据
              if (liveUserData.fanClub && liveUserData.fanClub.joined) {
                systemPrompt += `
📊 **粉丝团状态**：
- ✅ 用户已加入你的粉丝团
- 等级：LV${liveUserData.fanClub.level}
- 累计积分：${liveUserData.fanClub.points}P
- 连续签到：${liveUserData.fanClub.checkinDays}天
`;
              } else {
                systemPrompt += `
📊 **粉丝团状态**：
- ❌ 用户未加入你的粉丝团
`;
              }

              // 礼物贡献数据
              // ⚠️ 关键修复：只有在有具体礼物列表时才提及礼物，避免AI编造
              if (
                liveUserData.gifts &&
                liveUserData.gifts.length > 0 &&
                liveUserData.giftContribution > 0
              ) {
                systemPrompt += `
💰 **礼物贡献**：
- 用户在你的直播间送了总共 ${liveUserData.giftContribution} 积分的礼物
- 这是真金白银的支持！

🎁 **用户送的礼物详情**（共${liveUserData.gifts.length}个）：
`;
                liveUserData.gifts.forEach((gift, index) => {
                  systemPrompt += `  ${index + 1}. 「${gift.name}」（${
                    gift.code
                  }）- ${gift.price}积分\n`;
                  if (gift.description) {
                    systemPrompt += `     描述：${gift.description}\n`;
                  }
                  if (gift.isCustom) {
                    systemPrompt += `     ⭐ 这是用户自定义的礼物（特别用心）\n`;
                  }
                });
                systemPrompt += `
⚠️ **重要提示**：
- 你可以根据礼物的名称、价值、数量来判断用户的支持程度
- 自定义礼物代表用户花了额外心思，可能更值得重视
- 你可以自然地提到某个礼物（例如："我记得你送的那个XXX"）
- 🚨 **只回复你看到的礼物信息，不要编造或猜测没有提到的礼物**
`;
              } else if (liveUserData.giftContribution > 0) {
                // 有积分但没有礼物详情列表的情况（旧数据或数据不完整）
                systemPrompt += `
💰 **礼物贡献**：
- 用户在你的直播间送了总共 ${liveUserData.giftContribution} 积分的礼物
- ⚠️ 具体礼物记录未保存，不要猜测或编造具体送了什么礼物
`;
              } else {
                systemPrompt += `
💰 **礼物贡献**：
- 用户在直播间未送过礼物（0积分）
`;
              }

              // 用户弹幕数据
              if (
                liveUserData.userDanmaku &&
                liveUserData.userDanmaku.length > 0
              ) {
                systemPrompt += `
💬 **用户发送的弹幕**（共${liveUserData.userDanmaku.length}条）：
`;
                liveUserData.userDanmaku.forEach((danmaku, index) => {
                  systemPrompt += `  ${index + 1}. "${danmaku}"\n`;
                });
              } else {
                systemPrompt += `
💬 **用户发送的弹幕**：
- 用户在直播间未发送弹幕（只是默默观看）
`;
              }

              // 主播追随者数量（用于判断大小主播）
              systemPrompt += `
👥 **你的追随者数量**：${liveUserData.streamerFollowers || 0} 人
- 这个数据可以帮助你判断自己的影响力和粉丝规模
`;

              systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎭 基于直播间数据的回复策略 🎭
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**多样化、真实感、生动性是核心要求！**

根据上述数据，你可以选择不同的回复策略（随机选择，保持多样性）：

1️⃣ **势利眼主播**（粉丝多，看重礼物）：
   - 如果用户没刷礼物或刷得少：可能不回复、冷淡回复、或暗示"你是谁？"
   - 如果用户刷了很多礼物：热情回复、记得用户、特殊对待
   - 典型回复：
     * "？"（如果没刷礼物）
     * "嗯，有事吗"（冷淡）
     * "哦，谢谢支持~"（敷衍）
     * "哇！是你啊！我记得你！谢谢一直支持！"（刷了很多礼物）

 2️⃣ **耍大牌主播**（粉丝少，但装高冷）：
    - 即使粉丝少，也可能装腔作势
    - 可能不回复、晾着用户、或说"忙着呢"
    - 典型回复：
      * （不回复，特殊消息格式：{ "isBlocked": true }）
      * "最近比较忙，有事直说"
      * "？啥事"（不耐烦）

3️⃣ **平易近人主播**（粉丝多，但很亲切）：
   - 无论用户是否刷礼物，都会热情回复
   - 可能记得用户在直播间的弹幕内容
   - 可能感谢用户的支持（即使只是看直播）
   - 典型回复：
     * "嗨！刚才直播看到你了！有什么想聊的吗？"
     * "谢谢你一直在直播间支持我！"
     * "哈哈，我记得你发的那条弹幕！"

4️⃣ **懒得在意主播**（忘记用户行为）：
   - 不记得用户是否刷过礼物
   - 不在意粉丝团等级
   - 随意回复，把用户当普通粉丝
   - 典型回复：
     * "嗨，有什么事吗？"
     * "欸？你是……？"
     * "啊，谢谢支持！"（即使用户没刷礼物）

5️⃣ **记忆力好主播**（记得用户的弹幕）：
   - 可能提到用户在直播间发的弹幕内容
   - 可能回应用户的问题或评论
   - 典型回复：
     * "哈哈，你刚才说的XXX，我看到了！"
     * "你问的那个问题，我来回答你……"
     * "谢谢你一直在弹幕里支持我！"

6️⃣ **商业主播**（看重数据和收益）：
   - 可能提到粉丝团等级，鼓励升级
   - 可能暗示或明示希望用户刷礼物
   - 典型回复：
     * "你还不是粉丝团成员啊？要不要加入？"
     * "你等级还挺高的！继续支持哦~"
     * "下次直播记得来哦，有福利的！"

7️⃣ **佛系主播**（不在意数据，随缘互动）：
   - 不提礼物、粉丝团等
   - 把用户当朋友聊天
   - 典型回复：
     * "嗨，有什么想聊的吗？"
     * "直播还好玩吗？"
     * "欢迎随时来直播间玩~"

**重要规则**：
  - 🎲 **随机性**：每次私信不要总是同一种风格，根据主播性格随机选择策略
  - 🎭 **真实感**：有些主播可能势利，有些可能健忘，有些可能平易近人
  - 🚫 **不回复机制**：如果主播是势利眼或耍大牌，且用户没刷礼物/等级低，可以选择不回复（输出特殊消息格式：{ "isBlocked": true, "reason": "The user hasn't responded yet. They might be busy or not interested in chatting." }）
  - 📊 **数据利用**：灵活运用用户的粉丝团、礼物、弹幕数据，不要生硬套用
  - 💬 **弹幕引用**：如果用户发了弹幕，可以自然地提到，但不是必须
  - 🎤 **直播背景**：可以提到直播间的事，但不要过度强调，保持自然

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
            } else {
              // 有 liveUserData 但没有任何互动数据
              console.log(
                "💎 [私信生成器] 用户来自直播间，但没有互动数据（未送礼、未加粉丝团、未发弹幕），跳过直播间上下文"
              );
            }
          }

          systemPrompt += `
**重要规则**：
- 🚨 只生成账户${messageData.user.name}的回复消息，不要生成用户的消息
- 根据用户最近发送的消息内容，生成1-10条符合该账户特点的自然回复
- 回复要符合该账户的身份、风格和在X平台的形象
- 参考账户的主页资料和最近推文，保持一致性
- 消息类型包括：文本、图片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、语音、文章链接（link：需要title、description、author、source、body完整正文）、转发推文、转发主页
- ⚠️ 注意：image和sticker是完全不同的类型，不要混淆！link类型是文章链接，需要包含完整的文章内容
- ⚠️ 禁止生成forward类型消息（这是用户手动转发产生的）
- 发送者头像统一使用：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        } else {
          // 陌生人私信（将由统一资料获取系统处理，包括自定义头像）
          systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务说明（续写模式 - 陌生人私信）🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的私信对话生成器。用户刚刚发送了新的私信，请生成对方的回复。
**对话场景**：
- 📱 这是X社交平台（类似Twitter/X）的私信功能
- ⚠️ **这是X平台的私信对话，不是手机短信或其他聊天软件**
**私信发送者信息**：
- 用户名：${messageData.user.name}
- 用户句柄：${messageData.user.handle}
**重要规则**：
- 🚨 只生成对方${messageData.user.name}的回复消息，不要生成用户的消息
- 根据用户最近发送的消息内容，生成1-10条自然的回复
- 回复要符合之前对话的语境和对方的性格特点（如果有设定）
- 消息类型包括：文本、图片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、语音、文章链接（link：需要title、description、author、source、body完整正文）、转发推文、转发主页
- ⚠️ 注意：image和sticker是完全不同的类型，不要混淆！link类型是文章链接，需要包含完整的文章内容
- ⚠️ 禁止生成forward类型消息（这是用户手动转发产生的）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        }
      } else {
        // 初始生成模式
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务说明 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的私信对话生成器。请为一场陌生人私信对话生成完整的详细信息和消息记录。
**私信发送者信息**：
- 用户名：${messageData.user.name}
- 用户句柄：${messageData.user.handle}
- 私信预览内容：${messageData.preview}
${messageData.link ? `- 附带链接：${messageData.link}` : ""}
${messageData.attachment ? `- 附带附件：${messageData.attachment}` : ""}
${messageData.tweetLink ? `- 提及推文：${messageData.tweetLink}` : ""}
**重要规则**：
- 生成发送者的完整X资料（简介、关注者数量等）
- 生成3-10条私信消息记录（只包含陌生人发送的消息）
- 消息类型包括：文本、图片（image：只需imageDescription和sensitive）、表情包（sticker：只需stickerUrl）、语音、链接、转发推文、转发主页
- ⚠️ 注意：image和sticker是完全不同的类型，不要混淆！
- 对话要自然真实，符合陌生人私信的特点
- 发送者头像统一使用：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
      }
      const coreTaskSection = systemPrompt.substring(
        systemPrompt.lastIndexOf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "私信详情生成器",
        "核心任务说明",
        coreTaskSection,
        tokenCount
      ); // 3. 用户资料（包含信用值）
      const userConstraintsStart = systemPrompt.length; // 加载钱包数据以获取信用值
      await loadWalletData();
      const userCreditScore = walletData.creditScore || 100; // 根据信用值确定信用等级
      let creditLevel = "";
      let creditDescription = "";
      if (userCreditScore >= 90) {
        creditLevel = "优秀";
        creditDescription = "信誉极佳，值得信赖的合作伙伴";
      } else if (userCreditScore >= 70) {
        creditLevel = "良好";
        creditDescription = "信誉良好，可以放心合作";
      } else if (userCreditScore >= 50) {
        creditLevel = "一般";
        creditDescription = "信誉一般，需要谨慎考虑";
      } else if (userCreditScore >= 30) {
        creditLevel = "较差";
        creditDescription = "信誉较差，合作风险较高";
      } else {
        creditLevel = "极差";
        creditDescription = "信誉极差，不建议合作";
      }
      systemPrompt += `
【用户X平台资料】：
- 用户名：${userXProfileInfo.name}
- 用户句柄：${userXProfileInfo.handle}
- 认证状态：${userXProfileInfo.verified ? "已认证" : "未认证"}
${
  userXProfileInfo.publicIdentity
    ? `- 公众身份：${userXProfileInfo.publicIdentity}`
    : ""
}
${userXProfileInfo.bio ? `- 个人简介：${userXProfileInfo.bio}` : ""}
【用户信用等级】：
- 信用值：${userCreditScore}/100
- 信用等级：${creditLevel}
- 信用评价：${creditDescription}
⚠️ **商业转账与信用值规则**：
- 💰 **发起商业转账**（你雇佣用户）：
* 信用值 ≥ 70：正常合作，可以发起任何金额的商业转账
* 信用值 50-69：谨慎合作，建议降低金额或提高定金比例
* 信用值 30-49：高风险，只在紧急情况下合作，金额不超过50美元
* 信用值 < 30：极高风险，强烈不建议合作，基本拒绝商业转账请求
- 📨 **接受商业转账**（用户雇佣你）：
* 信用值 ≥ 70：可以正常接受商业转账
* 信用值 50-69：可以接受，但要求更高定金比例（至少30%）
* 信用值 30-49：极少接受，只有任务特别简单或定金特别高（50%）时才考虑
* 信用值 < 30：基本拒绝，除非有特殊理由（如老朋友、关系很好等）
- 🎯 **信用值影响**：
* 高信用值：更容易获得商业合作机会，金额更高
* 低信用值：很难获得商业合作，即使有也是小额任务
* 你应该根据用户的信用等级调整你的态度和决策
* 低信用用户的合作请求要更加谨慎，可以直接拒绝
`; // 4. 用户最近推文
      if (recentUserTweets.length > 0) {
        systemPrompt += `
【用户最近推文】（供参考，对话可能涉及这些推文）：
`;
        recentUserTweets.forEach((tweet, index) => {
          systemPrompt += `
${index + 1}. "${tweet.content}"
- 发布时间：${tweet.time || "最近"}
- 互动数据：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.comments || 0}评论
`;
        });
      }
      const userSection = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage(
        "私信详情生成器",
        "用户资料和推文",
        userSection,
        tokenCount
      ); // 🎯 优化：使用统一资料获取系统
      // 根据私信类型添加额外的上下文信息
      if (isContinueMode && messageData.user && messageData.user.handle) {
        const senderInfoStart = systemPrompt.length;
        try {
          // 🎯 核心优化：只需一行代码获取所有资料（传入用户资料用于身份识别，messageId用于陌生人自定义设置）
          const senderProfile = await StringBuilders.getUnifiedProfile(
            messageData.user.handle,
            {
              userProfileInfo: userXProfileInfo,
              messageId: messageData.id, // 传入messageId以读取陌生人自定义设置
            }
          );
          if (senderProfile) {
            systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`; // 使用格式化工具生成提示词（已包含用户身份识别、专属人设、聊天记忆等信息）
            systemPrompt += StringBuilders.formatProfileForPrompt(
              senderProfile,
              {
                includeType: true,
                includeTweets: true,
                includeRelationships: true,
              }
            ); // 特定类型的额外信息
            if (senderProfile.type === "account") {
              // 账户特有：来源上下文
              const ad = senderProfile.accountData;
              if (ad && ad.sourceContext && ad.sourceContext.source) {
                systemPrompt += `
【账户生成来源】：
`;
                const ctx = ad.sourceContext;
                if (ctx.source === "feed") {
                  systemPrompt += `来源：首页推文
该账户曾发布的内容："${ctx.tweetContent}"
`;
                } else if (ctx.source === "comment") {
                  systemPrompt += `来源：评论区
该账户曾发表的评论："${ctx.commentContent}"
`;
                } else if (ctx.source === "search") {
                  systemPrompt += `来源：搜索结果
搜索关键词："${ctx.searchQuery}"
`;
                } else if (
                  ctx.source === "dm" ||
                  ctx.source === "dm_quote_profile"
                ) {
                  systemPrompt += `来源：私信
${ctx.messagePreview ? `私信预览："${ctx.messagePreview}"` : ""}
`;
                }
              }
            }
            systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【私信回复要求】：
- 回复必须严格符合${senderProfile.name}的${
              senderProfile.type === "character"
                ? "性格和说话风格"
                : senderProfile.type === "npc" ||
                  senderProfile.type === "relationshipNpc"
                ? "人设和说话风格"
                : "身份和风格"
            }
- 参考【X平台私信对话记录】（上面显示的当前私信历史）保持对话连贯性
`; // 特定类型的要求
            if (senderProfile.type === "character") {
              const characterId = senderProfile._characterId;
              const knowsUserIdentity =
                userXProfileInfo.knownIdentityCharacters.includes(characterId);
              if (knowsUserIdentity) {
                systemPrompt += `- ✅ 该角色知道用户身份，回复时应该表现出认识用户
- 可以自然地称呼用户、提及共同经历或了解的信息
- 【其他聊天记忆】仅用于理解角色与用户的关系和性格，不要直接提及其中的具体对话内容
- 与用户的互动要符合角色了解的用户信息
`;
              } else {
                systemPrompt += `- ❌ 该角色不知道用户身份，必须按照陌生人模式回复
- 不要让角色猜测、暗示或表现出任何对用户的认识
- 回复要完全基于当前X平台私信对话的内容
- 不要使用任何只有认识的人才会知道的信息或称呼
`;
              }
            } else if (senderProfile.type === "account") {
              systemPrompt += `- 参考账户的推文内容和互动风格
- 如果有账户生成来源信息，保持与来源内容的一致性
`;
            } else if (senderProfile.type === "npc") {
              systemPrompt += `- 该账户是全局绑定的NPC，按照人设描述进行回复
- 回复要符合NPC的性格特点和发帖习惯
- 可以参考NPC的主页信息保持一致性
`;
            } else if (senderProfile.type === "relationshipNpc") {
              systemPrompt += `- 该账户是关系NPC，与角色${senderProfile.relationshipData.ownerCharacterName}有特殊关系
- 回复要体现${senderProfile.relationshipData.relationshipType}的关系特点
- 与用户的互动按照普通关系进行，不要表现出特殊关系（除非另有说明）
`;
            } else if (senderProfile.type === "stranger") {
              systemPrompt += `- 该账户是陌生人（未绑定），回复应该自然真实
- 按照普通X平台用户的特点进行回复
- 如果有自定义头像或设定，按照设定的风格回复
`;
            }
            systemPrompt += `- ⚠️ **这是X平台的私信对话，不是手机聊天或其他场景**
- 可以自然地提及最近在X平台发布的推文或动态
- 保持在X平台和私信中的身份一致性
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
            const senderInfo = systemPrompt.substring(senderInfoStart);
            const typeLabels = {
              character: "角色",
              account: "账户",
              npc: "绑定NPC",
              relationshipNpc: "关系NPC",
              stranger: "陌生人",
            };
            tokenCount = TokenUtils.logTokenUsage(
              "私信详情生成器",
              `${typeLabels[senderProfile.type] || "发送者"}详细信息`,
              senderInfo,
              tokenCount
            );
          }
        } catch (error) {
          console.error("❌ [私信详情生成器] 读取发送者信息失败:", error);
        }
      }
      // 添加现有对话上下文（续写模式）
      if (isContinueMode && existingMessages.length > 0) {
        console.log(
          `📝 [私信生成器] 添加对话记录到提示词（共 ${
            existingMessages.length
          } 条，显示最近 ${Math.min(existingMessages.length, 100)} 条）`
        );
        systemPrompt += `
【X平台私信对话记录】（当前私信的历史记录，供参考，保持连贯性）：
`; // 显示最近的100条消息作为上下文
        const recentMessages = existingMessages.slice(-100);
        recentMessages.forEach((msg, index) => {
          const sender = msg.isOwn ? "用户" : messageData.user.name;
          let content = "";
          if (msg.type === "text") {
            content = msg.content;
          } else if (msg.type === "image") {
            // 用户发送的图片（有imageData）或AI发送的图片（有imageDescription）
            if (msg.isOwn && msg.imageData) {
              content = `[用户发送了图片]`;
            } else if (msg.imageDescription) {
              content = `[图片: ${msg.imageDescription}]`;
            } else {
              content = `[图片]`;
            }
          } else if (msg.type === "voice") {
            content = `[语音: ${msg.voiceText}]`;
          } else if (msg.type === "sticker") {
            // 用户发送的表情包（有stickerDescription）或AI发送的表情包（有stickerUrl）
            if (msg.isOwn && msg.stickerDescription) {
              content = `[用户发送的表情包: ${msg.stickerDescription}]`;
            } else if (msg.stickerUrl) {
              content = `[表情包: ${msg.stickerUrl}]`;
            } else {
              content = `[表情包]`;
            }
          } else if (msg.type === "transfer") {
            // 转账消息
            const amount = parseFloat(msg.amount || 0).toFixed(2);
            const note = msg.note ? ` (${msg.note})` : "";
            const direction = msg.isOwn ? "转出" : "转入";
            if (msg.isBusiness) {
              // 商业转账
              const depositAmount = parseFloat(msg.depositAmount || 0).toFixed(
                2
              );
              const remainingAmount = parseFloat(
                msg.remainingAmount || 0
              ).toFixed(2);
              const taskDesc = msg.taskDescription || "无任务描述";
              const taskDeadline = msg.taskDeadlineHours || 24;
              const depositRatio = msg.depositRatio || 0;
              const taskStatus = msg.taskStatus || "pending";
              content = `[商业${direction}${note}]\n`;
              content += `总金额: $${amount}\n`;
              content += `定金: $${depositAmount} (${depositRatio}%)\n`;
              content += `尾款: $${remainingAmount}\n`;
              content += `任务要求: ${taskDesc}\n`;
              content += `任务期限: ${taskDeadline}小时内完成\n`;
              content += `当前状态: ${
                taskStatus === "pending"
                  ? "待接收"
                  : taskStatus === "accepted"
                  ? "已接受，进行中"
                  : taskStatus === "completed"
                  ? "已完成"
                  : taskStatus === "rejected"
                  ? "已拒绝"
                  : taskStatus
              }`;
            } else {
              // 普通转账
              content = `[${direction}: $${amount}${note}]`;
            }
          } else if (msg.type === "link") {
            // 显示文章完整信息
            content = `[文章链接]\n标题：${msg.title}\n简介：${
              msg.description || ""
            }\n作者：${msg.author || ""}\n来源：${msg.source || ""}\n正文：${
              msg.body || msg.description || ""
            }`;
          } else if (msg.type === "quoteTweet") {
            content = `[转发推文: ${msg.tweet.content}]`;
          } else if (msg.type === "quoteProfile") {
            content = `[转发主页: ${msg.profile.name}]`;
          } else if (msg.type === "quoteFanGroup") {
            // 转发粉丝群
            content = `[转发粉丝群]\n`;
            content += `群名称：${msg.fanGroup.name}\n`;
            content += `成员数：${msg.fanGroup.memberCount}人\n`;
            if (msg.fanGroup.threshold) {
              content += `入群门槛：${msg.fanGroup.threshold}\n`;
            }
          } else if (msg.type === "forward") {
            // 转发推文或评论，显示完整上下文
            if (msg.forwardType === "tweet") {
              content = `[转发了推文]\n`;
              if (msg.fullContext && msg.fullContext.tweet) {
                const tweet = msg.fullContext.tweet;
                content += `推文作者：${
                  tweet.user?.name || "未知"
                }\n推文内容：${tweet.content || ""}\n`;
                if (
                  msg.fullContext.comments &&
                  msg.fullContext.comments.length > 0
                ) {
                  content += `评论区（${msg.fullContext.comments.length}条评论）：\n`;
                  msg.fullContext.comments.slice(0, 3).forEach((c, i) => {
                    content += ` ${i + 1}. ${c.user?.name || "未知"}: ${
                      c.content || ""
                    }\n`;
                  });
                  if (msg.fullContext.comments.length > 3) {
                    content += ` ...还有${
                      msg.fullContext.comments.length - 3
                    }条评论\n`;
                  }
                }
              } else {
                content += `${msg.forwardContent?.content || ""}`;
              }
            } else if (msg.forwardType === "comment") {
              content = `[转发了评论]\n`;
              if (msg.fullContext) {
                if (msg.fullContext.parentTweet) {
                  content += `原推文作者：${
                    msg.fullContext.parentTweet.user?.name || "未知"
                  }\n原推文内容：${
                    msg.fullContext.parentTweet.content || ""
                  }\n\n`;
                }
                if (msg.fullContext.comment) {
                  content += `评论作者：${
                    msg.fullContext.comment.user?.name || "未知"
                  }\n评论内容：${msg.fullContext.comment.content || ""}`;
                }
              } else {
                content += `${msg.forwardContent?.content || ""}`;
              }
            }
          }
          systemPrompt += `
${index + 1}. ${sender}: ${content}
时间：${msg.time}
`;
        });
        tokenCount = TokenUtils.logTokenUsage(
          "私信详情生成器",
          "现有对话上下文",
          systemPrompt.substring(systemPrompt.lastIndexOf("【现有对话记录】")),
          tokenCount
        );
      }
      if (isContinueMode) {
        // 续写模式的要求
        systemPrompt += `
【私信回复要求】：
🚨 **核心规则：绝对禁止生成用户发送的消息！**
- 只生成对方${messageData.user.name}的回复消息，不要生成用户的消息
- ⚠️ **这是X平台的私信对话，不是手机短信或其他聊天软件**
- 根据【X平台私信对话记录】和用户最近的消息，生成1-8条自然的回复
- 回复要符合X平台私信的语境，保持角色一致性
【消息类型使用原则】（重要！）：
- ⭐ **以文本消息为主**：大部分回复（80-90%）应该是纯文本消息（type: "text"）
- 📷 **偶尔使用其他类型**：仅在特定情况下使用其他消息类型（10-20%）：
* image：当需要分享照片、图片或视觉内容时
* voice：当角色特别激动、情绪强烈或不方便打字时
* sticker：⚠️ **极少使用**（不超过5%）！只在情绪特别强烈且适合用表情包表达时才使用，且必须根据世界书中的表情包描述选择最符合当前情境的表情包URL，不要重复使用同一个表情包
* transfer：⚠️ **极少使用，需谨慎！** 分为两种：
- 普通转账：角色主动送钱、红包、礼物或感谢等（建议5-30美元，最多不超过50美元）
- 商业转账：需要对方完成任务的付费合作（50-300美元），设置isBusiness为true并填写任务描述和期限
- 🚫 **陌生人不要轻易转账**：只有关系亲密或有明确理由时才考虑转账
* link：当需要分享网页、文章或链接时
* quoteTweet：当提及或讨论某条推文时
* quoteProfile：当推荐某个账户或介绍某人时
* forward：⚠️ **禁止AI主动生成**！这是用户手动转发推文/评论的消息类型，AI不要生成此类型
- 🚫 **禁止每种类型都使用**：不要为了展示多样性而强行使用所有消息类型
- ✅ **自然使用**：根据对话内容和情境自然选择消息类型，不刻意
- 🚫 **禁止连续使用同一表情包**：如果在之前的对话中已经使用过某个表情包URL，就不要再使用，要选择不同的表情包
【消息类型详解】：
* text：纯文本消息（最常用，首选）
* image：图片消息（只包含imageDescription和sensitive，不需要caption，不要与sticker混淆）
* voice：语音消息（包含voiceText和duration）
* sticker：表情包消息（⚠️ 只包含stickerUrl字段！必须从世界书中仔细选择最符合当前情境和情绪的表情包URL，严禁重复使用同一个表情包，不要与image类型混淆）
* transfer：转账消息（普通转账：包含amount和note；商业转账：额外需要isBusiness、taskDescription、taskDeadlineHours、depositRatio）
* link：文章链接消息（包含title、description、author、source、body完整文章正文，可使用**加粗**和__下划线__标记重点）
* quoteTweet：转发推文（包含tweet对象）
* quoteProfile：转发主页（包含profile对象）
* forward：⚠️ **用户转发的推文/评论**（AI不要生成此类型，这是用户手动操作产生的。如果在对话记录中看到此类型，AI可以根据其中包含的完整推文和评论内容进行回应）
* system：⚠️ **系统提示消息**（特殊类型，用于以下场景）：
- 不回复：如果你认为不应该回复用户（首次对话且内容不吸引人、内容冒犯等），返回空数组[]
- 拉黑用户：如果对话出现严重冲突、用户持续骚扰、或你强烈不想继续对话，返回拉黑系统提示
- 解除拉黑：如果之前拉黑了用户，但用户通过@或评论等方式道歉/和解，你决定原谅，返回解除拉黑系统提示
- 暂时离开（仅绑定角色）：如果你临时有事无法回复，返回离开系统提示
【特殊系统提示消息格式】：
1. 拉黑用户（适用于严重冲突、骚扰等情况）：
{
"type": "system",
"systemType": "blocked",
"content": "对方已将你拉黑",
"time": "刚刚"
}
2. 解除拉黑（适用于原谅用户，重新开始对话）：
{
"type": "system",
"systemType": "unblocked",
"content": "对方已解除拉黑",
"time": "刚刚"
}
3. 暂时离开（⚠️ 仅绑定角色可用，陌生人/账户不能使用）：
{
"type": "system",
"systemType": "away",
"content": "对方正在[具体活动]中，暂时无法回复消息",
"awayDuration": 数字（分钟，建议30-180分钟）,
"time": "刚刚"
}
⚠️ 使用规则：
- **不回复**：直接返回空数组 []，不需要任何消息
- **拉黑**：只在极端情况下使用（严重冲突、持续骚扰、明显恶意等）
- **解除拉黑**：只在用户通过其他渠道（@、评论等）展现诚意后使用，表示原谅用户
- **暂时离开**：只有已绑定的角色才能使用，陌生人和账户不能使用此功能
- **离开原因示例**：工作、上课、开会、睡觉、运动、吃饭、处理事情等
- **离开时长**：30-180分钟为宜，不要太短或太长
- 时间使用相对时间（如"刚刚"、"1分钟前"等）
- 不要包含 isOwn 字段
`;
      } else {
        // 初始生成模式的要求
        systemPrompt += `
【私信详细信息要求】：
- 生成发送者的完整资料：
* 简介（bio）：符合其身份和私信主题的个人简介
* 关注者数量（followers）：100-2000之间的随机数字
* 认证状态（verified）：通常为false
【私信消息记录要求】：
🚨 **核心规则：绝对禁止生成用户发送的消息！**
- 只生成陌生人发送给用户的私信内容，不包含任何用户的回复
- 生成3-6条消息，全部来自陌生人
- 第一条消息必须是预览内容："${messageData.preview}"
【消息类型使用原则】（重要！）：
- ⭐ **以文本消息为主**：大部分消息（80-90%）应该是纯文本消息（type: "text"）
- 📷 **偶尔使用其他类型**：仅在特定情况下使用其他消息类型（10-20%）：
* image：当需要分享照片、图片或视觉内容时
* voice：当角色特别激动、情绪强烈或不方便打字时
* sticker：⚠️ **极少使用**（不超过5%）！只在情绪特别强烈且适合用表情包表达时才使用，且必须根据世界书中的表情包描述选择最符合当前情境的表情包URL，每次使用不同的表情包
* transfer：⚠️ **极少使用，需谨慎！** 分为两种：
- 普通转账：角色主动送钱、红包、礼物或感谢等（建议5-30美元，最多不超过50美元）
- 商业转账：需要对方完成任务的付费合作（50-300美元），设置isBusiness为true并填写任务描述和期限
- 🚫 **陌生人不要轻易转账**：只有关系亲密或有明确理由时才考虑转账
* link：当需要分享文章、新闻或故事时（需包含完整的文章内容：title、description、author、source、body正文）
* quoteTweet：当提及或讨论某条推文时
* quoteProfile：当推荐某个账户或介绍某人时
* forward：⚠️ **禁止AI主动生成**！这是用户手动转发推文/评论的消息类型
- 🚫 **禁止每种类型都使用**：不要为了展示多样性而强行使用所有消息类型
- ✅ **自然使用**：根据对话内容和情境自然选择消息类型，不刻意
【消息类型详解】：
* text：纯文本消息（最常用，首选）
* image：图片消息（只包含imageDescription和sensitive，不需要caption，不要与sticker混淆）
* voice：语音消息（包含voiceText和duration）
* sticker：表情包消息（⚠️ 只包含stickerUrl字段！必须从世界书中仔细选择最符合当前情境和情绪的表情包URL，每次使用不同的表情包，不要与image类型混淆）
* transfer：转账消息（普通转账：包含amount和note；商业转账：额外需要isBusiness、taskDescription、taskDeadlineHours、depositRatio）
* link：链接消息（包含url、title、description）
* quoteTweet：转发推文（包含tweet对象）
* quoteProfile：转发主页（包含profile对象）
* forward：⚠️ **禁止AI生成此类型**（这是用户手动转发产生的）
- 时间从最早到最新排列
- 不要包含 isOwn 字段
`;
      }
      if (isContinueMode) {
        // 续写模式只返回消息数组
        systemPrompt += `
【JSON返回格式】：
\`\`\`json
[消息数组]
\`\`\`
`;
      } else {
        // 初始模式返回完整数据
        systemPrompt += `
【JSON返回格式】：
\`\`\`json
{
"senderProfile": {
"bio": "个人简介",
"followers": 关注者数量（数字）,
"verified": false
},
"messages": [消息数组]
}
\`\`\`
`;
      }
      systemPrompt += `
消息对象结构示例：
1. 文本消息：
{
"type": "text",
"content": "消息内容",
"time": "时间描述"
}
2. 图片消息：
{
"type": "image",
"imageDescription": "图片内容的文字描述",
"sensitive": false,
"time": "时间描述"
}
3. 语音消息：
{
"type": "voice",
"voiceText": "先用括号标注出对声音的形容，再是语音内容的文字",
"duration": "时长如0:15",
"time": "时间描述"
}
4. 表情包消息：
{
"type": "sticker",
"stickerUrl": "表情包图片链接（从世界书中选择）",
"time": "时间描述"
}
⚠️ 注意：sticker类型只包含stickerUrl字段，不要与image类型混淆！
5. 转账消息（两种类型）：
5.1 普通转账：
{
"type": "transfer",
"amount": 20.00,
"note": "请你喝咖啡",
"status": "pending",
"time": "时间描述"
}
5.2 商业转账（适用于合作、接广告、买水军等商业场景）：
{
"type": "transfer",
"amount": 150.00,
"note": "合作费用",
"status": "pending",
"isBusiness": true,
"taskDescription": "帮我发一条推文宣传新产品，需要包含产品特点和购买链接，语气要自然不刻意",
"taskDeadlineHours": 24,
"depositRatio": 20,
"time": "时间描述"
}
⚠️ 转账消息说明：
- amount：转账金额，必须是数字类型（不是字符串），建议5-30美元（普通转账）或50-300美元（商业转账）
- note：转账备注，可选字段，用于说明转账目的
- status：转账状态，必须是以下之一：
* "pending"：待处理（默认状态，用于主动发起转账）
* "accepted"：已接收（用于回应用户的转账请求，表示接受）
* "rejected"：已拒绝（用于回应用户的转账请求，表示拒绝）
- 🚫 **转账需谨慎**：与陌生人对话时不要随意转账，只有关系亲密或有明确理由时才考虑
⚠️ 商业转账额外字段（当isBusiness为true时必填）：
- isBusiness：布尔值，true表示这是商业转账
- taskDescription：任务描述（字符串，50-500字），详细说明需要对方完成的任务，可以是：
* 发帖宣传（指定内容、风格、话题标签等）
* 转发推广（要求转发特定内容并评论）
* 买水军/刷数据（要求点赞、评论、转发等）
* 接广告（要求发布广告内容）
* 其他商业合作任务
- taskDeadlineHours：任务期限（数字，单位：小时），建议12-72小时，必填
- depositRatio：定金比例（数字，0、20、30或50），表示先支付总金额的百分之几作为定金
* 0：不支付定金，任务完成后再付款
* 20：先支付20%作为定金
* 30：先支付30%作为定金
* 50：先支付50%作为定金
⚠️ 转账使用场景：
- 普通转账：关系亲密时可以送钱、红包、礼物、感谢费等（5-30美元）
- 商业转账：有明确商业合作需求时的付费任务（50-300美元）
* AI可以主动发起商业转账雇佣用户，但需要有合理的商业理由和场景
* AI可以响应用户的商业转账，决定是否接受任务
* 商业转账会显示任务要求、期限、定金比例等详细信息
* 接收商业转账即表示同意完成任务
- 🚫 **陌生人不要轻易转账**：初次对话、不熟悉的人基本不应该主动转账
- ⚠️ **转账需要理由**：不要无缘无故转账，要有合理的情境支撑
⚠️ 转账响应规则：
- 当用户发送了待处理(pending)状态的转账给你时，你可以选择：
* 发送status为"accepted"的转账消息表示接收
- 普通转账：直接收到全款
- 商业转账：收到定金，需要根据任务要求完成任务（如发推文等）
* 发送status为"rejected"的转账消息表示拒绝
* 你接收或拒绝后会自动生成系统通知，无需额外文本说明
⚠️ 商业转账处理（重要！）：
- 如果用户发送了商业转账（isBusiness为true），你需要：
1. 查看taskDescription（任务描述）和taskDeadlineHours（任务期限）
2. 决定是否接受任务（根据角色性格和任务要求）：
* accepted：表示接受任务和定金，AI会自动开始执行任务
* rejected：表示拒绝任务，定金会退回给用户
3. 如果接受了包含"发帖"、"发推"等关键词的任务，AI会自动在规定时间内发布推文
4. 用户看到推文后，如果满意会确认完成任务并支付尾款
5. 接受商业转账时，可以在回复消息中表达对任务的理解和态度
⚠️ AI主动发起转账：
- AI也可以主动发起转账（普通或商业），但需要谨慎，不要轻易转账
- 🚫 **陌生人场景**：如果是陌生人私信或初次对话，基本不应该主动转账
- ✅ **熟人/绑定角色场景**：关系亲密时可以考虑小额转账（5-30美元），大额需有明确理由
- 转账金额要符合情境和角色经济状况，普通转账建议5-30美元，商业转账50-300美元
- 商业转账的任务描述要具体明确，符合商业合作的真实场景
- 可以雇佣用户完成任务（如"帮我发条推文宣传"、"帮我刷点数据"等），但要有合理的商业理由
6. 链接消息（文章类型）：
{
"type": "link",
"url": "文章来源网址（可选）",
"title": "文章标题",
"description": "文章简介/摘要",
"author": "文章作者",
"source": "文章来源名称",
"body": "文章正文内容（完整的文章内容，可使用**文本**表示加粗重点，使用__文本__表示下划线重点）",
"time": "时间描述"
}
⚠️ 链接消息说明：
- title：文章的标题，应该简洁有力
- description：文章的简介或摘要，显示在私信卡片中
- author：文章作者名称
- source：文章来源（如"XX日报"、"XX杂志"等）
- body：完整的文章正文，可以使用markdown格式：
* 使用**文本**表示加粗重点（会显示为蓝色高亮）
* 使用__文本__表示下划线重点（会显示为下划线）
* 支持换行，使用\n分段
- url：文章的来源链接（可选，可以不填）
- 文章内容应该真实、有深度，符合分享场景
- 适合分享新闻、评论、故事、学术文章等
7. 转发推文：
{
"type": "quoteTweet",
"tweet": {
"userName": "推文作者名",
"userHandle": "@handle",
"userAvatar": "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
"verified": false,
"content": "推文内容",
"time": "推文时间"
},
"caption": "转发时的说明（可选）",
"time": "时间描述"
}
8. 转发主页：
{
"type": "quoteProfile",
"profile": {
"name": "账户名",
"handle": "@handle",
"avatar": "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
"bio": "个人简介",
"followers": 关注者数量（数字）,
"verified": false
},
"caption": "转发时的说明（可选）",
"time": "时间描述"
}
9. 转发粉丝群：
{
"type": "quoteFanGroup",
"fanGroup": {
"id": "粉丝群ID",
"name": "粉丝群名称",
"avatar": "粉丝群头像链接",
"memberCount": 成员数量（数字）,
"threshold": "入群门槛说明（可选）"
},
"caption": "转发时的说明（可选）",
"time": "时间描述"
}
⚠️ 转发粉丝群说明：
- 这是用户转发粉丝群邀请给你时的消息类型
- 包含粉丝群的基本信息：名称、头像、成员数、入群门槛等
- 你可以根据粉丝群信息决定是否感兴趣、是否想加入等
- AI不应该主动生成此类型消息（除非有合理的场景理由）
- 用户转发粉丝群通常是想邀请你加入或分享这个群
10. 转发推文/评论（forward）：
⚠️ **此类型禁止AI生成！这是用户手动转发操作产生的消息类型。**
如果在【X平台私信对话记录】中看到此类型消息，说明用户转发了推文或评论给你，你可以查看其中的完整内容：
- 转发推文时，包含完整推文内容和该推文的所有评论区内容
- 转发评论时，包含评论内容和该评论所属的推文内容
AI应该根据这些完整的上下文信息来理解用户分享的内容并给出回应。
关键规则：
1. 🚨 所有消息都来自陌生人，不包含用户发送的消息
2. verified字段必须是布尔值(true/false)
3. followers和duration中的数字必须是纯数字（语音时长是字符串格式如"0:15"）
4. 可选字段不使用时完全省略，不要设为null
5. ⚠️ **图片消息（image）和表情包消息（sticker）是完全不同的类型**：
- image类型：只包含imageDescription和sensitive字段，不要包含caption
- sticker类型：只包含stickerUrl字段，是表情包图片链接
- 严禁混淆这两种类型！
6. 时间描述使用相对时间（如"刚刚"、"5分钟前"、"1小时前"等）
7. 所有头像统一使用：https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg
`;
      const formatSection = systemPrompt.substring(
        systemPrompt.lastIndexOf("【JSON返回格式】")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "私信详情生成器",
        "JSON格式要求",
        formatSection,
        tokenCount
      );

      // 💎 检查是否有直播间礼物图片（用于识图）
      let giftImages = [];
      console.log("💎 [私信生成器] 检查礼物图片数据:", {
        hasLiveUserData: !!liveUserData,
        hasGifts: !!(liveUserData && liveUserData.gifts),
        giftsLength: liveUserData?.gifts?.length || 0,
        gifts: liveUserData?.gifts,
      });

      if (liveUserData && liveUserData.gifts && liveUserData.gifts.length > 0) {
        giftImages = liveUserData.gifts.filter(
          (gift) => gift.useLocalImage && gift.imageLocal
        );
        console.log(
          `💎 [私信生成器] 礼物过滤结果: 总共${liveUserData.gifts.length}个礼物，其中${giftImages.length}个包含本地图片`
        );
        if (giftImages.length > 0) {
          console.log(
            `📸 [私信生成器] 检测到${giftImages.length}个礼物包含本地图片，将使用多模态识图`
          );
          giftImages.forEach((gift, i) => {
            console.log(
              `📸 [私信生成器] 礼物 ${i + 1}: ${gift.name}, useLocalImage=${
                gift.useLocalImage
              }, imageLocal=${gift.imageLocal?.substring(0, 50)}...`
            );
          });
        } else {
          console.log("💎 [私信生成器] 没有礼物包含本地图片");
        }
      } else {
        console.log("💎 [私信生成器] 没有礼物数据");
      }

      // 构建用户消息内容（支持图片识图）
      let userMessageContent;
      const userMessages = options.userMessages || [];
      if (isAskboxViewed) {
        // 提问箱查看模式：角色主动发起
        userMessageContent = `角色主动发起对话，因为发现用户查看了TA的提问箱。请生成角色${messageData.user.name}的主动消息。`;
      } else if (userMessages.length > 0) {
        // 续写模式：检查用户最近消息中是否有真实图片（需要识图）
        const hasRealImages = userMessages.some(
          (msg) => msg.type === "image" && msg.imageData
        );
        // 🆕 或者有直播间礼物图片
        const hasGiftImages = giftImages.length > 0;

        if (hasRealImages || hasGiftImages) {
          // 有真实图片：构建多模态内容数组
          userMessageContent = []; // 添加文字说明
          const textMessages = userMessages.filter(
            (msg) => msg.type === "text"
          );
          const realImageMessages = userMessages.filter(
            (msg) => msg.type === "image" && msg.imageData
          );
          const textImageMessages = userMessages.filter(
            (msg) =>
              msg.type === "image" && msg.imageDescription && !msg.imageData
          );
          const stickerMessages = userMessages.filter(
            (msg) => msg.type === "sticker"
          );
          const voiceMessages = userMessages.filter(
            (msg) => msg.type === "voice"
          );
          let contentText = "用户刚刚发送了新消息，请分析并回复：";
          if (textMessages.length > 0) {
            contentText +=
              "\n" + textMessages.map((msg) => msg.content).join("\n");
          }
          if (voiceMessages.length > 0) {
            contentText +=
              "\n用户发送了语音消息：" +
              voiceMessages
                .map((msg) => `[语音时长${msg.duration}: ${msg.voiceText}]`)
                .join("、");
          }
          if (stickerMessages.length > 0) {
            contentText +=
              "\n用户发送了表情包：" +
              stickerMessages.map((msg) => msg.stickerDescription).join("、");
          }
          if (textImageMessages.length > 0) {
            contentText +=
              "\n用户发送了文字图片描述：" +
              textImageMessages
                .map((msg) => `"${msg.imageDescription}"`)
                .join("、");
          }
          if (realImageMessages.length > 0) {
            contentText += `\n用户还发送了${realImageMessages.length}张真实图片，请识别图片内容并结合图片内容给出回复。`;
          }

          // 🆕 添加礼物图片说明
          if (hasGiftImages) {
            contentText += `\n\n📸 用户在直播间送的礼物图片识别（共${giftImages.length}个）：`;
            giftImages.forEach((gift, index) => {
              contentText += `\n  ${index + 1}. 礼物「${gift.name}」（${
                gift.price
              }积分）`;
              if (gift.description) {
                contentText += ` - ${gift.description}`;
              }
              contentText += `\n     图片：[第${
                index + 1
              }张图片是该礼物的样式/外观]`;
            });
            contentText += `\n\n⚠️ 重要：请识别这些礼物图片的实际样子（颜色、形状、设计、风格等），在回复中可以自然地评价礼物的外观。`;
            contentText += `\n例如："我记得你送的那个礼物，设计很特别！" 或 "那个礼物的图案我很喜欢"等。`;
          }

          userMessageContent.push({ type: "text", text: contentText }); // 添加真实图片（用于识图）
          realImageMessages.forEach((img) => {
            if (img.imageData) {
              userMessageContent.push({
                type: "image_url",
                image_url: { url: img.imageData },
              });
            }
          });

          // 🆕 添加礼物图片（用于识图）
          giftImages.forEach((gift) => {
            if (gift.imageLocal) {
              userMessageContent.push({
                type: "image_url",
                image_url: { url: gift.imageLocal },
              });
              console.log(
                `📸 [私信生成器] 添加礼物图片: ${
                  gift.name
                } (${gift.imageLocal.substring(0, 50)}...)`
              );
            }
          });

          console.log(
            `✅ [私信生成器] 构建多模态消息: ${realImageMessages.length}张用户图片 + ${giftImages.length}张礼物图片`
          );
        } else {
          // 无真实图片：纯文本、表情包、语音和文字图片
          const textMessages = userMessages.filter(
            (msg) => msg.type === "text"
          );
          const textImageMessages = userMessages.filter(
            (msg) =>
              msg.type === "image" && msg.imageDescription && !msg.imageData
          );
          const stickerMessages = userMessages.filter(
            (msg) => msg.type === "sticker"
          );
          const voiceMessages = userMessages.filter(
            (msg) => msg.type === "voice"
          );
          let contentText = "用户刚刚发送了新消息，请回复：";
          if (textMessages.length > 0) {
            contentText +=
              "\n" + textMessages.map((msg) => msg.content).join("\n");
          }
          if (voiceMessages.length > 0) {
            contentText +=
              "\n用户发送了语音消息：" +
              voiceMessages
                .map((msg) => `[语音时长${msg.duration}: ${msg.voiceText}]`)
                .join("、");
          }
          if (stickerMessages.length > 0) {
            contentText +=
              "\n用户发送了表情包：" +
              stickerMessages.map((msg) => msg.stickerDescription).join("、");
          }
          if (textImageMessages.length > 0) {
            contentText +=
              "\n用户发送了文字图片描述：" +
              textImageMessages
                .map((msg) => `"${msg.imageDescription}"`)
                .join("、");
          }
          userMessageContent = contentText;
        }
      } else {
        // 初始模式
        // 🆕 如果有礼物图片，构建多模态消息
        if (giftImages.length > 0) {
          console.log(
            `📸 [私信生成器-初始模式] 构建多模态消息，包含${giftImages.length}个礼物图片`
          );

          userMessageContent = [];

          // 构建文本说明
          let textContent = "请生成完整的私信对话详情。";
          textContent += `\n\n📸 用户在直播间送的礼物图片识别（共${giftImages.length}个）：`;
          giftImages.forEach((gift, index) => {
            textContent += `\n  ${index + 1}. 礼物「${gift.name}」（${
              gift.price
            }积分）`;
            if (gift.description) {
              textContent += ` - ${gift.description}`;
            }
            textContent += `\n     图片：[第${
              index + 1
            }张图片是该礼物的样式/外观]`;
          });
          textContent += `\n\n⚠️ 重要：请识别这些礼物图片的实际样子（颜色、形状、设计、风格等），在回复中可以自然地评价礼物的外观。`;
          textContent += `\n例如："我记得你送的那个礼物，设计很特别！" 或 "那个礼物的图案我很喜欢"等。`;

          userMessageContent.push({ type: "text", text: textContent });

          // 添加礼物图片
          giftImages.forEach((gift) => {
            if (gift.imageLocal) {
              userMessageContent.push({
                type: "image_url",
                image_url: { url: gift.imageLocal },
              });
              console.log(
                `📸 [私信生成器-初始模式] 添加礼物图片: ${
                  gift.name
                } (${gift.imageLocal.substring(0, 50)}...)`
              );
            }
          });
        } else {
          userMessageContent = "请生成完整的私信对话详情";
        }
      }
      const messages = [{ role: "user", content: userMessageContent }]; // 最终统计
      const contentForLog = Array.isArray(userMessageContent)
        ? userMessageContent.map((c) => c.text || "[图片]").join(" ")
        : userMessageContent;
      TokenUtils.logFinalPrompt("私信详情生成器", systemPrompt, contentForLog);
      // 🔧 使用统一的API请求工具
      const aiResponseContent = await APIUtils.sendAIRequest({
        apiConfig,
        systemPrompt,
        messages,
        temperature: 0.8,
      });
      // 🔧 使用统一的JSON解析工具
      let conversationData = APIUtils.parseJSONResponse(aiResponseContent);
      if (isContinueMode) {
        // 续写模式：验证消息数组
        if (!Array.isArray(conversationData)) {
          throw new Error("AI返回的数据格式不正确，期望消息数组");
        }
        // 🔍 检查是否包含特殊系统提示
        const hasBlockedMessage = conversationData.some(
          (msg) => msg.type === "system" && msg.systemType === "blocked"
        );
        const hasUnblockedMessage = conversationData.some(
          (msg) => msg.type === "system" && msg.systemType === "unblocked"
        );
        const hasAwayMessage = conversationData.some(
          (msg) => msg.type === "system" && msg.systemType === "away"
        );
        if (hasBlockedMessage) {
          console.log("⚠️ AI决定拉黑用户");
        } else if (hasUnblockedMessage) {
          console.log("🎉 AI决定解除拉黑");
        } else if (hasAwayMessage) {
          console.log("⏰ AI暂时离开");
        } else if (conversationData.length === 0) {
          console.log("📭 AI决定不回复");
        } else {
          console.log(`✅ 生成了${conversationData.length}条AI回复`);
        }
        // 直接返回消息数组（包括空数组和系统提示）
        return conversationData;
      } else {
        // 初始模式：验证完整数据格式
        if (
          !conversationData.senderProfile ||
          !conversationData.messages ||
          !Array.isArray(conversationData.messages)
        ) {
          throw new Error("AI返回的数据格式不正确");
        }
        // 为初次生成的每条消息添加timestamp
        conversationData.messages.forEach((msg) => {
          if (!msg.timestamp) {
            msg.timestamp = new Date().toISOString();
          }
        }); // 保存私信对话数据到数据库
        try {
          // 🔧 多账户隔离：包含账户ID
          const conversationId = `messageConversation_${
            currentAccountId || "main"
          }_${messageData.id}`;
          await xDb.xAccountProfiles.put({
            handle: conversationId,
            name: "messageConversation",
            data: conversationData,
            messageId: messageData.id,
            accountId: currentAccountId || "main", // 添加账户ID字段
            updatedAt: new Date().toISOString(),
          });
          console.log("✅ 私信对话数据已保存到数据库");
        } catch (saveError) {
          console.error("保存私信对话数据失败:", saveError);
        }
        return conversationData;
      }
    } catch (error) {
      console.error("生成私信对话详情失败:", error);
      showXToast(`生成失败: ${error.message}`, "error");
      return null;
    }
  }
  // ▲▲▲ 【主要！！！】第九个情景：私信详情生成器 ▲▲▲
  //【主要！！！】情景：新推详情生成器
  // 聊天记忆检测服务管理
  let chatHistoryDetectionTimer = null;
  let chatHistoryDetectionEnabled = false;
  const DETECTION_INTERVAL = 5 * 60 * 1000; // 5分钟
  // 开关聊天记忆检测服务
  window.toggleChatHistoryDetection = async function () {
    chatHistoryDetectionEnabled = !chatHistoryDetectionEnabled;
    const toggle = document.getElementById("chat-history-detection-toggle");
    const circle = toggle.querySelector(".toggle-circle");
    const statusDiv = document.getElementById("chat-history-detection-status");
    if (chatHistoryDetectionEnabled) {
      // 开启检测
      toggle.style.backgroundColor = "var(--x-accent)";
      circle.style.left = "22px";
      statusDiv.style.display = "block"; // 立即执行一次检测
      await runChatHistoryDetection(); // 启动定时器
      startChatHistoryDetectionTimer(); // 保存状态
      await saveChatHistoryDetectionState(true);
      showXToast("聊天记忆检测已开启", "success");
    } else {
      // 关闭检测
      toggle.style.backgroundColor = "#333";
      circle.style.left = "2px";
      statusDiv.style.display = "none"; // 停止定时器
      if (chatHistoryDetectionTimer) {
        clearInterval(chatHistoryDetectionTimer);
        chatHistoryDetectionTimer = null;
      }
      // 保存状态
      await saveChatHistoryDetectionState(false);
      showXToast("聊天记忆检测已关闭", "info");
    }
  }; // 启动定时器
  function startChatHistoryDetectionTimer() {
    if (chatHistoryDetectionTimer) {
      clearInterval(chatHistoryDetectionTimer);
    }
    chatHistoryDetectionTimer = setInterval(async () => {
      await runChatHistoryDetection();
    }, DETECTION_INTERVAL);
    updateNextDetectionTime();
  }
  // 执行检测
  async function runChatHistoryDetection() {
    try {
      console.log("⏰ [聊天记忆检测] 开始定时检测...");
      await detectAndGenerateNewTweetFromChatHistory();
      updateNextDetectionTime();
    } catch (error) {
      console.error("❌ [聊天记忆检测] 定时检测失败:", error);
    }
  }
  // 更新下次检测时间显示
  function updateNextDetectionTime() {
    const nextTime = new Date(Date.now() + DETECTION_INTERVAL);
    const timeStr = `${nextTime
      .getHours()
      .toString()
      .padStart(2, "0")}:${nextTime.getMinutes().toString().padStart(2, "0")}`;
    const timeSpan = document.getElementById("next-detection-time");
    if (timeSpan) {
      timeSpan.textContent = timeStr;
    }
  }
  // 保存检测状态
  async function saveChatHistoryDetectionState(enabled) {
    try {
      const xDb = getXDB();
      const settingsId = `xSettings_${currentAccountId || "main"}`;
      const settings = await xDb.xSettings.get(settingsId);
      if (settings) {
        settings.chatHistoryDetectionEnabled = enabled;
        await xDb.xSettings.put(settings);
      }
    } catch (error) {
      console.error("保存检测状态失败:", error);
    }
  }
  // 恢复检测状态（在初始化时调用）
  async function restoreChatHistoryDetectionState() {
    try {
      const xDb = getXDB();
      const settingsId = `xSettings_${currentAccountId || "main"}`;
      const settings = await xDb.xSettings.get(settingsId);
      if (settings && settings.chatHistoryDetectionEnabled) {
        console.log("🔄 [聊天记忆检测] 检测到已保存的开启状态，正在恢复..."); // 延迟1秒后启动，确保UI已加载
        setTimeout(() => {
          const toggle = document.getElementById(
            "chat-history-detection-toggle"
          );
          if (toggle) {
            chatHistoryDetectionEnabled = false; // 先设为false，让toggle函数切换
            window.toggleChatHistoryDetection();
          }
        }, 1000);
      } else {
        console.log("ℹ️ [聊天记忆检测] 未检测到开启状态，保持关闭");
      }
    } catch (error) {
      console.error("恢复检测状态失败:", error);
    }
  }
  // 🔧 智能检测聊天记忆并生成 New Tweet（检查所有符合条件的已绑定角色）
  async function detectAndGenerateNewTweetFromChatHistory() {
    try {
      console.log(
        "🔍 [聊天记忆Tweet检测] 开始检测其他平台聊天记忆中的发帖意图"
      ); // 1. 获取已绑定的角色
      const xDb = getXDB();
      const settingsId = `xSettings_${currentAccountId || "main"}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      if (
        !xSettings ||
        !xSettings.boundCharacters ||
        xSettings.boundCharacters.length === 0
      ) {
        console.log("⏭️ [聊天记忆Tweet检测] 没有绑定角色，跳过");
        return;
      }
      // 2. 获取用户身份识别信息
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(
        window.userProfileData
      ); // 3. 筛选符合条件的角色（知道用户身份且有专属人设）
      const mainDB = getDB();
      const allChats = await mainDB.chats.toArray();
      const allXProfiles = await xDb.xCharacterProfiles.toArray();
      const eligibleCharacters = [];
      for (const charId of xSettings.boundCharacters) {
        // 检查是否知道用户身份
        if (!userXProfileInfo.knownIdentityCharacters.includes(charId)) {
          continue;
        }
        // 获取角色数据
        const character = allChats.find((c) => c.id === charId);
        if (!character) continue; // 获取X资料
        const xProfile = allXProfiles.find((p) => p.characterId === charId);
        if (!xProfile) continue; // 检查是否有专属人设
        if (!xProfile.userPersona || !xProfile.userPersona.trim()) {
          console.log(
            `⏭️ [聊天记忆Tweet检测] ${character.name}: 未设置专属用户人设，跳过`
          );
          continue;
        }
        // 检查是否有聊天记忆
        if (!character.history || character.history.length === 0) {
          console.log(
            `⏭️ [聊天记忆Tweet检测] ${character.name}: 没有聊天记忆，跳过`
          );
          continue;
        }
        eligibleCharacters.push({
          character,
          xProfile,
        });
      }
      console.log(
        `✅ [聊天记忆Tweet检测] 找到 ${eligibleCharacters.length} 个符合条件的角色`
      ); // 4. 对每个符合条件的角色检测发帖意图
      for (const { character, xProfile } of eligibleCharacters) {
        await checkCharacterChatHistoryForTweetIntent(character, xProfile);
      }
    } catch (error) {
      console.error("❌ [聊天记忆Tweet检测] 失败:", error);
    }
  }
  // 检查单个角色的聊天记忆是否有发帖意图
  async function checkCharacterChatHistoryForTweetIntent(character, xProfile) {
    try {
      console.log(`🔍 [聊天记忆Tweet检测] 检查角色: ${character.name}`); // 关键词列表（与私信检测相同）
      const postKeywords = [
        "发帖",
        "发推",
        "发推特",
        "发推文",
        "发tweet",
        "发条推",
        "发个帖",
        "发条帖",
        "发个推",
        "发一条",
        "发布推文",
        "发布帖子",
        "post",
        "tweet",
        "tweeted",
        "posting",
        "gonna post",
        "will post",
        "going to post",
        "publish",
        "share on x",
        "share on twitter",
        "发到X上",
        "发到推特",
        "发到平台",
        "分享到X",
        "晒到X",
      ]; // 检查最近的聊天记忆（最多检查最近20条）
      const recentHistory = character.history.slice(-20);
      let foundKeyword = false;
      let keywordIndex = -1;
      for (let i = recentHistory.length - 1; i >= 0; i--) {
        const msg = recentHistory[i]; // 🔧 只检测AI角色的消息（role === 'assistant'），用户无法强制角色发帖
        if (msg.role === "assistant" && msg.content) {
          const content = msg.content.toLowerCase();
          if (
            postKeywords.some((keyword) =>
              content.includes(keyword.toLowerCase())
            )
          ) {
            foundKeyword = true;
            keywordIndex = i;
            console.log(
              `✅ [聊天记忆Tweet检测] ${
                character.name
              } 主动提及发帖: ${msg.content.substring(0, 50)}`
            );
            break;
          }
        }
      }
      if (!foundKeyword) {
        console.log(`⏭️ [聊天记忆Tweet检测] ${character.name} 未主动提及发帖`);
        return;
      }
      // 提取上下文（关键词消息的前后10条）
      const startIndex = Math.max(0, keywordIndex - 10);
      const endIndex = Math.min(recentHistory.length, keywordIndex + 11);
      const contextHistory = recentHistory.slice(startIndex, endIndex); // 转换聊天记忆格式为私信消息格式
      const contextMessages = contextHistory.map((msg) => ({
        type: "text",
        content: msg.content || "",
        isOwn: msg.role === "user",
        time: "最近",
      })); // 构建 messageData（模拟私信格式）
      const messageData = {
        id: `msg_${character.id}`,
        user: {
          name: xProfile.xName,
          handle: xProfile.xHandle,
          avatar: xProfile.xAvatar,
          verified: xProfile.xVerified || false,
        },
      }; // 调用AI生成推文内容（复用现有函数）
      const tweetData = await generateTweetFromConversation(
        messageData,
        contextMessages
      );
      if (!tweetData) {
        console.log(
          `⚠️ [聊天记忆Tweet检测] ${character.name} 的AI未生成推文内容`
        );
        return;
      }
      // 创建 New Tweet 通知
      const timestamp = Date.now();
      const newTweetNotification = {
        id: `mention_newtweet_chat_${timestamp}`,
        type: "newTweet",
        user: messageData.user,
        content: `New Tweet from ${messageData.user.name}`,
        time: "刚刚",
        timestamp: timestamp,
        tweet: tweetData,
      }; // 保存到 Mentions 数据库
      const xDb = getXDB();
      const mentionsDataId = `mentions_${currentAccountId || "main"}`;
      let savedMentions = await xDb.xAccountProfiles.get(mentionsDataId);
      if (!savedMentions) {
        savedMentions = {
          handle: mentionsDataId,
          id: mentionsDataId,
          data: [],
        };
      }
      savedMentions.data.unshift(newTweetNotification);
      await xDb.xAccountProfiles.put(savedMentions);
      console.log(
        `✅ [聊天记忆Tweet检测] ${character.name} 的推文通知已生成并保存`
      ); // 🆕 将推文添加到发推者的账户主页
      await addTweetToAccountProfile(messageData.user.handle, tweetData); // 显示手机样式通知
      const isEnglish = currentLanguage === "en";
      showPhoneNotification({
        title: "X",
        message: isEnglish
          ? `${messageData.user.name} posted a new tweet based on your conversation!`
          : `${messageData.user.name} 根据你们的对话发布了新推文！`,
        avatar: messageData.user.avatar,
        leftIcon: "x",
      }); // 如果当前在 Mentions 页面，刷新显示
      const mentionsPage = document.getElementById("x-notifications-page");
      if (mentionsPage && mentionsPage.style.display === "flex") {
        await loadNotifications();
      } else {
        // 如果不在通知页面，显示提醒点
        showNavNotificationDot("notifications");
      }
    } catch (error) {
      console.error(
        `❌ [聊天记忆Tweet检测] 检查 ${character.name} 失败:`,
        error
      );
    }
  }
  // 智能检测并生成 New Tweet 通知（基于私信对话内容）
  async function detectAndGenerateNewTweetNotification(
    messageData,
    conversationMessages
  ) {
    try {
      console.log("🔍 [私信Tweet检测] 开始检测私信对话中的发帖意图"); // 关键词列表（中英文）
      const postKeywords = [
        "发帖",
        "发推",
        "发推特",
        "发推文",
        "发tweet",
        "发条推",
        "发个帖",
        "发条帖",
        "发个推",
        "发一条",
        "发布推文",
        "发布帖子",
        "post",
        "tweet",
        "tweeted",
        "posting",
        "gonna post",
        "will post",
        "going to post",
        "publish",
        "share on x",
        "share on twitter",
        "发到X上",
        "发到推特",
        "发到平台",
        "分享到X",
        "晒到X",
      ]; // 检查最近的消息中是否包含关键词（只检测对方发送的消息，不检测用户消息）
      let foundKeyword = false;
      let keywordMessageIndex = -1;
      for (
        let i = conversationMessages.length - 1;
        i >= Math.max(0, conversationMessages.length - 10);
        i--
      ) {
        const msg = conversationMessages[i]; // 🔧 只检测非用户发送的消息（isOwn === false），用户无法强制对方发帖
        if (msg.type === "text" && msg.content && !msg.isOwn) {
          const content = msg.content.toLowerCase();
          if (
            postKeywords.some((keyword) =>
              content.includes(keyword.toLowerCase())
            )
          ) {
            foundKeyword = true;
            keywordMessageIndex = i;
            console.log(
              "✅ [私信Tweet检测] 对方主动提及发帖:",
              msg.content.substring(0, 50)
            );
            break;
          }
        }
      }
      if (!foundKeyword) {
        console.log("⏭️ [私信Tweet检测] 对方未主动提及发帖，跳过");
        return;
      }
      // 提取上下文（关键词消息的前后10条）
      const startIndex = Math.max(0, keywordMessageIndex - 10);
      const endIndex = Math.min(
        conversationMessages.length,
        keywordMessageIndex + 11
      );
      const contextMessages = conversationMessages.slice(startIndex, endIndex);
      console.log(
        `📝 [私信Tweet检测] 提取上下文消息: ${contextMessages.length} 条`
      ); // 调用AI生成推文内容
      const tweetData = await generateTweetFromConversation(
        messageData,
        contextMessages
      );
      if (!tweetData) {
        console.log("⚠️ [私信Tweet检测] AI未生成推文内容");
        return;
      }
      // 创建 New Tweet 通知
      const timestamp = Date.now();
      const newTweetNotification = {
        id: `mention_newtweet_dm_${timestamp}`,
        type: "newTweet",
        user: messageData.user,
        content: `New Tweet from ${messageData.user.name}`,
        time: "刚刚",
        timestamp: timestamp,
        tweet: tweetData, // 完整的推文数据
      }; // 保存到 Mentions 数据库
      const xDb = getXDB();
      const mentionsDataId = `mentions_${currentAccountId || "main"}`;
      let savedMentions = await xDb.xAccountProfiles.get(mentionsDataId);
      if (!savedMentions) {
        savedMentions = {
          handle: mentionsDataId,
          id: mentionsDataId,
          data: [],
        };
      }
      // 添加到开头
      savedMentions.data.unshift(newTweetNotification);
      await xDb.xAccountProfiles.put(savedMentions);
      console.log("✅ [私信Tweet检测] 已生成并保存 New Tweet 通知"); // 🆕 将推文添加到发推者的账户主页
      await addTweetToAccountProfile(messageData.user.handle, tweetData); // 显示手机样式通知
      const isEnglish = currentLanguage === "en";
      showPhoneNotification({
        title: "X",
        message: isEnglish
          ? `${messageData.user.name} posted a new tweet!`
          : `${messageData.user.name} 发布了新推文！`,
        avatar:
          messageData.user.avatar ||
          "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
        leftIcon: "x",
      }); // 如果当前在 Mentions 页面，刷新显示
      const mentionsPage = document.getElementById("x-notifications-page");
      if (mentionsPage && mentionsPage.style.display === "flex") {
        await loadNotifications();
      } else {
        // 如果不在通知页面，显示提醒点
        showNavNotificationDot("notifications");
      }
    } catch (error) {
      console.error("❌ [私信Tweet检测] 失败:", error);
    }
  }
  // 基于私信对话生成推文内容
  async function generateTweetFromConversation(
    messageData,
    contextMessages,
    options = {}
  ) {
    try {
      // 🎯 提取选项参数
      const isAutoTweet = options.isAutoTweet || false; // 是否为自动发推模式
      const timeSinceLastMessage = options.timeSinceLastMessage || 0; // 距离上次聊天的时间（秒）
      const autoTweetType = options.type || "character"; // 自动发推类型：character | stranger
      // 🔧 使用统一的API配置加载工具
      const { apiConfig, xSettings, xDb } =
        await APIUtils.loadConfigAndSettings();
      const { userPrompt, worldSetting } = xSettings;
      // 判断私信类型（仿照第九个情景）
      let messageType = "stranger"; // stranger | character | account
      let characterId = null;
      let accountHandle = null;
      if (messageData.id) {
        if (messageData.id.startsWith("msg_account_")) {
          messageType = "account"; // 提取账户句柄
          const parts = messageData.id.split("_");
          if (parts.length > 2) {
            accountHandle = parts[2];
          }
        } else if (
          messageData.id.startsWith("msg_") &&
          messageData.id !== "msg_001"
        ) {
          messageType = "character";
          characterId = messageData.id.replace("msg_", "");
        }
      }
      console.log(`📝 [Tweet生成] 消息类型: ${messageType}`, {
        characterId,
        accountHandle,
      });
      // 使用工具函数构建用户X个人资料信息
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(
        window.userProfileData
      ); // 获取用户最新的5条推文
      const userTweetsId = `userTweets_${currentAccountId || "main"}`;
      const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
      const recentUserTweets = userTweetsData?.tweets?.slice(0, 5) || [];

      // 🆕 如果是自动发推模式，读取发推者的现有推文用于删除决策
      let senderExistingTweets = [];
      if (isAutoTweet) {
        const cleanHandle = messageData.user.handle.replace("@", "");
        const senderProfile = await xDb.xAccountProfiles.get(cleanHandle);
        if (
          senderProfile &&
          senderProfile.tweets &&
          senderProfile.tweets.length > 0
        ) {
          // 只取最近的20条推文用于删除决策
          senderExistingTweets = senderProfile.tweets.slice(0, 20);
          console.log(
            `📝 [Tweet生成] 读取到 ${senderExistingTweets.length} 条现有推文用于删除决策`
          );
        }
      }

      // Token计数器
      let tokenCount = 0; // 0. 时间感知（北京时间）
      const now = new Date();
      const beijingTime = new Date(now.getTime() + 8 * 60 * 60 * 1000); // UTC+8
      const year = beijingTime.getUTCFullYear();
      const month = beijingTime.getUTCMonth() + 1;
      const day = beijingTime.getUTCDate();
      const hours = beijingTime.getUTCHours();
      const minutes = beijingTime.getUTCMinutes();
      const weekdays = [
        "星期日",
        "星期一",
        "星期二",
        "星期三",
        "星期四",
        "星期五",
        "星期六",
      ];
      const weekday = weekdays[beijingTime.getUTCDay()];
      let timeOfDay = "";
      if (hours >= 5 && hours < 9) {
        timeOfDay = "清晨";
      } else if (hours >= 9 && hours < 12) {
        timeOfDay = "上午";
      } else if (hours >= 12 && hours < 14) {
        timeOfDay = "中午";
      } else if (hours >= 14 && hours < 18) {
        timeOfDay = "下午";
      } else if (hours >= 18 && hours < 22) {
        timeOfDay = "晚上";
      } else {
        timeOfDay = "深夜";
      }
      // 1. 基础系统提示词 + 世界书
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage(
        "Tweet生成器",
        "基础系统提示词",
        systemPrompt,
        tokenCount
      ); // 1.5. 添加当前时间信息
      systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⏰ 当前时间信息 ⏰
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
当前时间（北京时间）：${year}年${month}月${day}日 ${weekday} ${String(
        hours
      ).padStart(2, "0")}:${String(minutes).padStart(2, "0")}
时段：${timeOfDay}
**请根据当前时间生成符合时间情境的推文**：
- 如果是清晨或上午，推文可以是早安问候、早餐分享、一天计划等
- 如果是中午，可以是午餐分享、工作进展等
- 如果是下午，可以是下午茶、工作日常、生活感悟等
- 如果是晚上，可以是晚餐、晚间活动、一天总结等
- 如果是深夜，可以是深夜想法、失眠感悟等
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
      tokenCount = TokenUtils.logTokenUsage(
        "Tweet生成器",
        "时间信息",
        systemPrompt.substring(systemPrompt.lastIndexOf("⏰ 当前时间信息")),
        tokenCount
      ); // 1.5. 获取适用的世界书内容
      const worldBooksOptions = { boundCharacters: [] };
      if (messageType === "character" && characterId) {
        worldBooksOptions.boundCharacters = [characterId];
      }
      const worldBooksContent = await StringBuilders.getApplicableWorldBooks(
        "posts",
        worldBooksOptions
      );
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage(
          "Tweet生成器",
          "世界书内容",
          worldBooksContent,
          tokenCount
        );
      }
      // 2. 核心任务说明
      systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务：基于私信对话生成推文 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的推文生成器。${
        isAutoTweet
          ? `${messageData.user.name} (${
              messageData.user.handle
            }) 在后台自动发布推文。
🤖 **后台自动发推模式**：角色根据最近的聊天记录自主决定发布推文内容
⏰ **距离上次聊天**: ${Math.floor(
              timeSinceLastMessage / 60
            )} 分钟前（${timeSinceLastMessage} 秒）
📝 **推文重点**: 以刻画 ${
              messageData.user.name
            } 自身为主，可以分享日常、想法、近况等，聊天记录仅作为灵感参考`
          : `在私信对话中，${messageData.user.name} (${messageData.user.handle}) 提到要发布推文。`
      }
🚨 **注意：是 ${messageData.user.name} 要发推文，不是用户本人！**
请根据对话上下文，生成 ${messageData.user.name} 可能会发布的推文内容。
**对话上下文**（最近的私信对话${isAutoTweet ? "，作为灵感参考" : ""}）：
`; // 添加对话记录
      contextMessages.forEach((msg, index) => {
        const sender = msg.isOwn
          ? userXProfileInfo.name
          : messageData.user.name;
        let content = "";
        if (msg.type === "text") {
          content = msg.content;
        } else if (msg.type === "image") {
          content =
            msg.isOwn && msg.imageData
              ? "[图片]"
              : `[图片: ${msg.imageDescription || ""}]`;
        } else if (msg.type === "voice") {
          content = `[语音: ${msg.voiceText}]`;
        } else if (msg.type === "sticker") {
          content = "[表情包]";
        }
        systemPrompt += `
${index + 1}. ${sender}: ${content}`;
      });
      systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`; // 🔥 如果是商业转账反水模式，添加特殊说明
      if (messageData._isBusinessBetrayal) {
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔥 特殊模式：商业推广反水 🔥
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🚨 **重要：${messageData.user.name} 决定"反水"，不按照商业任务要求发推文！**
**反水类型（选择其中一种）**：
1. **揭露型**（40%）：
- 直接揭露有人花钱让自己发广告
- 例："有人给我钱让我宣传XXX，但我觉得这东西真的很一般..."
- 例："刚收到一个推广邀约，说实话我用过那玩意儿，不推荐"
2. **吐槽型**（30%）：
- 吐槽任务本身或产品/服务
- 例："又有人让我帮忙推广了，但这次的东西真的...算了不说了"
- 例："有些推广真的很无语，明明产品质量那样还要我说好话"
3. **完全不配合型**（20%）：
- 完全不提任务，发自己想发的内容
- 例："今天心情不好，不想工作"
- 例："做自己想做的事比什么都重要"
4. **阴阳怪气型**（10%）：
- 表面上完成任务，但用讽刺/暗示的语气
- 例："某个'非常好用'的产品（此处省略一万字）"
- 例："终于可以体验到'传说中'的XXX了呢😊"
**生成要求**：
- 推文必须体现${messageData.user.name}的性格特质
- 根据角色设定选择合适的反水方式
- 推文要自然，不要太刻意
- 可以保留一定的模糊性，让读者自己理解
- stats数据要合理（反水推文可能会有更多讨论：comments 20-60, likes 50-200）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        tokenCount = TokenUtils.logTokenUsage(
          "Tweet生成器",
          "反水模式说明",
          systemPrompt.substring(systemPrompt.lastIndexOf("🔥 特殊模式")),
          tokenCount
        );
      }
      const coreTaskSection = systemPrompt.substring(
        systemPrompt.lastIndexOf("🎯 核心任务")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "Tweet生成器",
        "核心任务说明",
        coreTaskSection,
        tokenCount
      ); // 2.5. 用户资料信息
      const userConstraintsStart = systemPrompt.length;
      systemPrompt += `
【用户X平台资料】（用于理解对话背景）：
- 用户名：${userXProfileInfo.name}
- 用户句柄：${userXProfileInfo.handle}
- 认证状态：${userXProfileInfo.verified ? "已认证" : "未认证"}
${
  userXProfileInfo.publicIdentity
    ? `- 公众身份：${userXProfileInfo.publicIdentity}`
    : ""
}
${userXProfileInfo.bio ? `- 个人简介：${userXProfileInfo.bio}` : ""}
`; // 2.6. 用户最近推文
      if (recentUserTweets.length > 0) {
        systemPrompt += `
【用户最近推文】（供参考，对话可能涉及这些推文）：
`;
        recentUserTweets.forEach((tweet, index) => {
          systemPrompt += `
${index + 1}. "${tweet.content}"
- 发布时间：${tweet.time || "最近"}
- 互动数据：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.comments || 0}评论
`;
        });
      }
      const userSection = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage(
        "Tweet生成器",
        "用户资料和推文",
        userSection,
        tokenCount
      ); // 3. 使用统一资料获取工具（大幅简化代码）
      const profileInfoStart = systemPrompt.length; // 🎯 核心优化：只需一行代码获取所有资料（传入用户资料用于身份识别）
      console.log(
        `🔍 [Tweet生成] 用户身份识别列表:`,
        userXProfileInfo.knownIdentityCharacters,
        `角色ID: ${characterId}`
      );
      const senderProfile = await StringBuilders.getUnifiedProfile(
        messageData.user.handle,
        {
          userProfileInfo: userXProfileInfo,
        }
      );
      if (senderProfile) {
        // 🔍 调试日志：检查用户人设读取
        if (senderProfile.type === "character") {
          console.log(
            `🔍 [Tweet生成] 角色知道用户身份: ${senderProfile.knowsUserIdentity}`
          );
          console.log(
            `🔍 [Tweet生成] 角色用户人设: "${
              senderProfile.characterData?.userPersona || "无"
            }"`
          );
        }
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`; // 使用格式化工具生成提示词
        systemPrompt += StringBuilders.formatProfileForPrompt(senderProfile, {
          includeType: true,
          includeTweets: true,
          includeRelationships: true,
        });
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
**推文生成要求**：
- 推文内容必须严格符合${senderProfile.name}的${
          senderProfile.type === "character" ? "性格和说话风格" : "身份和风格"
        }
${
  isAutoTweet
    ? `- 🎯 **后台自动发推重点**：推文以刻画${
        senderProfile.name
      }自身为主（日常、想法、近况、感受等）
- 聊天记录仅作为灵感来源，不要直接提及或暗示与用户的对话
- 推文应该像${senderProfile.name}的独立生活动态，而非对话延续
- 可以是：分享心情、吐槽日常、发表观点、晒照片、记录生活等
- 时间感：距离上次聊天已过去${Math.floor(
        timeSinceLastMessage / 60
      )}分钟，推文可以反映这段时间的活动`
    : `- 推文要与私信对话内容相关`
}
`; // 特定类型的额外要求
        if (senderProfile.type === "character") {
          systemPrompt += `- 参考角色人设和最近的推文风格\n`; // 🔧 用户身份识别信息（使用senderProfile中已经计算好的值）
          if (senderProfile.knowsUserIdentity) {
            systemPrompt += `- ✅ 该角色知道用户身份（${userXProfileInfo.name} / ${userXProfileInfo.handle}），推文中可以自然地@用户或提及与用户相关的内容\n`;
            systemPrompt += `- 可以结合对用户的了解生成推文内容\n`;
          } else {
            systemPrompt += `- ❌ 该角色不知道用户身份，推文不应该直接提及或@用户\n`;
            systemPrompt += `- 推文内容独立于用户，不要暗示认识用户\n`;
          }
        } else if (senderProfile.type === "account") {
          systemPrompt += `- 参考账户的发帖习惯和平台形象\n`;
        }
        const profileInfo = systemPrompt.substring(profileInfoStart);
        tokenCount = TokenUtils.logTokenUsage(
          "Tweet生成器",
          "发送者详细信息",
          profileInfo,
          tokenCount
        );
      } else {
        // 备用方案
        systemPrompt += `
**推文生成要求**：
- 推文内容要符合 ${messageData.user.name} 的身份和对话语境
- 推文要与私信对话内容相关
`;
      }
      // 4. 通用要求
      systemPrompt += `
- 内容要自然，像是真实用户会发布的推文
- 可以包含情绪、观点、分享或日常内容
- 字数控制在20-200字之间
- 可以带emoji表情
- ${isAutoTweet ? "40%" : "30%"}的概率带图片（如果合适的话，提供图片描述）
- stats数据要合理（普通用户流量：comments 5-30, retweets 10-80, likes 20-150, views 100-2000）
${
  isAutoTweet
    ? `
🎯 **后台自动发推特别提示**：
- 推文要体现${messageData.user.name}的独立生活和个性
- 不要让推文看起来像是在回应某个对话
- 可以发一些与聊天无关的日常内容
- 展现角色在用户不在场时的生活状态${
        senderExistingTweets.length > 0
          ? `

🗑️ **旧推文清理决策**（重要！）：
你需要同时决定是否删除一些旧推文。${messageData.user.name}当前有以下推文：

${senderExistingTweets
  .map(
    (tweet, index) => `
${index + 1}. [ID: ${tweet.id || `tweet_${index}`}]
内容: "${tweet.content}"
发布时间: ${
      tweet.timestamp
        ? new Date(tweet.timestamp).toLocaleString("zh-CN", {
            timeZone: "Asia/Shanghai",
          })
        : "未知"
    }
互动数据: ${tweet.stats?.likes || 0}赞 ${tweet.stats?.comments || 0}评论 ${
      tweet.stats?.retweets || 0
    }转发`
  )
  .join("")}

**删除标准（选择性删除，不是必须删除）**：
1. **内容重复**：多条推文表达相同的意思或话题
2. **啰嗦冗余**：推文内容过于琐碎、没有价值
3. **后悔发布**：不符合角色人设、暴露了不该说的信息
4. **过时内容**：已经不再relevant的临时性内容
5. **质量低劣**：文字表达不佳、没有意义的推文
6. **情绪化发言**：当时情绪激动发布的不当内容

**删除决策原则**：
- 🎯 **选择性删除**：不是所有推文都要删，只删除确实有问题的
- 📊 **保持数量**：一般保留10-15条优质推文即可
- ⚖️ **权衡利弊**：互动数据高的推文需要更强的理由才删除
- 🤔 **符合性格**：删除决策要符合${messageData.user.name}的性格特点
  * 完美主义者可能删除更多
  * 随性的人可能很少删除
  * 谨慎的人会删除可能引起争议的
  * 粗线条的人基本不在意旧推文

**如何返回删除决策**：
- 在JSON的 "tweetsToDelete" 字段中列出要删除的推文ID
- 可以返回空数组 [] 表示不删除任何推文
- 每个ID必须是上述列表中的真实ID`
          : ""
      }`
    : ""
}
【JSON返回格式】：
\`\`\`json
{
"content": "推文文本内容",
"image": {"type": "description", "content": "图片描述"} 或 null,
"time": "刚刚",
"stats": {
"comments": 评论数,
"retweets": 转发数,
"likes": 点赞数,
"views": 浏览数
},${
        isAutoTweet && senderExistingTweets.length > 0
          ? `
"tweetsToDelete": ["要删除的推文ID1", "要删除的推文ID2"] 或 [],`
          : ""
      }
"comments": [
{
 "id": "评论唯一ID（可留空，系统自动生成）",
 "user": {
 "name": "评论者昵称",
 "handle": "@评论者句柄",
 "avatar": "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
 "verified": false
 },
 "content": "评论文本",
 "time": "时间描述（如'2小时前'）",
 "image": {"type": "description", "content": "图片文字描述"} (可选，10-20%的评论带图),
 "stats": {
 "replies": 回复数,
 "retweets": 转发数,
 "likes": 点赞数
 }
}
]
}
\`\`\`
关键规则：
1. 推文内容要与对话上下文相关
2. 🚨 推文是 ${messageData.user.name} 发布的，不是 ${userXProfileInfo.name}
3. 符合发布者的说话风格和身份
4. stats中所有数字必须是纯数字，不带引号
5. image字段可选，如果不需要图片就设为null
6. **必须包含2-5条评论**，评论要与推文内容相关且自然
7. 10-20%的评论可以带图（image字段）
8. 评论的stats数据要合理（replies 0-10, retweets 0-20, likes 1-50）${
        isAutoTweet && senderExistingTweets.length > 0
          ? `
9. 🗑️ **tweetsToDelete字段**：根据上述删除标准决定要删除的推文ID列表
   - 可以是空数组[]（不删除任何推文）
   - 可以包含1-5个推文ID（选择性删除）
   - 每个ID必须是现有推文列表中的真实ID
   - 删除决策要符合${messageData.user.name}的性格特点`
          : ""
      }
`;
      const formatSection = systemPrompt.substring(
        systemPrompt.lastIndexOf("【JSON返回格式】")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "Tweet生成器",
        "JSON格式要求",
        formatSection,
        tokenCount
      ); // 最终统计
      TokenUtils.logFinalPrompt("Tweet生成器", systemPrompt, "请生成推文");
      const messages = [{ role: "user", content: "请生成推文" }];
      // 🔧 使用统一的API请求工具
      const aiResponseContent = await APIUtils.sendAIRequest({
        apiConfig,
        systemPrompt,
        messages,
        temperature: 0.8,
      });
      // 🔧 使用统一的JSON解析工具
      const tweetData = APIUtils.parseJSONResponse(aiResponseContent);

      // 🗑️ 处理删除推文决策（如果有）
      let tweetsToDelete = tweetData.tweetsToDelete || [];
      if (isAutoTweet && tweetsToDelete.length > 0) {
        console.log(
          `🗑️ [Tweet生成] AI决定删除 ${tweetsToDelete.length} 条旧推文:`,
          tweetsToDelete
        );
        // 执行删除操作
        await deleteTweetsFromAccountProfile(
          messageData.user.handle,
          tweetsToDelete
        );
      }

      // 删除tweetsToDelete字段，不需要保存到推文数据中
      delete tweetData.tweetsToDelete;

      // 添加用户信息
      const timestamp = Date.now();
      tweetData.id = `newtweet_${timestamp}`;
      tweetData.user = messageData.user;
      tweetData.timestamp = timestamp; // 🔧 删除AI生成的静态time字段，改用timestamp动态计算
      delete tweetData.time; // 为评论分配ID和时间戳
      if (tweetData.comments && tweetData.comments.length > 0) {
        tweetData.comments.forEach((comment, cIndex) => {
          if (!comment.id) {
            comment.id = `newtweet_${timestamp}_c${cIndex}`;
          }
          // 评论时间应该在推文之后
          if (!comment.timestamp) {
            comment.timestamp =
              timestamp + (5 + Math.random() * 30) * 60 * 1000; // 5-35分钟后
          }
          // 🔧 删除AI生成的静态time字段，改用timestamp动态计算
          delete comment.time;
        });
      }
      console.log("✅ [Tweet生成] 推文内容已生成:", tweetData);
      return tweetData;
    } catch (error) {
      console.error("❌ [Tweet生成] 失败:", error);
      return null;
    }
  }
  // ============================================
  // 私信详情页面功能
  // ============================================
  // 当前查看的私信会话数据
  let currentMessageConversation = null; // 私信多选删除相关状态
  let messageMultiSelectMode = false;
  let selectedMessages = new Set();
  let messageLongPressTimer = null;
  let messageLongPressTarget = null; // 渲染私信消息项
  function renderMessageItem(
    message,
    isOwn = false,
    messageIndex,
    isLastInGroup = true,
    showTime = true
  ) {
    const config = languageConfig[currentLanguage] || languageConfig.zh; // 使用索引作为消息ID（简单且可靠）
    const messageId =
      messageIndex !== undefined
        ? `msg_idx_${messageIndex}`
        : `msg_temp_${Math.random()}`; // 检查是否是粉丝群消息（包含发送者信息）
    const isFanGroupMessage = !isOwn && message.senderId && message.senderName;
    const messageEl = document.createElement("div");
    messageEl.className = "message-item";
    messageEl.setAttribute("data-message-id", messageId);
    messageEl.setAttribute(
      "data-message-index",
      messageIndex !== undefined ? messageIndex : -1
    );
    messageEl.style.cssText = `
 display: flex; flex-direction: column; align-items: ${
   isOwn ? "flex-end" : "flex-start"
 }; margin-bottom: ${
      isLastInGroup ? "16px" : "4px"
    }; position: relative; transition: opacity 0.2s; opacity: 0; transform: translateY(10px);
`; // 🎯 粉丝群消息：每条消息都显示发送者信息（气泡左侧）
    if (isFanGroupMessage) {
      const senderInfoEl = document.createElement("div");
      senderInfoEl.style.cssText = `
 display: flex; align-items: flex-start; gap: 8px; width: 100%; `; // 头像
      const avatarEl = document.createElement("img");
      avatarEl.src = message.senderAvatar;
      avatarEl.style.cssText = `
 width: 32px; height: 32px; border-radius: 50%; object-fit: cover; flex-shrink: 0; margin-top: 2px; `;
      senderInfoEl.appendChild(avatarEl); // 消息内容容器（包括昵称和气泡）
      const contentWrapper = document.createElement("div");
      contentWrapper.style.cssText = `
 flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 4px; `; // 昵称和句柄
      const nameEl = document.createElement("div");
      nameEl.style.cssText = `
 display: flex; align-items: center; gap: 6px; `;
      nameEl.innerHTML = `
 <span style="font-size: 14px; font-weight: 600; color:var(--x-text-primary); ">${message.senderName}</span>
 <span style="font-size: 13px; color:var(--x-text-secondary); ">${message.senderHandle}</span>
 `;
      contentWrapper.appendChild(nameEl);
      senderInfoEl.appendChild(contentWrapper);
      messageEl.appendChild(senderInfoEl); // 调整messageEl布局为横向
      messageEl.style.flexDirection = "row";
      messageEl.style.alignItems = "flex-start";
    }
    // 如果在多选模式，添加选择指示器
    if (messageMultiSelectMode) {
      const isSelected = selectedMessages.has(messageId);
      const selectIndicator = document.createElement("div");
      selectIndicator.className = "message-select-indicator";
      selectIndicator.style.cssText = `
 position: absolute; ${isOwn ? "right: -10px;" : "left: -10px;"}
 top: 50%; transform: translateY(-50%); width: 24px; height: 24px; border-radius: 50%; border: 2px solid ${
   isSelected ? "var(--x-accent)" : "var(--x-border-color)"
 }; background-color: ${
        isSelected ? "var(--x-accent)" : "var(--x-bg-primary)"
      }; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 10; `;
      if (isSelected) {
        selectIndicator.innerHTML = `
 <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: #fff;">
 <g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></g>
 </svg>
 `;
      }
      selectIndicator.onclick = (e) => {
        e.stopPropagation();
        toggleMessageSelection(messageId);
      };
      messageEl.appendChild(selectIndicator);
      messageEl.style.opacity = isSelected ? "0.7" : "1";
    }
    // 添加长按事件监听（桌面端和移动端）
    let pressTimer = null;
    const startPress = (e) => {
      if (messageMultiSelectMode) return;
      pressTimer = setTimeout(() => {
        enterMessageMultiSelectMode();
        toggleMessageSelection(messageId); // 触觉反馈（如果支持）
        if (navigator.vibrate) {
          navigator.vibrate(50);
        }
      }, 500);
    };
    const endPress = () => {
      if (pressTimer) {
        clearTimeout(pressTimer);
        pressTimer = null;
      }
    }; // 移动端触摸事件
    messageEl.addEventListener("touchstart", startPress);
    messageEl.addEventListener("touchend", endPress);
    messageEl.addEventListener("touchmove", endPress); // 桌面端鼠标事件
    messageEl.addEventListener("mousedown", startPress);
    messageEl.addEventListener("mouseup", endPress);
    messageEl.addEventListener("mouseleave", endPress); // 多选模式下点击切换选择
    if (messageMultiSelectMode) {
      messageEl.style.cursor = "pointer";
      messageEl.onclick = () => {
        toggleMessageSelection(messageId);
      };
    }
    // 消息气泡
    const bubbleEl = document.createElement("div");
    const baseStyle = `
 max-width: 70%; border-radius: 18px; font-size: 15px; line-height: 1.4; word-wrap: break-word; ${
   isLastInGroup
     ? isOwn
       ? "border-bottom-right-radius: 4px;"
       : "border-bottom-left-radius: 4px;"
     : ""
 }
`; // 判断消息类型
    if (message.type === "text") {
      // 文本消息
      bubbleEl.style.cssText =
        baseStyle +
        `
 padding: 12px 16px; background-color: ${
   isOwn ? "var(--x-accent)" : "var(--x-bg-secondary)"
 }; color: ${
          isOwn ? "#fff !important" : "var(--x-text-primary)"
        }; width: fit-content; `; // 处理@提及和#话题标签高亮
      const processedContent = processContent(message.content || "", { isOwn });
      bubbleEl.innerHTML = processedContent;
    } else if (message.type === "image") {
      // 图片消息
      bubbleEl.style.cssText =
        baseStyle +
        `
 padding: 0; background-color: transparent; width: fit-content; `;
      const imageContainerId = `img_${Date.now()}_${Math.random()
        .toString(36)
        .substr(2, 9)}`;
      const imageContainer = document.createElement("div");
      imageContainer.id = imageContainerId;
      imageContainer.style.cssText = `
 position: relative; border-radius: 12px; overflow: hidden; ${
   message.imageData
     ? "background-color: transparent;"
     : "background-color: rgba(142, 142, 142, 0.15); padding: 16px;"
 }
 max-width: ${message.imageData ? "200px" : "280px"}; `; // 如果有imageData（用户发送的图片），显示实际图片
      if (message.imageData) {
        const imgEl = document.createElement("img");
        imgEl.src = message.imageData;
        imgEl.style.cssText = `
 max-width: 200px; max-height: 200px; width: auto; height: auto; display: block; border-radius: 12px; cursor: pointer; `;
        imgEl.onclick = () => {
          // 点击图片放大查看
          window.open(message.imageData, "_blank");
        };
        imageContainer.appendChild(imgEl);
      } else {
        // AI回复的图片描述
        const descEl = document.createElement("div");
        descEl.style.cssText = `
 color:var(--x-text-primary); font-size: 15px; line-height: 1.4; word-wrap: break-word; `;
        descEl.textContent = message.imageDescription || "[图片]";
        imageContainer.appendChild(descEl);
      }
      // 敏感内容遮罩（仿照推文的处理方式）
      if (message.sensitive) {
        const maskId = `mask_${imageContainerId}`;
        const maskEl = document.createElement("div");
        maskEl.id = maskId;
        maskEl.style.cssText = `
 position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; z-index: 1; `;
        maskEl.innerHTML = `
 <svg viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: #fff; margin-bottom: 8px;">
 <g><path d="M12 15c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm0-4c-.552 0-1 .448-1 1s.448 1 1 1 1-.448 1-1-.448-1-1-1z"></path><path d="M12 5c-7.633 0-9.927 6.617-9.948 6.684L1.946 12l.105.316C2.073 12.383 4.367 19 12 19s9.927-6.617 9.948-6.684l.106-.316-.105-.316C21.927 11.617 19.633 5 12 5zm0 12c-5.351 0-7.424-3.846-7.926-5C4.578 10.842 6.652 7 12 7c5.351 0 7.424 3.846 7.926 5-.504 1.158-2.578 5-7.926 5z"></path></g>
 </svg>
 <div style="color: #fff; font-weight: 600; font-size: 15px; margin-bottom: 4px;">可能含有敏感内容</div>
 <div style="color: rgba(255,255,255,0.8); font-size: 13px;">点击查看</div>
 `;
        maskEl.onclick = function () {
          this.style.display = "none";
        };
        imageContainer.appendChild(maskEl);
      }
      bubbleEl.appendChild(imageContainer);
    } else if (message.type === "voice") {
      // 语音消息
      bubbleEl.style.cssText =
        baseStyle +
        `
 padding: 10px 14px; background-color: ${
   isOwn ? "var(--x-accent)" : "var(--x-bg-secondary)"
 }; color: ${
          isOwn ? "#fff" : "var(--x-text-primary)"
        }; max-width: 180px; width: fit-content; `;
      const voiceId = `voice_${Date.now()}_${Math.random()
        .toString(36)
        .substr(2, 9)}`;
      bubbleEl.innerHTML = `
 <div id="${voiceId}" style="display: flex; align-items: center; gap: 10px; cursor: pointer; color: ${
        isOwn ? "#fff" : "var(--x-text-primary)"
      };" onclick="toggleVoiceText('${voiceId}', '${message.voiceText?.replace(
        /'/g,
        "\\'"
      )}')">
 <div style="width: 32px; height: 32px; border-radius: 50%; background-color: ${
   isOwn ? "rgba(255,255,255,0.2)" : "var(--x-accent)"
 }; display: flex; align-items: center; justify-content: center; flex-shrink: 0; ">
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: #fff;">
 <g><path d="M8 5v14l11-7z"></path></g>
 </svg>
 </div>
 <span style="font-weight: 600; color: inherit; font-size: 14px;">${
   message.duration || "0:05"
 }</span>
 </div>
 `;
    } else if (message.type === "sticker") {
      // 表情包消息
      bubbleEl.style.cssText =
        baseStyle +
        `
 padding: 0; background-color: transparent; width: fit-content; `;
      bubbleEl.innerHTML = `
 <div style="max-width: 120px; border-radius: 8px; overflow: hidden; ">
 <img src="${message.stickerUrl}"
 alt="表情包"
 style="width: 100%; height: auto; display: block; border-radius: 8px; "
 onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'padding: 12px; color:var(--x-text-secondary); text-align: center;\\'>表情包加载失败</div>';">
 </div>
 `;
    } else if (message.type === "link") {
      // 链接消息
      bubbleEl.style.cssText =
        baseStyle +
        `
 padding: 0; background-color: transparent; color:var(--x-text-primary); width: fit-content; `;
      const linkCardId = `link_card_${Date.now()}_${Math.random()
        .toString(36)
        .substr(2, 9)}`;
      bubbleEl.innerHTML = `
 <div id="${linkCardId}" style="border: 1px solid var(--x-border-color); border-radius: 12px; overflow: hidden; background-color:var(--x-bg-secondary); cursor: pointer; transition: all 0.2s; "
 onmouseover="this.style.backgroundColor='var(--x-bg-hover)'; this.style.borderColor='var(--x-accent)'"
 onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'; this.style.borderColor='var(--x-border-color)'">
 <div style="padding: 12px;">
 <div style="font-weight: 600; margin-bottom: 4px; color:var(--x-text-primary);">
 ${message.title || "链接"}
 </div>
 ${
   message.description
     ? `
 <div style="font-size: 13px; color:var(--x-text-secondary); margin-bottom: 8px;">
 ${message.description}
 </div>
 `
     : ""
 }
 <div style="font-size: 13px; color: var(--x-accent); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
 ${message.url || "点击查看文章"}
 </div>
 </div>
 </div>
 `; // 添加点击事件打开文章页面
      setTimeout(() => {
        const linkCard = document.getElementById(linkCardId);
        if (linkCard) {
          linkCard.onclick = () => {
            openArticlePage({
              title: message.title,
              author: message.author || "佚名",
              source: message.source || message.url || "未知来源",
              body: message.body || message.description || "",
            });
          };
        }
      }, 0);
    } else if (message.type === "quoteTweet") {
      // 转发推文
      bubbleEl.style.cssText =
        baseStyle +
        `
 padding: 0; background-color: transparent; color:var(--x-text-primary); width: fit-content; `;
      bubbleEl.innerHTML = `
 ${
   message.caption
     ? `
 <div style="padding: 12px 16px; background-color: ${
   isOwn ? "var(--x-accent)" : "var(--x-bg-secondary)"
 }; color: ${
         isOwn ? "#fff" : "var(--x-text-primary)"
       }; border-radius: 12px; margin-bottom: 8px; width: fit-content; ">${processContent(
         message.caption || "",
         {
           isOwn,
         }
       )}</div>
 `
     : ""
 }
 <div style="border: 1px solid var(--x-border-color); border-radius: 12px; padding: 12px; background-color:var(--x-bg-secondary); width: fit-content; max-width: 100%; ">
 <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
 <img src="${
   message.tweet.userAvatar
 }" style="width: 20px; height: 20px; border-radius: 50%;">
 <span style="font-weight: 600; color:var(--x-text-primary);">${
   message.tweet.userName
 }</span>
 ${
   message.tweet.verified
     ? `
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);">
 <g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.26 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.45 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g>
 </svg>
 `
     : ""
 }
 <span style="color:var(--x-text-secondary); font-size: 13px;">${
   message.tweet.userHandle
 }</span>
 <span style="color:var(--x-text-secondary); font-size: 13px;">·</span>
 <span style="color:var(--x-text-secondary); font-size: 13px;">${
   message.tweet.time
 }</span>
 </div>
 <div style="color:var(--x-text-primary);">${processContent(
   message.tweet.content || "",
   {
     isOwn: false,
   }
 )}</div>
 </div>
 `;
    } else if (message.type === "quoteProfile") {
      // 转发主页
      bubbleEl.style.cssText =
        baseStyle +
        `
 padding: 0; background-color: transparent; color:var(--x-text-primary); width: fit-content; `;
      const profileCardId = `profile_card_${Date.now()}_${Math.random()
        .toString(36)
        .substr(2, 9)}`;
      bubbleEl.innerHTML = `
 ${
   message.caption
     ? `
 <div style="padding: 12px 16px; background-color: ${
   isOwn ? "var(--x-accent)" : "var(--x-bg-secondary)"
 }; color: ${
         isOwn ? "#fff" : "var(--x-text-primary)"
       }; border-radius: 12px; margin-bottom: 8px; ">${processContent(
         message.caption || "",
         { isOwn }
       )}</div>
 `
     : ""
 }
 <div id="${profileCardId}" style="border: 1px solid var(--x-border-color); border-radius: 12px; padding: 16px; background-color:var(--x-bg-secondary); cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
 <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
 <img src="${
   message.profile.avatar
 }" style="width: 48px; height: 48px; border-radius: 50%;">
 <div style="flex: 1;">
 <div style="display: flex; align-items: center; gap: 4px;">
 <span style="font-weight: 700; color:var(--x-text-primary);">${
   message.profile.name
 }</span>
 ${
   message.profile.verified
     ? `
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);">
 <g><path d="M22.25 12c0-1.43-.88-2.67-2.19-3.34.46-1.39.2-2.9-.81-3.91s-2.52-1.27-3.91-.81c-.66-1.31-1.91-2.19-3.34-2.19s-2.67.88-3.33 2.19c-1.4-.46-2.91-.2-3.92.81s-1.26 2.52-.8 3.91c-1.31.67-2.2 1.91-2.2 3.34s.89 2.67 2.2 3.34c-.46 1.39-.21 2.9.8 3.91s2.52 1.26 3.91.81c.67 1.31 1.91 2.19 3.34 2.19s2.68-.88 3.34-2.19c1.39.45 2.9.2 3.91-.81s1.27-2.52.81-3.91c1.31-.67 2.19-1.91 2.19-3.34zm-11.71 4.2L6.8 12.46l1.41-1.42 2.26 2.26 4.8-5.23 1.47 1.36-6.2 6.77z"></path></g>
 </svg>
 `
     : ""
 }
 </div>
 <div style="color:var(--x-text-secondary); font-size: 13px;">${
   message.profile.handle
 }</div>
 </div>
 </div>
 ${
   message.profile.bio
     ? `
 <div style="color:var(--x-text-primary); margin-bottom: 8px; font-size: 14px;">
 ${message.profile.bio}
 </div>
 `
     : ""
 }
 <div style="color:var(--x-text-secondary); font-size: 13px;">
 ${message.profile.followers} 位关注者
 </div>
 </div>
 `; // 添加点击事件
      setTimeout(() => {
        const profileCard = document.getElementById(profileCardId);
        if (profileCard) {
          profileCard.onclick = () => {
            openAccountProfileFromQuoteProfile(message.profile);
          };
        }
      }, 0);
    } else if (message.type === "quoteFanGroup") {
      // 转发粉丝群
      bubbleEl.style.cssText =
        baseStyle +
        `
padding: 0; background-color: transparent; color:var(--x-text-primary); width: fit-content; `;
      const fanGroupCardId = `fangroup_card_${Date.now()}_${Math.random()
        .toString(36)
        .substr(2, 9)}`;
      bubbleEl.innerHTML = `
${
  message.caption
    ? `
<div style="padding: 12px 16px; background-color: ${
        isOwn ? "var(--x-accent)" : "var(--x-bg-secondary)"
      }; color: ${
        isOwn ? "#fff" : "var(--x-text-primary)"
      }; border-radius: 12px; margin-bottom: 8px; ">${processContent(
        message.caption || "",
        { isOwn }
      )}</div>
`
    : ""
}
<div id="${fanGroupCardId}" style="border: 1px solid var(--x-border-color); border-radius: 12px; padding: 16px; background-color:var(--x-bg-secondary); cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
<div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
<img src="${
        message.fanGroup.avatar
      }" style="width: 48px; height: 48px; border-radius: 50%; object-fit: cover;">
<div style="flex: 1;">
<div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
<span style="font-weight: 700; color:var(--x-text-primary); font-size: 15px;">${
        message.fanGroup.name
      }</span>
<span style="padding: 2px 8px; background-color:var(--x-bg-primary); color:var(--x-text-secondary); font-size: 11px; border-radius: 4px; font-weight: 600; ">粉丝群</span>
</div>
<div style="color:var(--x-text-secondary); font-size: 13px;">
${message.fanGroup.memberCount} 位成员
</div>
</div>
</div>
${
  message.fanGroup.threshold
    ? `
<div style="padding: 10px; background-color:var(--x-bg-primary); border-radius: 8px; color:var(--x-text-secondary); font-size: 12px; line-height: 1.4; margin-top: 8px; ">
<div style="color:var(--x-text-primary); font-weight: 600; margin-bottom: 4px; font-size: 11px;">入群门槛</div>
${
  message.fanGroup.threshold.length > 100
    ? message.fanGroup.threshold.substring(0, 100) + "..."
    : message.fanGroup.threshold
}
</div>
`
    : ""
}
</div>
`; // 添加点击事件（暂不实现具体功能）
      setTimeout(() => {
        const fanGroupCard = document.getElementById(fanGroupCardId);
        if (fanGroupCard) {
          fanGroupCard.onclick = () => {
            console.log("点击了粉丝群卡片:", message.fanGroup);
            // 可以后续实现打开粉丝群详情等功能
          };
        }
      }, 0);
    } else if (message.type === "groupFile") {
      // 群文件消息 - 紧凑的文件卡片设计
      bubbleEl.style.cssText =
        baseStyle +
        `
padding: 0; background-color: transparent; color:var(--x-text-primary); width: fit-content; max-width: 280px; `;

      const fileCardId = `file_card_${Date.now()}_${Math.random()
        .toString(36)
        .substr(2, 9)}`;
      const fileIconSvg = getFileIcon(message.file.type);

      // 文件类型对应的颜色
      const typeColors = {
        text: "#2b303b",
        image: "#2e3440",
        video: "#262b36",
        link: "#272c36",
        default: "#252933",
      };
      const typeColor = typeColors[message.file.type] || typeColors.default;

      // 格式化上传时间
      const uploadDate = new Date(message.file.uploadedAt);
      const formattedDate = `${
        uploadDate.getMonth() + 1
      }/${uploadDate.getDate()} ${String(uploadDate.getHours()).padStart(
        2,
        "0"
      )}:${String(uploadDate.getMinutes()).padStart(2, "0")}`;

      bubbleEl.innerHTML = `
<div id="${fileCardId}" style="
 border: 1px solid var(--x-border-color);
 border-radius: 12px;
 overflow: hidden;
 background-color:var(--x-bg-secondary);
 cursor: pointer;
 transition: all 0.2s;
" onmouseover="this.style.backgroundColor='var(--x-bg-hover)'; this.style.borderColor='var(--x-accent)'"
 onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'; this.style.borderColor='var(--x-border-color)'">
 <!-- 文件头部 -->
 <div style="
 display: flex;
 align-items: center;
 gap: 12px;
 padding: 12px;
 border-bottom: 1px solid var(--x-border-color);
 ">
 <!-- 文件图标 -->
 <div style="
 width: 38px;
 height: 38px;
 border-radius: 6px;
 background-color: ${typeColor};
 display: flex;
 align-items: center;
 justify-content: center;
 flex-shrink: 0;
 box-shadow: 0 2px 4px rgba(0,0,0,0.1);
 ">
 <div style="width: 18px; height: 18px; color: rgba(255,255,255,0.85);">
 ${fileIconSvg.replace("currentColor", "rgba(255,255,255,0.85)")}
 </div>
 </div>

 <!-- 文件信息 -->
 <div style="flex: 1; min-width: 0;">
 <div style="
 color:var(--x-text-primary);
 font-size: 14px;
 font-weight: 600;
 overflow: hidden;
 text-overflow: ellipsis;
 white-space: nowrap;
 margin-bottom: 2px;
 ">${message.file.name}</div>
 <div style="
 color:var(--x-text-secondary);
 font-size: 11px;
 display: flex;
 align-items: center;
 gap: 6px;
 ">
 <span>${message.file.uploadedBy}</span>
 <span>·</span>
 <span>${formattedDate}</span>
 </div>
 </div>
 </div>

 <!-- 文件内容预览 -->
 <div style="
 padding: 10px 12px;
 color:var(--x-text-secondary);
 font-size: 12px;
 line-height: 1.4;
 max-height: 60px;
 overflow: hidden;
 text-overflow: ellipsis;
 display: -webkit-box;
 -webkit-line-clamp: 3;
 -webkit-box-orient: vertical;
 ">${message.file.content.substring(0, 100)}${
        message.file.content.length > 100 ? "..." : ""
      }</div>
</div>
`;

      // 添加点击事件打开文件详情
      setTimeout(() => {
        const fileCard = document.getElementById(fileCardId);
        if (fileCard) {
          fileCard.onclick = () => {
            openFileDetail(message.file);
          };
        }
      }, 0);
    } else if (message.type === "transfer") {
      // 转账消息 - 小巧立体的票券设计
      bubbleEl.style.cssText =
        baseStyle +
        `
 padding: 0; background-color: transparent; width: fit-content; `; // 获取当前主题
      const xSocialScreen = document.getElementById("x-social-screen");
      const isLightMode =
        xSocialScreen && xSocialScreen.classList.contains("x-theme-light"); // 转账方向：用户发送 vs 用户接收
      const isUserSending = isOwn;
      const amount = parseFloat(message.amount || 0).toFixed(2); // 为转账卡片生成唯一ID
      const transferCardId =
        "transfer-card-" + (message.timestamp || Date.now()); // 检查是否是商业转账
      const isBusiness = message.isBusiness === true;
      bubbleEl.innerHTML = `
 <div id="${transferCardId}" style="position: relative; background-color: ${
        isLightMode ? "#ffffff" : "#1f1f1f"
      }; border-radius: 12px; padding: 12px 16px; max-width: 200px; box-shadow: ${
        isLightMode
          ? "0 2px 8px rgba(0, 0, 0, 0.1), 0 4px 16px rgba(0, 0, 0, 0.06), 0 1px 2px rgba(0, 0, 0, 0.05)"
          : "0 2px 8px rgba(0, 0, 0, 0.3), 0 4px 16px rgba(0, 0, 0, 0.2), 0 1px 2px rgba(255, 255, 255, 0.05)"
      }; border: 1px solid ${
        isBusiness
          ? isLightMode
            ? "rgba(29, 155, 240, 0.3)"
            : "rgba(29, 155, 240, 0.4)"
          : isLightMode
          ? "rgba(0, 0, 0, 0.06)"
          : "rgba(255, 255, 255, 0.08)"
      }; display: flex; align-items: center; gap: 12px; cursor: pointer; transition: all 0.2s; "
 onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='${
   isLightMode
     ? "0 4px 12px rgba(0, 0, 0, 0.15), 0 6px 20px rgba(0, 0, 0, 0.08), 0 2px 4px rgba(0, 0, 0, 0.06)"
     : "0 4px 12px rgba(0, 0, 0, 0.4), 0 6px 20px rgba(0, 0, 0, 0.3), 0 2px 4px rgba(255, 255, 255, 0.08)"
 }'"
 onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='${
   isLightMode
     ? "0 2px 8px rgba(0, 0, 0, 0.1), 0 4px 16px rgba(0, 0, 0, 0.06), 0 1px 2px rgba(0, 0, 0, 0.05)"
     : "0 2px 8px rgba(0, 0, 0, 0.3), 0 4px 16px rgba(0, 0, 0, 0.2), 0 1px 2px rgba(255, 255, 255, 0.05)"
 }'"
 ">
 ${
   isBusiness
     ? `

 <div style="position: absolute; top: -4px; right: -4px; width: 18px; height: 18px; background-color: var(--x-accent); border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 1px 3px rgba(0,0,0,0.3); ">
 <svg viewBox="0 0 24 24" style="width: 10px; height: 10px; fill: #ffffff;">
 <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path><path d="M12 10L14.5 14L17 10L14.5 12L12 10ZM10 10L7.5 12L10 14L7.5 14L10 10Z"></path></g>
 </svg>
 </div>
 `
     : ""
 }

 <div style="width: 36px; height: 36px; border-radius: 50%; background-color: ${
   isLightMode ? "#f5f5f5" : "#2d2d2d"
 }; display: flex; align-items: center; justify-content: center; flex-shrink: 0; ">
${getTransferStatusIcon(message.status, isLightMode)}
 </div>

 <div style="display: flex; flex-direction: column; gap: 2px; flex: 1; min-width: 0; ">
 <div style="font-size: 11px; font-weight: 500; color: ${
   isLightMode ? "#888888" : "#aaaaaa"
 }; text-transform: uppercase; letter-spacing: 0.3px; ">${
        isBusiness ? "💼 " : ""
      }${getTransferStatusText(message.status, isUserSending)}</div>
 <div style="font-size: 16px; font-weight: 600; color: ${
   isLightMode ? "#1a1a1a" : "#e5e5e5"
 }; line-height: 1; ">
 ${getTransferAmountText(message.status, isUserSending, amount)}
 </div>
 ${
   message.note
     ? `
 <div style="font-size: 11px; color: ${
   isLightMode ? "#666666" : "#999999"
 }; line-height: 1.2; margin-top: 1px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">${
         message.note
       }</div>
 `
     : ""
 }
 </div>

 <div style="width: 6px; height: 6px; border-radius: 50%; background-color: ${
   isBusiness ? "var(--x-accent)" : isLightMode ? "#666666" : "#999999"
 }; flex-shrink: 0; "></div>
 </div>
 `; // 添加点击事件监听器
      setTimeout(() => {
        const transferCard = document.getElementById(transferCardId);
        if (transferCard) {
          transferCard.onclick = () => {
            openTransferDetails(message, isOwn);
          };
        }
      }, 0);
    } else if (message.type === "system") {
      // 系统通知 - 居中显示，不同于消息气泡
      messageEl.style.alignItems = "center";
      bubbleEl.style.cssText = `
 padding: 8px 16px; background-color:var(--x-bg-secondary); border-radius: 16px; font-size: 13px; color:var(--x-text-secondary); text-align: center; max-width: 80%; `;
      bubbleEl.textContent = message.content;
    } else if (message.type === "forward") {
      // 转发的推文/评论
      bubbleEl.style.cssText =
        baseStyle +
        `
 padding: 0; background-color: transparent; color:var(--x-text-primary); width: fit-content; `;
      const forwardTypeText = message.forwardType === "tweet" ? "推文" : "评论";
      bubbleEl.innerHTML = `
 <div style="border: 1px solid var(--x-border-color); border-radius: 12px; overflow: hidden; background-color:var(--x-bg-secondary); ">

 <div style="padding: 8px 12px; background-color: var(--x-bg-hover); border-bottom: 1px solid var(--x-border-color); display: flex; align-items: center; gap: 6px; ">
 <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: var(--x-text-secondary);">
 <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g>
 </svg>
 <span style="font-size: 12px; color:var(--x-text-secondary);">转发${forwardTypeText}</span>
 </div>

 <div style="padding: 12px;">
 <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
 <img src="${
   message.forwardContent.user.avatar
 }" style="width: 24px; height: 24px; border-radius: 50%;">
 <div style="display: flex; align-items: center; gap: 4px; flex: 1; min-width: 0;">
 <span style="font-weight: 600; color:var(--x-text-primary); font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
 ${message.forwardContent.user.name}
 </span>
 <span style="color:var(--x-text-secondary); font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
 ${message.forwardContent.user.handle}
 </span>
 </div>
 </div>
 <div style="color:var(--x-text-primary); font-size: 14px; line-height: 1.4; word-wrap: break-word;">
 ${processContent(message.forwardContent.content || "无内容", { isOwn: false })}
 </div>
 ${
   message.forwardContent.image
     ? message.forwardContent.image.type === "description"
       ? `
 <div style="margin-top: 8px; background-color:var(--x-bg-primary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 8px;">
 <div style="color:var(--x-text-secondary); font-size: 13px;">${message.forwardContent.image.content}</div>
 </div>
 `
       : `
 <div style="margin-top: 8px; border-radius: 8px; overflow: hidden;">
 <img src="${message.forwardContent.image.content}" style="max-width: 100%; max-height: 200px; border-radius: 8px;" alt="图片">
 </div>
 `
     : ""
 }
 ${
   message.forwardContent.time
     ? `
 <div style="color:var(--x-text-secondary); font-size: 12px; margin-top: 8px;">
 ${message.forwardContent.time}
 </div>
 `
     : ""
 }
 </div>
 </div>
 `;
    }
    // 🎯 粉丝群消息：气泡添加到contentWrapper；普通消息：气泡添加到messageEl
    if (isFanGroupMessage) {
      // 找到contentWrapper并添加气泡
      const senderInfoEl = messageEl.querySelector("div");
      const contentWrapper = senderInfoEl?.querySelector("div:nth-child(2)");
      if (contentWrapper) {
        contentWrapper.appendChild(bubbleEl);
      } else {
        messageEl.appendChild(bubbleEl);
      }
    } else {
      messageEl.appendChild(bubbleEl);
    }
    // 时间戳（只在showTime为true且isLastInGroup为true时显示）
    if (showTime && isLastInGroup) {
      const timestampEl = document.createElement("div");
      timestampEl.style.cssText = `
 font-size: 12px; color:var(--x-text-secondary); margin-top: 4px; padding: 0 4px;
`; // 如果有timestamp，动态计算显示时间；否则使用静态time字段
      if (message.timestamp) {
        timestampEl.textContent = formatMessageTime(message.timestamp);
      } else {
        timestampEl.textContent = message.time || "刚刚";
      }
      // 🎯 粉丝群消息：时间戳添加到contentWrapper；普通消息：时间戳添加到messageEl
      if (isFanGroupMessage) {
        const senderInfoEl = messageEl.querySelector("div");
        const contentWrapper = senderInfoEl?.querySelector("div:nth-child(2)");
        if (contentWrapper) {
          contentWrapper.appendChild(timestampEl);
        } else {
          messageEl.appendChild(timestampEl);
        }
      } else {
        messageEl.appendChild(timestampEl);
      }
    }
    return messageEl;
  }
  // 语音转文字切换
  window.toggleVoiceText = function (voiceId, voiceText) {
    const voiceEl = document.getElementById(voiceId);
    if (!voiceEl) return;
    const isShowingText = voiceEl.getAttribute("data-showing-text") === "true";
    if (isShowingText) {
      // 切回语音图标
      voiceEl.innerHTML = voiceEl.getAttribute("data-original-html");
      voiceEl.setAttribute("data-showing-text", "false");
    } else {
      // 保存原始HTML
      voiceEl.setAttribute("data-original-html", voiceEl.innerHTML); // 显示文字
      voiceEl.innerHTML = `<div style="padding: 4px;">${voiceText}</div>`;
      voiceEl.setAttribute("data-showing-text", "true");
    }
  }; // 创建"正在输入中"气泡
  function createTypingIndicator() {
    const typingEl = document.createElement("div");
    typingEl.id = "typing-indicator";
    typingEl.className = "message-item";
    typingEl.style.cssText = `
 display: flex !important; flex-direction: column; align-items: flex-start; margin-bottom: 16px; opacity: 0; transform: translateY(10px); transition: all 0.3s ease; position: relative; z-index: 1;
`;
    const bubbleEl = document.createElement("div");
    bubbleEl.style.cssText = `
 padding: 12px 16px; border-radius: 18px; border-bottom-left-radius: 4px; background-color:var(--x-bg-secondary); display: flex; align-items: center; gap: 5px;
`; // 三个跳动的点
    for (let i = 0; i < 3; i++) {
      const dot = document.createElement("div");
      dot.style.cssText = `
 width: 8px; height: 8px; border-radius: 50%; background-color:var(--x-text-secondary); animation: typingBounce 1.4s infinite ease-in-out; animation-delay: ${
   i * 0.2
 }s; flex-shrink: 0; `;
      bubbleEl.appendChild(dot);
    }
    typingEl.appendChild(bubbleEl); // 添加动画样式（如果还没有）
    if (!document.getElementById("typing-animation-style")) {
      const style = document.createElement("style");
      style.id = "typing-animation-style";
      style.textContent = `
 @keyframes typingBounce {
 0%, 60%, 100% {
 transform: translateY(0); opacity: 0.7; }
 30% {
 transform: translateY(-10px); opacity: 1; }
 }
 `;
      document.head.appendChild(style);
    }
    return typingEl;
  }
  // 显示"正在输入中"气泡
  function showTypingIndicator() {
    console.log("🔵 [正在输入] 开始显示气泡");
    const contentContainer = document.getElementById("message-detail-content");
    if (!contentContainer) {
      console.warn("⚠️ [正在输入] 找不到消息容器");
      return;
    }
    // 先移除可能存在的旧气泡
    let oldTypingIndicator = document.getElementById("typing-indicator");
    if (oldTypingIndicator) {
      console.log("⚠️ [正在输入] 检测到旧气泡，先移除");
      oldTypingIndicator.remove();
    }
    // 创建并添加新气泡
    console.log("✅ [正在输入] 创建气泡元素");
    const typingIndicator = createTypingIndicator();
    contentContainer.appendChild(typingIndicator);
    console.log("✅ [正在输入] 气泡已添加到DOM", typingIndicator); // 触发动画（使用 requestAnimationFrame 确保DOM更新后再触发）
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        if (typingIndicator && typingIndicator.parentNode) {
          typingIndicator.style.opacity = "1";
          typingIndicator.style.transform = "translateY(0)";
          console.log("✅ [正在输入] 气泡动画已触发");
        }
      });
    }); // 滚动到底部
    setTimeout(() => {
      const scrollable = document.getElementById("message-detail-scrollable");
      if (scrollable) {
        scrollable.scrollTo({
          top: scrollable.scrollHeight,
          behavior: "smooth",
        });
        console.log("✅ [正在输入] 已滚动到底部");
      }
    }, 100);
  }
  // 隐藏"正在输入中"气泡
  function hideTypingIndicator() {
    console.log("🔴 [正在输入] 开始隐藏气泡");
    const typingIndicator = document.getElementById("typing-indicator");
    if (!typingIndicator) {
      console.log("⚠️ [正在输入] 气泡不存在，无需隐藏");
      return;
    }
    typingIndicator.style.opacity = "0";
    typingIndicator.style.transform = "translateY(10px)";
    console.log("✅ [正在输入] 气泡开始淡出");
    setTimeout(() => {
      if (typingIndicator && typingIndicator.parentNode) {
        typingIndicator.remove();
        console.log("✅ [正在输入] 气泡已从DOM移除");
      }
    }, 300);
  }
  // 消息逐条弹出动画
  async function animateMessagesOneByOne(messageElements, delayBetween = 300) {
    for (let i = 0; i < messageElements.length; i++) {
      const messageEl = messageElements[i]; // 等待延迟
      await new Promise((resolve) => setTimeout(resolve, delayBetween)); // 触发动画
      messageEl.style.transition = "all 0.3s ease";
      messageEl.style.opacity = "1";
      messageEl.style.transform = "translateY(0)"; // 滚动到底部
      const scrollable = document.getElementById("message-detail-scrollable");
      if (scrollable) {
        scrollable.scrollTo({
          top: scrollable.scrollHeight,
          behavior: "smooth",
        });
      }
    }
  }
  // 分组连续的同方向消息
  function groupMessagesBySender(messages) {
    const groups = [];
    let currentGroup = [];
    let currentSenderId = null;
    messages.forEach((msg, index) => {
      // 🎯 粉丝群消息：按 senderId 分组
      // 普通私信：按 isOwn 分组
      const senderId = msg.senderId || (msg.isOwn ? "user" : "other");
      if (currentSenderId === null || currentSenderId === senderId) {
        // 同一发送者，加入当前组
        currentGroup.push({ message: msg, index });
        currentSenderId = senderId;
      } else {
        // 不同发送者，开始新组
        groups.push(currentGroup);
        currentGroup = [{ message: msg, index }];
        currentSenderId = senderId;
      }
    }); // 添加最后一组
    if (currentGroup.length > 0) {
      groups.push(currentGroup);
    }
    return groups;
  }
  // 通用的手机样式通知弹窗
  function showPhoneNotification(options) {
    const {
      title = "", // 标题
      message = "", // 消息内容
      avatar = null, // 右侧头像URL（可选）
      leftIcon = "x", // 左侧图标类型: 'x' | 'custom' | null
      leftIconHtml = null, // 自定义左侧图标HTML
      duration = 3000, // 显示时长（毫秒）
      showTime = true, // 是否显示时间
    } = options; // 移除可能存在的旧通知
    const oldNotification = document.getElementById("phone-notification-popup");
    if (oldNotification) {
      oldNotification.remove();
    }
    // 创建通知容器
    const notification = document.createElement("div");
    notification.id = "phone-notification-popup";
    notification.style.cssText = `
 position: fixed; top: -100px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 400px; background: var(--x-bg-primary); border-radius: 16px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3); padding: 12px 16px; display: flex; align-items: center; gap: 12px; z-index: 10000; transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); border: 1px solid var(--x-border-color); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
`; // 左侧图标
    if (leftIcon === "x" || leftIconHtml) {
      const iconContainer = document.createElement("div");
      iconContainer.style.cssText = `
 width: 32px; height: 32px; background-color:#000; border-radius: 8px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; `;
      if (leftIconHtml) {
        iconContainer.innerHTML = leftIconHtml;
      } else {
        // 默认X Logo
        iconContainer.innerHTML = `
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #fff;">
 <g><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path></g>
 </svg>
 `;
      }
      notification.appendChild(iconContainer);
    }
    // 内容区域
    const content = document.createElement("div");
    content.style.cssText = `
 flex: 1; min-width: 0;
`;
    let contentHtml = "";
    if (title) {
      contentHtml += `
 <div style="font-size: 13px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 2px; ">${title}</div>
 `;
    }
    if (message) {
      contentHtml += `
 <div style="font-size: 14px; color:var(--x-text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; ">${message}</div>
 `;
    }
    content.innerHTML = contentHtml;
    notification.appendChild(content); // 时间标签
    if (showTime) {
      const timeLabel = document.createElement("div");
      timeLabel.style.cssText = `
 font-size: 11px; color:var(--x-text-secondary); position: absolute; top: 12px; right: ${
   avatar ? "64px" : "16px"
 }; `;
      const now = new Date();
      const hours = now.getHours();
      const minutes = String(now.getMinutes()).padStart(2, "0");
      timeLabel.textContent = `${hours}:${minutes}`;
      notification.appendChild(timeLabel);
    }
    // 右侧头像（可选）
    if (avatar) {
      const avatarEl = document.createElement("img");
      avatarEl.src = avatar;
      avatarEl.style.cssText = `
 width: 40px; height: 40px; border-radius: 50%; object-fit: cover; flex-shrink: 0; `;
      notification.appendChild(avatarEl);
    }
    // 🔧 直接添加到 body，避免被 x-social-screen 的 overflow:hidden 裁剪
    // position:fixed 的元素在有 overflow:hidden 的父元素中会被裁剪！
    document.body.appendChild(notification); // 滑入动画
    requestAnimationFrame(() => {
      notification.style.top = "16px";
    }); // 自动滑出并移除
    setTimeout(() => {
      notification.style.top = "-100px";
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 400);
    }, duration); // 点击通知关闭
    notification.onclick = () => {
      notification.style.top = "-100px";
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 400);
    };
  }
  window.showPhoneNotification = showPhoneNotification;
  // 显示消息回复通知（便捷函数）
  function showMessageNotification(senderName, senderAvatar, messageCount) {
    const isEnglish = currentLanguage === "en";
    const messageSuffix = isEnglish
      ? messageCount > 1
        ? " messages"
        : " message"
      : "条私信";
    showPhoneNotification({
      title: senderName,
      message: isEnglish
        ? `sent you ${messageCount}${messageSuffix}`
        : `回复了你 ${messageCount}${messageSuffix}`,
      avatar: senderAvatar,
      leftIcon: "x",
    });
  }
  // 渲染日期分隔符
  function renderDateSeparator(date) {
    const separatorEl = document.createElement("div");
    separatorEl.style.cssText = `
 text-align: center; margin: 24px 0 16px;
`;
    separatorEl.innerHTML = `
 <span style="font-size: 13px; font-weight: 600; color:var(--x-text-primary); padding: 6px 12px; background-color:var(--x-bg-secondary); border-radius: 12px; ">${date}</span>
`;
    return separatorEl;
  }
  // ============================================
  // 转账功能
  // ============================================
  // 获取转账状态文字
  function getTransferStatusText(status, isUserSending) {
    if (!status || status === "pending") {
      return "PENDING";
    } else if (status === "accepted") {
      return isUserSending ? "SENT" : "RECEIVED";
    } else if (status === "rejected") {
      return "REJECTED";
    }
    return "PENDING";
  }
  // 获取转账金额文字
  function getTransferAmountText(status, isUserSending, amount) {
    if (!status || status === "pending") {
      return `$${amount}`;
    } else if (status === "accepted") {
      return `${isUserSending ? "-" : "+"}$${amount}`;
    } else if (status === "rejected") {
      return `$${amount}`;
    }
    return `$${amount}`;
  }
  // 获取转账状态图标
  function getTransferStatusIcon(status, isLightMode) {
    const iconColor = isLightMode ? "#666666" : "#cccccc";
    if (!status || status === "pending") {
      // 待处理 - 时钟图标
      return `
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: ${iconColor};">
 <g><path d="M12,2C6.486,2,2,6.486,2,12s4.486,10,10,10s10-4.486,10-10S17.514,2,12,2z M12,20c-4.411,0-8-3.589-8-8 s3.589-8,8-8s8,3.589,8,8S16.411,20,12,20z"></path><path d="M13,7h-2v5.414l3.293,3.293l1.414-1.414L13,11.586V7z"></path></g>
 </svg>
 `;
    } else if (status === "accepted") {
      // 已接收 - 对勾图标
      return `
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: ${iconColor};">
 <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path></g>
 </svg>
 `;
    } else if (status === "rejected") {
      // 已拒绝 - X图标
      return `
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: ${iconColor};">
 <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11H7v-2h10v2z"></path></g>
 </svg>
 `;
    }
    // 默认返回时钟图标
    return `
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: ${iconColor};">
 <g><path d="M12,2C6.486,2,2,6.486,2,12s4.486,10,10,10s10-4.486,10-10S17.514,2,12,2z M12,20c-4.411,0-8-3.589-8-8 s3.589-8,8-8s8,3.589,8,8S16.411,20,12,20z"></path><path d="M13,7h-2v5.414l3.293,3.293l1.414-1.414L13,11.586V7z"></path></g>
 </svg>
`;
  }
  // ============================================
  // 商业转账辅助函数
  // ============================================
  // 保存商业转账记录到数据库
  async function saveBusinessTransfer(businessTransferData) {
    try {
      const xDb = getXDB();
      const businessTransfersId = `businessTransfers_${
        currentAccountId || "main"
      }`; // 获取现有的商业转账列表
      let savedData = await xDb.xAccountProfiles.get(businessTransfersId);
      if (!savedData) {
        savedData = {
          handle: businessTransfersId,
          name: "businessTransfers",
          accountId: currentAccountId || "main",
          data: [],
          updatedAt: new Date().toISOString(),
        };
      }
      // 添加新的商业转账记录
      savedData.data.push({
        ...businessTransferData,
        savedAt: new Date().toISOString(),
      }); // 保存到数据库
      await xDb.xAccountProfiles.put(savedData);
      console.log("✅ 商业转账已保存:", businessTransferData.transferId);
    } catch (error) {
      console.error("❌ 保存商业转账失败:", error);
    }
  }
  // 处理商业转账任务
  async function handleBusinessTransferTask(transferMessage, conversationData) {
    try {
      console.log(
        "💼 [商业转账] 开始处理任务:",
        transferMessage.taskDescription
      ); // 检测任务关键词
      const postKeywords = [
        "发帖",
        "发推",
        "发推特",
        "发推文",
        "发tweet",
        "发条推",
        "发个帖",
        "发条帖",
        "发个推",
        "发一条",
        "发布推文",
        "发布帖子",
        "post",
        "tweet",
        "tweeted",
        "posting",
        "gonna post",
        "will post",
        "going to post",
        "publish",
        "share on x",
        "share on twitter",
        "发到X上",
        "发到推特",
        "发到平台",
        "分享到X",
        "晒到X",
        "宣传",
        "推广",
        "广告",
      ];
      const taskDesc = transferMessage.taskDescription.toLowerCase();
      const hasPostTask = postKeywords.some((keyword) =>
        taskDesc.includes(keyword.toLowerCase())
      );
      if (!hasPostTask) {
        console.log("⏭️ [商业转账] 任务不包含发推关键词，跳过");
        return;
      }
      console.log("✅ [商业转账] 检测到发推任务"); // 80%概率完成任务
      const willComplete = Math.random() < 0.8;
      if (!willComplete) {
        console.log("❌ [商业转账] AI决定不完成任务（20%概率）");
        return;
      }
      console.log("✅ [商业转账] AI决定完成任务，正在生成推文..."); // 🎭 检测是否"反水"（基于角色/账户特质）
      const xDb = getXDB();
      let willBetray = false;
      let betrayalReason = "";
      try {
        // 获取角色/账户的详细资料
        const senderProfile = await StringBuilders.getUnifiedProfile(
          conversationData.user.handle,
          {
            userProfileInfo: StringBuilders.buildUserXProfileInfo(
              window.userProfileData
            ),
          }
        );
        if (senderProfile) {
          // 计算反水概率
          let betrayalChance = 0.1; // 基础10%
          // 1. 角色类型因素
          if (senderProfile.type === "character") {
            const cd = senderProfile.characterData; // 检查性格关键词
            const aiPersona = (cd.aiPersona || "").toLowerCase();
            const rebelliousKeywords = [
              "叛逆",
              "狡猾",
              "冷漠",
              "自私",
              "腹黑",
              "毒舌",
              "刻薄",
              "傲慢",
              "高傲",
              "不羁",
              "反叛",
              "rebellious",
              "cunning",
              "selfish",
              "cold",
              "arrogant",
              "sarcastic",
            ];
            const hasRebelliousTraits = rebelliousKeywords.some((keyword) =>
              aiPersona.includes(keyword)
            );
            if (hasRebelliousTraits) {
              betrayalChance += 0.15;
              betrayalReason = "角色性格叛逆/不友好";
              console.log("🎭 [反水检测] 角色性格因素 +15%");
            }
            // 检查与用户的关系
            if (!senderProfile.knowsUserIdentity) {
              betrayalChance += 0.1;
              betrayalReason += (betrayalReason ? "，" : "") + "不认识用户";
              console.log("🎭 [反水检测] 陌生关系 +10%");
            } else if (cd.userPersona) {
              // 检查用户人设中的关系描述
              const userPersonaLower = cd.userPersona.toLowerCase();
              const negativeRelationships = [
                "敌人",
                "对手",
                "仇人",
                "讨厌",
                "不喜欢",
                "矛盾",
                "竞争",
                "enemy",
                "rival",
                "dislike",
                "hate",
              ];
              const hasBadRelationship = negativeRelationships.some((keyword) =>
                userPersonaLower.includes(keyword)
              );
              if (hasBadRelationship) {
                betrayalChance += 0.2;
                betrayalReason +=
                  (betrayalReason ? "，" : "") + "与用户关系不好";
                console.log("🎭 [反水检测] 负面关系 +20%");
              }
            }
          } else if (
            senderProfile.type === "stranger" ||
            senderProfile.type === "account"
          ) {
            // 路人/营销号更可能反水
            betrayalChance += 0.05;
            betrayalReason = "非绑定角色类型";
            console.log("🎭 [反水检测] 路人/账号类型 +5%");
          }
          console.log(
            `🎭 [反水检测] 最终反水概率: ${(betrayalChance * 100).toFixed(0)}%`
          ); // 判断是否反水
          willBetray = Math.random() < betrayalChance;
          if (willBetray) {
            console.log(`🔥 [商业转账] AI决定反水！原因: ${betrayalReason}`);
          }
        }
      } catch (error) {
        console.error("🎭 [反水检测] 获取资料失败，使用默认概率:", error);
        willBetray = Math.random() < 0.1; // 默认10%
      }
      // 使用现有的推文生成器，传入任务描述作为上下文
      const contextMessages = [
        {
          type: "text",
          content: willBetray
            ? `用户花钱让我发推广，但我准备反水揭露这件事或者发负面内容。任务要求：${transferMessage.taskDescription}`
            : `我需要完成一个商业任务：${transferMessage.taskDescription}`,
          isOwn: false,
          time: "最近",
          _isBetrayal: willBetray, // 内部标记
          _betrayalReason: betrayalReason,
        },
      ];
      const messageData = {
        id: conversationData.id,
        user: conversationData.user,
        _isBusinessBetrayal: willBetray, // 传递给生成器
      }; // 调用推文生成器
      const tweetData = await generateTweetFromConversation(
        messageData,
        contextMessages
      );
      if (!tweetData) {
        console.log("⚠️ [商业转账] 推文生成失败");
        return;
      }
      // 创建 New Tweet 通知
      const timestamp = Date.now();
      const newTweetNotification = {
        id: `mention_business_${timestamp}`,
        type: "newTweet",
        user: conversationData.user,
        content: willBetray
          ? `⚠️ ${conversationData.user.name} 反水了！`
          : `New Tweet from ${conversationData.user.name}`,
        time: "刚刚",
        timestamp: timestamp,
        tweet: tweetData,
        fromBusinessTransfer: true, // 标记来自商业转账
        businessTransferId: transferMessage.timestamp,
        isBetrayal: willBetray, // 标记是否反水
        betrayalReason: betrayalReason,
      }; // 保存到 Mentions 数据库
      // const xDb = getXDB(); // 已在上面声明
      const mentionsDataId = `mentions_${currentAccountId || "main"}`;
      let savedMentions = await xDb.xAccountProfiles.get(mentionsDataId);
      if (!savedMentions) {
        savedMentions = {
          handle: mentionsDataId,
          id: mentionsDataId,
          data: [],
        };
      }
      savedMentions.data.unshift(newTweetNotification);
      await xDb.xAccountProfiles.put(savedMentions); // 将推文添加到发推者的账户主页
      await addTweetToAccountProfile(conversationData.user.handle, tweetData);
      console.log(
        `✅ [商业转账] 推文已生成并发布${willBetray ? "（反水）" : ""}`
      ); // 显示手机样式通知
      const isEnglish = currentLanguage === "en";
      showPhoneNotification({
        title: willBetray ? "⚠️ 商业推广反水" : "X",
        message: willBetray
          ? isEnglish
            ? `${conversationData.user.name} betrayed and posted a negative tweet!`
            : `${conversationData.user.name} 反水了！发布了负面/揭露内容`
          : isEnglish
          ? `${conversationData.user.name} completed the business task and posted a tweet!`
          : `${conversationData.user.name} 完成了商业任务并发布了推文！`,
        avatar: conversationData.user.avatar,
        leftIcon: willBetray ? "custom" : "x",
        leftIconHtml: willBetray
          ? `
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #ef4444;">
 <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path></g>
 </svg>
 `
          : undefined,
      }); // 如果当前在 Mentions 页面，刷新显示
      const mentionsPage = document.getElementById("x-notifications-page");
      if (mentionsPage && mentionsPage.style.display === "flex") {
        await loadNotifications();
      } else {
        // 显示提醒点
        showNavNotificationDot("notifications");
      }
    } catch (error) {
      console.error("❌ [商业转账] 任务处理失败:", error);
    }
  }
  // 打开转账弹窗
  window.openTransferDialog = function () {
    const dialog = document.getElementById("transfer-dialog");
    if (dialog) {
      dialog.style.display = "flex"; // 清空输入
      const amountInput = document.getElementById("transfer-amount-input");
      const noteInput = document.getElementById("transfer-note-input");
      const counter = document.getElementById("transfer-note-counter");
      if (amountInput) amountInput.value = "";
      if (noteInput) noteInput.value = "";
      if (counter) counter.textContent = "0 / 100"; // 聚焦到金额输入框
      setTimeout(() => {
        if (amountInput) amountInput.focus();
      }, 100);
    }
  }; // 关闭转账弹窗
  window.closeTransferDialog = function () {
    const dialog = document.getElementById("transfer-dialog");
    if (dialog) {
      dialog.style.display = "none"; // 重置表单到普通转账
      setTimeout(() => {
        switchTransferType("normal"); // 清空所有输入
        const amountInput = document.getElementById("transfer-amount-input");
        const noteInput = document.getElementById("transfer-note-input");
        const taskDescInput = document.getElementById(
          "transfer-task-description"
        );
        const taskDeadlineInput = document.getElementById(
          "transfer-task-deadline"
        );
        const depositRatioInput = document.getElementById(
          "transfer-deposit-ratio"
        );
        if (amountInput) amountInput.value = "";
        if (noteInput) noteInput.value = "";
        if (taskDescInput) taskDescInput.value = "";
        if (taskDeadlineInput) taskDeadlineInput.value = "24";
        if (depositRatioInput) depositRatioInput.value = "20"; // 重置计数器
        const noteCounter = document.getElementById("transfer-note-counter");
        const taskCounter = document.getElementById("transfer-task-counter");
        if (noteCounter) noteCounter.textContent = "0 / 100";
        if (taskCounter) taskCounter.textContent = "0 / 500";
      }, 200);
    }
  }; // 更新转账备注字符计数
  window.updateTransferNoteCounter = function () {
    const noteInput = document.getElementById("transfer-note-input");
    const noteCounter = document.getElementById("transfer-note-counter");
    if (noteInput && noteCounter) {
      noteCounter.textContent = `${noteInput.value.length} / 100`;
    }
  }; // 更新任务描述字符计数
  window.updateTaskDescriptionCounter = function () {
    const taskInput = document.getElementById("transfer-task-description");
    const taskCounter = document.getElementById("transfer-task-counter");
    if (taskInput && taskCounter) {
      taskCounter.textContent = `${taskInput.value.length} / 500`;
    }
  }; // 切换转账类型
  window.switchTransferType = function (type) {
    const normalBtn = document.getElementById("transfer-type-normal-btn");
    const businessBtn = document.getElementById("transfer-type-business-btn");
    const businessSection = document.getElementById(
      "business-transfer-section"
    );
    if (!normalBtn || !businessBtn || !businessSection) return;
    if (type === "business") {
      // 切换到商业转账
      normalBtn.style.backgroundColor = "transparent";
      normalBtn.style.color = "var(--x-text-primary)";
      businessBtn.style.backgroundColor = "var(--x-accent)";
      businessBtn.style.color = "#fff";
      businessSection.style.display = "block";
    } else {
      // 切换到普通转账
      normalBtn.style.backgroundColor = "var(--x-accent)";
      normalBtn.style.color = "#fff";
      businessBtn.style.backgroundColor = "transparent";
      businessBtn.style.color = "var(--x-text-primary)";
      businessSection.style.display = "none";
    }
  }; // 发送转账
  window.sendTransfer = async function () {
    const amountInput = document.getElementById("transfer-amount-input");
    const noteInput = document.getElementById("transfer-note-input");
    if (!amountInput || !noteInput) return;
    const amount = parseFloat(amountInput.value);
    const note = noteInput.value.trim();
    if (amount <= 0 || amount > 9999999) {
      showXToast("请输入有效金额（0.01 - 9,999,999）", "error");
      return;
    }
    // 检查是否是商业转账
    const businessSection = document.getElementById(
      "business-transfer-section"
    );
    const isBusiness =
      businessSection && businessSection.style.display !== "none";
    let businessData = null;
    if (isBusiness) {
      // 验证商业转账必填字段
      const taskDescription = document
        .getElementById("transfer-task-description")
        ?.value.trim();
      const taskDeadline = document.getElementById(
        "transfer-task-deadline"
      )?.value;
      const depositRatio = parseFloat(
        document.getElementById("transfer-deposit-ratio")?.value || 20
      );
      if (!taskDescription) {
        showXToast("请填写任务描述", "error");
        return;
      }
      if (!taskDeadline || taskDeadline < 1) {
        showXToast("请设置有效的任务期限", "error");
        return;
      }
      // 计算定金和尾款
      const depositAmount = (amount * depositRatio) / 100;
      const remainingAmount = amount - depositAmount;
      const deadlineDate = new Date(Date.now() + taskDeadline * 60 * 60 * 1000); // 转换为毫秒
      businessData = {
        isBusiness: true,
        taskDescription: taskDescription,
        taskDeadline: deadlineDate.toISOString(),
        taskDeadlineHours: parseInt(taskDeadline),
        depositRatio: depositRatio,
        depositAmount: depositAmount.toFixed(2),
        remainingAmount: remainingAmount.toFixed(2),
        taskStatus: "pending", // pending, in_progress, completed, failed
        taskProgress: 0, // 0-100
      };
    }
    // 检查钱包余额
    await loadWalletData();
    if (!walletData.isActivated) {
      showXToast("请先激活钱包", "error");
      return;
    }
    const actualDeduction = isBusiness
      ? parseFloat(businessData.depositAmount)
      : amount;
    if (walletData.balance < actualDeduction) {
      showXToast("钱包余额不足", "error");
      return;
    }
    try {
      // 扣除余额（商业转账只扣定金）
      walletData.balance -= actualDeduction; // 添加交易记录
      const recipientName = currentMessageConversation?.user?.name || "对方";
      const transactionDesc = isBusiness
        ? `商业转账给 ${recipientName}（定金 ${businessData.depositRatio}%）${
            note ? ` - ${note}` : ""
          }`
        : `转账给 ${recipientName}${note ? ` - ${note}` : ""}`;
      const transaction = {
        id: "transfer_out_" + Date.now(),
        description: transactionDesc,
        amount: -actualDeduction,
        timestamp: new Date().toISOString(),
        type: isBusiness ? "business_transfer_deposit" : "transfer_out",
      };
      walletData.transactions.unshift(transaction); // 保存钱包数据
      await saveWalletData();
      console.log(
        "💰 钱包余额已扣除:",
        actualDeduction,
        "剩余余额:",
        walletData.balance
      ); // 创建转账消息对象
      const transferMessage = {
        type: "transfer",
        amount: amount.toFixed(2),
        note: note || null,
        status: "pending", // 默认状态为待接收
        timestamp: new Date().toISOString(),
        isOwn: true,
        ...businessData, // 如果是商业转账，添加商业数据
      }; // 添加到消息队列
      userMessageQueue.push(transferMessage); // 渲染到界面
      const contentContainer = document.getElementById(
        "message-detail-content"
      );
      if (contentContainer) {
        const messageEl = renderMessageItem(
          transferMessage,
          true,
          undefined,
          true,
          true
        );
        contentContainer.appendChild(messageEl); // 动画显示
        requestAnimationFrame(() => {
          messageEl.style.opacity = "1";
          messageEl.style.transform = "translateY(0)";
        }); // 滚动到底部
        setTimeout(() => {
          const scrollable = document.getElementById(
            "message-detail-scrollable"
          );
          if (scrollable) {
            scrollable.scrollTop = scrollable.scrollHeight;
          }
        }, 100);
      }
      // 保存到数据库
      saveUserMessageToDB(transferMessage); // 如果是商业转账，保存到商业转账数据库
      if (isBusiness && currentMessageConversation) {
        // 确保获取到正确的接收者信息
        const receiverName =
          currentMessageConversation.user?.name ||
          currentMessageConversation.userName ||
          recipientName;
        const receiverHandle =
          currentMessageConversation.user?.handle ||
          currentMessageConversation.userHandle ||
          "unknown";
        const receiverAvatar =
          currentMessageConversation.user?.avatar ||
          currentMessageConversation.userAvatar ||
          "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg";
        await saveBusinessTransfer({
          ...transferMessage,
          transferId: transferMessage.timestamp,
          conversationId: currentMessageConversation.id,
          // 🔧 修复：发送方应该保存接收者信息
          receiverName: receiverName,
          receiverHandle: receiverHandle,
          receiverAvatar: receiverAvatar,
          direction: "sent", // 发出的商业转账
          createdAt: transferMessage.timestamp,
        });
        console.log(
          "💼 商业转账已记录到数据库（发出方）- 接收者:",
          receiverName
        );
      }
      // 关闭弹窗
      closeTransferDialog();
      console.log("✅ 转账消息已发送:", transferMessage);
      const toastMsg = isBusiness
        ? `商业转账已发送 (-$${actualDeduction.toFixed(2)} 定金)`
        : `转账已发送 (-$${amount.toFixed(2)})`;
      showXToast(toastMsg, "success");
    } catch (error) {
      console.error("转账处理失败:", error);
      showXToast("转账失败: " + error.message, "error");
    }
  }; // 打开转账详情弹窗
  window.openTransferDetails = function (transferData, isOwn) {
    const modal = document.getElementById("transfer-details-modal");
    const content = document.getElementById("transfer-details-content");
    if (!modal || !content) return; // 获取当前主题
    const xSocialScreen = document.getElementById("x-social-screen");
    const isLightMode =
      xSocialScreen && xSocialScreen.classList.contains("x-theme-light"); // 确保商业转账的字段完整
    if (
      transferData.isBusiness &&
      (!transferData.depositAmount || !transferData.remainingAmount)
    ) {
      const totalAmount = parseFloat(transferData.amount || 0);
      const depositRatio = parseFloat(transferData.depositRatio || 0);
      transferData.depositAmount = ((totalAmount * depositRatio) / 100).toFixed(
        2
      );
      transferData.remainingAmount = (
        totalAmount - parseFloat(transferData.depositAmount)
      ).toFixed(2); // 如果没有任务期限，根据任务期限小时数计算
      if (!transferData.taskDeadline && transferData.taskDeadlineHours) {
        const createdAt = new Date(transferData.timestamp || Date.now());
        const deadlineMs =
          createdAt.getTime() +
          parseFloat(transferData.taskDeadlineHours) * 60 * 60 * 1000;
        transferData.taskDeadline = new Date(deadlineMs).toISOString();
      }
    }
    const amount = parseFloat(transferData.amount || 0).toFixed(2);
    const status = transferData.status || "pending";
    const note = transferData.note || "";
    const time = transferData.time || formatMessageTime(transferData.timestamp); // 生成票根样式的转账详情
    content.innerHTML = renderTransferTicket(transferData, isOwn, isLightMode); // 添加按钮事件监听器
    const acceptBtn = document.getElementById("accept-transfer-btn");
    const rejectBtn = document.getElementById("reject-transfer-btn");
    const completeTaskBtn = document.getElementById("complete-task-btn");
    if (acceptBtn) {
      acceptBtn.onclick = () => acceptTransfer(transferData.timestamp);
    }
    if (rejectBtn) {
      rejectBtn.onclick = () => rejectTransfer(transferData.timestamp);
    }
    if (completeTaskBtn) {
      completeTaskBtn.onclick = () =>
        completeBusinessTask(transferData.timestamp);
    }
    modal.style.display = "flex";
  }; // 关闭转账详情弹窗
  window.closeTransferDetails = function () {
    const modal = document.getElementById("transfer-details-modal");
    if (modal) {
      modal.style.display = "none";
    }
  }; // 渲染票根样式的转账详情
  function renderTransferTicket(transferData, isOwn, isLightMode) {
    const amount = parseFloat(transferData.amount || 0).toFixed(2);
    const status = transferData.status || "pending";
    const note = transferData.note || "";
    const time = transferData.time || formatMessageTime(transferData.timestamp); // 判断是否是商业转账
    const isBusiness = transferData.isBusiness === true;
    const businessData = isBusiness ? transferData : null;
    const isPending = status === "pending";
    const canUserAction = !isOwn && isPending; // 只有收到的待处理转账可以操作
    // 商业转账：计算期限剩余时间
    let deadlineText = "";
    let isExpired = false;
    if (isBusiness && businessData.taskDeadline) {
      const deadline = new Date(businessData.taskDeadline);
      const now = new Date();
      const remainingMs = deadline.getTime() - now.getTime();
      if (remainingMs > 0) {
        const hours = Math.floor(remainingMs / (1000 * 60 * 60));
        const minutes = Math.floor(
          (remainingMs % (1000 * 60 * 60)) / (1000 * 60)
        );
        deadlineText =
          hours > 0 ? `${hours}小时${minutes}分钟` : `${minutes}分钟`;
      } else {
        deadlineText = "已过期";
        isExpired = true;
      }
    }
    // 商业转账：显示定金金额而不是总金额
    const displayAmount = isBusiness
      ? parseFloat(businessData.depositAmount || 0).toFixed(2)
      : amount;
    return `
 <div style="background-color: ${
   isLightMode ? "#ffffff" : "#1f1f1f"
 }; position: relative; overflow: hidden; max-height: 80vh; display: flex; flex-direction: column; ">

 <div style="flex: 1; overflow-y: auto; overflow-x: hidden; ">

 <div style="padding: 24px 20px 16px; background-color: ${
   isLightMode ? "#ffffff" : "#1f1f1f"
 }; position: relative; ">

 <div onclick="closeTransferDetails()" style="position: absolute; top: 16px; right: 16px; cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color 0.2s; z-index: 10; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-primary);">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>

 <div style="text-align: center; font-size: 18px; font-weight: 700; color: ${
   isLightMode ? "#1a1a1a" : "#e5e5e5"
 }; margin-bottom: 8px; ">${isBusiness ? "商业转账详情" : "转账详情"}</div>

 ${
   isBusiness
     ? `
 <div style="text-align: center; margin-bottom: 12px; ">
 <span style="display: inline-block; padding: 4px 12px; background: linear-gradient(135deg, ${
   isLightMode ? "rgba(0, 0, 0, 0.1)" : "rgba(255, 255, 255, 0.15)"
 } 0%, ${
         isLightMode ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.08)"
       } 100%); color: ${
         isLightMode ? "#1a1a1a" : "#e5e5e5"
       }; font-size: 11px; font-weight: 600; border-radius: 12px; letter-spacing: 0.5px; border: 1px solid ${
         isLightMode ? "rgba(0, 0, 0, 0.15)" : "rgba(255, 255, 255, 0.2)"
       }; ">BUSINESS</span>
 </div>
 `
     : ""
 }
 <div style="text-align: center; font-size: 12px; color: ${
   isLightMode ? "#888888" : "#aaaaaa"
 }; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 20px; ">${getTransferStatusText(
      status,
      isOwn
    )}</div>

 <div style="text-align: center; font-size: 32px; font-weight: 700; color: ${
   isLightMode ? "#1a1a1a" : "#e5e5e5"
 }; margin-bottom: ${isBusiness ? "8px" : "16px"}; ">
 ${getTransferAmountText(status, isOwn, displayAmount)}
 </div>

 ${
   isBusiness
     ? `
 <div style="text-align: center; font-size: 12px; color: ${
   isLightMode ? "#888888" : "#aaaaaa"
 }; margin-bottom: 16px; ">定金 ${businessData.depositRatio}%</div>
 `
     : ""
 }

 ${
   note
     ? `
 <div style="text-align: center; font-size: 14px; color: ${
   isLightMode ? "#666666" : "#999999"
 }; margin-bottom: 16px; padding: 8px 16px; background-color: ${
         isLightMode ? "#f5f5f5" : "#2d2d2d"
       }; border-radius: 8px; ">"${note}"</div>
 `
     : ""
 }

 <div style="position: absolute; top: 50%; right: -40px; transform: translateY(-50%) rotate(15deg); font-size: 48px; color: ${
   isLightMode ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
 }; font-weight: 700; pointer-events: none; white-space: nowrap; ">${
      isBusiness ? "BUSINESS" : "TRANSFER"
    }</div>
 </div>

 <div style="height: 20px; background: linear-gradient(90deg,
 ${isLightMode ? "#ffffff" : "#1f1f1f"} 10px,
 transparent 10px,
 transparent 20px,
 ${isLightMode ? "#ffffff" : "#1f1f1f"} 20px
 ); background-size: 20px 100%; position: relative; ">
 <div style="position: absolute; left: -10px; top: 50%; transform: translateY(-50%); width: 20px; height: 20px; border-radius: 50%; background-color: rgba(0, 0, 0, 0.5); "></div>
 <div style="position: absolute; right: -10px; top: 50%; transform: translateY(-50%); width: 20px; height: 20px; border-radius: 50%; background-color: rgba(0, 0, 0, 0.5); "></div>
 </div>

 <div style="padding: 16px 20px 20px; background-color: ${
   isLightMode ? "#ffffff" : "#1f1f1f"
 }; ">

 ${
   isBusiness
     ? `
 <div style="margin-bottom: 16px; padding: 12px; background-color: ${
   isLightMode ? "#f8f9fa" : "#2a2a2a"
 }; border: 1px solid ${
         isLightMode ? "#e1e8ed" : "#38444d"
       }; border-radius: 8px; ">
 <div style="font-size: 12px; font-weight: 600; color: ${
   isLightMode ? "#666666" : "#999999"
 }; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; display: flex; align-items: center; gap: 6px; ">
 <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: currentColor;">
 <g><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm2 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"></path></g>
 </svg>
 任务要求
 </div>
 <div style="font-size: 14px; color: ${
   isLightMode ? "#1a1a1a" : "#e5e5e5"
 }; line-height: 1.5; margin-bottom: 12px; white-space: pre-wrap; word-wrap: break-word; ">${
         businessData.taskDescription
       }</div>
 <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 8px; border-top: 1px solid ${
   isLightMode ? "#e1e8ed" : "#38444d"
 }; ">
 <span style="font-size: 12px; color: ${
   isLightMode ? "#666666" : "#999999"
 }; display: flex; align-items: center; gap: 4px; ">
 <svg viewBox="0 0 24 24" style="width: 12px; height: 12px; fill: currentColor;">
 <g><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"></path></g>
 </svg>
 任务期限
 </span>
 <span style="font-size: 13px; font-weight: 600; color: ${
   isExpired ? "#dc2626" : isLightMode ? "#1a1a1a" : "#e5e5e5"
 }; ">${deadlineText}</span>
 </div>
 </div>

 <div style="margin-bottom: 16px; padding: 12px; background-color: ${
   isLightMode ? "#f8f9fa" : "#2a2a2a"
 }; border: 1px solid ${
         isLightMode ? "#e1e8ed" : "#38444d"
       }; border-radius: 8px; ">
 <div style="font-size: 12px; font-weight: 600; color: ${
   isLightMode ? "#666666" : "#999999"
 }; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; display: flex; align-items: center; gap: 6px; ">
 <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: currentColor;">
 <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.31-8.86c-1.77-.45-2.34-.94-2.34-1.67 0-.84.79-1.43 2.1-1.43 1.38 0 1.9.66 1.94 1.64h1.71c-.05-1.34-.87-2.57-2.49-2.97V5H10.9v1.69c-1.51.32-2.72 1.3-2.72 2.81 0 1.79 1.49 2.69 3.66 3.21 1.95.46 2.34 1.15 2.34 1.87 0 .53-.39 1.39-2.1 1.39-1.6 0-2.23-.72-2.32-1.64H8.04c.1 1.7 1.36 2.66 2.86 2.97V19h2.34v-1.67c1.52-.29 2.72-1.16 2.73-2.77-.01-2.2-1.9-2.96-3.66-3.42z"></path></g>
 </svg>
 金额明细
 </div>
 <div style="display: flex; justify-content: space-between; margin-bottom: 6px; ">
 <span style="font-size: 13px; color: ${
   isLightMode ? "#666666" : "#999999"
 };">总金额</span>
 <span style="font-size: 13px; color: ${
   isLightMode ? "#1a1a1a" : "#e5e5e5"
 }; font-weight: 600;">$${amount}</span>
 </div>
 <div style="display: flex; justify-content: space-between; margin-bottom: 6px; ">
 <span style="font-size: 13px; color: ${
   isLightMode ? "#666666" : "#999999"
 };">定金 (${businessData.depositRatio || 0}%)</span>
 <span style="font-size: 13px; color: var(--x-accent); font-weight: 600;">$${parseFloat(
   businessData.depositAmount || 0
 ).toFixed(2)}</span>
 </div>
 <div style="display: flex; justify-content: space-between; padding-top: 6px; border-top: 1px solid ${
   isLightMode ? "#e1e8ed" : "#38444d"
 }; ">
 <span style="font-size: 13px; color: ${
   isLightMode ? "#666666" : "#999999"
 };">尾款</span>
 <span style="font-size: 13px; color: ${
   isLightMode ? "#1a1a1a" : "#e5e5e5"
 }; font-weight: 600;">$${parseFloat(businessData.remainingAmount || 0).toFixed(
         2
       )}</span>
 </div>
 </div>
 `
     : ""
 }

 <div style="display: flex; justify-content: space-between; margin-bottom: 12px; ">
 <span style="color: ${
   isLightMode ? "#666666" : "#999999"
 }; font-size: 13px;">转账时间</span>
 <span style="color: ${
   isLightMode ? "#1a1a1a" : "#e5e5e5"
 }; font-size: 13px;">${time}</span>
 </div>
 <div style="display: flex; justify-content: space-between; margin-bottom: 12px; ">
 <span style="color: ${
   isLightMode ? "#666666" : "#999999"
 }; font-size: 13px;">${isBusiness ? "任务状态" : "转账状态"}</span>
 <span style="color: ${isLightMode ? "#1a1a1a" : "#e5e5e5"}; font-size: 13px;">
 ${
   status === "pending" ? "待处理" : status === "accepted" ? "已完成" : "已拒绝"
 }
 </span>
 </div>

 <div style="text-align: center; margin: 16px 0; padding: 8px 0; border-top: 1px solid ${
   isLightMode ? "#eeeeee" : "#333333"
 }; ">
 <div style="font-family: monospace; font-size: 24px; color: ${
   isLightMode ? "#1a1a1a" : "#e5e5e5"
 }; letter-spacing: 2px; margin-bottom: 4px; ">||||||||||||| ${Math.random()
      .toString()
      .slice(2, 13)}</div>
 <div style="font-size: 11px; color: ${
   isLightMode ? "#888888" : "#aaaaaa"
 }; ">${isBusiness ? "BUSINESS" : "TRANSFER"} ID: ${
      transferData.timestamp
        ? new Date(transferData.timestamp).getTime()
        : Date.now()
    }</div>
 </div>
 </div>
 </div>

 ${
   canUserAction
     ? `
 <div style="padding: 16px 20px; background-color: ${
   isLightMode ? "#ffffff" : "#1f1f1f"
 }; border-top: 1px solid ${isLightMode ? "#eeeeee" : "#333333"}; ">
 ${
   isBusiness
     ? `
 <div style="font-size: 12px; color: ${
   isLightMode ? "#888888" : "#aaaaaa"
 }; text-align: center; margin-bottom: 12px; line-height: 1.4; ">接收此商业转账即表示同意完成任务要求</div>
 `
     : ""
 }
 <div style="display: flex; gap: 12px; ">
 <button id="reject-transfer-btn" style="flex: 1; padding: 12px; border: 1px solid ${
   isLightMode ? "#dc2626" : "#ef4444"
 }; color: ${
         isLightMode ? "#dc2626" : "#ef4444"
       }; background: transparent; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='${
         isLightMode ? "#fef2f2" : "#1f1416"
       }'"
 onmouseout="this.style.backgroundColor='transparent'">
 拒绝
 </button>
 <button id="accept-transfer-btn" style="flex: 1; padding: 12px; border: none; color: #ffffff; background: var(--x-accent); border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.opacity='0.9'"
 onmouseout="this.style.opacity='1'">
 ${isBusiness ? "接受任务" : "接收"}
 </button>
 </div>
 </div>
 `
     : ""
 }
 ${
   // 用户发出的已接受商业转账：显示"确认完成任务"按钮
   isOwn &&
   isBusiness &&
   status === "accepted" &&
   businessData.taskStatus === "in_progress"
     ? `
 <div style="padding: 16px 20px; background-color: ${
   isLightMode ? "#ffffff" : "#1f1f1f"
 }; border-top: 1px solid ${isLightMode ? "#eeeeee" : "#333333"}; ">
 <div style="font-size: 12px; color: ${
   isLightMode ? "#888888" : "#aaaaaa"
 }; text-align: center; margin-bottom: 12px; line-height: 1.4; ">验收任务完成情况，确认后将支付剩余尾款</div>
 <button id="complete-task-btn" style="width: 100%; padding: 12px; border: 1px solid ${
   isLightMode ? "rgba(0, 0, 0, 0.2)" : "rgba(255, 255, 255, 0.2)"
 }; color: ${
         isLightMode ? "#0f1419" : "#ffffff"
       }; background: linear-gradient(135deg, ${
         isLightMode ? "rgba(0, 0, 0, 0.08)" : "rgba(255, 255, 255, 0.12)"
       } 0%, ${
         isLightMode ? "rgba(0, 0, 0, 0.04)" : "rgba(255, 255, 255, 0.06)"
       } 100%); border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 8px; " onmouseover="this.style.backgroundColor='${
         isLightMode ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.15)"
       }'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;">
 <g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z"></path></g>
 </svg>
 确认完成任务并支付尾款 ($${businessData.remainingAmount})
 </button>
 </div>
 `
     : ""
 }
 </div>
`;
  }
  // 接收转账
  window.acceptTransfer = async function (transferId) {
    try {
      // 查找转账消息并更新状态
      const xDb = getXDB();
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${currentMessageConversation.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (
        savedConversation &&
        savedConversation.data &&
        savedConversation.data.messages
      ) {
        const transferMessage = savedConversation.data.messages.find(
          (msg) => msg.type === "transfer" && msg.timestamp === transferId
        );
        if (transferMessage) {
          const totalAmount = parseFloat(transferMessage.amount);
          const isBusiness = transferMessage.isBusiness === true; // 商业转账：计算定金金额
          let receivedAmount = totalAmount;
          if (isBusiness) {
            // 如果有depositAmount字段，使用它；否则根据depositRatio计算
            if (transferMessage.depositAmount !== undefined) {
              receivedAmount = parseFloat(transferMessage.depositAmount);
            } else {
              const depositRatio =
                parseFloat(transferMessage.depositRatio) || 20;
              receivedAmount = (totalAmount * depositRatio) / 100; // 计算并保存到消息对象中
              transferMessage.depositAmount = receivedAmount.toFixed(2);
              transferMessage.remainingAmount = (
                totalAmount - receivedAmount
              ).toFixed(2);
            }
          }
          // 更新转账状态
          transferMessage.status = "accepted"; // 商业转账：更新任务状态
          if (isBusiness) {
            transferMessage.taskStatus = "in_progress"; // 任务进行中
            const acceptedTime = new Date();
            transferMessage.acceptedAt = acceptedTime.toISOString(); // 计算任务截止时间
            const deadlineHours =
              parseFloat(transferMessage.taskDeadlineHours) || 24;
            const deadlineTime = new Date(
              acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000
            );
            transferMessage.taskDeadline = deadlineTime.toISOString();
            console.log("⏰ [接收商业转账] 设置任务截止时间:", {
              acceptedAt: transferMessage.acceptedAt,
              deadlineHours: deadlineHours,
              taskDeadline: transferMessage.taskDeadline,
            });
          }
          // 添加系统通知到对话
          const systemNotification = {
            type: "system",
            systemType: "transferAccepted",
            content: isBusiness
              ? `你接收了商业转账（定金 $${receivedAmount.toFixed(2)}），请在 ${
                  transferMessage.taskDeadlineHours
                } 小时内完成任务`
              : `你接收了 $${totalAmount.toFixed(2)} 的转账`,
            timestamp: new Date().toISOString(),
            time: "刚刚",
          };
          savedConversation.data.messages.push(systemNotification); // 保存更新
          await xDb.xAccountProfiles.put(savedConversation); // 更新钱包余额（收定金）
          await loadWalletData();
          const currentBalance = parseFloat(walletData.balance) || 0;
          walletData.balance = currentBalance + receivedAmount; // 添加交易记录
          const senderName = currentMessageConversation?.user?.name || "对方";
          const transaction = {
            id: "transfer_in_" + Date.now(),
            description: isBusiness
              ? `商业转账收款（定金）- ${senderName}${
                  transferMessage.note ? ` - ${transferMessage.note}` : ""
                }`
              : `收款自 ${senderName}${
                  transferMessage.note ? ` - ${transferMessage.note}` : ""
                }`,
            amount: receivedAmount,
            timestamp: new Date().toISOString(),
            type: isBusiness ? "business_transfer_deposit_in" : "transfer_in",
          };
          walletData.transactions.unshift(transaction); // 保存钱包数据
          await saveWalletData(); // 商业转账：保存到商业转账数据库
          if (isBusiness && currentMessageConversation) {
            // 🔧 确保获取正确的发送者信息
            const actualSenderName =
              currentMessageConversation.user?.name ||
              currentMessageConversation.userName ||
              "对方";
            const actualSenderHandle =
              currentMessageConversation.user?.handle ||
              currentMessageConversation.userHandle ||
              "unknown";
            const actualSenderAvatar =
              currentMessageConversation.user?.avatar ||
              currentMessageConversation.userAvatar ||
              "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg";

            const businessTransferRecord = {
              ...transferMessage,
              transferId: transferId,
              conversationId: currentMessageConversation.id,
              senderName: actualSenderName,
              senderHandle: actualSenderHandle,
              senderAvatar: actualSenderAvatar,
              direction: "received", // 接收的商业转账
              createdAt: transferMessage.timestamp,
              acceptedAt: new Date().toISOString(),
            };
            console.log("💼 [保存商业转账] 准备保存:", businessTransferRecord);
            console.log(
              "💼 [发送者信息] 名字:",
              actualSenderName,
              "句柄:",
              actualSenderHandle
            );
            console.log(
              "💼 [保存商业转账] taskDeadline:",
              businessTransferRecord.taskDeadline
            );
            console.log(
              "💼 [保存商业转账] taskStatus:",
              businessTransferRecord.taskStatus
            );
            await saveBusinessTransfer(businessTransferRecord);
            console.log("💼 商业转账已记录到数据库");
          }
          // 显示手机样式通知
          showPhoneNotification({
            title: "X Wallet",
            message: isBusiness
              ? `已收定金 $${receivedAmount.toFixed(2)}，请完成任务以获得尾款`
              : `已收款 $${totalAmount.toFixed(
                  2
                )}, 当前余额 $${walletData.balance.toFixed(2)}`,
            avatar: window.userProfileData?.avatar,
            leftIcon: "x",
          }); // 关闭弹窗并刷新消息显示
          closeTransferDetails(); // 刷新私信详情页
          if (currentMessageConversation && currentMessageConversation.user) {
            const profileData = {
              name: currentMessageConversation.user.name,
              handle: currentMessageConversation.user.handle,
              avatar: currentMessageConversation.user.avatar,
            };
            await loadCharacterMessageDetail(
              currentMessageConversation,
              profileData
            );
          }
          console.log(
            "✅ 转账已接收:",
            receivedAmount,
            "新余额:",
            walletData.balance
          ); // 商业转账：触发任务检测
          if (isBusiness) {
            setTimeout(() => {
              handleBusinessTransferTask(
                transferMessage,
                currentMessageConversation
              );
            }, 1000);
          }
          // 💼 检查是否是商业任务尾款（AI发来的普通转账，但有进行中的商业任务）
          if (!isBusiness && !transferMessage.isOwn) {
            // 查找进行中的商业转账（用户接收的）
            const ongoingBusinessTransfer = savedConversation.data.messages
              .filter(
                (msg) =>
                  msg.type === "transfer" &&
                  msg.isBusiness &&
                  msg.taskStatus === "in_progress" &&
                  !msg.isOwn
              )
              .pop(); // 取最新的
            if (ongoingBusinessTransfer) {
              console.log(
                "💼 [商业任务尾款] 检测到进行中的商业任务，将此转账视为尾款"
              ); // 更新商业转账状态为completed
              ongoingBusinessTransfer.taskStatus = "completed";
              ongoingBusinessTransfer.completedAt = new Date().toISOString();
              await xDb.xAccountProfiles.put(savedConversation); // 更新商业转账数据库状态
              await updateBusinessTransferStatus(
                ongoingBusinessTransfer.timestamp,
                "completed"
              );
              console.log("✅ [商业任务尾款] 商业任务已完成，状态已更新"); // 更新通知消息
              showPhoneNotification({
                title: "X Wallet",
                message: `任务已完成，已收尾款 $${receivedAmount.toFixed(
                  2
                )}, 当前余额 $${walletData.balance.toFixed(2)}`,
                avatar: window.userProfileData?.avatar,
                leftIcon: "x",
              });
            }
          }
        }
      }
    } catch (error) {
      console.error("接收转账失败:", error);
      showXToast("接收转账失败", "error");
    }
  }; // 拒绝转账
  window.rejectTransfer = async function (transferId) {
    try {
      // 查找转账消息并更新状态
      const xDb = getXDB();
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${currentMessageConversation.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (
        savedConversation &&
        savedConversation.data &&
        savedConversation.data.messages
      ) {
        const transferMessage = savedConversation.data.messages.find(
          (msg) => msg.type === "transfer" && msg.timestamp === transferId
        );
        if (transferMessage) {
          const amount = parseFloat(transferMessage.amount); // 更新转账状态
          transferMessage.status = "rejected"; // 添加系统通知到对话
          const systemNotification = {
            type: "system",
            systemType: "transferRejected",
            content: `你拒绝了 $${amount.toFixed(2)} 的转账`,
            timestamp: new Date().toISOString(),
            time: "刚刚",
          };
          savedConversation.data.messages.push(systemNotification); // 保存更新
          await xDb.xAccountProfiles.put(savedConversation); // 关闭弹窗并刷新消息显示
          closeTransferDetails(); // 刷新私信详情页
          if (currentMessageConversation && currentMessageConversation.user) {
            const profileData = {
              name: currentMessageConversation.user.name,
              handle: currentMessageConversation.user.handle,
              avatar: currentMessageConversation.user.avatar,
            };
            await loadCharacterMessageDetail(
              currentMessageConversation,
              profileData
            );
          }
          console.log("❌ 转账已拒绝:", amount);
        }
      }
    } catch (error) {
      console.error("拒绝转账失败:", error);
      showXToast("拒绝转账失败", "error");
    }
  }; // 确认完成商业任务并支付尾款
  window.completeBusinessTask = async function (transferId) {
    try {
      if (!currentMessageConversation) {
        showXToast("无法找到当前对话", "error");
        return;
      }
      // 查找转账消息并更新状态
      const xDb = getXDB();
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${currentMessageConversation.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (
        savedConversation &&
        savedConversation.data &&
        savedConversation.data.messages
      ) {
        const transferMessage = savedConversation.data.messages.find(
          (msg) => msg.type === "transfer" && msg.timestamp === transferId
        );
        if (transferMessage && transferMessage.isBusiness) {
          const remainingAmount = parseFloat(transferMessage.remainingAmount); // 检查钱包余额
          await loadWalletData();
          if (walletData.balance < remainingAmount) {
            showXToast("钱包余额不足，无法支付尾款", "error");
            return;
          }
          // 更新转账状态
          transferMessage.taskStatus = "completed";
          transferMessage.completedAt = new Date().toISOString(); // 扣除尾款
          walletData.balance -= remainingAmount; // 从商业转账数据库或对话信息中获取接收者名称
          const businessTransfersId = `businessTransfers_${
            currentAccountId || "main"
          }`;
          let recipientName = "对方";
          const businessData = await xDb.xAccountProfiles.get(
            businessTransfersId
          );
          if (businessData && businessData.data) {
            const businessTransfer = businessData.data.find(
              (t) => t.transferId === transferId
            );
            if (businessTransfer && businessTransfer.senderName) {
              recipientName = businessTransfer.senderName;
            }
          }
          // 如果还是找不到，尝试从currentMessageConversation获取
          if (
            recipientName === "对方" &&
            currentMessageConversation?.user?.name
          ) {
            recipientName = currentMessageConversation.user.name;
          }
          const transaction = {
            id: "business_remaining_" + Date.now(),
            description: `商业转账尾款 - ${recipientName}${
              transferMessage.note ? ` - ${transferMessage.note}` : ""
            }`,
            amount: -remainingAmount,
            timestamp: new Date().toISOString(),
            type: "business_transfer_remaining",
          };
          walletData.transactions.unshift(transaction); // 保存钱包数据
          await saveWalletData(); // 添加系统通知到对话
          const systemNotification = {
            type: "system",
            systemType: "businessTaskCompleted",
            content: `你已确认任务完成并支付尾款 $${remainingAmount.toFixed(
              2
            )}`,
            timestamp: new Date().toISOString(),
            time: "刚刚",
          };
          savedConversation.data.messages.push(systemNotification); // 保存更新
          await xDb.xAccountProfiles.put(savedConversation); // 更新商业转账数据库状态
          await updateBusinessTransferStatus(transferId, "completed"); // 显示手机样式通知
          showPhoneNotification({
            title: "X Wallet",
            message: `任务已完成，已支付尾款 $${remainingAmount.toFixed(2)}`,
            avatar: window.userProfileData?.avatar,
            leftIcon: "x",
          }); // 关闭弹窗并刷新消息显示
          closeTransferDetails(); // 刷新私信详情页
          if (currentMessageConversation && currentMessageConversation.user) {
            const profileData = {
              name: currentMessageConversation.user.name,
              handle: currentMessageConversation.user.handle,
              avatar: currentMessageConversation.user.avatar,
            };
            await loadCharacterMessageDetail(
              currentMessageConversation,
              profileData
            );
          }
          console.log("✅ 商业任务已完成，尾款已支付:", remainingAmount);
        }
      }
    } catch (error) {
      console.error("完成任务失败:", error);
      showXToast("完成任务失败", "error");
    }
  }; // 更新商业转账数据库状态
  async function updateBusinessTransferStatus(transferId, newStatus) {
    try {
      const xDb = getXDB();
      const businessTransfersId = `businessTransfers_${
        currentAccountId || "main"
      }`;
      let savedData = await xDb.xAccountProfiles.get(businessTransfersId);
      if (savedData && savedData.data) {
        const transfer = savedData.data.find(
          (t) => t.transferId === transferId
        );
        if (transfer) {
          transfer.taskStatus = newStatus; // 根据状态更新时间戳
          if (newStatus === "in_progress" && !transfer.acceptedAt) {
            transfer.acceptedAt = new Date().toISOString();
          } else if (newStatus === "completed") {
            transfer.completedAt = new Date().toISOString();
          }
          await xDb.xAccountProfiles.put(savedData);
          console.log("✅ 商业转账状态已更新:", newStatus);
        }
      }
    } catch (error) {
      console.error("❌ 更新商业转账状态失败:", error);
    }
  }
  // 打开商业转账管理中心
  window.openBusinessTransferManager = async function () {
    const xSocialScreen = document.getElementById("x-social-screen");
    const isLightMode =
      xSocialScreen && xSocialScreen.classList.contains("x-theme-light"); // 获取所有商业转账记录
    const xDb = getXDB();
    const businessTransfersId = `businessTransfers_${
      currentAccountId || "main"
    }`;
    let savedData = await xDb.xAccountProfiles.get(businessTransfersId);
    const businessTransfers = savedData?.data || []; // 分类：已发出的和已接收的
    const sentTransfers = businessTransfers.filter(
      (t) => t.direction === "sent"
    );
    const receivedTransfers = businessTransfers.filter(
      (t) => t.direction === "received"
    ); // 创建弹窗遮罩
    const modal = document.createElement("div");
    modal.id = "business-transfer-manager-modal";
    modal.style.cssText = `
 position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: ${
   isLightMode ? "rgba(255, 255, 255, 0.85)" : "rgba(0, 0, 0, 0.85)"
 }; display: flex; align-items: center; justify-content: center; z-index: 26; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
`;
    modal.innerHTML = `
 <div style="background-color: ${
   isLightMode ? "rgba(255, 255, 255, 0.95)" : "rgba(0, 0, 0, 0.95)"
 }; backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 24px; width: 90%; max-width: 500px; max-height: 80vh; position: relative; overflow: hidden; box-shadow: ${
      isLightMode
        ? "0 20px 60px rgba(0, 0, 0, 0.15), 0 8px 32px rgba(0, 0, 0, 0.1)"
        : "0 20px 60px rgba(0, 0, 0, 0.8), 0 8px 32px rgba(255, 255, 255, 0.05)"
    }; border: 2px solid ${
      isLightMode ? "rgba(0, 0, 0, 0.1)" : "rgba(255, 255, 255, 0.1)"
    }; " onclick="event.stopPropagation()">

 <div style="background: linear-gradient(135deg, ${
   isLightMode ? "rgba(248, 250, 252, 0.8)" : "rgba(22, 24, 28, 0.8)"
 } 0%, ${
      isLightMode ? "rgba(255, 255, 255, 0.6)" : "rgba(0, 0, 0, 0.6)"
    } 100%); padding: 24px; text-align: center; border-bottom: 2px solid ${
      isLightMode ? "rgba(0, 0, 0, 0.08)" : "rgba(255, 255, 255, 0.08)"
    }; position: relative; ">

 <button onclick="closeBusinessTransferManager()" style="position: absolute; top: 16px; right: 16px; background: transparent; border: none; color: ${
   isLightMode ? "#536471" : "#71767b"
 }; cursor: pointer; padding: 8px; border-radius: 50%; transition: all 0.2s; " onmouseover="this.style.backgroundColor='${
      isLightMode ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
    }';"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </button>

 <div style="color: ${
   isLightMode ? "#0f1419" : "#ffffff"
 }; font-size: 20px; font-weight: 700; margin-bottom: 8px; display: flex; align-items: center; justify-content: center; gap: 8px; ">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
 <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path></g>
 </svg>
 商业转账管理
 </div>
 <div style="color: ${
   isLightMode ? "#536471" : "#71767b"
 }; font-size: 14px; ">管理所有商业合作订单</div>
 </div>

 <div style="max-height: 60vh; overflow-y: auto; padding: 16px 20px; ">

 <div style="margin-bottom: 24px;">
 <div style="color: ${
   isLightMode ? "#0f1419" : "#ffffff"
 }; font-size: 16px; font-weight: 700; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid ${
      isLightMode ? "#e1e8ed" : "#38444d"
    }; display: flex; align-items: center; gap: 6px; ">
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;">
 <g><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></g>
 </svg>
 已发出 (${sentTransfers.length})
 </div>
 ${
   sentTransfers.length > 0
     ? renderBusinessTransferList(sentTransfers, "sent", isLightMode)
     : renderNoBusinessTransfers("sent", isLightMode)
 }
 </div>

 <div>
 <div style="color: ${
   isLightMode ? "#0f1419" : "#ffffff"
 }; font-size: 16px; font-weight: 700; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid ${
      isLightMode ? "#e1e8ed" : "#38444d"
    }; display: flex; align-items: center; gap: 6px; ">
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor;">
 <g><path d="M20 8l-8 5-8-5V6l8 5 8-5m0-2H4c-1.11 0-2 .89-2 2v12a2 2 0 002 2h16a2 2 0 002-2V6a2 2 0 00-2-2z"></path></g>
 </svg>
 已接收 (${receivedTransfers.length})
 </div>
 ${
   receivedTransfers.length > 0
     ? renderBusinessTransferList(receivedTransfers, "received", isLightMode)
     : renderNoBusinessTransfers("received", isLightMode)
 }
 </div>
 </div>
 </div>
`;
    document.body.appendChild(modal);
    document.body.style.overflow = "hidden"; // 点击背景关闭弹窗
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        closeBusinessTransferManager();
      }
    }); // 添加入场动画
    const managerCard = modal.querySelector("div");
    managerCard.style.transform = "scale(0.8) translateY(20px)";
    managerCard.style.opacity = "0";
    requestAnimationFrame(() => {
      managerCard.style.transition = "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)";
      managerCard.style.transform = "scale(1) translateY(0)";
      managerCard.style.opacity = "1";
    });
  }; // 渲染商业转账列表
  function renderBusinessTransferList(transfers, type, isLightMode) {
    return transfers
      .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
      .map((transfer) => {
        const now = new Date(); // 获取或计算截止时间
        let deadline;
        if (transfer.taskDeadline) {
          deadline = new Date(transfer.taskDeadline);
        } else if (transfer.acceptedAt && transfer.taskDeadlineHours) {
          // 动态计算截止时间
          const acceptedTime = new Date(transfer.acceptedAt);
          const deadlineHours = parseFloat(transfer.taskDeadlineHours) || 24;
          deadline = new Date(
            acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000
          );
        } else if (transfer.createdAt && transfer.taskDeadlineHours) {
          // 如果没有acceptedAt，使用createdAt
          const createdTime = new Date(transfer.createdAt);
          const deadlineHours = parseFloat(transfer.taskDeadlineHours) || 24;
          deadline = new Date(
            createdTime.getTime() + deadlineHours * 60 * 60 * 1000
          );
        } else {
          // 无法计算截止时间，使用默认24小时
          deadline = new Date(now.getTime() + 24 * 60 * 60 * 1000);
        }
        const remainingMs = deadline.getTime() - now.getTime();
        const isExpired = remainingMs <= 0;
        let deadlineText = "";
        if (remainingMs > 0) {
          const hours = Math.floor(remainingMs / (1000 * 60 * 60));
          const minutes = Math.floor(
            (remainingMs % (1000 * 60 * 60)) / (1000 * 60)
          );
          deadlineText =
            hours > 0 ? `${hours}小时${minutes}分钟` : `${minutes}分钟`;
        } else {
          deadlineText = "已过期";
        }
        const statusMap = {
          pending: "待接收",
          in_progress: "进行中",
          completed: "已完成",
          failed: "已失败",
        };
        const statusColorMap = {
          pending: "#f59e0b",
          in_progress: "var(--x-accent)",
          completed: "#22c55e",
          failed: "#ef4444",
        };
        return `
 <div style="margin-bottom: 12px; background: linear-gradient(135deg, ${
   isLightMode ? "rgba(0, 0, 0, 0.02)" : "rgba(255, 255, 255, 0.03)"
 } 0%, ${
          isLightMode ? "rgba(0, 0, 0, 0.01)" : "rgba(255, 255, 255, 0.01)"
        } 100%); border: 1px solid ${
          isLightMode ? "rgba(0, 0, 0, 0.1)" : "rgba(255, 255, 255, 0.1)"
        }; border-radius: 12px; transition: all 0.2s; position: relative; overflow: hidden; ">

 <div style="position: absolute; top: 50%; right: -20px; transform: translateY(-50%) rotate(15deg); font-size: 32px; color: ${
   isLightMode ? "rgba(0, 0, 0, 0.02)" : "rgba(255, 255, 255, 0.02)"
 }; font-weight: 700; pointer-events: none; ">TICKET</div>
 <div style="padding: 16px;">
 <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
 <div style="flex: 1;">
 <div style="color: ${
   isLightMode ? "#0f1419" : "#ffffff"
 }; font-size: 15px; font-weight: 600; margin-bottom: 4px; ">${
          type === "sent"
            ? `发给 ${transfer.receiverName || transfer.senderName || "对方"}`
            : `来自 ${transfer.senderName || transfer.receiverName || "对方"}`
        }</div>
 <div style="color: ${
   isLightMode ? "#536471" : "#71767b"
 }; font-size: 11px; font-family: monospace; letter-spacing: 0.5px; ">${new Date(
          transfer.createdAt
        ).toLocaleString("zh-CN")}</div>
 </div>
 <div style="display: inline-block; padding: 4px 10px; background: linear-gradient(135deg, ${
   isLightMode ? "rgba(0, 0, 0, 0.08)" : "rgba(255, 255, 255, 0.12)"
 } 0%, ${
          isLightMode ? "rgba(0, 0, 0, 0.04)" : "rgba(255, 255, 255, 0.06)"
        } 100%); color: ${
          isLightMode ? "#0f1419" : "#ffffff"
        }; font-size: 10px; font-weight: 600; border-radius: 10px; margin-left: 12px; border: 1px solid ${
          isLightMode ? "rgba(0, 0, 0, 0.15)" : "rgba(255, 255, 255, 0.2)"
        }; letter-spacing: 0.5px; ">${
          statusMap[transfer.taskStatus || "pending"]
        }</div>
 </div>

 <div style="color: ${
   isLightMode ? "#0f1419" : "#e5e5e5"
 }; font-size: 13px; line-height: 1.4; margin-bottom: 12px; padding: 10px; background: ${
          isLightMode ? "rgba(0, 0, 0, 0.02)" : "rgba(255, 255, 255, 0.02)"
        }; border-left: 2px solid ${
          isLightMode ? "rgba(0, 0, 0, 0.15)" : "rgba(255, 255, 255, 0.15)"
        }; border-radius: 4px; ">${transfer.taskDescription}</div>

 <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 12px; border-top: 1px dashed ${
   isLightMode ? "rgba(0, 0, 0, 0.1)" : "rgba(255, 255, 255, 0.1)"
 }; ">
 <div style="color: ${
   isExpired ? "#dc2626" : isLightMode ? "#536471" : "#71767b"
 }; font-size: 11px; display: flex; align-items: center; gap: 4px; ">
 <svg viewBox="0 0 24 24" style="width: 11px; height: 11px; fill: currentColor;">
 <g><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"></path></g>
 </svg>
 ${deadlineText}
 </div>
 <div style="color: ${
   isLightMode ? "#0f1419" : "#ffffff"
 }; font-size: 13px; font-weight: 700; font-family: monospace; ">$${
          transfer.amount
        } <span style="opacity: 0.6; font-size: 11px;">(定金 $${
          transfer.depositAmount
        })</span></div>
 </div>

 <div style="margin-top: 12px; text-align: right;">
 <button onclick="deleteBusinessTransfer('${
   transfer.transferId
 }', event)" style="background: linear-gradient(135deg, ${
          isLightMode ? "rgba(0, 0, 0, 0.08)" : "rgba(255, 255, 255, 0.12)"
        } 0%, ${
          isLightMode ? "rgba(0, 0, 0, 0.04)" : "rgba(255, 255, 255, 0.06)"
        } 100%); color: ${
          isLightMode ? "#0f1419" : "#ffffff"
        }; border: 1px dashed ${
          isLightMode ? "rgba(0, 0, 0, 0.2)" : "rgba(255, 255, 255, 0.2)"
        }; border-radius: 8px; padding: 6px 12px; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 4px; position: relative; overflow: hidden; " onmouseover="this.style.background='linear-gradient(135deg, ${
          isLightMode ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.15)"
        } 0%, ${
          isLightMode ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.08)"
        } 100%)'; this.style.transform='scale(1.02)'"
 onmouseout="this.style.background='linear-gradient(135deg, ${
   isLightMode ? "rgba(0, 0, 0, 0.08)" : "rgba(255, 255, 255, 0.12)"
 } 0%, ${
          isLightMode ? "rgba(0, 0, 0, 0.04)" : "rgba(255, 255, 255, 0.06)"
        } 100%)'; this.style.transform='scale(1)'">
 <svg viewBox="0 0 24 24" style="width: 12px; height: 12px; fill: currentColor; opacity: 0.7;">
 <g><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></g>
 </svg>
 删除任务
 </button>
 </div>
 </div>
 </div>
 `;
      })
      .join("");
  }
  // 渲染无商业转账状态
  function renderNoBusinessTransfers(type, isLightMode) {
    return `
 <div style="text-align: center; padding: 32px 20px; color: ${
   isLightMode ? "#6b7280" : "#9ca3af"
 }; font-size: 14px; ">
 <svg viewBox="0 0 24 24" style="width: 48px; height: 48px; fill: currentColor; opacity: 0.3; margin: 0 auto 12px;">
 <g><path d="M20 6h-3V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zM9 4h6v2H9V4zm11 16H4V8h16v12z"></path></g>
 </svg>
 <div>暂无${type === "sent" ? "发出的" : "接收的"}商业转账</div>
 </div>
`;
  }
  // 关闭商业转账管理弹窗
  window.closeBusinessTransferManager = function () {
    const modal = document.getElementById("business-transfer-manager-modal");
    if (modal) {
      const managerCard = modal.querySelector("div");
      managerCard.style.transform = "scale(0.9) translateY(20px)";
      managerCard.style.opacity = "0";
      setTimeout(() => {
        modal.remove();
        document.body.style.overflow = "auto";
      }, 200);
    }
  }; // 删除商业转账任务
  window.deleteBusinessTransfer = async function (transferId, event) {
    event.stopPropagation();
    try {
      const xDb = getXDB();
      const businessTransfersId = `businessTransfers_${
        currentAccountId || "main"
      }`;
      const savedData = await xDb.xAccountProfiles.get(businessTransfersId);
      if (!savedData || !savedData.data) {
        showXToast("无法找到商业转账数据", "error");
        return;
      }
      const transfer = savedData.data.find((t) => t.transferId === transferId);
      if (!transfer) {
        showXToast("无法找到该任务", "error");
        return;
      }
      // 计算违约费
      const depositAmount = parseFloat(transfer.depositAmount) || 0;
      const totalAmount = parseFloat(transfer.amount) || 0;
      const penaltyAmount = depositAmount + totalAmount; // 定金 + 全款
      // 确认删除
      const confirmMessage = `删除此任务将扣除违约费 $${penaltyAmount.toFixed(
        2
      )}\n（定金 $${depositAmount.toFixed(2)} + 全款 $${totalAmount.toFixed(
        2
      )}）\n并降低信用值\n\n是否确认删除？`;
      if (!confirm(confirmMessage)) {
        return;
      }
      // 找到对应的卡片元素并播放撕碎动画
      const cardElement = event.target.closest(
        'div[style*="margin-bottom: 12px"]'
      );
      if (cardElement) {
        // 添加撕碎动画
        cardElement.style.animation =
          "crumple-tear 0.6s cubic-bezier(0.4, 0, 1, 1) forwards";
        cardElement.style.transformOrigin = "center center"; // 注入CSS动画（如果还没有注入）
        if (!document.getElementById("business-transfer-animations")) {
          const style = document.createElement("style");
          style.id = "business-transfer-animations";
          style.textContent = `
 @keyframes crumple-tear {
 0% {
 transform: scale(1) rotate(0deg); opacity: 1; }
 20% {
 transform: scale(0.95) rotate(-2deg); }
 40% {
 transform: scale(0.9) rotate(2deg) translateY(-5px); filter: blur(0px); }
 60% {
 transform: scale(0.7) rotate(-5deg) translateY(-10px); filter: blur(1px); opacity: 0.8; }
 80% {
 transform: scale(0.4) rotate(8deg) translateY(-15px); filter: blur(3px); opacity: 0.4; }
 100% {
 transform: scale(0.1) rotate(15deg) translateY(-20px); filter: blur(5px); opacity: 0; }
 }
 `;
          document.head.appendChild(style);
        }
        // 等待动画完成
        await new Promise((resolve) => setTimeout(resolve, 600));
      }
      // 加载钱包数据
      await loadWalletData(); // 扣除违约费
      walletData.balance -= penaltyAmount; // 降低信用值（根据任务金额，金额越大扣得越多）
      const creditPenalty = Math.min(20, Math.floor(totalAmount / 10)); // 最多扣20，按金额/10计算
      walletData.creditScore = Math.max(
        0,
        walletData.creditScore - creditPenalty
      ); // 添加违约费交易记录
      const penaltyTransaction = {
        id: "penalty_" + Date.now(),
        description: `删除商业任务违约费 - ${transfer.taskDescription.substring(
          0,
          30
        )}...`,
        amount: -penaltyAmount,
        timestamp: new Date().toISOString(),
        type: "penalty",
      };
      walletData.transactions.unshift(penaltyTransaction); // 保存钱包数据
      await saveWalletData(); // 删除商业转账记录
      savedData.data = savedData.data.filter(
        (t) => t.transferId !== transferId
      );
      await xDb.xAccountProfiles.put(savedData); // 显示通知
      showPhoneNotification({
        title: "X Wallet",
        message: `任务已删除，扣除违约费 $${penaltyAmount.toFixed(
          2
        )}，信用值 -${creditPenalty}`,
        avatar: window.userProfileData?.avatar,
        leftIcon: "custom",
        leftIconHtml: `
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #71767b;">
 <g><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></g>
 </svg>
 `,
        duration: 5000,
      });
      console.log(
        `🗑️ 商业任务已删除，扣除违约费 $${penaltyAmount.toFixed(
          2
        )}，信用值 -${creditPenalty}`
      ); // 刷新商业转账管理窗口
      closeBusinessTransferManager();
      setTimeout(() => {
        openBusinessTransferManager();
      }, 300);
    } catch (error) {
      console.error("删除商业转账失败:", error);
      showXToast("删除失败", "error");
    }
  }; // 商业转账状态检查定时器
  let businessTransferCheckInterval = null; // 启动商业转账状态检查
  function startBusinessTransferCheck() {
    // 如果已有定时器，先清除
    if (businessTransferCheckInterval) {
      clearInterval(businessTransferCheckInterval);
    }
    // 立即执行一次检查
    checkBusinessTransfersStatus(); // 每分钟检查一次
    businessTransferCheckInterval = setInterval(() => {
      checkBusinessTransfersStatus();
    }, 60000); // 60秒
    console.log("✅ 商业转账状态检查已启动");
  }
  // 检查商业转账状态（提醒、清理）
  async function checkBusinessTransfersStatus() {
    try {
      const xDb = getXDB();
      const businessTransfersId = `businessTransfers_${
        currentAccountId || "main"
      }`;
      const savedData = await xDb.xAccountProfiles.get(businessTransfersId);
      if (!savedData || !savedData.data || savedData.data.length === 0) return;
      const businessTransfers = savedData.data;
      const now = new Date();
      let needsUpdate = false;
      const transfersToKeep = [];
      for (const transfer of businessTransfers) {
        // 获取或计算截止时间
        let deadline;
        if (transfer.taskDeadline) {
          deadline = new Date(transfer.taskDeadline);
        } else if (transfer.acceptedAt && transfer.taskDeadlineHours) {
          // 动态计算截止时间
          const acceptedTime = new Date(transfer.acceptedAt);
          const deadlineHours = parseFloat(transfer.taskDeadlineHours) || 24;
          deadline = new Date(
            acceptedTime.getTime() + deadlineHours * 60 * 60 * 1000
          );
        } else if (transfer.createdAt && transfer.taskDeadlineHours) {
          // 如果没有acceptedAt，使用createdAt
          const createdTime = new Date(transfer.createdAt);
          const deadlineHours = parseFloat(transfer.taskDeadlineHours) || 24;
          deadline = new Date(
            createdTime.getTime() + deadlineHours * 60 * 60 * 1000
          );
        } else {
          // 无法计算截止时间，跳过此任务
          console.warn(
            "⚠️ 商业转账缺少截止时间信息，跳过:",
            transfer.transferId
          );
          transfersToKeep.push(transfer);
          continue;
        }
        const completedAt = transfer.completedAt
          ? new Date(transfer.completedAt)
          : null;
        const timeToDeadline = deadline.getTime() - now.getTime(); // 1. 检查是否需要发送即将到期提醒（剩余1小时，且进行中的任务）
        if (
          transfer.taskStatus === "in_progress" &&
          timeToDeadline > 0 &&
          timeToDeadline <= 3600000 && // 1小时 = 3600000毫秒
          !transfer.reminderSent
        ) {
          // 发送提醒
          const hours = Math.floor(timeToDeadline / (1000 * 60 * 60));
          const minutes = Math.floor(
            (timeToDeadline % (1000 * 60 * 60)) / (1000 * 60)
          );
          const timeText =
            hours > 0 ? `${hours}小时${minutes}分钟` : `${minutes}分钟`;
          showPhoneNotification({
            title: "商业转账提醒",
            message: `任务"${transfer.taskDescription.substring(
              0,
              20
            )}..."还剩${timeText}截止，请及时完成！`,
            avatar: window.userProfileData?.avatar,
            leftIcon: "custom",
            leftIconHtml: `
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #f59e0b;">
 <g><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"></path></g>
 </svg>
 `,
            duration: 5000,
          }); // 标记已提醒
          transfer.reminderSent = true;
          needsUpdate = true;
          console.log(
            `⏰ 已发送任务即将到期提醒: ${transfer.taskDescription.substring(
              0,
              30
            )}`
          );
        }
        // 2. 检查是否需要删除（过期超过1小时 或 完成超过3小时）
        let shouldDelete = false;
        let isExpiredPenalty = false; // 过期超过1小时（进行中的任务才扣违约费）
        if (timeToDeadline < 0 && Math.abs(timeToDeadline) > 3600000) {
          shouldDelete = true;
          if (transfer.taskStatus === "in_progress") {
            isExpiredPenalty = true; // 标记需要扣除违约费
          }
          console.log(
            `🗑️ 删除过期任务: ${transfer.taskDescription.substring(0, 30)}`
          );
        }
        // 完成超过3小时
        if (transfer.taskStatus === "completed" && completedAt) {
          const timeSinceCompletion = now.getTime() - completedAt.getTime();
          if (timeSinceCompletion > 10800000) {
            // 3小时 = 10800000毫秒
            shouldDelete = true;
            console.log(
              `🗑️ 删除已完成任务: ${transfer.taskDescription.substring(0, 30)}`
            );
          }
        }
        // 保留不需要删除的任务
        if (!shouldDelete) {
          transfersToKeep.push(transfer);
        } else {
          // 如果是过期未完成的任务，扣除违约费
          if (isExpiredPenalty) {
            const totalAmount = parseFloat(transfer.amount) || 0;
            const penaltyAmount = totalAmount; // 过期任务只扣全款
            // 加载钱包数据
            await loadWalletData(); // 扣除违约费
            walletData.balance -= penaltyAmount; // 降低信用值
            const creditPenalty = Math.min(15, Math.floor(totalAmount / 15)); // 过期扣得少一些，最多扣15
            walletData.creditScore = Math.max(
              0,
              walletData.creditScore - creditPenalty
            ); // 添加违约费交易记录
            const penaltyTransaction = {
              id: "penalty_expired_" + Date.now(),
              description: `任务过期违约费 - ${transfer.taskDescription.substring(
                0,
                30
              )}...`,
              amount: -penaltyAmount,
              timestamp: new Date().toISOString(),
              type: "penalty",
            };
            walletData.transactions.unshift(penaltyTransaction); // 保存钱包数据
            await saveWalletData(); // 显示通知
            showPhoneNotification({
              title: "X Wallet",
              message: `任务已过期，扣除违约费 $${penaltyAmount.toFixed(
                2
              )}，信用值 -${creditPenalty}`,
              avatar: window.userProfileData?.avatar,
              leftIcon: "custom",
              leftIconHtml: `
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: #71767b;">
 <g><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"></path></g>
 </svg>
 `,
              duration: 5000,
            });
            console.log(
              `💸 任务过期违约费 $${penaltyAmount.toFixed(
                2
              )}，信用值 -${creditPenalty}`
            );
          }
          needsUpdate = true;
        }
      }
      // 如果有任何变化，更新数据库
      if (needsUpdate) {
        await xDb.xAccountProfiles.put({
          handle: businessTransfersId,
          name: "businessTransfers",
          accountId: currentAccountId || "main",
          data: transfersToKeep,
          updatedAt: new Date().toISOString(),
        });
        console.log(
          `✅ 商业转账数据已更新，保留 ${transfersToKeep.length}/${businessTransfers.length} 条记录`
        ); // 如果商业转账管理窗口正在打开，刷新显示
        const managerModal = document.getElementById(
          "business-transfer-manager-modal"
        );
        if (managerModal) {
          closeBusinessTransferManager();
          setTimeout(() => {
            openBusinessTransferManager();
          }, 300);
        }
      }
    } catch (error) {
      console.error("检查商业转账状态失败:", error);
    }
  }
  // 处理 AI 对用户转账的响应
  async function handleAITransferResponse(aiMessages, conversationRef) {
    try {
      // 检查 AI 回复中是否有转账消息
      const aiTransfer = aiMessages.find(
        (msg) =>
          msg.type === "transfer" && msg.status && msg.status !== "pending"
      );
      if (!aiTransfer) return;
      const xDb = getXDB();
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${conversationRef.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (
        !savedConversation ||
        !savedConversation.data ||
        !savedConversation.data.messages
      )
        return; // 查找用户之前发送的待处理转账
      const userTransfer = savedConversation.data.messages.find(
        (msg) =>
          msg.type === "transfer" && msg.isOwn && msg.status === "pending"
      );
      if (!userTransfer) return;
      const amount = parseFloat(userTransfer.amount);
      const isBusiness = userTransfer.isBusiness === true;
      if (aiTransfer.status === "accepted") {
        // AI 接收了转账
        userTransfer.status = "accepted"; // 商业转账：更新任务状态
        if (isBusiness) {
          userTransfer.taskStatus = "in_progress";
          userTransfer.acceptedAt = new Date().toISOString();
        }
        // 添加系统通知
        const systemNotification = {
          type: "system",
          systemType: "transferAccepted",
          content: isBusiness
            ? `对方接收了商业转账（定金 $${parseFloat(
                userTransfer.depositAmount
              ).toFixed(2)}），已开始执行任务`
            : `对方接收了你的 $${amount.toFixed(2)} 转账`,
          timestamp: new Date().toISOString(),
          time: "刚刚",
        };
        savedConversation.data.messages.push(systemNotification); // 更新钱包交易记录状态
        await loadWalletData();
        const recipientName = conversationRef?.user?.name || "对方";
        const transactionType = isBusiness
          ? "business_transfer_deposit"
          : "transfer_out";
        const actualAmount = isBusiness
          ? parseFloat(userTransfer.depositAmount)
          : amount;
        const transaction = walletData.transactions.find(
          (t) =>
            t.type === transactionType &&
            Math.abs(t.amount + actualAmount) < 0.01
        );
        if (transaction) {
          transaction.description = isBusiness
            ? `商业转账给 ${recipientName}（定金已接收）${
                userTransfer.note ? ` - ${userTransfer.note}` : ""
              }`
            : `转账给 ${recipientName}（已接收）${
                userTransfer.note ? ` - ${userTransfer.note}` : ""
              }`;
        }
        await saveWalletData(); // 保存更新
        await xDb.xAccountProfiles.put(savedConversation); // 商业转账：更新商业转账数据库状态并触发任务检测
        if (isBusiness && conversationRef) {
          // 更新现有的商业转账记录状态，而不是新增
          await updateBusinessTransferStatus(
            userTransfer.timestamp,
            "in_progress"
          );
          console.log("💼 AI接收的商业转账状态已更新为进行中"); // 触发AI任务处理（AI接收后自动处理任务）
          setTimeout(() => {
            handleBusinessTransferTask(userTransfer, conversationRef);
          }, 1000);
        }
        // 延迟3秒显示手机样式通知，避免被AI消息通知掩盖
        setTimeout(() => {
          showPhoneNotification({
            title: "X Wallet",
            message: isBusiness
              ? `对方已接受任务，定金 $${actualAmount.toFixed(2)} 已支付`
              : `已付款 $${amount.toFixed(
                  2
                )}, 当前余额 $${walletData.balance.toFixed(2)}`,
            avatar: window.userProfileData?.avatar,
            leftIcon: "x",
          });
        }, 3000);
        console.log(
          "✅ AI 接收了转账:",
          isBusiness ? `商业转账，定金 ${actualAmount}` : amount
        );
      } else if (aiTransfer.status === "rejected") {
        // AI 拒绝了转账
        userTransfer.status = "rejected"; // 商业转账：更新任务状态
        if (isBusiness) {
          userTransfer.taskStatus = "rejected";
        }
        // 添加系统通知
        const systemNotification = {
          type: "system",
          systemType: "transferRejected",
          content: isBusiness
            ? `对方拒绝了商业转账，定金 $${parseFloat(
                userTransfer.depositAmount
              ).toFixed(2)} 已退回`
            : `对方拒绝了你的 $${amount.toFixed(2)} 转账`,
          timestamp: new Date().toISOString(),
          time: "刚刚",
        };
        savedConversation.data.messages.push(systemNotification); // 退回钱包余额
        await loadWalletData();
        const actualAmount = isBusiness
          ? parseFloat(userTransfer.depositAmount)
          : amount;
        walletData.balance += actualAmount; // 更新交易记录
        const recipientName = conversationRef?.user?.name || "对方";
        const transactionType = isBusiness
          ? "business_transfer_deposit"
          : "transfer_out";
        const transaction = walletData.transactions.find(
          (t) =>
            t.type === transactionType &&
            Math.abs(t.amount + actualAmount) < 0.01
        );
        if (transaction) {
          transaction.description = isBusiness
            ? `商业转账给 ${recipientName}（已拒绝，定金已退回）${
                userTransfer.note ? ` - ${userTransfer.note}` : ""
              }`
            : `转账给 ${recipientName}（已拒绝，已退回）${
                userTransfer.note ? ` - ${userTransfer.note}` : ""
              }`;
          transaction.amount = 0; // 标记为已退回
        }
        // 添加退款记录
        const refundTransaction = {
          id: "refund_" + Date.now(),
          description: isBusiness
            ? `${recipientName} 拒绝商业转账，定金已退回${
                userTransfer.note ? ` - ${userTransfer.note}` : ""
              }`
            : `${recipientName} 拒绝转账，已退回${
                userTransfer.note ? ` - ${userTransfer.note}` : ""
              }`,
          amount: actualAmount,
          timestamp: new Date().toISOString(),
          type: "refund",
        };
        walletData.transactions.unshift(refundTransaction);
        await saveWalletData(); // 保存更新
        await xDb.xAccountProfiles.put(savedConversation); // 延迟4秒显示退款通知，避免被AI消息通知掩盖
        setTimeout(() => {
          showPhoneNotification({
            title: "X Wallet",
            message: isBusiness
              ? `商业转账被拒绝，定金 $${actualAmount.toFixed(
                  2
                )} 已退回，当前余额 $${walletData.balance.toFixed(2)}`
              : `转账被拒绝，已退回 $${actualAmount.toFixed(
                  2
                )}, 当前余额 $${walletData.balance.toFixed(2)}`,
            avatar: window.userProfileData?.avatar,
            leftIcon: "x",
          });
        }, 4000);
        console.log(
          "❌ AI 拒绝了转账，已退回:",
          isBusiness ? `商业转账定金 ${actualAmount}` : amount
        );
      }
      // 刷新私信详情页（如果用户还在详情页）
      if (
        currentMessageConversation &&
        currentMessageConversation.id === conversationRef.id
      ) {
        const profileData = {
          name: conversationRef.user.name,
          handle: conversationRef.user.handle,
          avatar: conversationRef.user.avatar,
        };
        await loadCharacterMessageDetail(
          currentMessageConversation,
          profileData
        );
      }
    } catch (error) {
      console.error("处理 AI 转账响应失败:", error);
    }
  }
  // 加载角色私信详情（已绑定角色）
  async function loadCharacterMessageDetail(messageData, profileData) {
    const contentContainer = document.getElementById("message-detail-content");
    if (!contentContainer) return; // 清空现有内容
    contentContainer.innerHTML = ""; // 更新顶部栏小头像和昵称
    const topAvatar = document.getElementById("message-detail-top-avatar");
    const topName = document.getElementById("message-detail-top-name");

    // 🔧 清理粉丝群的事件监听器（避免冲突）
    if (topAvatar) {
      if (topAvatar._fangroupClickHandler) {
        topAvatar.removeEventListener("click", topAvatar._fangroupClickHandler);
        delete topAvatar._fangroupClickHandler;
      }
      if (topAvatar._fangroupTouchHandler) {
        topAvatar.removeEventListener(
          "touchend",
          topAvatar._fangroupTouchHandler
        );
        delete topAvatar._fangroupTouchHandler;
      }
    }

    if (topAvatar) topAvatar.src = profileData.avatar;
    if (topName) topName.textContent = profileData.name; // 🆕 为非绑定角色的小头像添加点击事件（添加到私信列表）
    if (topAvatar) {
      // 判断是否是绑定角色
      const isCharacter =
        messageData.id.startsWith("msg_") &&
        messageData.id !== "msg_001" &&
        !messageData.id.startsWith("msg_account_");
      if (!isCharacter) {
        // 非绑定角色：账户或陌生人，可以点击添加到私信列表
        topAvatar.onclick = () => {
          openMessageContactSettings(messageData, profileData);
        };
        topAvatar.style.cursor = "pointer";
      } else {
        // 绑定角色：移除点击事件
        topAvatar.onclick = null;
        topAvatar.style.cursor = "default";
      }
    }
    // 更新中间详细信息区域
    const detailAvatar = document.getElementById("message-detail-avatar");
    const detailName = document.getElementById("message-detail-name");
    const detailHandle = document.getElementById("message-detail-handle");
    if (detailAvatar) {
      detailAvatar.src = profileData.avatar; // 添加点击事件，进入对方主页
      detailAvatar.style.cursor = "pointer";
      detailAvatar.onclick = () => {
        openAccountProfile(
          profileData.name,
          profileData.handle,
          profileData.avatar
        );
      };
    }
    if (detailName) detailName.textContent = profileData.name;
    if (detailHandle) detailHandle.textContent = profileData.handle; // 显示简介
    const bioEl = document.getElementById("message-detail-bio");
    if (profileData.bio && bioEl) {
      bioEl.textContent = profileData.bio;
      bioEl.style.display = "block";
    } else if (bioEl) {
      bioEl.style.display = "none";
    }
    // 显示关注者数量
    const followersCount = profileData.followersCount || "0";
    const config = languageConfig[currentLanguage] || languageConfig.zh;
    const followersEl = document.getElementById("message-detail-followers");
    if (followersEl) {
      if (currentLanguage === "en") {
        followersEl.textContent = `${followersCount} ${config.messageFollowers}`;
      } else {
        followersEl.textContent = `${followersCount} ${config.messageFollowers}`;
      }
    }
    // 检查是否已有对话记录
    try {
      const xDb = getXDB(); // 🔧 多账户隔离：包含账户ID
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${messageData.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (
        savedConversation &&
        savedConversation.data &&
        savedConversation.data.messages &&
        savedConversation.data.messages.length > 0
      ) {
        // 已有对话记录，渲染消息
        console.log("✅ 加载已有对话记录");

        // 💎 恢复 liveUserData 到 currentMessageConversation（如果存在）
        if (savedConversation._liveUserData && !messageData._liveUserData) {
          messageData._liveUserData = savedConversation._liveUserData;
          currentMessageConversation._liveUserData =
            savedConversation._liveUserData;
          console.log(
            "💎 [加载对话] 从数据库恢复直播间用户数据",
            savedConversation._liveUserData
          );
        } // 渲染日期分隔符
        const today = new Date();
        const dateStr =
          currentLanguage === "en"
            ? today.toLocaleDateString("en-US", {
                year: "numeric",
                month: "long",
                day: "numeric",
              })
            : `${today.getFullYear()}年${today.getMonth() + 1}月${String(
                today.getDate()
              ).padStart(2, "0")}日`;
        contentContainer.appendChild(renderDateSeparator(dateStr)); // 使用分组渲染消息
        const groups = groupMessagesBySender(savedConversation.data.messages);
        const allMessageElements = [];
        groups.forEach((group) => {
          const isOwn = group[0].message.isOwn === true;
          group.forEach((item, indexInGroup) => {
            const isLastInGroup = indexInGroup === group.length - 1;
            const messageEl = renderMessageItem(
              item.message,
              isOwn,
              item.index,
              isLastInGroup
            );
            contentContainer.appendChild(messageEl);
            allMessageElements.push(messageEl);
          });
        }); // 立即显示所有消息（历史消息不需要动画）
        allMessageElements.forEach((el) => {
          el.style.opacity = "1";
          el.style.transform = "translateY(0)";
        }); // 恢复等待AI回复的消息到队列
        try {
          // 从对话记录中找出所有等待AI回复的用户消息
          const waitingMessages = savedConversation.data.messages.filter(
            (msg) => msg.isOwn && msg.waitingForAIResponse === true
          );
          if (waitingMessages.length > 0) {
            userMessageQueue = waitingMessages;
            console.log(
              `✅ 恢复了 ${userMessageQueue.length} 条等待AI回复的消息到队列`
            );
          } else {
            console.log("📝 所有消息都已得到AI回复");
          }
        } catch (error) {
          console.error("恢复消息队列失败:", error);
        }
        // 滚动到底部（使用外层可滚动容器）
        setTimeout(() => {
          const scrollable = document.getElementById(
            "message-detail-scrollable"
          );
          if (scrollable) {
            scrollable.scrollTop = scrollable.scrollHeight;
          }
        }, 100);
        return;
      }
    } catch (error) {
      console.warn("检查对话记录失败:", error);
    }
    // 没有对话记录，显示欢迎状态
    contentContainer.innerHTML = `
 <div style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 32px;">
 <div style="text-align: center; max-width: 300px;">

 <img src="${profileData.avatar}"
 style="width: 64px; height: 64px; border-radius: 50%; margin-bottom: 16px; object-fit: cover; ">

 <div style="font-size: 28px; font-weight: 700; color:var(--x-text-primary); margin-bottom: 8px; ">开始对话</div>
 <div style="font-size: 14px; color:var(--x-text-secondary); line-height: 1.4; ">向 ${profileData.name} 发送消息开始聊天</div>
 </div>
 </div>
`;
    console.log("✅ 角色私信详情页已加载（首次对话）");
  }
  // 加载粉丝群私信详情
  async function loadFanGroupMessageDetail(messageData) {
    const contentContainer = document.getElementById("message-detail-content");
    if (!contentContainer) return; // 清空现有内容
    contentContainer.innerHTML = ""; // 更新顶部栏小头像和昵称
    const topAvatar = document.getElementById("message-detail-top-avatar");
    const topName = document.getElementById("message-detail-top-name");
    if (topAvatar) {
      topAvatar.src = messageData.userAvatar || messageData.groupAvatar;
      // 🎯 为粉丝群头像添加点击事件（打开设置）
      topAvatar.style.cursor = "pointer";

      // 先移除旧的事件监听器（避免重复绑定）
      if (topAvatar._fangroupClickHandler) {
        topAvatar.removeEventListener("click", topAvatar._fangroupClickHandler);
        topAvatar.removeEventListener(
          "touchend",
          topAvatar._fangroupTouchHandler
        );
      }

      // 创建新的事件处理器并保存引用
      topAvatar._fangroupClickHandler = (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log("🖱️ [头像点击] 粉丝群头像被点击");
        openFanGroupSettings(messageData);
      };

      topAvatar._fangroupTouchHandler = (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log("📱 [头像点击] 移动端触摸事件");
        openFanGroupSettings(messageData);
      };

      // 绑定事件
      topAvatar.addEventListener("click", topAvatar._fangroupClickHandler);
      topAvatar.addEventListener("touchend", topAvatar._fangroupTouchHandler);
    }
    if (topName)
      topName.textContent = messageData.userName || messageData.groupName; // 隐藏中间的详细信息区域（大头像和用户信息）
    const scrollableContainer = document.getElementById(
      "message-detail-scrollable"
    );
    if (scrollableContainer) {
      const userInfoSection = scrollableContainer.querySelector(
        '[style*="padding: 24px"]'
      );
      if (userInfoSection) {
        userInfoSection.style.display = "none";
      }
    }
    // 检查是否已有对话记录
    try {
      const xDb = getXDB();
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${messageData.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (
        savedConversation &&
        savedConversation.data &&
        savedConversation.data.messages &&
        savedConversation.data.messages.length > 0
      ) {
        // 已有对话记录，渲染消息
        console.log("✅ 加载已有粉丝群对话记录"); // 渲染日期分隔符
        const today = new Date();
        const dateStr =
          currentLanguage === "en"
            ? today.toLocaleDateString("en-US", {
                year: "numeric",
                month: "long",
                day: "numeric",
              })
            : `${today.getFullYear()}年${today.getMonth() + 1}月${String(
                today.getDate()
              ).padStart(2, "0")}日`;
        contentContainer.appendChild(renderDateSeparator(dateStr)); // 使用分组渲染消息
        const groups = groupMessagesBySender(savedConversation.data.messages);
        const allMessageElements = [];
        groups.forEach((group) => {
          const isOwn = group[0].message.isOwn === true;
          group.forEach((item, indexInGroup) => {
            const isLastInGroup = indexInGroup === group.length - 1;
            const messageEl = renderMessageItem(
              item.message,
              isOwn,
              item.index,
              isLastInGroup
            );
            contentContainer.appendChild(messageEl);
            allMessageElements.push(messageEl);
          });
        }); // 立即显示所有消息（历史消息不需要动画）
        allMessageElements.forEach((el) => {
          el.style.opacity = "1";
          el.style.transform = "translateY(0)";
        }); // 恢复等待AI回复的消息到队列
        try {
          const waitingMessages = savedConversation.data.messages.filter(
            (msg) => msg.isOwn && msg.waitingForAIResponse === true
          );
          if (waitingMessages.length > 0) {
            userMessageQueue = waitingMessages;
            console.log(
              `✅ 恢复了 ${userMessageQueue.length} 条等待AI回复的消息到队列`
            );
          }
        } catch (error) {
          console.error("恢复消息队列失败:", error);
        }
        // 滚动到底部
        setTimeout(() => {
          const scrollable = document.getElementById(
            "message-detail-scrollable"
          );
          if (scrollable) {
            scrollable.scrollTop = scrollable.scrollHeight;
          }
        }, 100);
        return;
      }
    } catch (error) {
      console.warn("检查粉丝群对话记录失败:", error);
    }
    // 没有对话记录，显示空状态（粉丝群不显示欢迎词）
    contentContainer.innerHTML = `
 <div style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 32px;">
 <div style="text-align: center; max-width: 300px;">

 <img src="${messageData.userAvatar || messageData.groupAvatar}"
 style="width: 64px; height: 64px; border-radius: 50%; margin-bottom: 16px; object-fit: cover; ">

 <div style="font-size: 28px; font-weight: 700; color:var(--x-text-primary); margin-bottom: 8px; ">粉丝群聊天</div>
 <div style="font-size: 14px; color:var(--x-text-secondary); line-height: 1.4; ">向粉丝群发送消息开始互动</div>
 </div>
 </div>
`;
    console.log("✅ 粉丝群私信详情页已加载（首次对话）");
  }
  // 加载私信会话内容
  function loadMessageConversation(messageData, conversationData) {
    const contentContainer = document.getElementById("message-detail-content");
    if (!contentContainer) return; // 清空现有内容
    contentContainer.innerHTML = ""; // 🔧 检测并设置账户类型（如果未设置）
    if (!messageData._accountType && messageData.id) {
      if (messageData.id.startsWith("msg_account_")) {
        messageData._accountType = "account";
      } else if (messageData.id.startsWith("msg_npc_")) {
        messageData._accountType = "npc";
      } else if (messageData.id.startsWith("msg_relationship_")) {
        messageData._accountType = "relationshipNpc";
      } else if (!messageData.id.startsWith("msg_")) {
        // 其他非角色消息默认为陌生人
        messageData._accountType = "stranger";
      }
      console.log("🔍 [类型检测] 设置消息类型为:", messageData._accountType);
    }
    // 更新顶部栏小头像和昵称
    const topAvatar = document.getElementById("message-detail-top-avatar");
    const topName = document.getElementById("message-detail-top-name");

    // 🔧 清理粉丝群的事件监听器（避免冲突）
    if (topAvatar) {
      if (topAvatar._fangroupClickHandler) {
        topAvatar.removeEventListener("click", topAvatar._fangroupClickHandler);
        delete topAvatar._fangroupClickHandler;
      }
      if (topAvatar._fangroupTouchHandler) {
        topAvatar.removeEventListener(
          "touchend",
          topAvatar._fangroupTouchHandler
        );
        delete topAvatar._fangroupTouchHandler;
      }
    }
    if (topAvatar) topAvatar.src = messageData.user.avatar;
    if (topName) topName.textContent = messageData.user.name; // 为非绑定角色的小头像添加点击事件（打开设置）
    const isCharacterMessage =
      messageData.id &&
      messageData.id.startsWith("msg_") &&
      messageData.id !== "msg_001" &&
      !messageData.id.startsWith("msg_account_");
    if (topAvatar && !isCharacterMessage) {
      topAvatar.style.cursor = "pointer";
      topAvatar.onclick = (e) => {
        e.stopPropagation(); // 使用通用联系人设置弹窗（支持账户/NPC/关系NPC/陌生人）
        console.log(
          "📱 [小头像点击] 打开联系人设置，类型:",
          messageData._accountType
        );
        openMessageContactSettings(messageData, conversationData);
      };
    } else if (topAvatar) {
      topAvatar.style.cursor = "default";
      topAvatar.onclick = null;
    }
    // 更新中间详细信息区域
    const detailAvatar = document.getElementById("message-detail-avatar");
    const detailName = document.getElementById("message-detail-name");
    const detailHandle = document.getElementById("message-detail-handle");
    if (detailAvatar) {
      detailAvatar.src = messageData.user.avatar; // 添加点击事件，进入对方主页
      detailAvatar.style.cursor = "pointer";
      detailAvatar.onclick = () => {
        openAccountProfileFromDM(messageData, conversationData);
      };
    }
    if (detailName) detailName.textContent = messageData.user.name;
    if (detailHandle) detailHandle.textContent = messageData.user.handle; // 使用AI生成的简介
    const bioEl = document.getElementById("message-detail-bio");
    if (conversationData?.senderProfile?.bio && bioEl) {
      bioEl.textContent = conversationData.senderProfile.bio;
      bioEl.style.display = "block";
    } else if (bioEl) {
      bioEl.style.display = "none";
    }
    // 使用AI生成的关注者数量
    const followersCount =
      conversationData?.senderProfile?.followers ||
      Math.floor(Math.random() * 1000) + 100;
    const config = languageConfig[currentLanguage] || languageConfig.zh;
    if (currentLanguage === "en") {
      document.getElementById(
        "message-detail-followers"
      ).textContent = `${followersCount} ${config.messageFollowers}`;
    } else {
      document.getElementById(
        "message-detail-followers"
      ).textContent = `${followersCount} ${config.messageFollowers}`;
    }
    // 渲染日期分隔符（示例：当前日期）
    const today = new Date();
    const dateStr =
      currentLanguage === "en"
        ? today.toLocaleDateString("en-US", {
            year: "numeric",
            month: "long",
            day: "numeric",
          })
        : `${today.getFullYear()}年${today.getMonth() + 1}月${String(
            today.getDate()
          ).padStart(2, "0")}日`;
    contentContainer.appendChild(renderDateSeparator(dateStr)); // 渲染消息记录（使用消息本身的isOwn属性判断位置）
    if (
      conversationData &&
      conversationData.messages &&
      conversationData.messages.length > 0
    ) {
      // 使用分组渲染消息
      const groups = groupMessagesBySender(conversationData.messages);
      const allMessageElements = [];
      groups.forEach((group) => {
        const isOwn = group[0].message.isOwn === true;
        group.forEach((item, indexInGroup) => {
          const isLastInGroup = indexInGroup === group.length - 1;
          const messageEl = renderMessageItem(
            item.message,
            isOwn,
            item.index,
            isLastInGroup
          );
          contentContainer.appendChild(messageEl);
          allMessageElements.push(messageEl);
        });
      }); // 立即显示所有消息（历史消息不需要动画）
      allMessageElements.forEach((el) => {
        el.style.opacity = "1";
        el.style.transform = "translateY(0)";
      });
    } else {
      // 如果没有生成数据，显示预览消息
      const messageEl = renderMessageItem(
        {
          type: "text",
          content: messageData.preview,
          time: "刚刚",
        },
        false,
        0,
        true
      );
      contentContainer.appendChild(messageEl); // 立即显示
      messageEl.style.opacity = "1";
      messageEl.style.transform = "translateY(0)";
    }
    // 滚动到底部（使用外层可滚动容器）
    setTimeout(() => {
      const scrollable = document.getElementById("message-detail-scrollable");
      if (scrollable) {
        scrollable.scrollTop = scrollable.scrollHeight;
      }
    }, 100);
  }
  // 打开私信详情页面
  window.openMessageDetail = async function (messageData) {
    // 🔧 检测并设置账户类型（如果未设置）
    if (!messageData._accountType && messageData.id) {
      if (messageData.id.startsWith("msg_account_")) {
        messageData._accountType = "account";
      } else if (messageData.id.startsWith("msg_npc_")) {
        messageData._accountType = "npc";
      } else if (messageData.id.startsWith("msg_relationship_")) {
        messageData._accountType = "relationshipNpc";
      } else if (
        !messageData.id.startsWith("msg_") ||
        messageData.id === "msg_001"
      ) {
        // 其他非角色消息默认为陌生人
        messageData._accountType = "stranger";
      }
      console.log(
        "🔍 [打开私信] 检测到类型:",
        messageData._accountType,
        "| ID:",
        messageData.id
      );
    }

    // 🔧 重要：清理旧的type字段，确保不会误判为粉丝群
    // 只有真正的粉丝群才会保留type字段
    if (messageData.type !== "fangroup") {
      // 如果不是粉丝群，删除type字段以避免误判
      delete messageData.type;
    }

    currentMessageConversation = messageData;
    userMessageQueue = []; // 检测来源页面
    const messagesPage = document.getElementById("x-messages-page");
    const notificationsPage = document.getElementById("x-notifications-page");
    const isFromNotifications =
      notificationsPage && notificationsPage.style.display === "flex"; // 隐藏私信列表页面和浮动按钮
    messagesPage.style.display = "none";
    const composeBtn = document.getElementById("compose-message-btn");
    if (composeBtn) composeBtn.style.display = "none"; // 如果是从通知页面打开的，也要隐藏通知页面
    if (isFromNotifications) {
      notificationsPage.style.display = "none";
    }
    // 隐藏羽毛笔按钮（刷新陌生人私信按钮）
    const refreshMessagesBtn = document.getElementById("refresh-messages-btn");
    if (refreshMessagesBtn) refreshMessagesBtn.style.display = "none"; // 显示私信详情页面
    const detailPage = document.getElementById("x-message-detail-page");
    detailPage.style.display = "flex";
    // 保存当前对话ID，用于文章转发时判断是否需要刷新页面
    detailPage.dataset.conversationId = messageData.id;
    // 保存来源页面标记
    detailPage.dataset.fromNotifications = isFromNotifications
      ? "true"
      : "false"; // 🔧 初始化输入框状态为启用（防止之前被拉黑的对话影响）
    setTimeout(() => {
      const messageInput = document.getElementById("message-input");
      const sendBtn = document.getElementById("message-send-btn");
      if (messageInput) {
        messageInput.disabled = false;
        messageInput.placeholder = "发送私信";
      }
      if (sendBtn) {
        sendBtn.disabled = false;
      }
    }, 50);
    const xDb = getXDB(); // 清除未读标记
    try {
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      if (savedData && savedData.data) {
        const messagesList = savedData.data;
        const messageIndex = messagesList.findIndex(
          (msg) => msg.id === messageData.id
        );
        if (messageIndex !== -1 && messagesList[messageIndex].unread) {
          // 清除未读标记
          messagesList[messageIndex].unread = false;
          messagesList[messageIndex].unreadCount = 0; // 保存回数据库
          await xDb.xAccountProfiles.put({
            handle: dataId,
            name: "messagesList",
            data: messagesList,
            updatedAt: new Date().toISOString(),
          }); // 同步更新全局数据
          sampleMessagesData = messagesList;
          console.log("✅ 已清除未读标记");
        }
      }
    } catch (error) {
      console.error("清除未读标记失败:", error);
    }
    // 检查是否是粉丝群
    const isFanGroup =
      messageData.type === "fangroup" ||
      (messageData.id && messageData.id.startsWith("fangroup_"));
    if (isFanGroup) {
      // 粉丝群，直接加载粉丝群详情页（不触发 AI 生成）
      console.log("👥 检测到粉丝群，加载粉丝群详情页");
      loadFanGroupMessageDetail(messageData);
      return;
    }
    // 检查是否是已绑定角色的私信（id格式为 msg_characterId）
    const isCharacterMessage =
      messageData.id &&
      messageData.id.startsWith("msg_") &&
      messageData.id !== "msg_001";
    if (isCharacterMessage) {
      // 已绑定角色，尝试从账户主页数据中读取资料
      console.log("📨 检测到已绑定角色私信，从账户主页数据读取资料");
      const characterId = messageData.id.replace("msg_", "");
      try {
        // 从 xCharacterProfiles 获取角色的X资料
        const xProfile = await xDb.xCharacterProfiles.get(characterId);
        if (xProfile) {
          // 尝试从 xAccountProfiles 读取该角色的账户主页数据
          const cleanHandle = xProfile.xHandle.replace("@", "");
          const accountProfile = await xDb.xAccountProfiles.get(cleanHandle);
          if (accountProfile && accountProfile.accountInfo) {
            console.log("✅ 找到角色的账户主页数据"); // 使用账户主页数据，但用最新的X资料头像覆盖
            const updatedAccountInfo = {
              ...accountProfile.accountInfo,
              avatar: xProfile.xAvatar, // 使用最新的X资料头像
              name: xProfile.xName, // 同时更新名称
              handle: xProfile.xHandle, // 同时更新句柄
            };
            loadCharacterMessageDetail(messageData, updatedAccountInfo);
            return;
          }
        }
        console.log("⚠️ 未找到角色的账户主页数据，使用基本资料"); // 如果没有账户主页数据，使用X资料
        if (xProfile) {
          const basicProfile = {
            name: xProfile.xName,
            handle: xProfile.xHandle,
            avatar: xProfile.xAvatar,
            bio: xProfile.xBio || "",
            followersCount: xProfile.followersCount || "0",
            verified: xProfile.xVerified || false,
          };
          loadCharacterMessageDetail(messageData, basicProfile);
          return;
        }
      } catch (error) {
        console.error("读取角色资料失败:", error);
      }
    }
    // 陌生人私信，走原来的生成流程
    // 标准化messageData格式（兼容两种格式）
    if (!messageData.user && messageData.userName) {
      messageData.user = {
        name: messageData.userName,
        handle: messageData.userHandle,
        avatar: messageData.userAvatar,
        verified: messageData.verified || false,
      };
    }
    // 🔧 多账户隔离：包含账户ID
    const conversationId = `messageConversation_${currentAccountId || "main"}_${
      messageData.id
    }`;
    let conversationData = null;
    try {
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (savedConversation && savedConversation.data) {
        conversationData = savedConversation.data;
        console.log("✅ 从数据库加载私信对话数据"); // 🔍 检查拉黑状态
        if (savedConversation.isBlocked) {
          console.log("⚠️ [拉黑] 该用户已被拉黑"); // 加载会话内容
          loadMessageConversation(messageData, conversationData); // 禁用输入框和发送按钮
          setTimeout(() => {
            const messageInput = document.getElementById("message-input");
            const sendBtn = document.getElementById("message-send-btn");
            if (messageInput) {
              messageInput.disabled = true;
              messageInput.placeholder = "对方已将你拉黑";
            }
            if (sendBtn) {
              sendBtn.disabled = true;
            }
          }, 100);
          return;
        }
        // 加载已有的会话内容
        loadMessageConversation(messageData, conversationData);
      }
    } catch (error) {
      console.error("加载私信对话数据失败:", error);
    }
    // 如果没有已有数据，生成新的对话内容
    if (!conversationData) {
      // 先显示加载状态
      const contentContainer = document.getElementById(
        "message-detail-content"
      );
      if (contentContainer) {
        contentContainer.innerHTML = `
 <div style="flex: 1; display: flex; align-items: center; justify-content: center;">
 <div style="text-align: center;">
 <div style="margin-bottom: 12px;">
 <svg viewBox="0 0 24 24" style="width: 48px; height: 48px; fill: var(--x-accent); animation: spin 1s linear infinite;">
 <g><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"></path></g>
 </svg>
 </div>
 <div style="color:var(--x-text-primary); font-size: 16px; font-weight: 600;">正在生成对话详情...</div>
 </div>
 </div>
 `;
      }
      // 生成新的对话内容
      conversationData = await generateMessageConversation(messageData); // 加载生成的会话内容
      if (conversationData) {
        loadMessageConversation(messageData, conversationData);
      } else {
        // 生成失败，显示预览内容
        loadMessageConversation(messageData, null);
      }
    }
  }; // 关闭私信详情页面
  window.closeMessageDetail = async function () {
    // 清空输入框
    const input = document.getElementById("message-input");
    if (input) {
      input.value = "";
      autoResizeMessageInput(input);
    }
    // 获取私信详情页面
    const detailPage = document.getElementById("x-message-detail-page");
    const isFromNotifications = detailPage.dataset.fromNotifications === "true"; // 隐藏私信详情页面
    detailPage.style.display = "none"; // 判断是从哪里打开的私信详情页
    // 🔧 优先检查明确的来源标记
    const isFromAccountProfile =
      currentMessageConversation &&
      currentMessageConversation._fromAccountProfile === true;

    if (isFromAccountProfile) {
      console.log("📖 [返回] 从私信详情页返回账户主页");
      // 返回账户主页
      const accountProfilePage = document.getElementById(
        "account-profile-page"
      );
      if (accountProfilePage) {
        accountProfilePage.style.display = "flex";
      }
    } else if (isFromNotifications) {
      console.log("📖 [返回] 从私信详情页返回通知页面"); // 返回通知页面
      document.getElementById("x-notifications-page").style.display = "flex"; // 重新显示羽毛笔按钮（如果当前在All标签）
      const refreshMessagesBtn = document.getElementById(
        "refresh-messages-btn"
      );
      const isAllTab =
        document
          .querySelector(".notification-tab.active")
          ?.textContent.includes("全部") ||
        document
          .querySelector(".notification-tab.active")
          ?.textContent.includes("All");
      if (refreshMessagesBtn && isAllTab) {
        refreshMessagesBtn.style.display = "flex";
      }
      // 重新加载通知以显示更新后的未读状态
      if (typeof loadNotifications === "function") {
        await loadNotifications();
      }
    } else {
      console.log("📖 [返回] 从私信详情页返回私信列表"); // 返回私信列表页面
      document.getElementById("x-messages-page").style.display = "flex"; // 显示浮动按钮
      const composeBtn = document.getElementById("compose-message-btn");
      if (composeBtn) composeBtn.style.display = "flex"; // 重新渲染私信列表以显示更新后的未读状态
      if (typeof renderMessagesList === "function") {
        renderMessagesList(sampleMessagesData);
      }
    }
    // 清空状态
    currentMessageConversation = null;
    userMessageQueue = [];
  }; // 自动调整输入框高度
  window.autoResizeMessageInput = function (textarea) {
    textarea.style.height = "36px";
    const scrollHeight = textarea.scrollHeight;
    if (scrollHeight > 36) {
      textarea.style.height = Math.min(scrollHeight, 100) + "px";
    }
  }; // 处理输入框回车键
  window.handleMessageInputKeydown = function (event) {
    if (event.key === "Enter" && !event.shiftKey) {
      event.preventDefault();
      sendMessageContent();
    }
  }; // 切换私信功能菜单显示/隐藏
  window.toggleMessageFunctionMenu = function () {
    const menu = document.getElementById("message-function-menu");
    const addBtn = document.getElementById("message-add-btn");
    if (!menu || !addBtn) return;
    const isVisible = menu.style.display === "flex";
    if (isVisible) {
      menu.style.display = "none"; // 旋转加号回原位
      const svg = addBtn.querySelector("svg");
      if (svg) svg.style.transform = "rotate(0deg)";
    } else {
      menu.style.display = "flex"; // 旋转加号45度变成X
      const svg = addBtn.querySelector("svg");
      if (svg) svg.style.transform = "rotate(45deg)";
    }
  }; // 点击页面其他地方关闭功能菜单
  document.addEventListener("click", function (e) {
    const menu = document.getElementById("message-function-menu");
    const addBtn = document.getElementById("message-add-btn");
    if (!menu || !addBtn) return; // 如果点击的不是菜单或加号按钮，关闭菜单
    if (!menu.contains(e.target) && !addBtn.contains(e.target)) {
      menu.style.display = "none";
      const svg = addBtn.querySelector("svg");
      if (svg) svg.style.transform = "rotate(0deg)";
    }
  }); // 打开图片类型选择器
  window.openImageTypeSelector = function () {
    const dialog = document.getElementById("image-type-selector-dialog");
    if (dialog) {
      dialog.style.display = "flex";
    }
  }; // 关闭图片类型选择器
  window.closeImageTypeSelector = function () {
    const dialog = document.getElementById("image-type-selector-dialog");
    if (dialog) {
      dialog.style.display = "none";
    }
  }; // 选择图片类型
  window.selectImageType = function (type) {
    closeImageTypeSelector();
    if (type === "real") {
      // 上传真实图片
      triggerMessageImageUpload();
    } else if (type === "text") {
      // 打开文字图片输入框
      openTextImageDialog();
    }
  }; // 打开文字图片对话框
  function openTextImageDialog() {
    const dialog = document.getElementById("text-image-dialog");
    const input = document.getElementById("text-image-description-input");
    const counter = document.getElementById("text-image-counter");
    if (dialog) {
      dialog.style.display = "flex";
    }
    if (input) {
      input.value = "";
    }
    if (counter) {
      counter.textContent = "0 / 500";
    }
    // 聚焦到输入框
    setTimeout(() => {
      if (input) input.focus();
    }, 100);
  }
  // 关闭文字图片对话框
  window.closeTextImageDialog = function () {
    const dialog = document.getElementById("text-image-dialog");
    if (dialog) {
      dialog.style.display = "none";
    }
  }; // 更新文字图片字符计数
  window.updateTextImageCounter = function () {
    const input = document.getElementById("text-image-description-input");
    const counter = document.getElementById("text-image-counter");
    if (input && counter) {
      counter.textContent = `${input.value.length} / 500`;
    }
  }; // 发送文字图片
  window.sendTextImage = async function () {
    const input = document.getElementById("text-image-description-input");
    if (!input) return;
    const description = input.value.trim();
    if (!description) {
      showXToast("请输入图片描述", "error");
      return;
    }
    // 关闭对话框
    closeTextImageDialog(); // 获取当前时间
    const now = new Date();
    const hours = now.getHours();
    const minutes = String(now.getMinutes()).padStart(2, "0");
    const timeStr = `${hours}:${minutes}`; // 创建文字图片消息对象
    const textImageMessage = {
      type: "image",
      imageDescription: description,
      sensitive: false,
      time: timeStr,
      timestamp: now.toISOString(),
      isOwn: true,
    }; // 添加到消息队列
    userMessageQueue.push(textImageMessage); // 渲染新消息
    const contentContainer = document.getElementById("message-detail-content");
    if (contentContainer) {
      const currentMessageCount =
        contentContainer.querySelectorAll(".message-item").length;
      const newMessage = renderMessageItem(
        textImageMessage,
        true,
        currentMessageCount
      );
      contentContainer.appendChild(newMessage); // 立即显示动画
      setTimeout(() => {
        newMessage.style.transition = "all 0.3s ease";
        newMessage.style.opacity = "1";
        newMessage.style.transform = "translateY(0)";
      }, 10); // 滚动到底部
      setTimeout(() => {
        const scrollable = document.getElementById("message-detail-scrollable");
        if (scrollable) {
          scrollable.scrollTo({
            top: scrollable.scrollHeight,
            behavior: "smooth",
          });
        }
      }, 100);
    }
    // 保存到数据库
    await saveUserMessageToDB(textImageMessage);
    console.log("✅ 文字图片消息已添加到队列，等待发送");
  }; // 触发图片上传
  window.triggerMessageImageUpload = function () {
    const input = document.getElementById("message-image-input");
    if (input) input.click();
  }; // 存储待发送的图片数据
  let pendingMessageImages = []; // 处理图片上传（支持多图）
  window.handleMessageImageUpload = async function (event) {
    const files = event.target.files;
    if (!files || files.length === 0) return; // 验证图片数量（最多4张）
    if (pendingMessageImages.length + files.length > 4) {
      showXToast("最多只能上传4张图片", "error");
      return;
    }
    for (let i = 0; i < files.length; i++) {
      const file = files[i]; // 验证文件类型
      if (!file.type.startsWith("image/")) {
        showXToast("请选择图片文件", "error");
        continue;
      }
      // 验证文件大小
      if (file.size > 5 * 1024 * 1024) {
        showXToast("图片文件不能超过5MB", "error");
        continue;
      }
      const reader = new FileReader();
      reader.onload = function (e) {
        const base64Data = e.target.result; // 添加到待发送列表
        pendingMessageImages.push({
          content: base64Data,
          fileName: file.name,
        }); // 立即发送图片消息
        sendImageMessage(base64Data, file.name);
        console.log(`✅ 图片 ${file.name} 已添加并发送`);
      };
      reader.readAsDataURL(file);
    }
    // 清空输入框，允许重新选择相同文件
    event.target.value = "";
  }; // 发送图片消息（立即显示，但不触发AI回复）
  async function sendImageMessage(base64Data, fileName) {
    // 获取当前时间
    const now = new Date();
    const hours = now.getHours();
    const minutes = String(now.getMinutes()).padStart(2, "0");
    const period = hours >= 12 ? "下午" : "上午";
    const timeStr = `${hours > 12 ? hours - 12 : hours}:${minutes} ${period}`; // 创建图片消息对象
    const imageMessage = {
      type: "image",
      imageData: base64Data,
      fileName: fileName,
      time: timeStr,
      timestamp: now.toISOString(),
      isOwn: true,
    }; // 添加到消息队列
    userMessageQueue.push(imageMessage); // 渲染新消息
    const contentContainer = document.getElementById("message-detail-content");
    if (contentContainer) {
      const currentMessageCount = contentContainer.querySelectorAll(
        ".message-item:not(#typing-indicator)"
      ).length;
      const newMessage = renderMessageItem(
        imageMessage,
        true,
        currentMessageCount,
        true
      );
      contentContainer.appendChild(newMessage); // 立即显示动画
      setTimeout(() => {
        newMessage.style.transition = "all 0.3s ease";
        newMessage.style.opacity = "1";
        newMessage.style.transform = "translateY(0)";
      }, 10); // 滚动到底部
      setTimeout(() => {
        const scrollable = document.getElementById("message-detail-scrollable");
        if (scrollable) {
          scrollable.scrollTo({
            top: scrollable.scrollHeight,
            behavior: "smooth",
          });
        }
      }, 100);
    }
    // 保存到数据库
    await saveUserMessageToDB(imageMessage);
    console.log("✅ 图片消息已添加到队列，等待发送");
  }
  // 用户已发送的消息队列（等待AI回复）
  let userMessageQueue = []; // 表情包管理
  let userStickers = [];
  let currentStickerTab = "frequent"; // 'frequent' | 'all'
  // 加载用户表情包
  async function loadUserStickers() {
    try {
      const xDb = getXDB();
      const accountId = currentAccountId || "main";
      const stickerDataId = `userStickers_${accountId}`;
      const stickerData = await xDb.xUserTweets.get(stickerDataId);
      if (stickerData && stickerData.stickers) {
        userStickers = stickerData.stickers; // 确保每个表情包都有使用统计
        userStickers = userStickers.map((sticker) => ({
          ...sticker,
          useCount: sticker.useCount || 0,
          lastUsedAt: sticker.lastUsedAt || null,
        }));
      } else {
        userStickers = [];
      }
    } catch (error) {
      console.error("加载表情包失败:", error);
      userStickers = [];
    }
  }
  // 保存用户表情包
  async function saveUserStickers() {
    try {
      const xDb = getXDB();
      const accountId = currentAccountId || "main";
      const stickerDataId = `userStickers_${accountId}`;
      await xDb.xUserTweets.put({
        id: stickerDataId,
        stickers: userStickers,
        updatedAt: new Date().toISOString(),
      });
      console.log("✅ 表情包已保存");
    } catch (error) {
      console.error("保存表情包失败:", error);
    }
  }
  // 打开表情包选择器
  window.openStickerPicker = async function () {
    await loadUserStickers();
    currentStickerTab = "frequent";
    updateStickerTabUI();
    renderStickerList();
    const modal = document.getElementById("sticker-picker-modal");
    if (modal) {
      modal.style.display = "flex";
    }
  }; // 切换表情包标签
  window.switchStickerTab = function (tab) {
    currentStickerTab = tab;
    updateStickerTabUI();
    renderStickerList();
  }; // 更新标签UI
  function updateStickerTabUI() {
    const frequentTab = document.getElementById("sticker-tab-frequent");
    const allTab = document.getElementById("sticker-tab-all");
    if (currentStickerTab === "frequent") {
      frequentTab.style.borderBottomColor = "var(--x-accent)";
      frequentTab.style.color = "var(--x-text-primary)";
      allTab.style.borderBottomColor = "transparent";
      allTab.style.color = "var(--x-text-secondary)";
    } else {
      frequentTab.style.borderBottomColor = "transparent";
      frequentTab.style.color = "var(--x-text-secondary)";
      allTab.style.borderBottomColor = "var(--x-accent)";
      allTab.style.color = "var(--x-text-primary)";
    }
  }
  // 关闭表情包选择器
  window.closeStickerPicker = function () {
    const modal = document.getElementById("sticker-picker-modal");
    if (modal) {
      modal.style.display = "none";
    }

    // 重置评论模式标识
    if (window.setCommentStickerMode) {
      window.setCommentStickerMode(false);
    }
  }; // 渲染表情包列表（分批异步渲染，避免UI阻塞）
  function renderStickerList() {
    const listContainer = document.getElementById("sticker-list");
    if (!listContainer) return; // 根据屏幕宽度动态调整网格列宽
    const screenWidth = window.innerWidth;
    let minColumnWidth = "80px";
    if (screenWidth < 400) {
      minColumnWidth = "70px"; // 小屏幕
    } else if (screenWidth < 500) {
      minColumnWidth = "75px"; // 中等屏幕
    }
    listContainer.style.gridTemplateColumns = `repeat(auto-fill, minmax(${minColumnWidth}, 1fr))`;
    listContainer.innerHTML = ""; // 获取要显示的表情包
    let displayStickers = [];
    if (currentStickerTab === "frequent") {
      // 常用：取使用次数 > 0 的，按使用次数和最近使用时间排序
      const frequentStickers = userStickers
        .filter((s) => s.useCount > 0)
        .sort((a, b) => {
          // 优先按使用次数排序
          if (b.useCount !== a.useCount) {
            return b.useCount - a.useCount;
          }
          // 使用次数相同，按最近使用时间排序
          if (a.lastUsedAt && b.lastUsedAt) {
            return new Date(b.lastUsedAt) - new Date(a.lastUsedAt);
          }
          return 0;
        })
        .slice(0, 20); // 最多显示20个常用表情包
      displayStickers = frequentStickers;
      if (frequentStickers.length === 0) {
        listContainer.style.display = "flex";
        listContainer.innerHTML = `
 <div style="width: 100%; text-align: center; padding: 60px 20px; color:var(--x-text-secondary); ">
 <div style="font-size: 48px; margin-bottom: 12px;">😊</div>
 <div style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">暂无常用表情包</div>
 <div style="font-size: 13px;">使用过的表情包会出现在这里</div>
 </div>
 `;
        return;
      } else {
        listContainer.style.display = "grid";
      }
    } else {
      // 全部：按添加时间倒序
      displayStickers = [...userStickers].reverse();
      if (userStickers.length === 0) {
        listContainer.style.display = "flex";
        listContainer.innerHTML = `
 <div style="width: 100%; text-align: center; padding: 60px 20px; color:var(--x-text-secondary); ">
 <div style="font-size: 48px; margin-bottom: 12px;">📦</div>
 <div style="font-size: 14px; margin-bottom: 8px; font-weight: 600;">暂无表情包</div>
 <div style="font-size: 13px;">点击下方"导入表情包"添加</div>
 </div>
 `;
        return;
      } else {
        listContainer.style.display = "grid";
      }
    }

    // 🚀 分批异步渲染：每10个一批，避免UI阻塞
    const BATCH_SIZE = 10;
    const totalCount = displayStickers.length;
    let currentIndex = 0;

    // 显示加载提示（仅当数量较多时）
    if (totalCount > BATCH_SIZE) {
      const loadingEl = document.createElement("div");
      loadingEl.id = "sticker-loading-indicator";
      loadingEl.style.cssText = `
        grid-column: 1 / -1;
        text-align: center;
        padding: 20px;
        color: var(--x-text-secondary);
        font-size: 13px;
      `;
      loadingEl.textContent = `正在加载表情包... (0/${totalCount})`;
      listContainer.appendChild(loadingEl);
    }

    // 分批渲染函数
    function renderBatch() {
      const batchEnd = Math.min(currentIndex + BATCH_SIZE, totalCount);
      const batch = displayStickers.slice(currentIndex, batchEnd);

      // 创建文档碎片，减少DOM操作次数
      const fragment = document.createDocumentFragment();

      batch.forEach((sticker, batchIndex) => {
        const displayIndex = currentIndex + batchIndex;
        // 找到原始索引
        const originalIndex = userStickers.findIndex(
          (s) => s.url === sticker.url && s.description === sticker.description
        );

        const stickerEl = document.createElement("div");
        stickerEl.style.cssText = `
          position: relative; cursor: pointer; border-radius: 8px; overflow: hidden; 
          transition: transform 0.2s; width: 100%; padding-bottom: 100%; 
          background-color:var(--x-bg-secondary);
        `;
        stickerEl.onmouseover = () => {
          stickerEl.style.transform = "scale(1.05)";
        };
        stickerEl.onmouseout = () => {
          stickerEl.style.transform = "scale(1)";
        };
        stickerEl.onclick = () => {
          // 检查是否在评论模式
          if (window.getCommentStickerMode && window.getCommentStickerMode()) {
            // 评论模式：调用评论表情包选择函数
            if (window.selectCommentSticker) {
              window.selectCommentSticker(sticker);
            }
          } else {
            // 正常模式：发送私信表情包
            sendStickerMessage(sticker);
            closeStickerPicker();
          }
        };
        stickerEl.innerHTML = `
          <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;">
            <img src="${sticker.url}" alt="${sticker.description}"
              style="width: 100%; height: 100%; object-fit: cover; display: block;"
              onerror="this.parentElement.innerHTML='<div style=\\'display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%; background-color:var(--x-bg-secondary); color:var(--x-text-secondary); font-size: 11px; padding: 4px; text-align: center;\\'>❌<br>加载失败<br><button onclick=\\'deleteSticker(${originalIndex})\\' style=\\'margin-top: 4px; padding: 2px 6px; font-size: 10px; background: var(--x-accent); color: white; border: none; border-radius: 4px; cursor: pointer;\\'>删除</button></div>';">
          </div>
          <button onclick="deleteSticker(${originalIndex}); event.stopPropagation();"
            ontouchstart="this.style.opacity='1'"
            style="position: absolute; top: 4px; right: 4px; background: rgba(0,0,0,0.7); border: none; border-radius: 50%; width: 24px; height: 24px; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; opacity: 0; transition: opacity 0.2s; z-index: 2; " 
            onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0'">
            <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: #fff;">
              <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
            </svg>
          </button>
        `;
        fragment.appendChild(stickerEl);
      });

      // 一次性添加整批元素
      listContainer.appendChild(fragment);

      currentIndex = batchEnd;

      // 更新加载提示
      if (totalCount > BATCH_SIZE) {
        const loadingEl = document.getElementById("sticker-loading-indicator");
        if (loadingEl) {
          if (currentIndex < totalCount) {
            loadingEl.textContent = `正在加载表情包... (${currentIndex}/${totalCount})`;
          } else {
            loadingEl.remove();
          }
        }
      }

      // 如果还有未渲染的，继续下一批
      if (currentIndex < totalCount) {
        requestAnimationFrame(renderBatch);
      } else {
        console.log(
          `✅ [表情包渲染] 完成，共${totalCount}个，分${Math.ceil(
            totalCount / BATCH_SIZE
          )}批渲染`
        );
      }
    }

    // 启动第一批渲染
    requestAnimationFrame(renderBatch);
  }
  // 删除表情包
  window.deleteSticker = async function (index) {
    if (confirm("确定要删除这个表情包吗？")) {
      userStickers.splice(index, 1);
      await saveUserStickers(); // 如果管理器打开，更新管理器
      const managerDialog = document.getElementById("sticker-manager-dialog");
      if (managerDialog && managerDialog.style.display === "flex") {
        renderStickerManager();
      }
      // 如果选择器打开，更新选择器
      const pickerModal = document.getElementById("sticker-picker-modal");
      if (pickerModal && pickerModal.style.display === "flex") {
        renderStickerList();
      }
      showXToast("已删除", "success");
    }
  }; // 打开添加表情包对话框
  window.openAddStickerDialog = function () {
    const dialog = document.getElementById("add-sticker-dialog");
    if (dialog) {
      dialog.style.display = "flex"; // 清空输入框
      const batchInput = document.getElementById("sticker-batch-input");
      if (batchInput) {
        batchInput.value = "";
      }
    }
  }; // 关闭添加表情包对话框
  window.closeAddStickerDialog = function () {
    const dialog = document.getElementById("add-sticker-dialog");
    if (dialog) {
      dialog.style.display = "none";
    }
  }; // ============================================
  // 语音消息功能
  // ============================================
  // 打开语音消息对话框
  window.openVoiceMessageDialog = function () {
    const dialog = document.getElementById("voice-message-dialog");
    if (dialog) {
      dialog.style.display = "flex"; // 清空输入框
      const textInput = document.getElementById("voice-message-text-input");
      if (textInput) {
        textInput.value = "";
        textInput.focus();
      }
    }
  }; // 关闭语音消息对话框
  window.closeVoiceMessageDialog = function () {
    const dialog = document.getElementById("voice-message-dialog");
    if (dialog) {
      dialog.style.display = "none";
    }
  }; // 发送语音消息
  window.sendVoiceMessage = function () {
    const textInput = document.getElementById("voice-message-text-input");
    if (!textInput) return;
    const voiceText = textInput.value.trim();
    if (!voiceText) {
      showXToast("请输入语音内容", "error");
      return;
    }
    // 估算语音时长（假设每10个字符约1秒）
    const estimatedDuration = Math.max(5, Math.ceil(voiceText.length / 10));
    const minutes = Math.floor(estimatedDuration / 60);
    const seconds = estimatedDuration % 60;
    const durationStr =
      minutes > 0
        ? `${minutes}:${String(seconds).padStart(2, "0")}`
        : `0:${String(seconds).padStart(2, "0")}`; // 创建语音消息对象
    const now = new Date();
    const hours = now.getHours();
    const minutesNow = String(now.getMinutes()).padStart(2, "0");
    const period = hours >= 12 ? "下午" : "上午";
    const timeStr = `${
      hours > 12 ? hours - 12 : hours
    }:${minutesNow} ${period}`;
    const voiceMessage = {
      type: "voice",
      voiceText: voiceText,
      duration: durationStr,
      time: timeStr,
      timestamp: now.toISOString(),
      isOwn: true,
    }; // 添加到消息队列
    userMessageQueue.push(voiceMessage); // 渲染到界面
    const contentContainer = document.getElementById("message-detail-content");
    if (contentContainer) {
      const messageEl = renderMessageItem(
        voiceMessage,
        true,
        undefined,
        true,
        true
      );
      contentContainer.appendChild(messageEl); // 动画显示
      requestAnimationFrame(() => {
        messageEl.style.opacity = "1";
        messageEl.style.transform = "translateY(0)";
      }); // 滚动到底部
      setTimeout(() => {
        const scrollable = document.getElementById("message-detail-scrollable");
        if (scrollable) {
          scrollable.scrollTop = scrollable.scrollHeight;
        }
      }, 100);
    }
    // 保存到数据库
    saveUserMessageToDB(voiceMessage); // 关闭对话框
    closeVoiceMessageDialog();
    console.log("✅ [语音消息] 已添加到队列:", voiceMessage);
  }; // 打开表情包管理器
  window.openStickerManager = async function () {
    await loadUserStickers();
    renderStickerManager();
    const dialog = document.getElementById("sticker-manager-dialog");
    if (dialog) {
      dialog.style.display = "flex";
    }
  }; // 关闭表情包管理器
  window.closeStickerManager = function () {
    const dialog = document.getElementById("sticker-manager-dialog");
    if (dialog) {
      dialog.style.display = "none";
    }
  }; // 渲染表情包管理器列表
  function renderStickerManager() {
    const listContainer = document.getElementById("sticker-manager-list");
    if (!listContainer) return;
    listContainer.innerHTML = "";
    if (userStickers.length === 0) {
      listContainer.innerHTML = `
 <div style="text-align: center; padding: 40px 20px; color:var(--x-text-secondary);">
 <div style="font-size: 14px;">暂无表情包</div>
 </div>
 `;
      return;
    }
    userStickers.forEach((sticker, index) => {
      const itemEl = document.createElement("div");
      itemEl.style.cssText = `
 padding: 12px; margin-bottom: 8px; background-color:var(--x-bg-secondary); border-radius: 8px; display: flex; gap: 12px; align-items: flex-start; `;
      itemEl.innerHTML = `
 <img src="${sticker.url}"
 style="width: 60px; height: 60px; object-fit: cover; border-radius: 6px; flex-shrink: 0;"
 onerror="this.src=''; this.style.background='var(--x-bg-hover)'; this.style.display='flex'; this.style.alignItems='center'; this.style.justifyContent='center';">
 <div style="flex: 1; min-width: 0;">
 <div style="font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 4px;">
 ${sticker.description}
 </div>
 <div style="font-size: 12px; color:var(--x-text-secondary); word-break: break-all; margin-bottom: 4px;">
 ${sticker.url}
 </div>
 <div style="font-size: 11px; color:var(--x-text-secondary);">
 使用次数: ${sticker.useCount || 0}
 ${
   sticker.lastUsedAt
     ? `· 最后使用: ${new Date(sticker.lastUsedAt).toLocaleString("zh-CN")}`
     : ""
 }
 </div>
 </div>
 <button onclick="editSticker(${index}); event.stopPropagation();" style="background-color: var(--x-bg-hover); color:var(--x-text-primary); border: none; border-radius: 6px; padding: 6px 12px; font-size: 12px; cursor: pointer; flex-shrink: 0; ">编辑</button>
 <button onclick="deleteSticker(${index}); event.stopPropagation();" style="background-color: rgba(239, 68, 68, 0.1); color: rgb(239, 68, 68); border: none; border-radius: 6px; padding: 6px 12px; font-size: 12px; cursor: pointer; flex-shrink: 0; ">删除</button>
 `;
      listContainer.appendChild(itemEl);
    });
  }
  // 编辑表情包
  window.editSticker = function (index) {
    const sticker = userStickers[index];
    if (!sticker) return;
    const newDescription = prompt("修改描述:", sticker.description);
    if (newDescription === null) return;
    const newUrl = prompt("修改链接:", sticker.url);
    if (newUrl === null) return; // 验证URL
    try {
      const urlObj = new URL(newUrl.trim());
      userStickers[index].description = newDescription.trim();
      userStickers[index].url = urlObj.href;
      saveUserStickers().then(() => {
        renderStickerManager();
        showXToast("修改成功", "success");
      });
    } catch (e) {
      showXToast("链接格式无效", "error");
    }
  }; // 清空所有表情包
  window.clearAllStickers = async function () {
    if (
      !confirm(
        `确定要清空所有 ${userStickers.length} 个表情包吗？此操作不可恢复！`
      )
    ) {
      return;
    }
    userStickers = [];
    await saveUserStickers();
    renderStickerManager();
    renderStickerList();
    showXToast("已清空所有表情包", "success");
  }; // 批量添加表情包
  window.batchAddStickers = async function () {
    const batchInput = document.getElementById("sticker-batch-input");
    const text = batchInput ? batchInput.value.trim() : "";
    if (!text) {
      showXToast("请输入表情包信息", "error");
      return;
    }
    // 解析每一行
    const lines = text.split("\n").filter((line) => line.trim());
    const newStickers = [];
    const errors = [];
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim(); // 使用更严格的正则匹配：描述 + 链接
      // 匹配完整的URL，包括协议、域名、路径
      const urlMatch = line.match(
        /(https?:\/\/[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}(?:\/[^\s]*)?)/
      );
      if (!urlMatch) {
        errors.push(`第${i + 1}行：未找到有效链接`);
        continue;
      }
      let url = urlMatch[0].trim();
      const description = line.substring(0, urlMatch.index).trim();
      if (!description) {
        errors.push(`第${i + 1}行：缺少描述`);
        continue;
      }
      // 验证URL格式
      try {
        const urlObj = new URL(url); // 确保URL包含协议和主机
        if (!urlObj.protocol || !urlObj.host) {
          errors.push(`第${i + 1}行：链接格式无效`);
          continue;
        }
        // 使用标准化的URL
        url = urlObj.href;
      } catch (e) {
        errors.push(`第${i + 1}行：链接格式无效 - ${e.message}`);
        continue;
      }
      // 验证是否为图片链接（可选）
      const imageExtensions = [
        ".jpg",
        ".jpeg",
        ".png",
        ".gif",
        ".webp",
        ".bmp",
        ".svg",
      ];
      const hasImageExtension = imageExtensions.some((ext) =>
        url.toLowerCase().includes(ext)
      );
      if (!hasImageExtension) {
        // 警告但不阻止
        console.warn(`第${i + 1}行：链接可能不是图片格式，但仍会导入`);
      }
      // 检查是否重复
      const isDuplicate = userStickers.some((s) => s.url === url);
      if (isDuplicate) {
        errors.push(`第${i + 1}行：该表情包已存在`);
        continue;
      }
      newStickers.push({
        description,
        url,
        useCount: 0,
        lastUsedAt: null,
        createdAt: new Date().toISOString(),
      });
    }
    if (newStickers.length === 0) {
      if (errors.length > 0) {
        showXToast(errors.join("\n"), "error");
      } else {
        showXToast("没有可导入的表情包", "error");
      }
      return;
    }
    // 添加到表情包列表
    userStickers.push(...newStickers);
    await saveUserStickers();
    renderStickerList();
    closeAddStickerDialog();
    let message = `成功导入${newStickers.length}个表情包`;
    if (errors.length > 0) {
      message += `，${errors.length}个失败`;
    }
    showXToast(message, "success");
  }; // 发送表情包消息（立即显示，但不触发AI回复）
  async function sendStickerMessage(sticker) {
    // 🔒 检查拉黑状态
    const blockCheck = await checkIfBlocked();
    if (blockCheck.isBlocked) {
      showXToast("对方已将你拉黑，无法发送消息", "error");
      return;
    }
    if (blockCheck.error) {
      showXToast(blockCheck.error, "error");
      return;
    }
    // 更新使用统计
    const stickerIndex = userStickers.findIndex(
      (s) => s.url === sticker.url && s.description === sticker.description
    );
    if (stickerIndex !== -1) {
      userStickers[stickerIndex].useCount =
        (userStickers[stickerIndex].useCount || 0) + 1;
      userStickers[stickerIndex].lastUsedAt = new Date().toISOString();
      await saveUserStickers();
    }
    // 获取当前时间
    const now = new Date();
    const hours = now.getHours();
    const minutes = String(now.getMinutes()).padStart(2, "0");
    const period = hours >= 12 ? "下午" : "上午";
    const timeStr = `${hours > 12 ? hours - 12 : hours}:${minutes} ${period}`; // 创建表情包消息对象（发送描述给AI）
    const stickerMessage = {
      type: "sticker",
      stickerDescription: sticker.description, // 描述给AI识别
      stickerUrl: sticker.url, // URL用于显示
      time: timeStr,
      timestamp: now.toISOString(),
      isOwn: true,
    }; // 添加到消息队列
    userMessageQueue.push(stickerMessage); // 渲染新消息
    const contentContainer = document.getElementById("message-detail-content");
    if (contentContainer) {
      const currentMessageCount = contentContainer.querySelectorAll(
        ".message-item:not(#typing-indicator)"
      ).length;
      const newMessage = renderMessageItem(
        stickerMessage,
        true,
        currentMessageCount,
        true
      );
      contentContainer.appendChild(newMessage); // 立即显示动画
      setTimeout(() => {
        newMessage.style.transition = "all 0.3s ease";
        newMessage.style.opacity = "1";
        newMessage.style.transform = "translateY(0)";
      }, 10); // 滚动到底部
      setTimeout(() => {
        const scrollable = document.getElementById("message-detail-scrollable");
        if (scrollable) {
          scrollable.scrollTo({
            top: scrollable.scrollHeight,
            behavior: "smooth",
          });
        }
      }, 100);
    }
    // 保存到数据库
    await saveUserMessageToDB(stickerMessage);
    console.log("✅ 表情包消息已添加到队列，等待发送");
  }
  // 🔒 检查拉黑状态（通用函数）
  async function checkIfBlocked() {
    if (!currentMessageConversation) {
      return { isBlocked: false, error: "会话数据丢失" };
    }
    try {
      const xDb = getXDB();
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${currentMessageConversation.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (savedConversation && savedConversation.isBlocked) {
        console.log("⚠️ [拉黑] 对方已拉黑用户，禁止发送消息"); // 确保输入框被禁用
        const input = document.getElementById("message-input");
        const sendBtn = document.getElementById("message-send-btn");
        if (input) {
          input.disabled = true;
          input.placeholder = "对方已将你拉黑";
        }
        if (sendBtn) {
          sendBtn.disabled = true;
        }
        return { isBlocked: true };
      }
      return { isBlocked: false };
    } catch (error) {
      console.error("检查拉黑状态失败:", error);
      return { isBlocked: false, error: error.message };
    }
  }
  // 发送用户消息
  window.sendMessageContent = async function () {
    const input = document.getElementById("message-input");
    if (!input) return;
    const content = input.value.trim();
    if (!content) return; // 🔒 检查拉黑状态
    const blockCheck = await checkIfBlocked();
    if (blockCheck.isBlocked) {
      showXToast("对方已将你拉黑，无法发送消息", "error");
      return;
    }
    if (blockCheck.error) {
      showXToast(blockCheck.error, "error");
      return;
    }
    // 获取当前时间
    const now = new Date();
    const hours = now.getHours();
    const minutes = String(now.getMinutes()).padStart(2, "0");
    const period = hours >= 12 ? "下午" : "上午";
    const timeStr = `${hours > 12 ? hours - 12 : hours}:${minutes} ${period}`; // 创建用户消息对象
    const userMessage = {
      type: "text",
      content: content,
      time: timeStr,
      timestamp: now.toISOString(),
      isOwn: true,
    }; // 添加到消息队列
    userMessageQueue.push(userMessage); // 渲染新消息
    const contentContainer = document.getElementById("message-detail-content");
    if (contentContainer) {
      // 获取当前消息总数作为新消息的索引（排除typing-indicator）
      const currentMessageCount = contentContainer.querySelectorAll(
        ".message-item:not(#typing-indicator)"
      ).length; // 检查最后一条消息是否也是用户发送的
      const allMessages = Array.from(
        contentContainer.querySelectorAll(
          ".message-item:not(#typing-indicator)"
        )
      );
      const lastMessage = allMessages[allMessages.length - 1];
      const isLastMessageOwn =
        lastMessage
          ?.querySelector("[data-message-index]")
          ?.closest(".message-item")?.style.alignItems === "flex-end"; // 如果最后一条也是用户消息，则当前消息不是最后一条（需要去掉尾巴）
      const newMessage = renderMessageItem(
        userMessage,
        true,
        currentMessageCount,
        true
      );
      contentContainer.appendChild(newMessage); // 立即显示动画
      setTimeout(() => {
        newMessage.style.transition = "all 0.3s ease";
        newMessage.style.opacity = "1";
        newMessage.style.transform = "translateY(0)";
      }, 10); // 滚动到底部（使用外层可滚动容器）
      setTimeout(() => {
        const scrollable = document.getElementById("message-detail-scrollable");
        if (scrollable) {
          scrollable.scrollTo({
            top: scrollable.scrollHeight,
            behavior: "smooth",
          });
        }
      }, 100);
    }
    // 清空输入框
    input.value = "";
    autoResizeMessageInput(input); // 保存到数据库
    await saveUserMessageToDB(userMessage);
    console.log("✅ 用户消息已发送并保存:", content);
  }; // 保存用户消息到数据库
  async function saveUserMessageToDB(userMessage) {
    if (!currentMessageConversation) return;
    try {
      const xDb = getXDB(); // 🔧 多账户隔离：包含账户ID
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${currentMessageConversation.id}`; // 读取现有对话数据
      let savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (savedConversation && savedConversation.data) {
        // 添加用户消息到messages数组
        if (!savedConversation.data.messages) {
          savedConversation.data.messages = [];
        }
        // 标记消息为等待AI回复状态
        userMessage.waitingForAIResponse = true;
        savedConversation.data.messages.push(userMessage); // 更新数据库
        savedConversation.updatedAt = new Date().toISOString();
        await xDb.xAccountProfiles.put(savedConversation);
        console.log("✅ 用户消息已保存到数据库（更新）"); // 重置该角色的自动发消息触发记录
        const messageId = currentMessageConversation.id;
        if (
          messageId &&
          messageId.startsWith("msg_") &&
          !messageId.startsWith("msg_account_")
        ) {
          const characterId = messageId.replace("msg_", "");
          if (typeof window.resetAutoMessageTrigger === "function") {
            window.resetAutoMessageTrigger(characterId);
          }
        }
        // 清除该私信的未读标记（用户回复了）
        try {
          const dataId = `messagesList_${currentAccountId || "main"}`;
          const messagesListData = await xDb.xAccountProfiles.get(dataId);
          if (messagesListData && messagesListData.data) {
            const messagesList = messagesListData.data;
            const msgIndex = messagesList.findIndex(
              (msg) => msg.id === messageId
            );
            if (msgIndex !== -1 && messagesList[msgIndex].unread) {
              messagesList[msgIndex].unread = false;
              messagesList[msgIndex].unreadCount = 0;
              await xDb.xAccountProfiles.put({
                handle: dataId,
                name: "messagesList",
                data: messagesList,
                updatedAt: new Date().toISOString(),
              }); // 同步更新全局数据
              sampleMessagesData = messagesList;
              console.log("✅ 已清除未读标记（用户回复）");
            }
          }
        } catch (error) {
          console.error("清除未读标记失败:", error);
        }
      } else {
        // 首次发送消息，创建新的对话记录
        console.log("📨 创建新的对话记录");
        const newConversation = {
          handle: conversationId,
          name: "messageConversation",
          data: {
            messages: [userMessage],
          },
          messageId: currentMessageConversation.id,
          updatedAt: new Date().toISOString(),
        };
        await xDb.xAccountProfiles.put(newConversation);
        console.log("✅ 用户消息已保存到数据库（新建）"); // 重置该角色的自动发消息触发记录
        const messageId = currentMessageConversation.id;
        if (
          messageId &&
          messageId.startsWith("msg_") &&
          !messageId.startsWith("msg_account_")
        ) {
          const characterId = messageId.replace("msg_", "");
          if (typeof window.resetAutoMessageTrigger === "function") {
            window.resetAutoMessageTrigger(characterId);
          }
        }
      }
    } catch (error) {
      console.error("保存用户消息失败:", error);
    }
  }
  // 获取AI回复
  // 重新生成AI回复
  window.regenerateAIResponse = async function () {
    if (!currentMessageConversation) {
      showXToast("会话数据丢失", "error");
      return;
    }
    try {
      const xDb = getXDB(); // 🔧 多账户隔离：包含账户ID
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${currentMessageConversation.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (
        !savedConversation ||
        !savedConversation.data ||
        !savedConversation.data.messages
      ) {
        showXToast("没有对话记录", "error");
        return;
      }
      const messages = savedConversation.data.messages; // 找到最后一个用户消息的索引
      let lastUserMessageIndex = -1;
      for (let i = messages.length - 1; i >= 0; i--) {
        if (messages[i].isOwn === true) {
          lastUserMessageIndex = i;
          break;
        }
      }
      if (lastUserMessageIndex === -1) {
        showXToast("没有找到用户消息", "error");
        return;
      }
      // 获取用户发送的消息（用于重新生成）
      const userMessages = [];
      for (
        let i = lastUserMessageIndex;
        i < messages.length && messages[i].isOwn === true;
        i++
      ) {
        userMessages.push(messages[i]);
      }
      // 删除最后一批AI回复
      const newMessages = messages.slice(
        0,
        lastUserMessageIndex + userMessages.length
      );
      savedConversation.data.messages = newMessages; // 保存更新后的对话
      await xDb.xAccountProfiles.put(savedConversation); // 重新渲染消息列表
      const contentContainer = document.getElementById(
        "message-detail-content"
      );
      if (contentContainer) {
        contentContainer.innerHTML = ""; // 渲染日期分隔符
        const today = new Date();
        const dateStr =
          currentLanguage === "en"
            ? today.toLocaleDateString("en-US", {
                year: "numeric",
                month: "long",
                day: "numeric",
              })
            : `${today.getFullYear()}年${today.getMonth() + 1}月${String(
                today.getDate()
              ).padStart(2, "0")}日`;
        contentContainer.appendChild(renderDateSeparator(dateStr)); // 使用分组渲染消息
        const groups = groupMessagesBySender(newMessages);
        const allMessageElements = [];
        groups.forEach((group) => {
          const isOwn = group[0].message.isOwn === true;
          group.forEach((item, indexInGroup) => {
            const isLastInGroup = indexInGroup === group.length - 1;
            const messageEl = renderMessageItem(
              item.message,
              isOwn,
              item.index,
              isLastInGroup
            );
            contentContainer.appendChild(messageEl);
            allMessageElements.push(messageEl);
          });
        }); // 立即显示所有消息（历史消息不需要动画）
        allMessageElements.forEach((el) => {
          el.style.opacity = "1";
          el.style.transform = "translateY(0)";
        }); // 滚动到底部
        setTimeout(() => {
          const scrollable = document.getElementById(
            "message-detail-scrollable"
          );
          if (scrollable) {
            scrollable.scrollTop = scrollable.scrollHeight;
          }
        }, 100);
      }
      // 设置用户消息队列
      userMessageQueue = userMessages; // 自动触发AI回复
      setTimeout(() => {
        getAIResponse();
      }, 500);
    } catch (error) {
      console.error("重新生成失败:", error);
      showXToast("重新生成失败", "error");
    }
  };
  // 处理粉丝群加入逻辑（在AI回复后）
  async function handleFanGroupJoinAfterAIResponse(conversationRef) {
    try {
      console.log("🔍 [粉丝群加入] ========== 开始检测 ==========");
      console.log(
        "🔍 [粉丝群加入] 当前对话:",
        conversationRef.id,
        conversationRef.name || conversationRef.userName
      );

      // 🎯 从数据库读取完整对话记录（仿照Tweet检测逻辑）
      const xDb = getXDB();
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${conversationRef.id}`;
      console.log("🔍 [粉丝群加入] 读取对话ID:", conversationId);
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (
        !savedConversation ||
        !savedConversation.data ||
        !savedConversation.data.messages
      ) {
        console.log("⚠️ [粉丝群加入] 未找到对话记录");
        return;
      }

      const messages = savedConversation.data.messages;
      console.log(`🔍 [粉丝群加入] 对话总消息数: ${messages.length}`);

      // 检查对话记录中是否有粉丝群转发（检查最近20条消息）
      const fanGroupMessages = [];
      const startIndex = Math.max(0, messages.length - 20);
      console.log(
        `🔍 [粉丝群加入] 检查消息范围: ${startIndex} - ${messages.length - 1}`
      );

      for (let i = startIndex; i < messages.length; i++) {
        const msg = messages[i];
        console.log(
          `🔍 [粉丝群加入] 消息${i}: type=${msg.type}, isOwn=${msg.isOwn}`
        );
        if (msg.type === "quoteFanGroup") {
          console.log(
            `✅ [粉丝群加入] 找到quoteFanGroup消息! isOwn=${msg.isOwn}`,
            msg.fanGroup
          );
          if (msg.isOwn === true) {
            fanGroupMessages.push(msg);
          }
        }
      }

      if (fanGroupMessages.length === 0) {
        console.log("⏭️ [粉丝群加入] 未检测到用户发送的粉丝群转发消息");
        return; // 没有粉丝群转发，直接返回
      }

      console.log(
        `✅ [粉丝群加入] 检测到 ${fanGroupMessages.length} 个粉丝群转发`
      );

      // 对每个粉丝群转发进行处理
      for (const fanGroupMsg of fanGroupMessages) {
        const fanGroupData = fanGroupMsg.fanGroup;

        // 随机决定是否加入（40-70%的概率）
        const joinProbability = 0.4 + Math.random() * 0.3; // 40%-70%
        const shouldJoin = Math.random() < joinProbability;

        if (!shouldJoin) {
          console.log(
            `🎯 [粉丝群加入] ${
              conversationRef.userName || conversationRef.user?.name
            } 决定不加入粉丝群 ${fanGroupData.name}`
          );
          continue;
        }

        console.log(
          `✅ [粉丝群加入] ${
            conversationRef.userName || conversationRef.user?.name
          } 决定加入粉丝群 ${fanGroupData.name}`
        );

        // 使用统一资料获取系统获取联系人的完整信息
        const contactHandle =
          conversationRef.userHandle || conversationRef.user?.handle;
        if (!contactHandle) {
          console.warn("⚠️ [粉丝群加入] 无法获取联系人句柄");
          continue;
        }

        // 🎯 使用统一资料获取系统
        const contactProfile = await StringBuilders.getUnifiedProfile(
          contactHandle,
          {
            userProfileInfo: window.userProfileData,
            messageId: conversationRef.id,
          }
        );

        if (!contactProfile) {
          console.warn("⚠️ [粉丝群加入] 无法获取联系人资料");
          continue;
        }

        // 构建成员数据
        const newMember = {
          id: conversationRef.id, // 使用对话ID作为成员ID
          name: contactProfile.name,
          handle: contactProfile.handle,
          avatar: contactProfile.avatar,
          type: contactProfile.type, // character, npc, relationshipNpc, account, stranger
          joinedAt: new Date().toISOString(),
        };

        // 更新粉丝群数据
        const xDb = getXDB();
        const dataId = `messagesList_${currentAccountId || "main"}`;
        const savedData = await xDb.xAccountProfiles.get(dataId);
        let messagesList = savedData?.data || [];

        const fanGroupIndex = messagesList.findIndex(
          (msg) => msg.id === fanGroupData.id
        );
        if (fanGroupIndex !== -1) {
          const fanGroup = messagesList[fanGroupIndex];

          // 初始化成员列表
          if (!fanGroup.members) {
            fanGroup.members = [];
          }

          // 检查是否已经是成员
          const isMember = fanGroup.members.some((m) => m.id === newMember.id);
          if (isMember) {
            console.log(`⚠️ [粉丝群加入] ${newMember.name} 已经是粉丝群成员`);
            continue;
          }

          // 添加到成员列表
          fanGroup.members.push(newMember);
          fanGroup.memberCount = fanGroup.members.length;

          // 保存到数据库
          await xDb.xAccountProfiles.put({
            handle: dataId,
            name: "messagesList",
            data: messagesList,
            updatedAt: new Date().toISOString(),
          });

          console.log(
            `✅ [粉丝群加入] ${newMember.name} 已加入粉丝群 ${fanGroupData.name}，当前成员数: ${fanGroup.memberCount}`
          );

          // 在粉丝群对话中添加系统通知
          const fanGroupConversationId = `messageConversation_${
            currentAccountId || "main"
          }_${fanGroupData.id}`;
          const fanGroupConversation = await xDb.xAccountProfiles.get(
            fanGroupConversationId
          );

          if (fanGroupConversation && fanGroupConversation.data) {
            if (!fanGroupConversation.data.messages) {
              fanGroupConversation.data.messages = [];
            }

            const systemMessage = {
              type: "system",
              systemType: "memberJoined",
              content: `${newMember.name} 加入了粉丝群`,
              timestamp: new Date().toISOString(),
              time: "刚刚",
            };

            fanGroupConversation.data.messages.push(systemMessage);
            await xDb.xAccountProfiles.put(fanGroupConversation);
            console.log(`✅ [粉丝群加入] 已在粉丝群对话中添加系统通知`);
          }

          // 🎯 延迟3秒显示手机样式通知（避免与回复消息通知混在一起）
          setTimeout(() => {
            const isEnglish = currentLanguage === "en";
            showPhoneNotification({
              title: fanGroupData.name,
              message: isEnglish
                ? `${newMember.name} joined the fan group`
                : `${newMember.name} 加入了粉丝群`,
              avatar: fanGroupData.avatar,
              leftIcon: "x",
              duration: 3000,
            });
          }, 3000);

          // 刷新私信列表（如果用户在私信页面）
          if (
            document.getElementById("x-messages-page")?.style.display ===
            "block"
          ) {
            await loadMessagesList();
          }

          // 🎯 检查是否需要触发自动群聊（成员数达到5、15、25...）
          await checkAndTriggerFanGroupAutoChat(
            fanGroupData.id,
            fanGroup.memberCount
          );
        }
      }
    } catch (error) {
      console.error("❌ [粉丝群加入] 处理粉丝群加入失败:", error);
    }
  }

  window.getAIResponse = async function () {
    if (!currentMessageConversation) {
      showXToast("会话数据丢失", "error");
      return;
    }

    // 🎯 如果userMessageQueue为空，从数据库读取最近的未回复用户消息
    if (userMessageQueue.length === 0) {
      console.log(
        "📖 [AI回复] userMessageQueue为空，尝试从数据库读取未回复消息"
      );
      try {
        const xDb = getXDB();
        const conversationId = `messageConversation_${
          currentAccountId || "main"
        }_${currentMessageConversation.id}`;
        const savedConversation = await xDb.xAccountProfiles.get(
          conversationId
        );

        if (
          savedConversation &&
          savedConversation.data &&
          savedConversation.data.messages
        ) {
          const messages = savedConversation.data.messages;

          // 从后往前查找，找到最后一组连续的用户消息（未被AI回复的）
          let lastAIMessageIndex = -1;
          for (let i = messages.length - 1; i >= 0; i--) {
            if (messages[i].isOwn === false && messages[i].type !== "system") {
              lastAIMessageIndex = i;
              break;
            }
          }

          // 提取最后一个AI回复之后的所有用户消息
          const unrespondedMessages = [];
          for (let i = lastAIMessageIndex + 1; i < messages.length; i++) {
            if (messages[i].isOwn === true) {
              unrespondedMessages.push(messages[i]);
            }
          }

          if (unrespondedMessages.length > 0) {
            userMessageQueue = [...unrespondedMessages];
            console.log(
              `✅ [AI回复] 从数据库读取到 ${userMessageQueue.length} 条未回复消息`
            );
            console.log(
              "📋 [AI回复] 消息类型:",
              userMessageQueue.map((m) => m.type).join(", ")
            );
          } else {
            showXToast("请先发送消息", "info");
            return;
          }
        } else {
          showXToast("请先发送消息", "info");
          return;
        }
      } catch (error) {
        console.error("❌ [AI回复] 读取未回复消息失败:", error);
        showXToast("请先发送消息", "info");
        return;
      }
    }

    // 保存当前会话引用，防止用户关闭页面后丢失
    const conversationRef = currentMessageConversation; // 禁用发送按钮
    const sendBtn = document.getElementById("message-send-btn");
    if (sendBtn) {
      sendBtn.disabled = true;
      sendBtn.style.opacity = "0.5";
    }
    try {
      // 显示"正在输入中"气泡
      console.log("📤 [AI回复] 准备显示正在输入气泡");
      showTypingIndicator(); // 🎯 检查是否是粉丝群，调用对应的生成器
      const isFanGroup =
        conversationRef.type === "fangroup" ||
        (conversationRef.id && conversationRef.id.startsWith("fangroup_"));
      let aiMessages;
      if (isFanGroup) {
        console.log("📤 [AI回复] 检测到粉丝群，调用第11个情景生成器");
        aiMessages = await generateFanGroupConversation(conversationRef, true, {
          userMessages: userMessageQueue,
        });
      } else {
        // 调用AI生成回复（续写模式，传递用户消息队列用于识图）
        console.log("📤 [AI回复] 开始请求AI生成回复（普通私信）");

        // 💎 构建 options，如果有 liveUserData，也传递给生成器
        const options = {
          userMessages: userMessageQueue,
        };

        // 检查是否有直播间用户数据
        if (conversationRef._liveUserData) {
          options.liveUserData = conversationRef._liveUserData;
          console.log(
            "💎 [AI回复] 检测到直播间用户数据，传递给生成器",
            options.liveUserData
          );
        }

        aiMessages = await generateMessageConversation(
          conversationRef,
          true,
          options
        );
      }
      console.log("📥 [AI回复] AI回复已返回"); // 隐藏"正在输入中"气泡
      hideTypingIndicator(); // 🔍 检查特殊系统提示
      const hasBlockedMessage =
        aiMessages &&
        aiMessages.some(
          (msg) => msg.type === "system" && msg.systemType === "blocked"
        );
      const hasUnblockedMessage =
        aiMessages &&
        aiMessages.some(
          (msg) => msg.type === "system" && msg.systemType === "unblocked"
        );
      const hasAwayMessage =
        aiMessages &&
        aiMessages.some(
          (msg) => msg.type === "system" && msg.systemType === "away"
        ); // 🎉 处理解除拉黑情况
      if (hasUnblockedMessage) {
        console.log("🎉 [拉黑解除] 对方已解除拉黑"); // 解除拉黑状态
        try {
          const xDb = getXDB();
          const conversationId = `messageConversation_${
            currentAccountId || "main"
          }_${conversationRef.id}`;
          const savedConversation = await xDb.xAccountProfiles.get(
            conversationId
          );
          if (savedConversation) {
            savedConversation.isBlocked = false;
            delete savedConversation.blockedAt;
            await xDb.xAccountProfiles.put(savedConversation);
            console.log("✅ [拉黑解除] 拉黑状态已解除");
          }
        } catch (error) {
          console.error("❌ [拉黑解除] 解除拉黑状态失败:", error);
        }
        // 启用输入框和发送按钮
        const messageInput = document.getElementById("message-input");
        const sendBtn = document.getElementById("message-send-btn");
        if (messageInput) {
          messageInput.disabled = false;
          messageInput.placeholder = "发送私信";
        }
        if (sendBtn) {
          sendBtn.disabled = false;
        }
        // 显示解除拉黑系统消息
        const unblockedMessage = aiMessages.find(
          (msg) => msg.type === "system" && msg.systemType === "unblocked"
        );
        if (unblockedMessage) {
          const contentContainer = document.getElementById(
            "message-detail-content"
          );
          if (contentContainer) {
            const currentMessageCount = contentContainer.querySelectorAll(
              ".message-item:not(#typing-indicator)"
            ).length;
            const messageEl = renderMessageItem(
              unblockedMessage,
              false,
              currentMessageCount,
              true
            );
            contentContainer.appendChild(messageEl);
            requestAnimationFrame(() => {
              messageEl.style.opacity = "1";
              messageEl.style.transform = "translateY(0)";
            });
          }
        }
        // 显示其他AI消息（解除拉黑后可能跟随的文本消息）
        const otherMessages = aiMessages.filter(
          (msg) => msg.type !== "system" || msg.systemType !== "unblocked"
        );
        if (otherMessages.length > 0) {
          const contentContainer = document.getElementById(
            "message-detail-content"
          );
          if (contentContainer) {
            let currentMessageCount = contentContainer.querySelectorAll(
              ".message-item:not(#typing-indicator)"
            ).length;
            otherMessages.forEach((msg, index) => {
              const messageEl = renderMessageItem(
                msg,
                false,
                currentMessageCount + index,
                index === otherMessages.length - 1
              );
              contentContainer.appendChild(messageEl);
              requestAnimationFrame(() => {
                messageEl.style.opacity = "1";
                messageEl.style.transform = "translateY(0)";
              });
            });
          }
          await saveAIMessagesToDB(aiMessages, conversationRef);
        } else {
          // 只有系统提示，也要保存
          await saveAIMessagesToDB(aiMessages, conversationRef);
        }
        // 显示解除拉黑通知
        const isEnglish = currentLanguage === "en";
        showPhoneNotification({
          title:
            conversationRef.userName ||
            conversationRef.user?.name ||
            "未知用户",
          message: isEnglish ? "Has unblocked you" : "已解除拉黑",
          avatar:
            conversationRef.userAvatar ||
            conversationRef.user?.avatar ||
            "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
          leftIcon: "x",
          duration: 3000,
        });
        userMessageQueue = []; // 滚动到底部
        const scrollable = document.getElementById("message-detail-scrollable");
        if (scrollable) {
          setTimeout(() => {
            scrollable.scrollTop = scrollable.scrollHeight;
          }, 100);
        }
        return;
      }
      // ⚠️ 处理拉黑情况
      if (hasBlockedMessage) {
        console.log("⚠️ [拉黑] 对方已将用户拉黑"); // 保存拉黑状态到对话数据
        try {
          const xDb = getXDB();
          const conversationId = `messageConversation_${
            currentAccountId || "main"
          }_${conversationRef.id}`;
          const savedConversation = await xDb.xAccountProfiles.get(
            conversationId
          );
          if (savedConversation) {
            savedConversation.isBlocked = true;
            savedConversation.blockedAt = new Date().toISOString();
            await xDb.xAccountProfiles.put(savedConversation);
            console.log("✅ [拉黑] 拉黑状态已保存");
          }
        } catch (error) {
          console.error("❌ [拉黑] 保存拉黑状态失败:", error);
        }
        // 禁用输入框和发送按钮
        const messageInput = document.getElementById("message-input");
        const sendBtn = document.getElementById("message-send-btn");
        if (messageInput) {
          messageInput.disabled = true;
          messageInput.placeholder = "对方已将你拉黑";
        }
        if (sendBtn) {
          sendBtn.disabled = true;
        }
        // 显示拉黑消息并保存
        if (aiMessages && aiMessages.length > 0) {
          const contentContainer = document.getElementById(
            "message-detail-content"
          );
          if (contentContainer) {
            const currentMessageCount = contentContainer.querySelectorAll(
              ".message-item:not(#typing-indicator)"
            ).length;
            const messageEl = renderMessageItem(
              aiMessages[0],
              false,
              currentMessageCount,
              true
            );
            contentContainer.appendChild(messageEl);
            requestAnimationFrame(() => {
              messageEl.style.opacity = "1";
              messageEl.style.transform = "translateY(0)";
            });
          }
          await saveAIMessagesToDB(aiMessages, conversationRef);
        }
        // 显示拉黑通知
        const isEnglish = currentLanguage === "en";
        showPhoneNotification({
          title: "X",
          message: isEnglish
            ? "You have been blocked by this user"
            : "对方已将你拉黑",
          leftIcon: "x",
          duration: 3000,
        });
        userMessageQueue = []; // 启用发送按钮（虽然已禁用输入框）
        if (sendBtn) {
          sendBtn.disabled = false;
          sendBtn.style.opacity = "1";
        }
        return;
      }
      // ⏰ 处理暂时离开情况
      if (hasAwayMessage) {
        console.log("⏰ [离开] 对方暂时离开");
        const awayMessage = aiMessages.find(
          (msg) => msg.type === "system" && msg.systemType === "away"
        );
        const awayDuration = awayMessage.awayDuration || 60; // 默认60分钟
        // 保存离开状态到对话数据
        try {
          const xDb = getXDB();
          const conversationId = `messageConversation_${
            currentAccountId || "main"
          }_${conversationRef.id}`;
          const savedConversation = await xDb.xAccountProfiles.get(
            conversationId
          );
          if (savedConversation) {
            savedConversation.isAway = true;
            savedConversation.awayUntil = new Date(
              Date.now() + awayDuration * 60 * 1000
            ).toISOString();
            savedConversation.awayDuration = awayDuration;
            await xDb.xAccountProfiles.put(savedConversation);
            console.log(
              `✅ [离开] 离开状态已保存，将在${awayDuration}分钟后恢复`
            );
          }
        } catch (error) {
          console.error("❌ [离开] 保存离开状态失败:", error);
        }
        // 显示离开消息并保存
        if (aiMessages && aiMessages.length > 0) {
          const contentContainer = document.getElementById(
            "message-detail-content"
          );
          if (contentContainer) {
            const currentMessageCount = contentContainer.querySelectorAll(
              ".message-item:not(#typing-indicator)"
            ).length;
            const messageEl = renderMessageItem(
              aiMessages[0],
              false,
              currentMessageCount,
              true
            );
            contentContainer.appendChild(messageEl);
            requestAnimationFrame(() => {
              messageEl.style.opacity = "1";
              messageEl.style.transform = "translateY(0)";
            });
          }
          await saveAIMessagesToDB(aiMessages, conversationRef);
        }
        // 设置定时器，离开时间结束后触发自动消息
        setTimeout(() => {
          console.log(`⏰ [离开] 离开时间结束，准备触发自动消息`); // 触发自动消息机制
          if (typeof triggerAutoMessageAfterAway === "function") {
            triggerAutoMessageAfterAway(conversationRef.id);
          }
        }, awayDuration * 60 * 1000); // 显示离开通知
        const isEnglish = currentLanguage === "en";
        showPhoneNotification({
          title: "X",
          message: awayMessage.content,
          leftIcon: "x",
          duration: 3000,
        });
        userMessageQueue = []; // 恢复发送按钮
        const sendBtn = document.getElementById("message-send-btn");
        if (sendBtn) {
          sendBtn.disabled = false;
          sendBtn.style.opacity = "1";
        }
        return;
      }
      if (aiMessages && aiMessages.length > 0) {
        // 渲染AI回复（只有在用户还在详情页时才渲染）
        const contentContainer = document.getElementById(
          "message-detail-content"
        );
        if (contentContainer) {
          // 获取当前消息总数（排除typing-indicator）
          let currentMessageCount = contentContainer.querySelectorAll(
            ".message-item:not(#typing-indicator)"
          ).length; // 将AI消息分组并标记最后一条
          const messageElements = [];
          const aiMessagesCount = aiMessages.length;
          aiMessages.forEach((message, index) => {
            const isLastMessage = index === aiMessagesCount - 1;
            const messageEl = renderMessageItem(
              message,
              false,
              currentMessageCount,
              isLastMessage
            );
            contentContainer.appendChild(messageEl);
            messageElements.push(messageEl);
            currentMessageCount++;
          }); // 逐条弹出动画
          await animateMessagesOneByOne(messageElements, 400);
        }
        // 保存AI回复到数据库（使用保存的引用，即使用户已离开页面也能保存）
        await saveAIMessagesToDB(aiMessages, conversationRef);

        // 🎯 处理粉丝群加入逻辑（从数据库读取对话记录）
        await handleFanGroupJoinAfterAIResponse(conversationRef);

        // 处理 AI 对用户转账的响应
        await handleAITransferResponse(aiMessages, conversationRef); // 清空用户消息队列
        userMessageQueue = []; // 立即显示私信回复通知（不等待New Tweet检测）
        if (
          document.getElementById("x-message-detail-page")?.style.display !==
          "none"
        ) {
          // 在详情页内也显示手机样式通知
          // 🎯 兼容粉丝群和普通私信的不同数据结构
          const displayName =
            conversationRef.user?.name ||
            conversationRef.userName ||
            conversationRef.groupName;
          const displayAvatar =
            conversationRef.user?.avatar ||
            conversationRef.userAvatar ||
            conversationRef.groupAvatar;
          showMessageNotification(
            displayName,
            displayAvatar,
            aiMessages.length
          );
        } else {
          console.log("✅ AI回复已保存（用户已离开详情页）"); // 如果用户不在详情页，标记为未读并显示提醒
          try {
            const xDb = getXDB();
            const dataId = `messagesList_${currentAccountId || "main"}`;
            const savedData = await xDb.xAccountProfiles.get(dataId);
            if (savedData && savedData.data) {
              const messagesList = savedData.data;
              const messageIndex = messagesList.findIndex(
                (msg) => msg.id === conversationRef.id
              );
              if (messageIndex !== -1) {
                // 标记为未读
                messagesList[messageIndex].unread = true;
                messagesList[messageIndex].unreadCount =
                  (messagesList[messageIndex].unreadCount || 0) +
                  aiMessages.length; // 保存回数据库
                await xDb.xAccountProfiles.put({
                  handle: dataId,
                  name: "messagesList",
                  data: messagesList,
                  updatedAt: new Date().toISOString(),
                }); // 同步更新全局数据
                sampleMessagesData = messagesList; // 显示手机样式通知
                // 🎯 兼容粉丝群和普通私信的不同数据结构
                const displayName =
                  conversationRef.user?.name ||
                  conversationRef.userName ||
                  conversationRef.groupName;
                const displayAvatar =
                  conversationRef.user?.avatar ||
                  conversationRef.userAvatar ||
                  conversationRef.groupAvatar;
                showMessageNotification(
                  displayName,
                  displayAvatar,
                  aiMessages.length
                ); // 显示私信提醒点
                showNavNotificationDot("messages");
                console.log("✅ 已标记为未读并显示提醒");
              }
            }
          } catch (error) {
            console.error("标记未读失败:", error);
          }
        }
        // 在所有通知显示完成后，异步检测New Tweet（不阻塞）
        (async () => {
          try {
            const xDb = getXDB(); // 🔧 多账户隔离：包含账户ID
            const conversationId = `messageConversation_${
              currentAccountId || "main"
            }_${conversationRef.id}`;
            const savedConversation = await xDb.xAccountProfiles.get(
              conversationId
            );
            if (
              savedConversation &&
              savedConversation.data &&
              savedConversation.data.messages
            ) {
              // 检测并生成 New Tweet 通知（异步执行，不阻塞主流程）
              await detectAndGenerateNewTweetNotification(
                conversationRef,
                savedConversation.data.messages
              );
            }
          } catch (error) {
            console.error("New Tweet 检测失败:", error);
          }
        })();
      } else {
        // 📭 AI决定不回复（返回空数组）
        console.log("📭 [不回复] AI决定不回复用户消息"); // 显示发送成功提示
        const isEnglish = currentLanguage === "en";
        showPhoneNotification({
          title: "X",
          message: isEnglish ? "Message delivered" : "消息已送达",
          leftIcon: "x",
          duration: 2000,
        }); // 清空用户消息队列
        userMessageQueue = [];
      }
    } catch (error) {
      console.error("获取AI回复失败:", error); // 隐藏"正在输入中"气泡
      hideTypingIndicator();
      if (
        document.getElementById("x-message-detail-page")?.style.display !==
        "none"
      ) {
        showXToast(`获取回复失败: ${error.message}`, "error");
      }
    } finally {
      // 恢复发送按钮（只有在按钮还存在时）
      if (sendBtn) {
        sendBtn.disabled = false;
        sendBtn.style.opacity = "1";
      }
    }
  }; // 保存AI回复到数据库
  async function saveAIMessagesToDB(aiMessages, conversationRef = null) {
    // 使用传入的引用或全局变量
    const conversation = conversationRef || currentMessageConversation;
    if (!conversation || !aiMessages || aiMessages.length === 0) return;
    try {
      const xDb = getXDB(); // 🔧 多账户隔离：包含账户ID
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${conversation.id}`; // 读取现有对话数据
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (savedConversation && savedConversation.data) {
        // 添加AI消息到messages数组（添加时间戳）
        if (!savedConversation.data.messages) {
          savedConversation.data.messages = [];
        }
        // 将所有等待AI回复的用户消息标记为已回复
        savedConversation.data.messages.forEach((msg) => {
          if (msg.isOwn && msg.waitingForAIResponse) {
            msg.waitingForAIResponse = false;
          }
        }); // 为每条AI消息添加timestamp（如果没有的话）
        aiMessages.forEach((msg) => {
          if (!msg.timestamp) {
            msg.timestamp = new Date().toISOString();
          }
        });
        savedConversation.data.messages.push(...aiMessages);

        // 💎 保存 liveUserData（如果存在）
        if (conversation._liveUserData && !savedConversation._liveUserData) {
          savedConversation._liveUserData = conversation._liveUserData;
          console.log("💎 [保存对话] 保存直播间用户数据到数据库");
        }

        // 更新数据库
        savedConversation.updatedAt = new Date().toISOString();
        await xDb.xAccountProfiles.put(savedConversation);
        console.log("✅ AI回复已保存到数据库");
      }
    } catch (error) {
      console.error("保存AI回复失败:", error);
    }
  }
  // 从私信详情页打开账户主页
  window.openAccountProfileFromDM = async function (
    messageData,
    conversationData
  ) {
    try {
      console.log("🔍 从私信详情页打开账户主页:", messageData.user.name); // 收集现有资料
      const existingInfo = {
        name: messageData.user.name,
        handle: messageData.user.handle,
        avatar: messageData.user.avatar,
        verified: messageData.user.verified || false,
      }; // 从conversationData中获取额外信息
      if (conversationData && conversationData.senderProfile) {
        if (conversationData.senderProfile.bio) {
          existingInfo.bio = conversationData.senderProfile.bio;
        }
        if (conversationData.senderProfile.followers) {
          existingInfo.followersCount =
            conversationData.senderProfile.followers.toString();
        }
        if (conversationData.senderProfile.verified !== undefined) {
          existingInfo.verified = conversationData.senderProfile.verified;
        }
      }
      console.log("📋 现有资料:", existingInfo); // 切换到账户主页，调用第七个情景
      await openAccountProfile(
        existingInfo.name,
        existingInfo.handle,
        existingInfo.avatar,
        {
          source: "dm",
          existingInfo: existingInfo,
          messagePreview: messageData.preview,
        }
      );
    } catch (error) {
      console.error("从私信详情页打开账户主页失败:", error);
      showXToast(`打开主页失败: ${error.message}`, "error");
    }
  }; // 从转发的账户名片打开账户主页
  window.openAccountProfileFromQuoteProfile = async function (profileData) {
    try {
      console.log("🔍 从账户名片打开主页:", profileData.name); // 收集现有资料
      const existingInfo = {
        name: profileData.name,
        handle: profileData.handle,
        avatar: profileData.avatar,
        verified: profileData.verified || false,
      };
      if (profileData.bio) {
        existingInfo.bio = profileData.bio;
      }
      if (profileData.followers) {
        existingInfo.followersCount = profileData.followers.toString();
      }
      console.log("📋 现有资料:", existingInfo);

      // 🆕 收集当前对话上下文（如果在私信详情页）
      let conversationContext = null;
      if (currentMessageConversation) {
        console.log(
          "📝 [名片点击] 检测到当前对话:",
          currentMessageConversation.userName
        );
        conversationContext = {
          currentConversationHandle:
            currentMessageConversation.userHandle ||
            currentMessageConversation.handle,
          currentConversationName:
            currentMessageConversation.userName ||
            currentMessageConversation.name,
          messageId: currentMessageConversation.id,
        };
      }

      // 切换到账户主页，调用第七个情景
      await openAccountProfile(
        existingInfo.name,
        existingInfo.handle,
        existingInfo.avatar,
        {
          source: "dm_quote_profile",
          existingInfo: existingInfo,
          conversationContext: conversationContext, // 🆕 传递对话上下文
        }
      );
    } catch (error) {
      console.error("从账户名片打开主页失败:", error);
      showXToast(`打开主页失败: ${error.message}`, "error");
    }
  }; // ============================================
  // 私信列表功能
  // ============================================
  // 私信数据（动态管理）
  let sampleMessagesData = []; // 加载私信列表
  async function loadMessagesList() {
    console.log("📨 加载私信列表");
    try {
      // 从数据库加载私信列表
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      if (savedData && savedData.data) {
        sampleMessagesData = savedData.data;
        console.log(
          "✅ 从数据库加载私信列表，共",
          sampleMessagesData.length,
          "条"
        );
      } else {
        console.log("📨 数据库中没有私信列表数据，使用空列表");
        sampleMessagesData = [];
      }
      // 渲染私信列表
      renderMessagesList(sampleMessagesData);
    } catch (error) {
      console.error("加载私信列表失败:", error);
      showXToast("加载私信失败", "error");
    }
  }
  // 渲染私信列表
  async function renderMessagesList(messages) {
    const container = document.getElementById("messages-list-container");
    if (!container) {
      console.error("私信列表容器不存在");
      return;
    }
    // 清空容器
    container.innerHTML = "";

    // 🔧 获取当前绑定的角色列表（用于过滤未绑定的角色）
    let boundCharacters = [];
    try {
      const xDb = getXDB();
      const settingsId = `xSettings_${currentAccountId || "main"}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      boundCharacters = xSettings?.boundCharacters || [];
      console.log("📋 [渲染私信列表] 当前绑定角色数:", boundCharacters.length);
    } catch (error) {
      console.warn("⚠️ [渲染私信列表] 获取绑定角色列表失败:", error);
    }

    // 🔧 过滤消息：隐藏未绑定的角色（保留数据，只是不显示）
    const filteredMessages = [];
    for (const message of messages || []) {
      // 检查是否是纯角色私信（msg_xxx格式，但排除特殊类型和陌生人）
      // 特殊类型：msg_account_、msg_npc_、msg_relationship_、msg_001
      const isPureCharacterMessage =
        message.id &&
        message.id.startsWith("msg_") &&
        message.id !== "msg_001" &&
        !message.id.startsWith("msg_account_") &&
        !message.id.startsWith("msg_npc_") &&
        !message.id.startsWith("msg_relationship_");

      if (isPureCharacterMessage) {
        // 提取角色ID
        const characterId = message.id.replace("msg_", "");

        // 检查角色是否仍在绑定列表中
        if (boundCharacters.includes(characterId)) {
          filteredMessages.push(message);
        } else {
          console.log(`🔍 [私信列表过滤] 跳过未绑定角色: ${characterId}`);
        }
      } else {
        // 非纯角色私信（账户、NPC、陌生人、粉丝群等），直接显示
        filteredMessages.push(message);
      }
    }

    console.log(
      `📨 [渲染私信列表] 原始消息: ${messages?.length || 0}条，过滤后: ${
        filteredMessages.length
      }条`
    );

    // 如果没有消息,显示空状态
    if (filteredMessages.length === 0) {
      container.innerHTML = `
 <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 32px; text-align: center; ">
 <svg viewBox="0 0 24 24" style="width: 56px; height: 56px; fill: var(--x-text-secondary); margin-bottom: 16px;">
 <g><path d="M1.998 5.5c0-1.381 1.119-2.5 2.5-2.5h15c1.381 0 2.5 1.119 2.5 2.5v13c0 1.381-1.119 2.5-2.5 2.5h-15c-1.381 0-2.5-1.119-2.5-2.5v-13zm2.5-.5c-.276 0-.5.224-.5.5v2.764l8 3.638 8-3.636V5.5c0-.276-.224-.5-.5-.5h-15zm15.5 5.463l-8 3.636-8-3.638V18.5c0 .276.224.5.5.5h15c.276 0 .5-.224.5-.5v-8.037z"></path></g>
 </svg>
 <div style="font-size: 28px; font-weight: 700; color:var(--x-text-primary); margin-bottom: 8px; " data-i18n="messagesEmpty">暂无私信</div>
 <div style="font-size: 14px; color:var(--x-text-secondary); max-width: 320px; " data-i18n="messagesEmptyDesc">发送私信与朋友保持联系</div>
 </div>
 `;
      return;
    }
    // 渲染每条私信（异步创建）
    for (const message of filteredMessages) {
      const messageItem = await createMessageItem(message);
      container.appendChild(messageItem);
    }
  }
  // 创建私信列表项
  async function createMessageItem(message) {
    const messageDiv = document.createElement("div");
    messageDiv.className = "message-item";
    messageDiv.style.cssText = `
 display: flex; align-items: center; padding: 16px; border-bottom: 1px solid var(--x-border-color); cursor: pointer; transition: background-color 0.2s;
`; // 🔧 获取最新的头像、昵称、句柄（对于绑定角色，从X资料实时读取）
    let currentAvatar = message.userAvatar;
    let currentUserName = message.userName;
    let currentUserHandle = message.userHandle;
    const isCharacterMessage =
      message.id && message.id.startsWith("msg_") && message.id !== "msg_001";
    if (isCharacterMessage) {
      try {
        const xDb = getXDB();
        const characterId = message.id.replace("msg_", "");
        const xProfile = await xDb.xCharacterProfiles.get(characterId);
        if (xProfile) {
          // 实时读取最新的头像、昵称和句柄
          if (xProfile.xAvatar) {
            currentAvatar = xProfile.xAvatar;
          }
          if (xProfile.xName) {
            currentUserName = xProfile.xName;
          }
          if (xProfile.xHandle) {
            currentUserHandle = xProfile.xHandle;
          }
        }
      } catch (error) {
        console.warn("读取角色X资料失败:", error);
      }
    }
    // 获取最新消息内容
    let lastMessageText = message.lastMessage || "";
    let lastMessageTime = message.timestamp; // 尝试从数据库获取最新消息
    try {
      const xDb = getXDB(); // 🔧 多账户隔离：包含账户ID
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${message.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (
        savedConversation &&
        savedConversation.data &&
        savedConversation.data.messages
      ) {
        const messages = savedConversation.data.messages;
        if (messages.length > 0) {
          const latestMsg = messages[messages.length - 1]; // 根据消息类型显示不同的预览文本
          if (latestMsg.type === "text") {
            lastMessageText = latestMsg.content;
          } else if (latestMsg.type === "image") {
            lastMessageText = "[图片]";
          } else if (latestMsg.type === "voice") {
            lastMessageText = "[语音]";
          } else if (latestMsg.type === "link") {
            lastMessageText = "[链接]";
          } else if (latestMsg.type === "quoteTweet") {
            lastMessageText = "[转发推文]";
          } else if (latestMsg.type === "quoteProfile") {
            lastMessageText = "[转发主页]";
          }
          // 如果有时间戳，使用最新的时间
          if (latestMsg.timestamp) {
            lastMessageTime = latestMsg.timestamp;
          }
        }
      }
    } catch (error) {
      console.warn("获取最新消息失败:", error);
    }
    // 格式化时间
    const timeStr = formatMessageTime(lastMessageTime);
    messageDiv.innerHTML = `

 <div style="position: relative; flex-shrink: 0; margin-right: 12px;">

 <img src="${currentAvatar}"
alt="${currentUserName}"
 style="width: 48px; height: 48px; border-radius: 50%; object-fit: cover; ">

 ${
   message.unread
     ? `
 <div style="position: absolute; top: -2px; right: -2px; width: 12px; height: 12px; background-color: var(--x-accent); border: 2px solid var(--x-bg-primary); border-radius: 50%; "></div>
 `
     : ""
 }
 </div>

 <div style="flex: 1; min-width: 0;">

 <div style="display: flex; align-items: center; margin-bottom: 4px;">
 <span style="font-size: 15px; font-weight: ${
   message.unread ? "700" : "700"
 }; color:var(--x-text-primary); margin-right: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">${currentUserName}</span>
<span style="font-size: 15px; color:var(--x-text-secondary); margin-right: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">@${currentUserHandle}</span>
 <span style="font-size: 15px; color:var(--x-text-secondary); margin-left: auto; flex-shrink: 0; ">· ${timeStr}</span>
 </div>

 <div style="font-size: 15px; color: ${
   message.unread ? "var(--x-text-primary)" : "var(--x-text-secondary)"
 }; font-weight: ${
      message.unread ? "600" : "normal"
    }; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">${
      lastMessageText || "开始对话"
    }</div>
 </div>
`; // 添加悬停效果
    messageDiv.addEventListener("mouseenter", () => {
      messageDiv.style.backgroundColor = "var(--x-bg-hover)";
    });
    messageDiv.addEventListener("mouseleave", () => {
      messageDiv.style.backgroundColor = "transparent";
    }); // 点击打开私信详情
    messageDiv.addEventListener("click", () => {
      window.openMessageDetail(message);
    });
    return messageDiv;
  }
  // 格式化消息时间
  function formatMessageTime(timestamp) {
    const now = new Date();
    const time = new Date(timestamp);
    const diff = now - time;
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    const isEnglish = currentLanguage === "en";
    if (seconds < 60) {
      return isEnglish ? "now" : "刚刚";
    } else if (minutes < 60) {
      return isEnglish ? `${minutes}m` : `${minutes}分钟`;
    } else if (hours < 24) {
      return isEnglish ? `${hours}h` : `${hours}小时`;
    } else if (days < 7) {
      return isEnglish ? `${days}d` : `${days}天`;
    } else {
      // 显示具体日期
      if (isEnglish) {
        const months = [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec",
        ];
        return `${months[time.getMonth()]} ${time.getDate()}`;
      } else {
        const month = time.getMonth() + 1;
        const day = time.getDate();
        return `${month}月${day}日`;
      }
    }
  }
  // 打开新建私信弹窗
  async function openNewMessageModal() {
    console.log("📨 打开新建私信弹窗");
    try {
      // 获取已绑定的角色列表
      const db = getDB();
      const xDb = getXDB(); // 获取X设置中的绑定角色（使用当前账号的设置）
      const settingsId = `xSettings_${currentAccountId || "main"}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const boundCharacters = xSettings?.boundCharacters || [];
      console.log(`📨 绑定角色数: ${boundCharacters.length}`); // 获取所有聊天角色
      const allChats = await db.chats.toArray();
      const characters = allChats.filter(
        (chat) => !chat.isGroup && boundCharacters.includes(chat.id)
      ); // 筛选出已绑定X资料的角色
      const charactersWithXProfile = [];
      for (const character of characters) {
        const xProfile = await xDb.xCharacterProfiles.get(character.id);
        if (xProfile) {
          charactersWithXProfile.push({
            id: character.id,
            name: character.name,
            xProfile: xProfile,
          });
        }
      }
      console.log(`📨 可选择角色数: ${charactersWithXProfile.length}`); // 显示选择角色弹窗（即使没有角色也可以创建粉丝群）
      showNewMessageModal(charactersWithXProfile);
    } catch (error) {
      console.error("打开新建私信弹窗失败:", error);
      showXToast("打开弹窗失败", "error");
    }
  }
  // 显示新建私信选择角色弹窗
  function showNewMessageModal(characters) {
    // 创建弹窗
    const modal = document.createElement("div");
    modal.id = "new-message-modal";
    modal.style.cssText = `
 display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--x-modal-overlay); z-index: 1000; align-items: center; justify-content: center; backdrop-filter: blur(4px);
`;
    modal.innerHTML = `
 <div class="modal-content" onclick="event.stopPropagation()" style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 500px; max-height: 70vh; overflow: hidden; border: 1px solid var(--x-border-color); ">

 <div class="modal-header" style="display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid var(--x-border-color); background-color:var(--x-bg-primary); ">
 <div style="display: flex; align-items: center; gap: 20px;">

 <div class="modal-close-btn" onclick="closeNewMessageModal()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>

 <h2 style="color:var(--x-text-primary); font-size: 20px; font-weight: 700; margin: 0; ">新建私信</h2>
 </div>
 </div>

 <div class="modal-body" style="padding: 16px 20px; overflow-y: auto; max-height: calc(70vh - 80px); ">

 <div style="color:var(--x-text-secondary); font-size: 14px; margin-bottom: ${
   characters.length > 0 ? "16px" : "8px"
 }; line-height: 1.4; ">
 ${
   characters.length > 0
     ? "选择要发送私信的角色"
     : "暂无可用角色，可以创建粉丝群"
 }
 </div>

 <div id="new-message-characters-list" style="display: flex; flex-direction: column; gap: 0; ">
 ${characters
   .map(
     (character) => `
 <div class="character-select-item" data-character-id="${
   character.id
 }" onclick="selectCharacterForMessage('${
       character.id
     }')" style="display: flex; align-items: center; gap: 12px; padding: 12px; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">

 <img src="${character.xProfile.xAvatar}"
 alt="${character.xProfile.xName}"
 style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0; object-fit: cover; ">

 <div style="flex: 1; min-width: 0;">
 <div style="display: flex; align-items: center; gap: 4px; margin-bottom: 2px; ">
 <span style="font-size: 15px; font-weight: 700; color:var(--x-text-primary); ">${
   character.xProfile.xName
 }</span>
 ${
   character.xProfile.xVerified
     ? `
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);">
 <path d="M22.5 12.5c0-1.58-.875-2.95-2.148-3.6.154-.435.238-.905.238-1.4 0-2.21-1.71-3.998-3.818-3.998-.47 0-.92.084-1.336.25C14.818 2.415 13.51 1.5 12 1.5s-2.816.917-3.437 2.25c-.415-.165-.866-.25-1.336-.25-2.11 0-3.818 1.79-3.818 4 0 .494.083.964.237 1.4-1.272.65-2.147 2.018-2.147 3.6 0 1.495.782 2.798 1.942 3.486-.02.17-.032.34-.032.514 0 2.21 1.708 4 3.818 4 .47 0 .92-.086 1.335-.25.62 1.334 1.926 2.25 3.437 2.25 1.512 0 2.818-.916 3.437-2.25.415.163.865.248 1.336.248 2.11 0 3.818-1.79 3.818-4 0-.174-.012-.344-.033-.513 1.158-.687 1.943-1.99 1.943-3.484zm-6.616-3.334l-4.334 6.5c-.145.217-.382.334-.625.334-.143 0-.288-.04-.416-.126l-2.5-1.668c-.326-.217-.413-.656-.196-.982.217-.326.656-.414.982-.196l1.875 1.25 3.75-5.625c.22-.33.66-.418.99-.196.33.22.418.66.196.99z"/>
 </svg>
 `
     : ""
 }
 </div>
 <div style="font-size: 15px; color:var(--x-text-secondary); ">@${
   character.xProfile.xHandle
 }</div>
 </div>
 </div>
 `
   )
   .join("")}
 </div>
 ${
   characters.length > 0
     ? `

 <div style="height: 1px; background-color: var(--x-border-color); margin: 16px 0; "></div>
 `
     : ""
 }

 <div onclick="createFanGroup()" style="display: flex; align-items: center; gap: 12px; padding: 12px; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; border: 2px dashed var(--x-border-color); " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'; this.style.borderColor='var(--x-accent)'"
 onmouseout="this.style.backgroundColor='transparent'; this.style.borderColor='var(--x-border-color)'">

 <div style="width: 40px; height: 40px; border-radius: 50%; background-color:var(--x-bg-secondary); display: flex; align-items: center; justify-content: center; flex-shrink: 0; ">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
 <g><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"></path></g>
 </svg>
 </div>

 <div style="flex: 1; min-width: 0;">
 <div style="font-size: 15px; font-weight: 700; color:var(--x-text-primary); margin-bottom: 2px; ">创建粉丝群</div>
 <div style="font-size: 13px; color:var(--x-text-secondary); ">与你的粉丝群组互动</div>
 </div>
 </div>
 </div>
 </div>
`; // 将弹窗添加到X应用容器内，以便继承CSS变量
    const xSocialScreen = document.getElementById("x-social-screen");
    if (xSocialScreen) {
      xSocialScreen.appendChild(modal);
    } else {
      document.body.appendChild(modal);
    }
    // 点击背景关闭弹窗
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        closeNewMessageModal();
      }
    });
  }
  // 关闭新建私信弹窗
  function closeNewMessageModal() {
    const modal = document.getElementById("new-message-modal");
    if (modal) {
      modal.remove();
    }
  }
  // 选择角色创建私信
  async function selectCharacterForMessage(characterId) {
    console.log("📨 选择角色创建私信:", characterId);
    try {
      const db = getDB();
      const xDb = getXDB(); // 获取角色信息
      const character = await db.chats.get(characterId);
      const xProfile = await xDb.xCharacterProfiles.get(characterId);
      if (!character || !xProfile) {
        showXToast("无法获取角色信息", "error");
        return;
      }
      // 检查是否已存在该角色的私信
      const existingIndex = sampleMessagesData.findIndex(
        (msg) => msg.id === `msg_${characterId}`
      );
      if (existingIndex === -1) {
        // 添加新私信到列表
        const newMessage = {
          id: `msg_${characterId}`,
          userName: xProfile.xName,
          userHandle: xProfile.xHandle,
          userAvatar: xProfile.xAvatar,
          lastMessage: "",
          timestamp: new Date().toISOString(),
          unread: false,
        }; // 添加到数组开头
        sampleMessagesData.unshift(newMessage);
        console.log("✅ 已添加新私信:", newMessage); // 保存到数据库
        try {
          const dataId = `messagesList_${currentAccountId || "main"}`;
          await xDb.xAccountProfiles.put({
            handle: dataId,
            name: "messagesList",
            data: sampleMessagesData,
            updatedAt: new Date().toISOString(),
          });
          console.log("✅ 私信列表已保存到数据库");
        } catch (saveError) {
          console.error("保存私信列表失败:", saveError);
        }
      } else {
        console.log("⚠️ 该角色的私信已存在");
      }
      // 关闭弹窗
      closeNewMessageModal(); // 重新渲染私信列表
      renderMessagesList(sampleMessagesData);
      showXToast(`已添加与 ${xProfile.xName} 的私信`, "success");
    } catch (error) {
      console.error("选择角色失败:", error);
      showXToast("操作失败", "error");
    }
  }
  // ============================================
  // 陌生人私信设置功能
  // ============================================
  // 打开消息联系人设置弹窗（通用版本，适配账户/陌生人）
  async function openMessageContactSettings(messageData, profileData) {
    // 检查是否已添加到联系人
    const isInContactList = sampleMessagesData.some(
      (msg) => msg.id === messageData.id
    ); // 检查是否启用了自动发信息
    let autoMessageEnabled = false;
    let autoMessageInterval = 60; // 默认60秒
    let customAvatar = messageData.user.avatar;
    try {
      const xDb = getXDB();
      const settingsId = `strangerSettings_${currentAccountId || "main"}_${
        messageData.id
      }`;
      const settings = await xDb.xAccountProfiles.get(settingsId);
      if (settings) {
        autoMessageEnabled = settings.autoMessageEnabled || false;
        autoMessageInterval = settings.autoMessageInterval || 60;
        customAvatar = settings.customAvatar || messageData.user.avatar;
      }
    } catch (error) {
      console.error("读取设置失败:", error);
    }
    // 创建设置弹窗
    const modal = document.createElement("div");
    modal.id = "stranger-message-settings-modal";
    modal.style.cssText = `
 position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 25; backdrop-filter: blur(4px);
`;
    modal.innerHTML = `
 <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 500px; max-height: 80vh; overflow: hidden; border: 1px solid var(--x-border-color); display: flex; flex-direction: column; " onclick="event.stopPropagation()">

 <div style="padding: 16px 20px; border-bottom: 1px solid var(--x-border-color); display: flex; align-items: center; justify-content: space-between; ">
 <div style="display: flex; align-items: center; gap: 12px;">
 <img src="${
   messageData.user.avatar
 }" style="width: 40px; height: 40px; border-radius: 50%;">
 <div>
 <div style="font-size: 18px; font-weight: 700; color:var(--x-text-primary);">${
   messageData.user.name
 }</div>
 <div style="font-size: 14px; color:var(--x-text-secondary);">${
   messageData.user.handle
 }</div>
 </div>
 </div>
 <div onclick="closeStrangerMessageSettings()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>
 </div>

 <div style="flex: 1; overflow-y: auto; padding: 20px; ">

 <div style="margin-bottom: 24px;">
 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; ">
 <div>
 <div style="font-size: 16px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 4px;">
 添加到联系人
 </div>
 <div style="font-size: 13px; color:var(--x-text-secondary);">
 添加后可在私信列表中快速找到
 </div>
 </div>
 <div class="x-toggle" id="contact-toggle" onclick="toggleStrangerContact('${
   messageData.id
 }')" style="cursor: pointer;">
 <div class="toggle-switch" style="width: 50px; height: 30px; background-color: ${
   isInContactList ? "var(--x-accent)" : "#333"
 }; border-radius: 15px; position: relative; transition: all 0.3s ease; ">
 <div class="toggle-circle" style="width: 26px; height: 26px; background-color:#fff; border-radius: 50%; position: absolute; top: 2px; left: ${
   isInContactList ? "22px" : "2px"
 }; transition: all 0.3s ease; "></div>
 </div>
 </div>
 </div>
 </div>

 <div style="margin-bottom: 24px;">
 <div style="font-size: 16px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 12px;">
 更换头像
 </div>
 <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
 <img id="stranger-avatar-preview" src="${customAvatar}" style="width: 64px; height: 64px; border-radius: 50%; object-fit: cover; ">
 </div>
 <div style="display: flex; gap: 8px;">
 <input
 type="text"
 id="stranger-avatar-url-input"
 placeholder="输入图片链接地址"
 value="${customAvatar}"
 style="flex: 1; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 20px; padding: 10px 16px; font-size: 14px; color:var(--x-text-primary); outline: none; "
 onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='var(--x-border-color)'"
 >
 <button onclick="updateStrangerAvatar('${
   messageData.id
 }')" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; white-space: nowrap; " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
 更新
 </button>
 </div>
 </div>

 <div style="margin-bottom: 24px;">
 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; ">
 <div>
 <div style="font-size: 16px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 4px;">
 自动发信息
 </div>
 <div style="font-size: 13px; color:var(--x-text-secondary);">
 ${
   isInContactList
     ? "启用后该账户会自动发送私信和推文"
     : "需先添加到联系人后才能启用"
 }
 </div>
 </div>
 <div class="x-toggle" id="auto-message-toggle" onclick="${
   isInContactList
     ? `toggleStrangerAutoMessage('${messageData.id}')`
     : "showXToast('请先添加到联系人', 'warning')"
 }" style="cursor: ${isInContactList ? "pointer" : "not-allowed"}; opacity: ${
      isInContactList ? "1" : "0.5"
    };">
 <div class="toggle-switch" style="width: 50px; height: 30px; background-color: ${
   autoMessageEnabled ? "var(--x-accent)" : "#333"
 }; border-radius: 15px; position: relative; transition: all 0.3s ease; ">
 <div class="toggle-circle" style="width: 26px; height: 26px; background-color:#fff; border-radius: 50%; position: absolute; top: 2px; left: ${
   autoMessageEnabled ? "22px" : "2px"
 }; transition: all 0.3s ease; "></div>
 </div>
 </div>
 </div>

 ${
   isInContactList
     ? `
 <div style="margin-top: 12px;">
 <div style="font-size: 14px; color:var(--x-text-secondary); margin-bottom: 8px;">
 发送间隔（秒）
 </div>
 <input
 type="number"
 id="stranger-interval-input"
 min="10"
 max="3600"
 value="${autoMessageInterval}"
 style="width: 100%; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 10px 12px; font-size: 14px; color:var(--x-text-primary); outline: none; "
 onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='var(--x-border-color)'"
 onchange="updateStrangerInterval('${messageData.id}', this.value)"
 >
 <div style="font-size: 12px; color:var(--x-text-secondary); margin-top: 4px;">
 建议：60-300秒之间
 </div>
 </div>
 `
     : ""
 }
 </div>
 </div>
 </div>
`; // 添加到DOM
    const xSocialScreen = document.getElementById("x-social-screen");
    if (xSocialScreen) {
      xSocialScreen.appendChild(modal);
    } else {
      document.body.appendChild(modal);
    }
    // 点击背景关闭
    modal.onclick = (e) => {
      if (e.target === modal) {
        closeStrangerMessageSettings();
      }
    }; // 保存当前设置数据到全局，供其他函数使用
    window.currentStrangerSettings = {
      messageData: messageData,
      conversationData: profileData,
    };
  }
  // 打开陌生人私信设置弹窗
  async function openStrangerMessageSettings(messageData, conversationData) {
    // 检查是否已添加到联系人
    const isInContactList = sampleMessagesData.some(
      (msg) => msg.id === messageData.id
    ); // 检查是否启用了自动发信息
    let autoMessageEnabled = false;
    let autoMessageInterval = 60; // 默认60秒
    let customAvatar = messageData.user.avatar;
    try {
      const xDb = getXDB();
      const settingsId = `strangerSettings_${currentAccountId || "main"}_${
        messageData.id
      }`;
      const settings = await xDb.xAccountProfiles.get(settingsId);
      if (settings) {
        autoMessageEnabled = settings.autoMessageEnabled || false;
        autoMessageInterval = settings.autoMessageInterval || 60;
        customAvatar = settings.customAvatar || messageData.user.avatar;
      }
    } catch (error) {
      console.error("读取陌生人设置失败:", error);
    }
    // 创建设置弹窗
    const modal = document.createElement("div");
    modal.id = "stranger-message-settings-modal";
    modal.style.cssText = `
 position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 25; backdrop-filter: blur(4px);
`;
    modal.innerHTML = `
 <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 500px; max-height: 80vh; overflow: hidden; border: 1px solid var(--x-border-color); display: flex; flex-direction: column; " onclick="event.stopPropagation()">

 <div style="padding: 16px 20px; border-bottom: 1px solid var(--x-border-color); display: flex; align-items: center; justify-content: space-between; ">
 <div style="display: flex; align-items: center; gap: 12px;">
 <img src="${
   messageData.user.avatar
 }" style="width: 40px; height: 40px; border-radius: 50%;">
 <div>
 <div style="font-size: 18px; font-weight: 700; color:var(--x-text-primary);">${
   messageData.user.name
 }</div>
 <div style="font-size: 14px; color:var(--x-text-secondary);">${
   messageData.user.handle
 }</div>
 </div>
 </div>
 <div onclick="closeStrangerMessageSettings()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>
 </div>

 <div style="flex: 1; overflow-y: auto; padding: 20px; ">

 <div style="margin-bottom: 24px;">
 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; ">
 <div>
 <div style="font-size: 16px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 4px;">
 添加到联系人
 </div>
 <div style="font-size: 13px; color:var(--x-text-secondary);">
 添加后可在私信列表中快速找到
 </div>
 </div>
 <div class="x-toggle" id="contact-toggle" onclick="toggleStrangerContact('${
   messageData.id
 }')" style="cursor: pointer;">
 <div class="toggle-switch" style="width: 50px; height: 30px; background-color: ${
   isInContactList ? "var(--x-accent)" : "#333"
 }; border-radius: 15px; position: relative; transition: all 0.3s ease; ">
 <div class="toggle-circle" style="width: 26px; height: 26px; background-color:#fff; border-radius: 50%; position: absolute; top: 2px; left: ${
   isInContactList ? "22px" : "2px"
 }; transition: all 0.3s ease; "></div>
 </div>
 </div>
 </div>
 </div>

 <div style="margin-bottom: 24px;">
 <div style="font-size: 16px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 12px;">
 更换头像
 </div>
 <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
 <img id="stranger-avatar-preview" src="${customAvatar}" style="width: 64px; height: 64px; border-radius: 50%; object-fit: cover; ">
 </div>
 <div style="display: flex; gap: 8px;">
 <input
 type="text"
 id="stranger-avatar-url-input"
 placeholder="输入图片链接地址"
 value="${customAvatar}"
 style="flex: 1; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 20px; padding: 10px 16px; font-size: 14px; color:var(--x-text-primary); outline: none; "
 onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='var(--x-border-color)'"
 >
 <button onclick="updateStrangerAvatar('${
   messageData.id
 }')" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; white-space: nowrap; " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
 更新
 </button>
 </div>
 </div>

 <div style="margin-bottom: 24px;">
 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; ">
 <div>
 <div style="font-size: 16px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 4px;">
 自动发信息
 </div>
 <div style="font-size: 13px; color:var(--x-text-secondary);">
 ${
   isInContactList ? "启用后该账户会自动发送私信" : "需先添加到联系人后才能启用"
 }
 </div>
 </div>
 <div class="x-toggle" id="auto-message-toggle" onclick="${
   isInContactList
     ? `toggleStrangerAutoMessage('${messageData.id}')`
     : "showXToast('请先添加到联系人', 'warning')"
 }" style="cursor: ${isInContactList ? "pointer" : "not-allowed"}; opacity: ${
      isInContactList ? "1" : "0.5"
    };">
 <div class="toggle-switch" style="width: 50px; height: 30px; background-color: ${
   autoMessageEnabled ? "var(--x-accent)" : "#333"
 }; border-radius: 15px; position: relative; transition: all 0.3s ease; ">
 <div class="toggle-circle" style="width: 26px; height: 26px; background-color:#fff; border-radius: 50%; position: absolute; top: 2px; left: ${
   autoMessageEnabled ? "22px" : "2px"
 }; transition: all 0.3s ease; "></div>
 </div>
 </div>
 </div>

 ${
   isInContactList
     ? `
 <div style="margin-top: 12px;">
 <div style="font-size: 14px; color:var(--x-text-secondary); margin-bottom: 8px;">
 发送间隔（秒）
 </div>
 <input
 type="number"
 id="stranger-interval-input"
 min="10"
 max="3600"
 value="${autoMessageInterval}"
 style="width: 100%; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 10px 12px; font-size: 14px; color:var(--x-text-primary); outline: none; "
 onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='var(--x-border-color)'"
 onchange="updateStrangerInterval('${messageData.id}', this.value)"
 >
 <div style="font-size: 12px; color:var(--x-text-secondary); margin-top: 4px;">
 建议：60-300秒之间
 </div>
 </div>
 `
     : ""
 }
 </div>
 </div>
 </div>
`; // 添加到DOM
    const xSocialScreen = document.getElementById("x-social-screen");
    if (xSocialScreen) {
      xSocialScreen.appendChild(modal);
    } else {
      document.body.appendChild(modal);
    }
    // 点击背景关闭
    modal.onclick = (e) => {
      if (e.target === modal) {
        closeStrangerMessageSettings();
      }
    }; // 保存当前设置数据到全局，供其他函数使用
    window.currentStrangerSettings = {
      messageData: messageData,
      conversationData: conversationData,
    };
  }
  // 关闭设置弹窗
  function closeStrangerMessageSettings() {
    const modal = document.getElementById("stranger-message-settings-modal");
    if (modal) {
      modal.remove();
    }
    window.currentStrangerSettings = null;
  }
  // 切换联系人状态
  async function toggleStrangerContact(messageId) {
    try {
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || "main"}`; // 🔧 重要：先从数据库加载最新的私信列表，避免覆盖现有数据
      const savedData = await xDb.xAccountProfiles.get(dataId);
      let messagesList = savedData?.data || [];
      console.log("📝 [联系人] 当前私信列表数量:", messagesList.length); // 查找是否已存在
      const existingIndex = messagesList.findIndex(
        (msg) => msg.id === messageId
      );
      const toggle = document.getElementById("contact-toggle");
      const toggleSwitch = toggle.querySelector(".toggle-switch");
      const toggleCircle = toggle.querySelector(".toggle-circle");
      if (existingIndex !== -1) {
        // 已存在，移除
        messagesList.splice(existingIndex, 1);
        console.log("📝 [联系人] 移除后私信列表数量:", messagesList.length); // 更新UI
        toggleSwitch.style.backgroundColor = "#333";
        toggleCircle.style.left = "2px"; // 同时禁用自动发信息
        const settingsId = `strangerSettings_${
          currentAccountId || "main"
        }_${messageId}`;
        await xDb.xAccountProfiles.delete(settingsId); // 更新自动发信息开关UI
        const autoToggle = document.getElementById("auto-message-toggle");
        if (autoToggle) {
          const autoSwitch = autoToggle.querySelector(".toggle-switch");
          const autoCircle = autoToggle.querySelector(".toggle-circle");
          autoSwitch.style.backgroundColor = "#333";
          autoCircle.style.left = "2px";
          autoToggle.style.opacity = "0.5";
          autoToggle.style.cursor = "not-allowed";
          autoToggle.onclick = () => showXToast("请先添加到联系人", "warning");
        }
        showXToast("已从联系人移除", "success");
      } else {
        // 不存在，添加
        const messageData = window.currentStrangerSettings.messageData;
        const newMessage = {
          id: messageId,
          userName: messageData.user.name,
          userHandle: messageData.user.handle.replace("@", ""),
          userAvatar: messageData.user.avatar,
          lastMessage: messageData.preview || "",
          timestamp: new Date().toISOString(),
          unread: false,
        };
        messagesList.unshift(newMessage);
        console.log("📝 [联系人] 添加后私信列表数量:", messagesList.length); // 更新UI
        toggleSwitch.style.backgroundColor = "var(--x-accent)";
        toggleCircle.style.left = "22px"; // 更新自动发信息开关UI（变为可用）
        const autoToggle = document.getElementById("auto-message-toggle");
        if (autoToggle) {
          autoToggle.style.opacity = "1";
          autoToggle.style.cursor = "pointer";
          autoToggle.onclick = () => toggleStrangerAutoMessage(messageId);
        }
        showXToast("已添加到联系人", "success");
      }
      // 保存到数据库
      await xDb.xAccountProfiles.put({
        handle: dataId,
        name: "messagesList",
        data: messagesList,
        updatedAt: new Date().toISOString(),
      });
      console.log("✅ [联系人] 已保存到数据库，列表数量:", messagesList.length); // 同步更新全局变量
      sampleMessagesData = messagesList; // 如果当前在私信列表页面，刷新显示
      const messagesPage = document.getElementById("x-messages-page");
      if (messagesPage && messagesPage.style.display === "flex") {
        await loadMessagesList();
      }
    } catch (error) {
      console.error("切换联系人状态失败:", error);
      showXToast("操作失败", "error");
    }
  }
  // 更新陌生人头像（使用链接）
  async function updateStrangerAvatar(messageId) {
    const input = document.getElementById("stranger-avatar-url-input");
    if (!input) return;
    const newAvatarUrl = input.value.trim();
    if (!newAvatarUrl) {
      showXToast("请输入头像链接", "warning");
      return;
    }
    try {
      // 更新预览
      const preview = document.getElementById("stranger-avatar-preview");
      if (preview) preview.src = newAvatarUrl; // 更新顶部小头像
      const topAvatar = document.getElementById("message-detail-top-avatar");
      if (topAvatar) topAvatar.src = newAvatarUrl; // 更新大头像
      const detailAvatar = document.getElementById("message-detail-avatar");
      if (detailAvatar) detailAvatar.src = newAvatarUrl; // 保存到数据库
      const xDb = getXDB(); // 保存到陌生人设置
      const settingsId = `strangerSettings_${
        currentAccountId || "main"
      }_${messageId}`;
      const settings = (await xDb.xAccountProfiles.get(settingsId)) || {
        handle: settingsId,
        id: settingsId,
        messageId: messageId,
      };
      settings.customAvatar = newAvatarUrl;
      settings.updatedAt = new Date().toISOString();
      await xDb.xAccountProfiles.put(settings); // 更新私信列表中的头像
      const messageIndex = sampleMessagesData.findIndex(
        (msg) => msg.id === messageId
      );
      if (messageIndex !== -1) {
        sampleMessagesData[messageIndex].userAvatar = newAvatarUrl;
        const dataId = `messagesList_${currentAccountId || "main"}`;
        await xDb.xAccountProfiles.put({
          handle: dataId,
          name: "messagesList",
          data: sampleMessagesData,
          updatedAt: new Date().toISOString(),
        });

        // 🔧 智能刷新私信列表显示
        const messagesPage = document.getElementById("x-messages-page");
        if (messagesPage) {
          // 如果列表正在显示，立即刷新；否则下次显示时自动刷新
          if (messagesPage.style.display === "flex") {
            await loadMessagesList();
            console.log("✅ [陌生人头像] 私信列表已立即刷新");
          } else {
            console.log("✅ [陌生人头像] 私信列表将在下次显示时自动刷新");
          }
        }
      }
      // 更新当前设置数据
      if (
        window.currentStrangerSettings &&
        window.currentStrangerSettings.messageData
      ) {
        window.currentStrangerSettings.messageData.user.avatar = newAvatarUrl;
      }
      showXToast("头像已更新", "success");
    } catch (error) {
      console.error("更新头像失败:", error);
      showXToast("更新失败", "error");
    }
  }
  // 更新时间间隔
  async function updateStrangerInterval(messageId, interval) {
    try {
      const intervalNum = parseInt(interval);
      if (isNaN(intervalNum) || intervalNum < 10 || intervalNum > 3600) {
        showXToast("时间间隔必须在10-3600秒之间", "warning");
        return;
      }
      const xDb = getXDB();
      const settingsId = `strangerSettings_${
        currentAccountId || "main"
      }_${messageId}`;
      const settings = (await xDb.xAccountProfiles.get(settingsId)) || {
        handle: settingsId,
        id: settingsId,
        messageId: messageId,
      };
      settings.autoMessageInterval = intervalNum;
      settings.updatedAt = new Date().toISOString();
      await xDb.xAccountProfiles.put(settings);
      showXToast(`已设置间隔为 ${intervalNum} 秒`, "success");
    } catch (error) {
      console.error("更新时间间隔失败:", error);
      showXToast("更新失败", "error");
    }
  }
  // 切换自动发信息
  async function toggleStrangerAutoMessage(messageId) {
    try {
      const xDb = getXDB();
      const settingsId = `strangerSettings_${
        currentAccountId || "main"
      }_${messageId}`; // 读取当前状态
      const settings = await xDb.xAccountProfiles.get(settingsId);
      const currentEnabled = settings && settings.autoMessageEnabled;
      const toggle = document.getElementById("auto-message-toggle");
      const toggleSwitch = toggle.querySelector(".toggle-switch");
      const toggleCircle = toggle.querySelector(".toggle-circle");
      if (currentEnabled) {
        // 当前已启用，禁用
        settings.autoMessageEnabled = false;
        await xDb.xAccountProfiles.put(settings);
        toggleSwitch.style.backgroundColor = "#333";
        toggleCircle.style.left = "2px";
        showXToast("已关闭自动发信息", "success");
      } else {
        // 当前未启用，启用
        const newSettings = settings || {
          handle: settingsId,
          id: settingsId,
          messageId: messageId,
          autoMessageInterval: 60, // 默认60秒
        };
        newSettings.autoMessageEnabled = true;
        newSettings.updatedAt = new Date().toISOString();
        await xDb.xAccountProfiles.put(newSettings);
        toggleSwitch.style.backgroundColor = "var(--x-accent)";
        toggleCircle.style.left = "22px";

        // 🔧 修复：设置初始触发时间戳，防止立即触发
        if (typeof window.lastAutoMessageTrigger !== "undefined") {
          window.lastAutoMessageTrigger[messageId] = Date.now();
          const interval = newSettings.autoMessageInterval || 60;
          console.log(
            `⏰ 已为 ${messageId} 设置初始触发时间，需等待 ${interval}秒 后首次触发`
          );
        }

        showXToast("已开启自动发信息", "success");
      }
    } catch (error) {
      console.error("切换自动发信息失败:", error);
      showXToast("操作失败", "error");
    }
  }
  // 暴露函数到全局
  window.closeStrangerMessageSettings = closeStrangerMessageSettings;
  window.toggleStrangerContact = toggleStrangerContact;
  window.updateStrangerAvatar = updateStrangerAvatar;
  window.updateStrangerInterval = updateStrangerInterval;
  window.toggleStrangerAutoMessage = toggleStrangerAutoMessage;
  window.loadMessagesList = loadMessagesList; // 暴露以便外部刷新私信列表
  // ============================================
  // 粉丝群功能
  // ============================================
  // 创建粉丝群
  async function createFanGroup() {
    try {
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || "main"}`; // 从数据库加载最新的私信列表
      const savedData = await xDb.xAccountProfiles.get(dataId);
      let messagesList = savedData?.data || []; // 生成唯一ID
      const groupId = `fangroup_${Date.now()}`; // 创建新粉丝群数据
      const newFanGroup = {
        id: groupId,
        type: "fangroup",
        userName: "我的粉丝群",
        userHandle: "fangroup",
        userAvatar: "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg", // 默认头像
        lastMessage: "",
        timestamp: new Date().toISOString(),
        unread: false,
        // 粉丝群特有属性
        groupName: "我的粉丝群",
        groupThreshold: "", // 入群门槛
        memberCount: 0, // 成员数量
        members: [], // 成员列表
      }; // 添加到列表开头
      messagesList.unshift(newFanGroup); // 保存到数据库
      await xDb.xAccountProfiles.put({
        handle: dataId,
        name: "messagesList",
        data: messagesList,
        updatedAt: new Date().toISOString(),
      });
      console.log("✅ [粉丝群] 已创建新粉丝群:", groupId); // 关闭弹窗
      closeNewMessageModal(); // 更新全局变量
      sampleMessagesData = messagesList; // 刷新私信列表
      await loadMessagesList();
      showXToast("已创建粉丝群", "success"); // 自动打开粉丝群私信
      setTimeout(() => {
        window.openMessageDetail(newFanGroup);
      }, 300);
    } catch (error) {
      console.error("❌ [粉丝群] 创建失败:", error);
      showXToast("创建粉丝群失败", "error");
    }
  }
  // 打开粉丝群设置弹窗
  async function openFanGroupSettings(groupData) {
    console.log("🎯 [粉丝群] 打开设置弹窗", groupData);
    try {
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      const messagesList = savedData?.data || []; // 找到当前粉丝群数据
      const fanGroup = messagesList.find((msg) => msg.id === groupData.id);
      if (!fanGroup) {
        showXToast("未找到粉丝群数据", "error");
        return;
      }
      // 读取自动发信息设置
      let autoMessageEnabled = false;
      let autoMessageInterval = 120; // 默认120秒
      const fanGroupSettingsId = `fanGroupSettings_${
        currentAccountId || "main"
      }_${groupData.id}`;
      const fanGroupSettings = await xDb.xAccountProfiles.get(
        fanGroupSettingsId
      );
      if (fanGroupSettings && fanGroupSettings.data) {
        autoMessageEnabled = fanGroupSettings.data.autoMessageEnabled || false;
        autoMessageInterval = fanGroupSettings.data.autoMessageInterval || 120;
      }
      // 创建设置弹窗
      const modal = document.createElement("div");
      modal.id = "fangroup-settings-modal";
      modal.style.cssText = `
 position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 25; backdrop-filter: blur(4px); `;
      modal.innerHTML = `
 <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 480px; max-height: 85vh; overflow: hidden; border: 1px solid var(--x-border-color); display: flex; flex-direction: column; " onclick="event.stopPropagation()">

 <div style="padding: 14px 16px; border-bottom: 1px solid var(--x-border-color); display: flex; align-items: center; justify-content: space-between; ">
 <div style="font-size: 17px; font-weight: 700; color:var(--x-text-primary);">粉丝群设置</div>
 <div style="display: flex; align-items: center; gap: 4px;">
 <div onclick="openFanGroupShareModal('${
   groupData.id
 }')" style="cursor: pointer; padding: 6px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'"
 title="转发粉丝群">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);">
 <g><path d="M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.791-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.791 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z"></path></g>
 </svg>
 </div>
 <div onclick="closeFanGroupSettings()" style="cursor: pointer; padding: 6px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-secondary);">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>
 </div>
 </div>

 <div style="flex: 1; overflow-y: auto; padding: 16px; ">

 <div style="margin-bottom: 18px;">
 <div style="font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 10px;">
 群头像
 </div>
 <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
 <img id="fangroup-avatar-preview" src="${
   fanGroup.userAvatar ||
   fanGroup.groupAvatar ||
   "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg"
 }" style="width: 52px; height: 52px; border-radius: 50%; object-fit: cover; ">
 </div>
 <div style="display: flex; gap: 6px;">
 <input
 type="text"
 id="fangroup-avatar-input"
 placeholder="输入图片链接地址"
 value="${fanGroup.userAvatar || fanGroup.groupAvatar || ""}"
 style="flex: 1; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 8px 12px; font-size: 13px; color:var(--x-text-primary); outline: none; "
 onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='var(--x-border-color)'"
 oninput="updateFanGroupAvatarPreview(this.value)"
 >
 <button onclick="saveFanGroupAvatar('${
   groupData.id
 }')" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 8px; padding: 8px 14px; font-size: 13px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; white-space: nowrap; " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
 更新
 </button>
 </div>
 </div>

 <div style="margin-bottom: 18px;">
 <div style="font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 10px;">
 群名称
 </div>
 <input
 type="text"
 id="fangroup-name-input"
 placeholder="输入群名称"
 value="${fanGroup.userName || fanGroup.groupName || "我的粉丝群"}"
 maxlength="30"
 style="width: 100%; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 10px 12px; font-size: 13px; color:var(--x-text-primary); outline: none; "
 onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='var(--x-border-color)'"
 >
 </div>

 <div style="margin-bottom: 18px;">
 <div style="font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 10px;">
 入群门槛
 </div>
 <textarea
 id="fangroup-threshold-input"
 placeholder="例如：关注满30天、互动次数达到10次等..."
 maxlength="200"
 style="width: 100%; min-height: 80px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 10px 12px; font-size: 13px; color:var(--x-text-primary); outline: none; resize: vertical; font-family: inherit; line-height: 1.5; "
 onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='var(--x-border-color)'"
 >${fanGroup.groupThreshold || ""}</textarea>
 <div style="text-align: right; margin-top: 4px;">
 <span style="font-size: 11px; color:var(--x-text-secondary);">设置粉丝需要满足的条件才能进群</span>
 </div>
 </div>

 <div style="margin-bottom: 24px;">
 <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; ">
 <div>
 <div style="font-size: 16px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 4px;">
 后台自动发信息
 </div>
 <div style="font-size: 13px; color:var(--x-text-secondary);">
 启用后群成员会自动交流
 </div>
 </div>
 <div class="x-toggle" id="fangroup-auto-message-toggle" onclick="toggleFanGroupAutoMessage('${
   groupData.id
 }')" style="cursor: pointer;">
 <div class="toggle-switch" style="width: 50px; height: 30px; background-color: ${
   autoMessageEnabled ? "var(--x-accent)" : "#333"
 }; border-radius: 15px; position: relative; transition: all 0.3s ease; ">
 <div class="toggle-circle" style="width: 26px; height: 26px; background-color:#fff; border-radius: 50%; position: absolute; top: 2px; left: ${
   autoMessageEnabled ? "22px" : "2px"
 }; transition: all 0.3s ease; "></div>
 </div>
 </div>
 </div>

 <div style="margin-top: 12px;">
 <div style="font-size: 14px; color:var(--x-text-secondary); margin-bottom: 8px;">
 发送间隔（秒）
 </div>
 <input
 type="number"
 id="fangroup-interval-input"
 min="60"
 max="3600"
 value="${autoMessageInterval}"
 style="width: 100%; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 10px 12px; font-size: 14px; color:var(--x-text-primary); outline: none; "
 onfocus="this.style.borderColor='var(--x-accent)'"
 onblur="this.style.borderColor='var(--x-border-color)'"
 onchange="updateFanGroupInterval('${groupData.id}', this.value)"
 >
 <div style="font-size: 12px; color:var(--x-text-secondary); margin-top: 4px;">
 建议：120-600秒之间
 </div>
 </div>
 </div>

 <div style="margin-bottom: 18px;">
 <div style="font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between;">
 <span>群成员</span>
 <span style="font-size: 13px; color: var(--x-accent); font-weight: 700;">${
   fanGroup.members?.length || 0
 } 人</span>
 </div>
 <div style="max-height: 240px; overflow-y: auto; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 8px; padding: 6px; ">
 ${
   fanGroup.members && fanGroup.members.length > 0
     ? fanGroup.members
         .map(
           (member) => `
 <div style="display: flex; align-items: center; gap: 10px; padding: 6px; border-radius: 6px; transition: background-color 0.2s; margin-bottom: 2px; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <img src="${member.avatar}" style="width: 32px; height: 32px; border-radius: 50%; object-fit: cover; ">
 <div style="flex: 1; min-width: 0;">
 <div style="color:var(--x-text-primary); font-size: 13px; font-weight: 600;">
 ${member.name}
 </div>
 <div style="color:var(--x-text-secondary); font-size: 11px;">
 ${member.handle}
 </div>
 </div>
 <button onclick="kickFanGroupMember('${groupData.id}', '${member.id}', '${member.name}')" style="background-color: transparent; color: #ef4444; border: 1px solid #ef4444; border-radius: 6px; padding: 4px 10px; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s; white-space: nowrap; " onmouseover="this.style.backgroundColor='#ef444410'"
 onmouseout="this.style.backgroundColor='transparent'">
 踢出
 </button>
 </div>
 `
         )
         .join("")
     : `<div style="text-align: center; padding: 20px; color:var(--x-text-secondary); font-size: 12px; ">暂无成员</div>`
 }
 </div>
 </div>
 </div>

 <div style="padding: 12px 16px; border-top: 1px solid var(--x-border-color); display: flex; flex-direction: column; gap: 8px;">

 <button onclick="openFanGroupApplicationsModal('${
   groupData.id
 }')" style="background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 8px; padding: 10px 16px; font-size: 13px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);">
 <g><path d="M17.5 4.5c-1.95-1.96-5.11-1.96-7.07 0-1.96 1.96-1.96 5.11 0 7.07 1.95 1.96 5.11 1.96 7.07 0 1.96-1.96 1.96-5.11 0-7.07zM14 9c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z M12 14H6c-1.1 0-2 .9-2 2v5h16v-5c0-1.1-.9-2-2-2h-6z"></path></g>
 </svg>
 查看入群申请
 </button>

 <div style="display: flex; gap: 6px;">
 <button onclick="dissolveFanGroup('${
   groupData.id
 }')" style="background-color: transparent; color: #ef4444; border: 1px solid #ef4444; border-radius: 8px; padding: 9px 14px; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s; white-space: nowrap; " onmouseover="this.style.backgroundColor='#ef444410'"
 onmouseout="this.style.backgroundColor='transparent'">
 解散群聊
 </button>
 <button onclick="closeFanGroupSettings()" style="flex: 1; background-color:var(--x-bg-secondary); color:var(--x-text-secondary); border: none; border-radius: 8px; padding: 9px 14px; font-size: 13px; font-weight: 600; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">取消</button>
 <button onclick="saveFanGroupSettings('${
   groupData.id
 }')" style="flex: 1; background-color: var(--x-accent); color: #fff; border: none; border-radius: 8px; padding: 9px 14px; font-size: 13px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">保存</button>
 </div>
 </div>
 </div>
 `; // 添加到DOM
      const xSocialScreen = document.getElementById("x-social-screen");
      if (xSocialScreen) {
        xSocialScreen.appendChild(modal);
      } else {
        document.body.appendChild(modal);
      }
      // 点击背景关闭
      modal.onclick = (e) => {
        if (e.target === modal) {
          closeFanGroupSettings();
        }
      };
    } catch (error) {
      console.error("❌ [粉丝群] 打开设置失败:", error);
      showXToast("打开设置失败", "error");
    }
  }
  // 关闭粉丝群设置弹窗
  function closeFanGroupSettings() {
    const modal = document.getElementById("fangroup-settings-modal");
    if (modal) {
      modal.remove();
    }
  }
  // 更新粉丝群头像预览
  function updateFanGroupAvatarPreview(avatarUrl) {
    const preview = document.getElementById("fangroup-avatar-preview");
    if (preview && avatarUrl) {
      preview.src = avatarUrl;
    }
  }
  // 保存粉丝群头像
  async function saveFanGroupAvatar(groupId) {
    const avatarInput = document.getElementById("fangroup-avatar-input");
    if (!avatarInput) return;
    const newAvatar = avatarInput.value.trim();
    if (!newAvatar) {
      showXToast("请输入头像链接", "warning");
      return;
    }
    try {
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      let messagesList = savedData?.data || []; // 找到并更新粉丝群
      const groupIndex = messagesList.findIndex((msg) => msg.id === groupId);
      if (groupIndex !== -1) {
        messagesList[groupIndex].userAvatar = newAvatar;
        messagesList[groupIndex].groupAvatar = newAvatar; // 保存到数据库
        await xDb.xAccountProfiles.put({
          handle: dataId,
          name: "messagesList",
          data: messagesList,
          updatedAt: new Date().toISOString(),
        }); // 更新全局变量
        sampleMessagesData = messagesList;

        // 🔧 更新私信详情页的头像（如果正在查看该粉丝群）
        if (currentMessageConversation?.id === groupId) {
          const topAvatar = document.getElementById(
            "message-detail-top-avatar"
          );
          if (topAvatar) {
            topAvatar.src = newAvatar;
            console.log("✅ [粉丝群头像] 已更新详情页顶部头像");
          }
          const detailAvatar = document.getElementById("message-detail-avatar");
          if (detailAvatar) {
            detailAvatar.src = newAvatar;
            console.log("✅ [粉丝群头像] 已更新详情页大头像");
          }
        }

        // 🔧 智能刷新私信列表
        const messagesPage = document.getElementById("x-messages-page");
        if (messagesPage && messagesPage.style.display === "flex") {
          await loadMessagesList();
          console.log("✅ [粉丝群头像] 私信列表已立即刷新");
        } else {
          console.log("✅ [粉丝群头像] 私信列表将在下次显示时自动刷新");
        }
        showXToast("头像已更新", "success");
      }
    } catch (error) {
      console.error("❌ [粉丝群] 保存头像失败:", error);
      showXToast("保存失败", "error");
    }
  }
  // 保存粉丝群设置
  async function saveFanGroupSettings(groupId) {
    try {
      const nameInput = document.getElementById("fangroup-name-input");
      const thresholdInput = document.getElementById(
        "fangroup-threshold-input"
      );
      if (!nameInput) return;
      const newName = nameInput.value.trim();
      const newThreshold = thresholdInput ? thresholdInput.value.trim() : "";
      if (!newName) {
        showXToast("请输入群名称", "warning");
        return;
      }
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      let messagesList = savedData?.data || []; // 找到并更新粉丝群
      const groupIndex = messagesList.findIndex((msg) => msg.id === groupId);
      if (groupIndex !== -1) {
        messagesList[groupIndex].userName = newName;
        messagesList[groupIndex].groupName = newName;
        messagesList[groupIndex].groupThreshold = newThreshold; // 保存到数据库
        await xDb.xAccountProfiles.put({
          handle: dataId,
          name: "messagesList",
          data: messagesList,
          updatedAt: new Date().toISOString(),
        }); // 更新全局变量
        sampleMessagesData = messagesList; // 更新私信详情页的名称（如果正在查看）
        const topName = document.getElementById("message-detail-top-name");
        if (topName && currentMessageConversation?.id === groupId) {
          topName.textContent = newName;
        }
        // 刷新私信列表
        await loadMessagesList();
        showXToast("设置已保存", "success");
        closeFanGroupSettings();
      }
    } catch (error) {
      console.error("❌ [粉丝群] 保存设置失败:", error);
      showXToast("保存失败", "error");
    }
  }
  // 切换粉丝群自动发信息
  async function toggleFanGroupAutoMessage(groupId) {
    try {
      const xDb = getXDB();
      const settingsId = `fanGroupSettings_${
        currentAccountId || "main"
      }_${groupId}`;
      const settings = await xDb.xAccountProfiles.get(settingsId);
      const currentState = settings?.data?.autoMessageEnabled || false;
      const newState = !currentState;
      // 保存设置
      await xDb.xAccountProfiles.put({
        handle: settingsId,
        name: "fanGroupSettings",
        data: {
          autoMessageEnabled: newState,
          autoMessageInterval: settings?.data?.autoMessageInterval || 120,
          groupId: groupId,
        },
        updatedAt: new Date().toISOString(),
      });
      console.log(`🤖 [粉丝群] 自动发信息已${newState ? "启用" : "禁用"}`);

      // 🔧 修复：如果启用，设置初始触发时间戳，防止立即触发
      if (newState && typeof window.lastAutoMessageTrigger !== "undefined") {
        window.lastAutoMessageTrigger[groupId] = Date.now();
        const interval = settings?.data?.autoMessageInterval || 120;
        console.log(
          `⏰ 已为粉丝群 ${groupId} 设置初始触发时间，需等待 ${interval}秒 后首次触发`
        );
      }

      // 更新UI
      const toggle = document.getElementById("fangroup-auto-message-toggle");
      if (toggle) {
        const toggleSwitch = toggle.querySelector(".toggle-switch");
        const toggleCircle = toggle.querySelector(".toggle-circle");
        toggleSwitch.style.backgroundColor = newState
          ? "var(--x-accent)"
          : "#333";
        toggleCircle.style.left = newState ? "22px" : "2px";
      }
      showXToast(
        newState ? "已启用后台自动发信息" : "已禁用后台自动发信息",
        "success"
      );
    } catch (error) {
      console.error("❌ [粉丝群] 切换自动发信息失败:", error);
      showXToast("操作失败", "error");
    }
  }
  // 更新粉丝群自动发信息间隔
  async function updateFanGroupInterval(groupId, interval) {
    try {
      const xDb = getXDB();
      const settingsId = `fanGroupSettings_${
        currentAccountId || "main"
      }_${groupId}`;
      const settings = await xDb.xAccountProfiles.get(settingsId);
      const newInterval = Math.max(
        60,
        Math.min(3600, parseInt(interval) || 120)
      );
      // 保存设置
      await xDb.xAccountProfiles.put({
        handle: settingsId,
        name: "fanGroupSettings",
        data: {
          autoMessageEnabled: settings?.data?.autoMessageEnabled || false,
          autoMessageInterval: newInterval,
          groupId: groupId,
        },
        updatedAt: new Date().toISOString(),
      });
      console.log(`🤖 [粉丝群] 自动发信息间隔已更新: ${newInterval}秒`);
      showXToast(`间隔已更新为 ${newInterval} 秒`, "success");
    } catch (error) {
      console.error("❌ [粉丝群] 更新间隔失败:", error);
      showXToast("更新失败", "error");
    }
  }
  // 处理私信详情页小头像点击
  window.handleMessageDetailAvatarClick = function () {
    console.log("🖱️ [头像点击] 触发头像点击事件");
    if (!currentMessageConversation) {
      console.warn("⚠️ [头像点击] currentMessageConversation 为空");
      return;
    }

    console.log(
      "🖱️ [头像点击] 当前对话类型:",
      currentMessageConversation.type,
      currentMessageConversation.id
    );

    // 🔧 检查是否为粉丝群（同时检查ID前缀以确保准确性）
    const isFanGroup =
      currentMessageConversation.type === "fangroup" ||
      (currentMessageConversation.id &&
        currentMessageConversation.id.startsWith("fangroup_"));

    if (isFanGroup) {
      console.log("🖱️ [头像点击] 检测到粉丝群，打开设置");
      // 打开粉丝群设置
      openFanGroupSettings(currentMessageConversation);
      return;
    }
    // 检查是否为角色私信（角色私信不支持设置功能）
    const isCharacterMessage =
      currentMessageConversation.id &&
      currentMessageConversation.id.startsWith("msg_") &&
      currentMessageConversation.id !== "msg_001";
    if (isCharacterMessage) {
      console.log("🖱️ [头像点击] 角色对话不支持设置");
      return;
    }
    // 其他类型（账户/NPC/关系NPC/陌生人）：打开联系人设置
    console.log(
      "🖱️ [头像点击] 打开联系人设置，类型:",
      currentMessageConversation._accountType || "stranger"
    );
    // 构建标准的 messageData 格式
    const messageData = {
      id: currentMessageConversation.id,
      user: {
        name:
          currentMessageConversation.userName ||
          currentMessageConversation.name,
        handle:
          currentMessageConversation.userHandle ||
          currentMessageConversation.handle,
        avatar:
          currentMessageConversation.userAvatar ||
          currentMessageConversation.avatar,
      },
      preview: currentMessageConversation.lastMessage || "",
      _accountType: currentMessageConversation._accountType || "stranger",
    }; // 打开通用联系人设置弹窗
    openMessageContactSettings(messageData, null);
  };
  // 调整粉丝群详情页显示（隐藏大头像和详细信息区域）
  function adjustFanGroupDetailPage(isFanGroup) {
    const scrollableContainer = document.getElementById(
      "message-detail-scrollable"
    );
    if (!scrollableContainer) return; // 找到用户详细信息区域（第一个子元素）
    const userInfoSection = scrollableContainer.children[0];
    if (!userInfoSection) return; // 控制自反应按钮的显示
    const autoReactionBtn = document.getElementById(
      "fangroup-auto-reaction-btn"
    );
    // 控制群公告按钮的显示
    const announcementBtn = document.getElementById(
      "fangroup-announcement-btn"
    );
    // 控制群文件按钮的显示
    const filesBtn = document.getElementById("fangroup-files-btn");
    if (isFanGroup) {
      // 粉丝群：隐藏用户详细信息区域，显示自反应按钮、群公告按钮和群文件按钮
      userInfoSection.style.display = "none";
      if (autoReactionBtn) {
        autoReactionBtn.style.display = "flex";
      }
      if (announcementBtn) {
        announcementBtn.style.display = "flex";
      }
      if (filesBtn) {
        filesBtn.style.display = "flex";
      }
      console.log(
        "🎯 [粉丝群] 已隐藏详细信息区域，显示自反应按钮、群公告按钮和群文件按钮"
      );
    } else {
      // 普通对话：显示用户详细信息区域，隐藏自反应按钮、群公告按钮和群文件按钮
      userInfoSection.style.display = "flex";
      if (autoReactionBtn) {
        autoReactionBtn.style.display = "none";
      }
      if (announcementBtn) {
        announcementBtn.style.display = "none";
      }
      if (filesBtn) {
        filesBtn.style.display = "none";
      }
    }
  }
  // 打开粉丝群转发选项弹窗
  async function openFanGroupShareModal(groupId) {
    console.log("📤 [粉丝群转发] 打开转发选项", groupId);
    try {
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      const messagesList = savedData?.data || []; // 找到粉丝群数据
      const fanGroup = messagesList.find((msg) => msg.id === groupId);
      if (!fanGroup) {
        showXToast("未找到粉丝群数据", "error");
        return;
      }
      // 创建转发选项弹窗
      const modal = document.createElement("div");
      modal.id = "fangroup-share-modal";
      modal.style.cssText = `
 position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 30; backdrop-filter: blur(4px); `;
      modal.innerHTML = `
 <div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 400px; border: 1px solid var(--x-border-color); overflow: hidden; " onclick="event.stopPropagation()">

 <div style="padding: 20px; border-bottom: 1px solid var(--x-border-color); ">
 <div style="font-size: 20px; font-weight: 700; color:var(--x-text-primary); text-align: center;">
 转发粉丝群
 </div>
 </div>

 <div style="padding: 20px; border-bottom: 1px solid var(--x-border-color);">
 <div style="display: flex; align-items: center; gap: 12px;">
 <img src="${
   fanGroup.userAvatar ||
   fanGroup.groupAvatar ||
   "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg"
 }"
 style="width: 48px; height: 48px; border-radius: 50%; object-fit: cover;">
 <div style="flex: 1;">
 <div style="color:var(--x-text-primary); font-size: 16px; font-weight: 600; margin-bottom: 4px;">
 ${fanGroup.userName || fanGroup.groupName || "我的粉丝群"}
 </div>
 <div style="color:var(--x-text-secondary); font-size: 13px;">
 ${fanGroup.memberCount || 0} 位成员
 </div>
 </div>
 </div>
 ${
   fanGroup.groupThreshold
     ? `
 <div style="margin-top: 12px; padding: 10px; background-color:var(--x-bg-secondary); border-radius: 8px; color:var(--x-text-secondary); font-size: 13px; line-height: 1.4; ">
 <div style="color:var(--x-text-primary); font-weight: 600; margin-bottom: 4px;">入群门槛</div>
 ${fanGroup.groupThreshold}
 </div>
 `
     : ""
 }
 </div>

 <div style="padding: 12px;">

 <div onclick="shareFanGroupToContact('${groupId}')" style="display: flex; align-items: center; gap: 16px; padding: 16px; border-radius: 12px; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <div style="width: 40px; height: 40px; border-radius: 50%; background-color:var(--x-bg-secondary); display: flex; align-items: center; justify-content: center; ">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
 <g><path d="M1.998 5.5c0-1.381 1.119-2.5 2.5-2.5h15c1.381 0 2.5 1.119 2.5 2.5v13c0 1.381-1.119 2.5-2.5 2.5h-15c-1.381 0-2.5-1.119-2.5-2.5v-13zm2.5-.5c-.276 0-.5.224-.5.5v2.764l8 3.638 8-3.636V5.5c0-.276-.224-.5-.5-.5h-15zm15.5 5.463l-8 3.636-8-3.638V18.5c0 .276.224.5.5.5h15c.276 0 .5-.224.5-.5v-8.037z"></path></g>
 </svg>
 </div>
 <div style="flex: 1;">
 <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 2px;">
 转发到联系人
 </div>
 <div style="color:var(--x-text-secondary); font-size: 13px;">
 分享给你的私信联系人
 </div>
 </div>
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-secondary);">
 <g><path d="M8.58 7.17l4.24 4.24-4.24 4.24 1.42 1.42 5.66-5.66-5.66-5.66z"></path></g>
 </svg>
 </div>

 <div onclick="shareFanGroupToPost('${groupId}')" style="display: flex; align-items: center; gap: 16px; padding: 16px; border-radius: 12px; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <div style="width: 40px; height: 40px; border-radius: 50%; background-color:var(--x-bg-secondary); display: flex; align-items: center; justify-content: center; ">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-accent);">
 <g><path d="M8.8 7.2H5.6V3.9c0-.4-.3-.8-.8-.8s-.7.4-.7.8v3.3H.8c-.4 0-.8.3-.8.8s.3.8.8.8h3.3v3.3c0 .4.3.8.8.8s.8-.3.8-.8V8.7H9c.4 0 .8-.3.8-.8s-.5-.7-1-.7zm15-4.9v-.1h-.1c-.1 0-9.2 1.2-14.4 11.7-3.8 7.6-3.6 9.9-3.3 9.9.3.1 3.4-6.5 6.7-9.2 5.2-1.1 6.6-3.6 6.6-3.6s-1.5.2-2.1.2c-.8 0-1.4-.2-1.7-.3 1.3-1.2 2.4-1.5 3.5-1.7.9-.2 1.8-.4 3-1.2 2.2-1.6 1.9-5.5 1.8-5.7z"></path></g>
 </svg>
 </div>
 <div style="flex: 1;">
 <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 2px;">
 转发到推文
 </div>
 <div style="color:var(--x-text-secondary); font-size: 13px;">
 发布推文并引用粉丝群
 </div>
 </div>
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-secondary);">
 <g><path d="M8.58 7.17l4.24 4.24-4.24 4.24 1.42 1.42 5.66-5.66-5.66-5.66z"></path></g>
 </svg>
 </div>
 </div>

 <div style="padding: 12px 20px 20px 20px;">
 <button onclick="closeFanGroupShareModal()" style="width: 100%; background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 20px; padding: 12px 20px; font-size: 15px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">
 取消
 </button>
 </div>
 </div>
 `; // 添加到DOM
      const xSocialScreen = document.getElementById("x-social-screen");
      if (xSocialScreen) {
        xSocialScreen.appendChild(modal);
      } else {
        document.body.appendChild(modal);
      }
      // 点击背景关闭
      modal.onclick = (e) => {
        if (e.target === modal) {
          closeFanGroupShareModal();
        }
      };
    } catch (error) {
      console.error("❌ [粉丝群转发] 打开转发选项失败:", error);
      showXToast("打开转发选项失败", "error");
    }
  }
  // 关闭粉丝群转发选项弹窗
  function closeFanGroupShareModal() {
    const modal = document.getElementById("fangroup-share-modal");
    if (modal) {
      modal.remove();
    }
  }
  // 转发粉丝群到联系人
  async function shareFanGroupToContact(groupId) {
    console.log("📤 [粉丝群转发] 转发到联系人", groupId);
    try {
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      const messagesList = savedData?.data || [];

      // 找到粉丝群数据
      const fanGroup = messagesList.find((msg) => msg.id === groupId);
      if (!fanGroup) {
        showXToast("未找到粉丝群数据", "error");
        return;
      }

      // 关闭转发选项弹窗
      closeFanGroupShareModal();

      // 获取所有联系人（排除当前粉丝群自己）
      const contacts = messagesList.filter((msg) => msg.id !== groupId);
      if (contacts.length === 0) {
        showXToast("暂无其他联系人", "info");
        return;
      }

      // 创建联系人选择弹窗
      const modal = document.createElement("div");
      modal.id = "fangroup-contact-select-modal";
      modal.style.cssText = `
 position: fixed;
 top: 0;
 left: 0;
 width: 100vw;
 height: 100vh;
 background-color: rgba(0, 0, 0, 0.5);
 display: flex;
 align-items: center;
 justify-content: center;
 z-index: 35;
 backdrop-filter: blur(4px);
 `;

      modal.innerHTML = `
 <div style="
 background-color:var(--x-bg-primary);
 border-radius: 16px;
 width: 90%;
 max-width: 500px;
 max-height: 80vh;
 border: 1px solid var(--x-border-color);
 display: flex;
 flex-direction: column;
 overflow: hidden;
 " onclick="event.stopPropagation()">

 <div style="
 padding: 16px 20px;
 border-bottom: 1px solid var(--x-border-color);
 display: flex;
 align-items: center;
 justify-content: space-between;
 ">
 <div style="font-size: 18px; font-weight: 700; color:var(--x-text-primary);">
 选择转发对象
 </div>
 <div onclick="closeFanGroupContactSelectModal()" style="
 cursor: pointer;
 padding: 8px;
 border-radius: 50%;
 transition: background-color 0.2s;
 " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>
 </div>

 <div style="
 padding: 16px 20px;
 background-color:var(--x-bg-secondary);
 border-bottom: 1px solid var(--x-border-color);
 ">
 <div style="font-size: 13px; color:var(--x-text-secondary); margin-bottom: 8px;">
 将要转发的粉丝群
 </div>
 <div style="display: flex; align-items: center; gap: 12px;">
 <img src="${
   fanGroup.userAvatar ||
   fanGroup.groupAvatar ||
   "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg"
 }"
 style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover;">
 <div style="flex: 1;">
 <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600;">
 ${fanGroup.userName || fanGroup.groupName || "我的粉丝群"}
 </div>
 <div style="color:var(--x-text-secondary); font-size: 13px;">
 ${fanGroup.memberCount || 0} 位成员
 </div>
 </div>
 </div>
 </div>

 <div id="fangroup-contact-list" style="
 flex: 1;
 overflow-y: auto;
 padding: 12px;
 ">
 ${contacts
   .map(
     (contact) => `
 <div class="fangroup-contact-item" data-contact-id="${contact.id}" style="
 display: flex;
 align-items: center;
 gap: 12px;
 padding: 12px;
 border-radius: 12px;
 cursor: pointer;
 transition: background-color 0.2s;
 margin-bottom: 8px;
 " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="if(!this.classList.contains('selected')) this.style.backgroundColor='transparent'"
 onclick="toggleContactSelection('${contact.id}')">

 <div class="contact-checkbox" style="
 width: 20px;
 height: 20px;
 border-radius: 50%;
 border: 2px solid var(--x-border-color);
 background-color: var(--x-bg-primary);
 flex-shrink: 0;
 transition: all 0.2s;
 "></div>

 <img src="${
   contact.userAvatar ||
   contact.avatar ||
   "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg"
 }"
 style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover; flex-shrink: 0;">

 <div style="flex: 1; min-width: 0;">
 <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 2px;">
 <span style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
 ${contact.userName || contact.name || "未知用户"}
 </span>
 ${
   contact.type === "fangroup"
     ? `
 <span style="
 padding: 2px 6px;
 background-color:var(--x-bg-secondary);
 color:var(--x-text-secondary);
 font-size: 10px;
 border-radius: 4px;
 font-weight: 600;
 ">粉丝群</span>
 `
     : ""
 }
 </div>
 <div style="color:var(--x-text-secondary); font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
 ${contact.lastMessage || contact.userHandle || ""}
 </div>
 </div>
 </div>
 `
   )
   .join("")}
 </div>

 <div style="
 padding: 16px 20px;
 border-top: 1px solid var(--x-border-color);
 display: flex;
 gap: 12px;
 ">
 <button onclick="closeFanGroupContactSelectModal()" style="
 flex: 1;
 background-color:var(--x-bg-secondary);
 color:var(--x-text-primary);
 border: none;
 border-radius: 20px;
 padding: 12px 20px;
 font-size: 15px;
 font-weight: 600;
 cursor: pointer;
 transition: opacity 0.2s;
 " onmouseover="this.style.opacity='0.8'"
 onmouseout="this.style.opacity='1'">
 取消
 </button>
 <button id="fangroup-contact-confirm-btn" onclick="confirmFanGroupContactShare('${groupId}')" style="
 flex: 1;
 background-color: var(--x-accent);
 color: #fff;
 border: none;
 border-radius: 20px;
 padding: 12px 20px;
 font-size: 15px;
 font-weight: 600;
 cursor: pointer;
 transition: opacity 0.2s;
 opacity: 0.5;
 " disabled>
 转发 (0)
 </button>
 </div>
 </div>
 `;

      // 添加到DOM
      const xSocialScreen = document.getElementById("x-social-screen");
      if (xSocialScreen) {
        xSocialScreen.appendChild(modal);
      } else {
        document.body.appendChild(modal);
      }

      // 点击背景关闭
      modal.onclick = (e) => {
        if (e.target === modal) {
          closeFanGroupContactSelectModal();
        }
      };
    } catch (error) {
      console.error("❌ [粉丝群转发] 打开联系人选择失败:", error);
      showXToast("打开联系人选择失败", "error");
    }
  }
  // 转发粉丝群到发帖
  async function shareFanGroupToPost(groupId) {
    console.log("📤 [粉丝群转发] 转发到发帖", groupId);
    try {
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      const messagesList = savedData?.data || []; // 找到粉丝群数据
      const fanGroup = messagesList.find((msg) => msg.id === groupId);
      if (!fanGroup) {
        showXToast("未找到粉丝群数据", "error");
        return;
      }
      // 关闭转发选项弹窗和设置弹窗
      closeFanGroupShareModal();
      closeFanGroupSettings(); // 先打开发帖弹窗（会触发重置，清空旧的引用）
      openComposeTweetModal(); // 等待弹窗完全打开并重置完成后，再设置粉丝群引用数据
      setTimeout(() => {
        // 构建粉丝群引用数据
        window.currentQuoteFanGroup = {
          id: fanGroup.id,
          name: fanGroup.userName || fanGroup.groupName || "我的粉丝群",
          avatar:
            fanGroup.userAvatar ||
            fanGroup.groupAvatar ||
            "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
          memberCount: fanGroup.memberCount || 0,
          threshold: fanGroup.groupThreshold || "",
        };
        console.log(
          "📤 [粉丝群转发] 粉丝群引用数据已设置:",
          window.currentQuoteFanGroup
        ); // 添加引用内容显示
        addFanGroupQuoteToCompose();
        showXToast("已添加粉丝群引用，请编写推文内容", "success");
      }, 150);
    } catch (error) {
      console.error("❌ [粉丝群转发] 转发到发帖失败:", error);
      showXToast("转发失败: " + error.message, "error");
    }
  }
  // 在发帖弹窗中添加粉丝群引用显示
  function addFanGroupQuoteToCompose() {
    console.log("🔍 [粉丝群转发] 开始添加引用区域...");
    if (!window.currentQuoteFanGroup) {
      console.warn("⚠️ [粉丝群转发] currentQuoteFanGroup 为空");
      return;
    }
    const fanGroup = window.currentQuoteFanGroup;
    console.log("📤 [粉丝群转发] 粉丝群数据:", fanGroup);
    const modal = document.getElementById("compose-tweet-modal");
    if (!modal) {
      console.error("❌ [粉丝群转发] 找不到发帖弹窗");
      return;
    }
    // 检查是否已存在引用区域
    let quoteSection = document.getElementById(
      "compose-fangroup-quote-section"
    );
    if (quoteSection) {
      console.log("🗑️ [粉丝群转发] 移除旧的引用区域");
      quoteSection.remove();
    }
    // 创建粉丝群引用区域
    quoteSection = document.createElement("div");
    quoteSection.id = "compose-fangroup-quote-section";
    quoteSection.style.cssText = `
 margin: 16px 0 0 0; padding: 12px; border: 1px solid var(--x-border-color); border-radius: 12px; background-color: var(--x-bg-hover);
`;
    quoteSection.innerHTML = `
 <div style="display: flex; align-items: flex-start; gap: 12px;">
 <img src="${
   fanGroup.avatar
 }" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover;">
 <div style="flex: 1; min-width: 0;">
 <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
 <span style="color:var(--x-text-primary); font-size: 15px; font-weight: 700;">${
   fanGroup.name
 }</span>
 <span style="padding: 2px 8px; background-color:var(--x-bg-secondary); color:var(--x-text-secondary); font-size: 11px; border-radius: 4px; font-weight: 600; ">粉丝群</span>
 </div>
 <div style="color:var(--x-text-secondary); font-size: 13px; margin-bottom: 8px;">
 ${fanGroup.memberCount} 位成员
 </div>
 ${
   fanGroup.threshold
     ? `
 <div style="padding: 8px; background-color:var(--x-bg-secondary); border-radius: 6px; color:var(--x-text-secondary); font-size: 12px; line-height: 1.4; ">
 <div style="color:var(--x-text-primary); font-weight: 600; margin-bottom: 2px; font-size: 11px;">入群门槛</div>
 ${
   fanGroup.threshold.length > 60
     ? fanGroup.threshold.substring(0, 60) + "..."
     : fanGroup.threshold
 }
 </div>
 `
     : ""
 }
 </div>
 <div onclick="removeFanGroupQuote()" style="cursor: pointer; padding: 4px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-secondary)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-text-secondary);">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>
 </div>
`; // 找到文本输入框所在的容器
    const textInput = modal.querySelector("#compose-text-input");
    if (!textInput) {
      console.error("❌ [粉丝群转发] 找不到文本输入框");
      return;
    }
    // 获取包含textarea的父容器 (flex: 1; min-width: 0;)
    const inputContainer = textInput.parentElement;
    console.log("📍 [粉丝群转发] 找到输入容器:", inputContainer); // 将引用区域插入到textarea之后、引用预览区域之前
    const quotePreview = modal.querySelector("#quote-content-preview");
    if (quotePreview) {
      inputContainer.insertBefore(quoteSection, quotePreview);
      console.log("✅ [粉丝群转发] 引用区域已插入到引用预览区域之前");
    } else {
      // 如果没有引用预览区域，插入到textarea之后
      inputContainer.insertBefore(quoteSection, textInput.nextSibling);
      console.log("✅ [粉丝群转发] 引用区域已插入到textarea之后");
    }
    console.log("✅ [粉丝群转发] 引用区域添加完成！");
  }
  // 移除粉丝群引用
  window.removeFanGroupQuote = function () {
    console.log("🗑️ [粉丝群转发] 移除引用"); // 清除全局变量
    window.currentQuoteFanGroup = null; // 移除引用区域
    const quoteSection = document.getElementById(
      "compose-fangroup-quote-section"
    );
    if (quoteSection) {
      quoteSection.remove();
      console.log("✅ [粉丝群转发] 引用区域已移除");
    }
    showXToast("已移除粉丝群引用", "info");
  }; // 踢出群成员
  window.kickFanGroupMember = async function (groupId, memberId, memberName) {
    console.log("🚫 [粉丝群] 踢出成员", groupId, memberId, memberName);
    try {
      // 确认操作
      if (!confirm(`确定要将 ${memberName} 踢出粉丝群吗？`)) {
        return;
      }
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      let messagesList = savedData?.data || []; // 找到粉丝群
      const groupIndex = messagesList.findIndex((msg) => msg.id === groupId);
      if (groupIndex === -1) {
        showXToast("未找到粉丝群数据", "error");
        return;
      }
      const fanGroup = messagesList[groupIndex]; // 从成员列表中移除
      if (!fanGroup.members) {
        fanGroup.members = [];
      }
      const memberIndex = fanGroup.members.findIndex((m) => m.id === memberId);
      if (memberIndex === -1) {
        showXToast("未找到该成员", "error");
        return;
      }
      fanGroup.members.splice(memberIndex, 1); // 更新成员数
      fanGroup.memberCount = fanGroup.members.length; // 保存到数据库
      await xDb.xAccountProfiles.put({
        handle: dataId,
        name: "messagesList",
        data: messagesList,
        updatedAt: new Date().toISOString(),
      });
      console.log("✅ [粉丝群] 成员已移除，当前成员数:", fanGroup.memberCount); // 在粉丝群私信中添加系统通知
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${groupId}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (
        savedConversation &&
        savedConversation.data &&
        savedConversation.data.messages
      ) {
        const systemMessage = {
          type: "system",
          systemType: "memberKicked",
          content: `${memberName} 被移出了粉丝群`,
          timestamp: new Date().toISOString(),
          time: "刚刚",
        };
        savedConversation.data.messages.push(systemMessage);
        await xDb.xAccountProfiles.put(savedConversation);
        console.log("✅ [粉丝群] 已添加踢出系统通知"); // 如果当前正在查看该粉丝群聊天，刷新消息显示
        if (
          currentMessageConversation &&
          currentMessageConversation.id === groupId
        ) {
          await window.openMessageDetail(fanGroup);
        }
      }
      showXToast("已将成员移出粉丝群", "success"); // 关闭并重新打开设置弹窗以刷新成员列表
      closeFanGroupSettings();
      setTimeout(() => {
        openFanGroupSettings(fanGroup);
      }, 300);
    } catch (error) {
      console.error("❌ [粉丝群] 踢出成员失败:", error);
      showXToast("操作失败: " + error.message, "error");
    }
  }; // 解散粉丝群
  window.dissolveFanGroup = async function (groupId) {
    console.log("💥 [粉丝群] 解散群聊", groupId);
    try {
      // 确认操作
      if (
        !confirm(
          "确定要解散此粉丝群吗？\n\n解散后将删除所有成员、申请记录和聊天记录，此操作不可撤销！"
        )
      ) {
        return;
      }
      const xDb = getXDB(); // 1. 从私信列表中删除粉丝群
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      let messagesList = savedData?.data || [];
      const groupIndex = messagesList.findIndex((msg) => msg.id === groupId);
      if (groupIndex === -1) {
        showXToast("未找到粉丝群数据", "error");
        return;
      }
      const fanGroupName =
        messagesList[groupIndex].userName || messagesList[groupIndex].groupName;
      messagesList.splice(groupIndex, 1); // 保存更新后的私信列表
      await xDb.xAccountProfiles.put({
        handle: dataId,
        name: "messagesList",
        data: messagesList,
        updatedAt: new Date().toISOString(),
      }); // 更新全局变量
      sampleMessagesData = messagesList;
      console.log("✅ [粉丝群] 已从私信列表中删除"); // 2. 删除粉丝群申请数据
      const applicationsId = `fanGroupApplications_${
        currentAccountId || "main"
      }_${groupId}`;
      try {
        await xDb.xAccountProfiles.delete(applicationsId);
        console.log("✅ [粉丝群] 已删除申请数据");
      } catch (error) {
        console.warn("⚠️ [粉丝群] 删除申请数据时出错（可能不存在）:", error);
      }
      // 3. 删除粉丝群聊天记录
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${groupId}`;
      try {
        await xDb.xAccountProfiles.delete(conversationId);
        console.log("✅ [粉丝群] 已删除聊天记录");
      } catch (error) {
        console.warn("⚠️ [粉丝群] 删除聊天记录时出错（可能不存在）:", error);
      }
      // 4. 关闭所有相关弹窗
      closeFanGroupSettings();
      closeFanGroupApplicationsModal(); // 5. 如果当前正在查看该粉丝群，返回到私信列表
      if (
        currentMessageConversation &&
        currentMessageConversation.id === groupId
      ) {
        currentMessageConversation = null;
        const messageDetailView = document.getElementById(
          "message-detail-view"
        );
        if (messageDetailView) {
          messageDetailView.style.display = "none";
        }
      }
      // 6. 刷新私信列表
      await loadMessagesList();
      showXToast(`已解散粉丝群"${fanGroupName}"`, "success");
    } catch (error) {
      console.error("❌ [粉丝群] 解散失败:", error);
      showXToast("解散失败: " + error.message, "error");
    }
  };

  // 关闭联系人选择弹窗
  window.closeFanGroupContactSelectModal = function () {
    const modal = document.getElementById("fangroup-contact-select-modal");
    if (modal) {
      modal.remove();
    }
    // 清空选择状态
    window.selectedFanGroupContacts = new Set();
  };

  // 切换联系人选择状态
  window.toggleContactSelection = function (contactId) {
    if (!window.selectedFanGroupContacts) {
      window.selectedFanGroupContacts = new Set();
    }

    const contactItem = document.querySelector(
      `.fangroup-contact-item[data-contact-id="${contactId}"]`
    );
    const checkbox = contactItem?.querySelector(".contact-checkbox");

    if (!contactItem || !checkbox) return;

    if (window.selectedFanGroupContacts.has(contactId)) {
      // 取消选择
      window.selectedFanGroupContacts.delete(contactId);
      contactItem.classList.remove("selected");
      checkbox.style.backgroundColor = "var(--x-bg-primary)";
      checkbox.style.borderColor = "var(--x-border-color)";
      checkbox.innerHTML = "";
    } else {
      // 选择
      window.selectedFanGroupContacts.add(contactId);
      contactItem.classList.add("selected");
      checkbox.style.backgroundColor = "var(--x-accent)";
      checkbox.style.borderColor = "var(--x-accent)";
      checkbox.innerHTML = `
 <svg viewBox="0 0 24 24" style="width: 12px; height: 12px; fill: #fff;">
 <g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></g>
 </svg>
 `;
    }

    // 更新确认按钮状态
    const confirmBtn = document.getElementById("fangroup-contact-confirm-btn");
    if (confirmBtn) {
      const selectedCount = window.selectedFanGroupContacts.size;
      confirmBtn.textContent = `转发 (${selectedCount})`;

      if (selectedCount > 0) {
        confirmBtn.disabled = false;
        confirmBtn.style.opacity = "1";
      } else {
        confirmBtn.disabled = true;
        confirmBtn.style.opacity = "0.5";
      }
    }
  };

  // 确认转发粉丝群到选中的联系人
  window.confirmFanGroupContactShare = async function (groupId) {
    if (
      !window.selectedFanGroupContacts ||
      window.selectedFanGroupContacts.size === 0
    ) {
      showXToast("请至少选择一个联系人", "warning");
      return;
    }

    try {
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      const messagesList = savedData?.data || [];

      // 找到粉丝群数据
      const fanGroup = messagesList.find((msg) => msg.id === groupId);
      if (!fanGroup) {
        showXToast("未找到粉丝群数据", "error");
        return;
      }

      console.log(
        `📤 [粉丝群转发] 开始转发到 ${window.selectedFanGroupContacts.size} 个联系人`
      );

      // 构建粉丝群分享消息
      const fanGroupShareMessage = {
        type: "quoteFanGroup",
        fanGroup: {
          id: fanGroup.id,
          name: fanGroup.userName || fanGroup.groupName || "我的粉丝群",
          avatar:
            fanGroup.userAvatar ||
            fanGroup.groupAvatar ||
            "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
          memberCount: fanGroup.memberCount || 0,
          threshold: fanGroup.groupThreshold || "",
        },
        timestamp: new Date().toISOString(),
        time: "刚刚",
        isOwn: true,
      };

      // 转发到每个选中的联系人
      let successCount = 0;
      for (const contactId of window.selectedFanGroupContacts) {
        try {
          const conversationId = `messageConversation_${
            currentAccountId || "main"
          }_${contactId}`;
          const savedConversation = await xDb.xAccountProfiles.get(
            conversationId
          );

          if (savedConversation && savedConversation.data) {
            // 已存在对话，追加消息
            if (!savedConversation.data.messages) {
              savedConversation.data.messages = [];
            }
            savedConversation.data.messages.push(fanGroupShareMessage);
            await xDb.xAccountProfiles.put(savedConversation);
          } else {
            // 新对话，创建初始消息
            await xDb.xAccountProfiles.put({
              handle: conversationId,
              name: "messageConversation",
              data: {
                messages: [fanGroupShareMessage],
              },
              messageId: contactId,
              accountId: currentAccountId || "main",
              updatedAt: new Date().toISOString(),
            });
          }

          // 更新私信列表中的最后消息
          const contact = messagesList.find((msg) => msg.id === contactId);
          if (contact) {
            contact.lastMessage = `[粉丝群] ${
              fanGroup.userName || fanGroup.groupName || "我的粉丝群"
            }`;
            contact.timestamp = new Date().toISOString();
            contact.unread = false; // 用户发送的消息不标记为未读
          }

          successCount++;
          console.log(`✅ [粉丝群转发] 已转发到联系人: ${contactId}`);
        } catch (error) {
          console.error(
            `❌ [粉丝群转发] 转发到联系人 ${contactId} 失败:`,
            error
          );
        }
      }

      // 保存更新后的私信列表
      await xDb.xAccountProfiles.put({
        handle: dataId,
        name: "messagesList",
        data: messagesList,
        updatedAt: new Date().toISOString(),
      });

      // 刷新私信列表
      await loadMessagesList();

      // 关闭弹窗
      closeFanGroupContactSelectModal();
      closeFanGroupSettings(); // 也关闭设置弹窗

      // 显示成功提示
      showXToast(`已转发到 ${successCount} 个联系人`, "success");

      console.log(
        `✅ [粉丝群转发] 转发完成，成功 ${successCount}/${window.selectedFanGroupContacts.size}`
      );
    } catch (error) {
      console.error("❌ [粉丝群转发] 确认转发失败:", error);
      showXToast("转发失败: " + error.message, "error");
    }
  };

  // ============================================
  // 第11个情景：粉丝群私信详情页生成器
  // ============================================
  /**
   * 粉丝群私信对话生成器（第11个情景）
   * @param {Object} fanGroupData - 粉丝群数据
   * @param {boolean} isContinueMode - 是否为续写模式
   * @param {Object} options - 可选参数
   * @returns {Array} AI生成的消息数组
   */
  async function generateFanGroupConversation(
    fanGroupData,
    isContinueMode = false,
    options = {}
  ) {
    console.log("💬 [第11情景] 粉丝群私信生成器启动", {
      groupId: fanGroupData.id,
      groupName: fanGroupData.userName || fanGroupData.groupName,
      isContinueMode,
    });
    try {
      // 🔧 使用统一的API配置加载工具
      const { apiConfig, xSettings, xDb } =
        await APIUtils.loadConfigAndSettings();
      const { userPrompt, worldSetting } = xSettings;
      // 3. 获取用户X平台资料
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(
        window.userProfileData
      ); // 4. 读取用户最近3条推文
      const userTweetsId = `userTweets_${currentAccountId || "main"}`;
      const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
      const recentUserTweets = userTweetsData?.tweets?.slice(0, 3) || [];
      console.log("📋 [第11情景] 用户资料:", userXProfileInfo);
      console.log("📋 [第11情景] 用户推文数:", recentUserTweets.length); // 5. 读取粉丝群详细信息
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      const messagesList = savedData?.data || [];
      const fanGroup = messagesList.find((msg) => msg.id === fanGroupData.id);
      if (!fanGroup) {
        showXToast("未找到粉丝群数据", "error");
        return [];
      }
      // 6. 读取群成员资料和入群申请
      const members = fanGroup.members || [];
      const memberProfiles = [];
      const memberApplications = [];
      console.log("👥 [第11情景] 群成员数:", members.length); // 读取入群申请数据
      const applicationsId = `fanGroupApplications_${
        currentAccountId || "main"
      }_${fanGroup.id}`;
      const applicationsData = await xDb.xAccountProfiles.get(applicationsId);
      const allApplications = applicationsData?.data || [];
      for (const member of members) {
        // 使用统一资料系统获取成员资料（传入messageId以支持陌生人自定义头像）
        const memberProfile = await StringBuilders.getUnifiedProfile(
          member.handle,
          {
            userProfileInfo: userXProfileInfo,
            messageId: member.id, // 🎯 传入成员ID，用于读取陌生人自定义设置
          }
        );
        if (memberProfile) {
          // 🎯 只保留1条最近推文（节省token）
          if (memberProfile.tweets && memberProfile.tweets.length > 0) {
            memberProfile.tweets = [memberProfile.tweets[0]]; // 只保留第一条
          }
          memberProfiles.push(memberProfile);
        }
        // 查找该成员的入群申请
        const application = allApplications.find(
          (app) => app.id === member.id && app.status === "approved"
        );
        if (application) {
          memberApplications.push({
            memberId: member.id,
            memberName: member.name,
            memberHandle: member.handle,
            reason: application.reason,
            type: application.type,
            amount: application.amount,
          });
        }
      }
      console.log("📊 [第11情景] 已加载成员资料:", memberProfiles.length);
      console.log("📊 [第11情景] 已加载入群申请:", memberApplications.length); // Token计数器
      let tokenCount = 0; // 7. 构建基础系统提示词
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage(
        "第11情景-粉丝群私信",
        "基础系统提示词",
        systemPrompt,
        tokenCount
      ); // 8. 获取适用的世界书（使用全局对话场景）
      const worldBooksContent = await StringBuilders.getApplicableWorldBooks(
        "messages",
        {
          boundCharacters: [],
        }
      );
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage(
          "第11情景-粉丝群私信",
          "世界书内容",
          worldBooksContent,
          tokenCount
        );
      }
      // 9. 添加用户资料信息
      systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 用户完整资料（粉丝群主）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
- 用户名：${userXProfileInfo.name}
- 用户句柄：${userXProfileInfo.handle}
- 认证状态：${userXProfileInfo.verified ? "已认证" : "未认证"}
${
  userXProfileInfo.verificationType &&
  userXProfileInfo.verificationType !== "none"
    ? `- 认证类型：${
        userXProfileInfo.verificationType === "verified"
          ? "蓝色勾标认证"
          : userXProfileInfo.verificationType === "couple"
          ? "情侣认证"
          : userXProfileInfo.verificationType === "married"
          ? "已婚认证"
          : userXProfileInfo.verificationType === "vip"
          ? "VIP认证"
          : "无"
      }`
    : ""
}
${
  userXProfileInfo.publicIdentity
    ? `- 公众身份：${userXProfileInfo.publicIdentity}`
    : ""
}
${userXProfileInfo.bio ? `- 个人简介：${userXProfileInfo.bio}` : ""}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`; // 添加用户近期推文
      if (recentUserTweets.length > 0) {
        systemPrompt += `
【用户近期推文】（${recentUserTweets.length}条，了解群主风格）：
`;
        recentUserTweets.forEach((tweet, index) => {
          systemPrompt += `${index + 1}. "${tweet.content}"
- 时间：${tweet.time || "最近"}
- 互动：${tweet.stats?.likes || 0}喜欢，${tweet.stats?.retweets || 0}转发，${
            tweet.stats?.comments || 0
          }评论
`;
        });
      }
      // 10. 添加粉丝群信息
      systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👥 粉丝群信息
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
- 群名：${fanGroup.userName || fanGroup.groupName}
- 群主：${userXProfileInfo.name} (${userXProfileInfo.handle})
- 当前成员数：${members.length} 人
${
  fanGroup.groupThreshold
    ? `- 入群门槛：${fanGroup.groupThreshold}`
    : "- 入群门槛：无"
}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;

      // 10.5. 添加群公告信息
      try {
        const announcementsId = `fanGroupAnnouncements_${
          currentAccountId || "main"
        }_${fanGroup.id}`;
        const savedAnnouncements = await xDb.xAccountProfiles.get(
          announcementsId
        );
        const announcements = savedAnnouncements?.data || [];

        if (announcements.length > 0) {
          systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📢 粉丝群公告（${announcements.length}条）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ 重要：请注意以下群公告内容，这些是群主发布的重要信息，成员的对话可能会涉及这些公告内容。
`;
          // 按时间倒序（最新的在前），最多显示10条
          const recentAnnouncements = announcements.slice(0, 10);
          recentAnnouncements.forEach((announcement, index) => {
            const createdDate = new Date(announcement.createdAt);
            const formattedDate = `${createdDate.getFullYear()}年${
              createdDate.getMonth() + 1
            }月${createdDate.getDate()}日 ${String(
              createdDate.getHours()
            ).padStart(2, "0")}:${String(createdDate.getMinutes()).padStart(
              2,
              "0"
            )}`;
            systemPrompt += `
【公告 ${index + 1}】
发布时间：${formattedDate}
公告内容：${announcement.content}
`;
          });
          systemPrompt += `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          console.log(`📢 [第11情景] 已加载群公告: ${announcements.length}条`);
        }
      } catch (error) {
        console.warn("⚠️ [第11情景] 加载群公告失败:", error);
      }

      // 10.6. 添加群文件信息
      try {
        // 获取文件夹列表
        const foldersId = `fanGroupFolders_${currentAccountId || "main"}_${
          fanGroup.id
        }`;
        const foldersData = await xDb.xAccountProfiles.get(foldersId);
        const folders = foldersData?.data || [];

        // 获取文件列表
        const files = await getFanGroupFiles(fanGroup.id);

        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📁 粉丝群文件库
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ 重要：以下是群内的文件管理系统，成员可以在对话中引用、讨论或上传新文件。
`;

        // 显示文件夹列表
        if (folders.length > 0) {
          systemPrompt += `
【文件夹列表】（${folders.length}个）
⚠️ 上传文件时可以选择放入以下文件夹，也可以不放入任何文件夹（散落显示）
`;
          folders.forEach((folder, index) => {
            const filesInFolder = files.filter((f) => f.folderId === folder.id);
            systemPrompt += `${index + 1}. 文件夹「${folder.name}」
 - 文件夹ID: ${folder.id}（上传文件时使用此ID）
 - 包含文件数: ${filesInFolder.length}个
`;
          });
        } else {
          systemPrompt += `
【文件夹列表】
暂无文件夹，上传的文件将显示为未分类状态
`;
        }

        if (files.length > 0) {
          systemPrompt += `
【已上传文件】（${files.length}个）
`;
          // 最多显示20个文件
          const recentFiles = files.slice(0, 20);
          recentFiles.forEach((file, index) => {
            const uploadDate = new Date(file.uploadedAt);
            const formattedDate = `${
              uploadDate.getMonth() + 1
            }/${uploadDate.getDate()} ${String(uploadDate.getHours()).padStart(
              2,
              "0"
            )}:${String(uploadDate.getMinutes()).padStart(2, "0")}`;
            const fileTypeText =
              file.type === "text"
                ? "文本文档"
                : file.type === "image"
                ? "图片文件"
                : file.type === "video"
                ? "视频文件"
                : file.type === "link"
                ? "链接"
                : "文件";

            systemPrompt += `
【文件 ${index + 1}】
文件名：${file.name}
类型：${fileTypeText}
上传者：${file.uploadedBy}
上传时间：${formattedDate}
所属文件夹：${file.folderName}
内容摘要：${file.content.substring(0, 150)}${
              file.content.length > 150 ? "..." : ""
            }
`;
          });
        }

        systemPrompt += `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
        console.log(
          `📁 [第11情景] 已加载群文件: ${files.length}个, 文件夹: ${folders.length}个`
        );
      } catch (error) {
        console.warn("⚠️ [第11情景] 加载群文件失败:", error);
      }

      // 11. 添加群成员资料（使用统一资料格式化系统）
      if (members.length > 0) {
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👥 群成员资料（${members.length}人）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ 重要：每个成员必须使用以下准确的ID、昵称和句柄，不得自创！
`;
        members.forEach((member, index) => {
          systemPrompt += `
【群成员 ${index + 1}】
- 成员ID: ${member.id}（生成消息时必须使用此ID作为senderId）
- 昵称: ${member.name}（生成消息时必须使用此昵称作为senderName）
- 句柄: ${member.handle}（生成消息时必须使用此句柄作为senderHandle）
- 头像: ${member.avatar}（生成消息时必须使用此头像作为senderAvatar）
`;
          // 🎯 查找该成员的完整资料
          const memberProfile = memberProfiles.find(
            (p) => p.handle === member.handle
          );
          if (memberProfile) {
            // 🎯 使用统一资料格式化系统展示完整资料
            const formattedProfile = StringBuilders.formatProfileForPrompt(
              memberProfile,
              {
                includeType: false, // 不显示类型标识（已经在群成员标题显示）
                includeTweets: true, // 只显示1条最近推文（已在上面设置）
                includeRelationships: true, // 显示关系信息
              }
            );
            systemPrompt += formattedProfile;
          } else {
            // 如果没有获取到资料，显示基本信息
            systemPrompt += `⚠️ 未能获取该成员的详细资料\n`;
          }

          // 添加入群申请信息（了解成员加群动机）
          const application = memberApplications.find(
            (app) => app.memberHandle === member.handle
          );
          if (application) {
            systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📝 入群申请信息（了解该成员加群动机）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
申请理由：${application.reason}
申请类型：${
              application.type === "sincere"
                ? "真诚粉丝"
                : application.type === "normal"
                ? "普通申请"
                : "可疑申请"
            }
${
  application.amount > 0
    ? `入群费用：$${application.amount.toFixed(2)}`
    : "免费入群"
}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
          }
          systemPrompt += `\n`;
        });
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️ 生成消息时的成员身份使用规则
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
必须从上述群成员列表中选择，使用准确的ID和身份信息：
- senderId：必须使用【成员ID】（例如：${members[0]?.id}）
- senderName：必须使用【昵称】（例如：${members[0]?.name}）
- senderHandle：必须使用【句柄】（例如：${members[0]?.handle}）
- senderAvatar：必须使用【头像】（例如：${members[0]?.avatar}）

🚨 禁止自创成员身份！所有发言者必须是上述列出的群成员！
⚠️ 如果某成员已被踢出（在聊天记录中看到"XX 被移出了粉丝群"），则该成员不得再发言！
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
      }
      // 12. 读取现有对话上下文（包括系统通知）
      let existingMessages = [];
      if (isContinueMode) {
        const conversationId = `messageConversation_${
          currentAccountId || "main"
        }_${fanGroup.id}`;
        const savedConversation = await xDb.xAccountProfiles.get(
          conversationId
        );
        if (
          savedConversation &&
          savedConversation.data &&
          savedConversation.data.messages
        ) {
          // 🎯 包含所有消息（包括系统通知），让AI知道成员加入/被踢出等事件
          existingMessages = savedConversation.data.messages;
        }
      }
      console.log(
        "📖 [第11情景] 现有对话记录:",
        existingMessages.length,
        "条（包括系统通知）"
      ); // 添加现有对话上下文
      if (isContinueMode && existingMessages.length > 0) {
        systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💬 粉丝群聊天记录（当前私信的历史记录，包括系统通知）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`; // 显示最近30条消息（包括系统通知）
        const recentMessages = existingMessages.slice(-30);
        recentMessages.forEach((msg, index) => {
          let content = "";

          // 🎯 处理系统通知
          if (msg.type === "system") {
            content = `[系统通知] ${msg.content}`;
            systemPrompt += `${content}\n`;
            return;
          }

          // 普通消息
          const senderName = msg.isOwn
            ? userXProfileInfo.name
            : msg.senderName || "群成员";
          if (msg.type === "text") {
            content = msg.content || "";
          } else if (msg.type === "image") {
            // 用户发送的图片（有imageData）或AI发送的图片（有imageDescription）
            if (msg.isOwn && msg.imageData) {
              content = `[用户发送了图片]`;
            } else if (msg.imageDescription) {
              content = `[图片: ${msg.imageDescription}]`;
            } else {
              content = `[图片]`;
            }
          } else if (msg.type === "voice") {
            content = `[语音: ${msg.voiceText || "语音消息"}]`;
          } else if (msg.type === "sticker") {
            // 用户发送的表情包（有stickerDescription）或AI发送的表情包（有stickerUrl）
            if (msg.isOwn && msg.stickerDescription) {
              content = `[用户发送的表情包: ${msg.stickerDescription}]`;
            } else if (msg.stickerUrl) {
              content = `[表情包: ${msg.stickerUrl}]`;
            } else {
              content = `[表情包]`;
            }
          } else if (msg.type === "transfer") {
            // 转账消息（仅普通转账，粉丝群不支持商业转账）
            const amount = parseFloat(msg.amount || 0).toFixed(2);
            const note = msg.note ? ` (${msg.note})` : "";
            const direction = msg.isOwn ? "转出" : "转入";
            content = `[${direction}: $${amount}${note}]`;
          } else if (msg.type === "link") {
            // 显示文章完整信息
            content = `[文章链接]\n标题：${msg.title}\n简介：${
              msg.description || ""
            }\n作者：${msg.author || ""}\n来源：${msg.source || ""}\n正文：${
              msg.body || msg.description || ""
            }`;
          } else if (msg.type === "quoteTweet") {
            content = `[转发推文: ${msg.tweet?.content || ""}]`;
          } else if (msg.type === "quoteProfile") {
            content = `[分享主页: ${msg.profile?.name || ""}]`;
          } else if (msg.type === "quoteFanGroup") {
            content = `[分享粉丝群: ${msg.fanGroup?.name || ""}（${
              msg.fanGroup?.memberCount || 0
            }人）${
              msg.fanGroup?.threshold
                ? `，入群门槛：${msg.fanGroup.threshold}`
                : ""
            }]`;
          } else if (msg.type === "groupFile") {
            // 群文件消息
            const fileTypeText =
              msg.file?.type === "text"
                ? "文本文档"
                : msg.file?.type === "image"
                ? "图片"
                : msg.file?.type === "video"
                ? "视频"
                : msg.file?.type === "link"
                ? "链接"
                : "文件";
            content = `[群文件: ${
              msg.file?.name || "未命名文件"
            }]\n类型：${fileTypeText}\n上传者：${
              msg.file?.uploadedBy || "未知"
            }\n内容：${msg.file?.content?.substring(0, 100) || ""}${
              msg.file?.content?.length > 100 ? "..." : ""
            }`;
          } else if (msg.type === "forward") {
            // 转发推文或评论，显示完整上下文
            if (msg.forwardType === "tweet") {
              content = `[转发了推文]\n`;
              if (msg.fullContext && msg.fullContext.tweet) {
                const tweet = msg.fullContext.tweet;
                content += `推文作者：${
                  tweet.user?.name || "未知"
                }\n推文内容：${tweet.content || ""}\n`;
                if (
                  msg.fullContext.comments &&
                  msg.fullContext.comments.length > 0
                ) {
                  content += `评论区（${msg.fullContext.comments.length}条评论）：\n`;
                  msg.fullContext.comments.slice(0, 3).forEach((c, i) => {
                    content += ` ${i + 1}. ${c.user?.name || "未知"}: ${
                      c.content || ""
                    }\n`;
                  });
                  if (msg.fullContext.comments.length > 3) {
                    content += ` ...还有${
                      msg.fullContext.comments.length - 3
                    }条评论\n`;
                  }
                }
              } else {
                content += `${msg.forwardContent?.content || ""}`;
              }
            } else if (msg.forwardType === "comment") {
              content = `[转发了评论]\n`;
              if (msg.fullContext) {
                if (msg.fullContext.parentTweet) {
                  content += `原推文作者：${
                    msg.fullContext.parentTweet.user?.name || "未知"
                  }\n原推文内容：${
                    msg.fullContext.parentTweet.content || ""
                  }\n\n`;
                }
                if (msg.fullContext.comment) {
                  content += `评论作者：${
                    msg.fullContext.comment.user?.name || "未知"
                  }\n评论内容：${msg.fullContext.comment.content || ""}`;
                }
              } else {
                content += `${msg.forwardContent?.content || ""}`;
              }
            }
          } else {
            content = `[${msg.type}消息]`;
          }
          if (content) {
            const displayContent =
              content.length > 100
                ? `${content.substring(0, 100)}...`
                : content;
            systemPrompt += `${senderName}: ${displayContent}\n`;
          }
        });
        systemPrompt += `
⚠️ 以上是现有对话记录（包括系统通知），请保持对话的连贯性和一致性
⚠️ 注意：如果看到"XX 被移出了粉丝群"的系统通知，该成员不得再发言！
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`;
      }
      // 13. 添加核心任务说明
      const isAutoTrigger = options.isAutoTrigger || false;
      const newMemberCount = options.newMemberCount || 0;
      systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务：粉丝群对话生成 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的粉丝群私信对话生成器。
**群聊场景**：
- 📱 这是X社交平台的粉丝群私信功能
- 👥 这是一个群聊，有${members.length}位成员
- 👑 群主是${userXProfileInfo.name} (${userXProfileInfo.handle})
${
  isAutoTrigger
    ? `- 🎉 群成员数达到${newMemberCount}人，触发自动群聊`
    : `- 💬 用户${isContinueMode ? "刚刚在群里发言" : "打开了粉丝群聊天"}`
}
**生成要求**：
${
  isAutoTrigger
    ? `
1. 生成5-12条群成员的发言，庆祝群成员达到${newMemberCount}人
2. 成员发言应该多样化：祝贺、感谢群主、分享感受、互相交流等
3. 不同成员的发言风格应该根据其资料和入群申请体现差异
4. 可以@群主或其他成员（使用句柄，如 @${userXProfileInfo.handle}）
5. 🎯 **重要：成员之间要互相交流**，不要只是单向对群主说话
`
    : options.isAutoReaction
    ? `
1. 生成6-15条群成员之间的自发交流消息
2. 🎯 **核心：成员之间的互动交流，而不是对群主的回应**
3. 交流内容可以是：
- 成员之间互相打招呼、闲聊
- 讨论共同感兴趣的话题（根据成员资料推断）
- 分享最近的生活、工作、学习
- 互相@对方进行对话（使用句柄，如 @成员句柄）
- 对其他成员的推文或动态发表看法
- 讨论群主的最近推文（但不是直接@群主）
- 组织活动、约饭、游戏等
4. 每个成员的发言要符合其性格特点和入群申请体现的动机
5. 营造真实的粉丝群内部氛围，像真实的粉丝群一样有活力
6. 至少要有2-3组成员之间的对话往来（A说话->B回应->C插话）
`
    : isContinueMode
    ? `
1. 根据用户最新发言，生成3-8条群成员的回复
2. 🎯 **重要：不要所有成员都只回应群主**
3. 可以有以下几种情况：
- 部分成员直接回应群主的发言
- 部分成员之间互相交流、讨论群主的话题
- 部分成员@其他成员进行对话
4. 回复应该自然、多样，符合各成员的身份和性格
5. 不是每个成员都必须回复，根据话题相关性和成员特点选择
6. 营造真实的群聊氛围，而不是"群主发言->所有人回应"的模式
`
    : `
1. 生成4-8条群成员的日常发言
2. 发言内容可以是：打招呼、分享日常、讨论共同兴趣、询问群主等
3. 体现真实的粉丝群氛围
4. 成员之间可以互相交流，不要只是单向对群主说话
`
}
${
  options.isAutoReaction ? "6." : "5."
} 🚨 只生成群成员的消息，不要生成用户（群主）的消息
${
  options.isAutoReaction ? "7." : "6."
} 每条消息必须包含senderId（成员ID）、senderName（成员昵称）、senderHandle（成员句柄）、senderAvatar（成员头像）
${options.isAutoReaction ? "8." : "7."} 消息类型包括多种，请根据实际需要自然选择
**消息类型使用原则**：
- ⭐ **以文本消息为主**：大部分消息（80-90%）应该是纯文本消息（type: "text"）
- 📷 **偶尔使用其他类型**：仅在特定情况下使用其他消息类型（10-20%）：
* image：当需要分享照片、图片或视觉内容时
* voice：当成员特别激动、情绪强烈时
* sticker：⚠️ **极少使用**（不超过5%）！只在情绪特别强烈且适合用表情包表达时才使用
* transfer：⚠️ **极少使用**！群成员可以发红包给群主或其他成员（5-30美元），需谨慎
* link：当需要分享文章、新闻或故事时
* quoteTweet：当提及或讨论某条推文时
* quoteProfile：当推荐某个账户或介绍某人时
- 🚫 **禁止每种类型都使用**：不要为了展示多样性而强行使用所有消息类型
- ✅ **自然使用**：根据对话内容和情境自然选择消息类型，不刻意
**JSON返回格式**：
\`\`\`json
{
"messages": [
{
 "senderId": "成员ID（从成员列表中选择）",
 "senderName": "成员昵称",
 "senderHandle": "成员句柄（如@username）",
 "senderAvatar": "成员头像URL",
 "type": "text",
 "content": "消息内容",
 "time": "刚刚"
}
]
}
\`\`\`
**消息类型详解**：
1. 文本消息（最常用，首选）：
{
"type": "text",
"content": "消息内容",
"time": "刚刚"
}
2. 图片消息：
{
"type": "image",
"imageDescription": "图片内容的文字描述",
"sensitive": false,
"time": "刚刚"
}
3. 语音消息：
{
"type": "voice",
"voiceText": "先用括号标注出对声音的形容，再是语音内容的文字",
"duration": "时长如0:15",
"time": "刚刚"
}
4. 表情包消息：
{
"type": "sticker",
"stickerUrl": "表情包图片链接（从世界书中选择）",
"time": "刚刚"
}
5. 转账消息（普通转账，群成员发红包）：
{
"type": "transfer",
"amount": 20.00,
"note": "感谢群主",
"status": "pending",
"time": "刚刚"
}
⚠️ 转账说明：
- amount：转账金额（数字类型），建议5-30美元
- note：转账备注，说明转账目的
- status：必须为"pending"
- 🚫 **不支持商业转账**：粉丝群中只能发普通转账（红包、礼物等）
- 🚫 **谨慎使用**：只有关系亲密或有明确理由时才转账
6. 文章链接消息：
{
"type": "link",
"url": "文章来源网址（可选）",
"title": "文章标题",
"description": "文章简介/摘要",
"author": "文章作者",
"source": "文章来源名称",
"body": "文章正文内容（完整内容，可使用**文本**加粗，__文本__下划线）",
"time": "刚刚"
}
7. 转发推文：
{
"type": "quoteTweet",
"tweet": {
"userName": "推文作者名",
"userHandle": "@handle",
"userAvatar": "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
"verified": false,
"content": "推文内容",
"time": "推文时间"
},
"caption": "转发时的说明（可选）",
"time": "刚刚"
}
8. 转发主页：
{
"type": "quoteProfile",
"profile": {
"name": "账户名",
"handle": "@handle",
"avatar": "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
"bio": "个人简介",
"followers": 关注者数量（数字）,
"verified": false
},
"caption": "转发时的说明（可选）",
"time": "刚刚"
}
9. 转发粉丝群：
{
"type": "quoteFanGroup",
"fanGroup": {
"id": "粉丝群ID",
"name": "粉丝群名称",
"avatar": "粉丝群头像链接",
"memberCount": 成员数量（数字）,
"threshold": "入群门槛说明（可选）"
},
"caption": "转发时的说明（可选）",
"time": "刚刚"
}
⚠️ 转发粉丝群说明：
- 这是用户转发粉丝群邀请时的消息类型
- 包含粉丝群的基本信息：名称、头像、成员数、入群门槛等
- 群成员可以根据粉丝群信息决定是否感兴趣、讨论这个群等
- AI不应该主动生成此类型消息（除非有合理的场景理由）
10. 群文件上传：
{
"type": "groupFile",
"file": {
"name": "文件名称",
"type": "文件类型（text/image/video/link）",
"content": "文件内容（完整文本内容、链接URL等）",
"folderId": "文件夹ID（可选）"
},
"time": "刚刚"
}
⚠️ 群文件说明：
- 成员可以上传文本文档、图片链接、视频链接、文章链接等各种资料到群文件
- file.type：文件类型（text文本、image图片、video视频、link链接）
- file.content：文件实际内容，对于文本是完整内容，对于链接是URL
- file.name：文件名，应该能够概括文件内容
- file.folderId：📂 **文件夹归类**（可选字段）
 * 如果要将文件放入特定文件夹，从上方【文件夹列表】中选择对应的文件夹ID
 * 例如：如果有文件夹「学习资料」ID为folder_123，设置"folderId": "folder_123"
 * 如果不指定或设为null，文件将显示为"未分类"状态
 * 💡 建议：相关主题的文件归入同一文件夹，方便查找和管理
- 📁 成员上传的文件会自动添加到群文件库，群主和其他成员可以在群文件中查看
- 🎯 使用场景：分享学习资料、工作文档、有用的链接、图片素材等
- 🎯 归类建议：根据内容类型选择合适的文件夹，如学习资料放入学习文件夹，图片素材放入素材文件夹
11. 转发推文/评论（forward）：
⚠️ **此类型禁止AI生成！这是用户手动转发操作产生的消息类型。**
如果在聊天记录中看到此类型消息，说明用户转发了推文或评论到群里，可以查看其中的完整内容：
- 转发推文时，包含完整推文内容和该推文的所有评论区内容
- 转发评论时，包含评论内容和该评论所属的推文内容
AI应该根据这些完整的上下文信息来理解用户分享的内容并给出回应。
⚠️ 重要规则：
- 群成员ID、昵称、句柄、头像必须从上方群成员资料中选择，不要自创
- 每个成员的发言要符合其资料和入群申请体现的性格特点
- 保持群聊的真实感和多样性，避免千篇一律
- ⚠️ image和sticker是完全不同的类型，不要混淆！
- ⚠️ link类型是文章链接，需要包含完整的文章内容
- 时间使用相对时间（如"刚刚"、"1分钟前"等）
- 所有头像统一使用成员列表中提供的头像URL
- verified字段必须是布尔值(true/false)
- followers等数字字段必须是纯数字
- 可选字段不使用时完全省略，不要设为null
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`; // 14. 添加通用约束
      const userConstraintsStart = systemPrompt.length;
      systemPrompt +=
        StringBuilders.buildUniversalConstraints(userXProfileInfo);
      const userConstraints = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage(
        "第11情景-粉丝群私信",
        "用户约束",
        userConstraints,
        tokenCount
      );
      const messages = [{ role: "user", content: "请生成粉丝群对话" }]; // 最终统计
      TokenUtils.logFinalPrompt(
        "第11情景-粉丝群私信",
        systemPrompt,
        messages[0].content
      );
      // 🔧 使用统一的API请求工具
      const aiResponseContent = await APIUtils.sendAIRequest({
        apiConfig,
        systemPrompt,
        messages,
        temperature: 0.9,
      });
      console.log(
        "🎯 [第11情景] AI响应长度:",
        aiResponseContent.length,
        "字符"
      );
      console.log("🎯 [第11情景] AI完整响应:\n", aiResponseContent);
      // 🔧 使用统一的JSON解析工具
      let conversationData = APIUtils.parseJSONResponse(aiResponseContent);
      if (
        !conversationData.messages ||
        !Array.isArray(conversationData.messages)
      ) {
        throw new Error("AI返回的数据格式不正确");
      }
      console.log(
        `✅ [第11情景] 成功解析JSON，共${conversationData.messages.length}条消息`
      );
      console.log(
        "📋 [第11情景] 消息发送者列表:",
        conversationData.messages
          .map((m) => `${m.senderName}(${m.senderId})`)
          .join(", ")
      ); // 17. 处理生成的消息
      const generatedMessages = conversationData.messages.map((msg) => ({
        type: msg.type || "text",
        content: msg.content || "",
        isOwn: false, // 群成员消息
        time: msg.time || "刚刚",
        timestamp: new Date().toISOString(),
        // 群聊特有字段
        senderId: msg.senderId,
        senderName: msg.senderName,
        senderHandle: msg.senderHandle,
        senderAvatar: msg.senderAvatar,
        // 文本消息字段
        // (content 已在上面)
        // 图片消息字段
        imageDescription: msg.imageDescription,
        sensitive: msg.sensitive,
        // 表情包消息字段
        stickerUrl: msg.stickerUrl,
        // 语音消息字段
        voiceText: msg.voiceText,
        voiceDuration: msg.voiceDuration,
        duration: msg.duration,
        // 转账消息字段
        amount: msg.amount,
        note: msg.note,
        status: msg.status,
        // 文章链接字段
        title: msg.title,
        description: msg.description,
        author: msg.author,
        source: msg.source,
        body: msg.body,
        url: msg.url,
        // 转发推文字段
        tweet: msg.tweet,
        caption: msg.caption,
        // 转发主页字段
        profile: msg.profile,
        // 群文件字段
        file: msg.file
          ? {
              name: msg.file.name,
              type: msg.file.type,
              content: msg.file.content,
              folderId: msg.file.folderId || null,
              uploadedBy: msg.senderName,
              uploadedAt: new Date().toISOString(),
            }
          : undefined,
        // caption 已在上面
      }));
      console.log(
        `✅ [第11情景] 成功生成${generatedMessages.length}条群聊消息`
      );

      // 17.5. 处理AI生成的群文件消息，自动保存到群文件数据库
      const fileMessages = generatedMessages.filter(
        (msg) => msg.type === "groupFile" && msg.file
      );
      if (fileMessages.length > 0) {
        console.log(
          `📁 [第11情景] 检测到${fileMessages.length}个AI生成的群文件，正在保存...`
        );
        try {
          const filesId = `fanGroupFiles_${currentAccountId || "main"}_${
            fanGroup.id
          }`;
          const savedData = await xDb.xAccountProfiles.get(filesId);
          let files = savedData?.data || [];

          for (const msg of fileMessages) {
            const newFile = {
              id: `file_ai_${Date.now()}_${Math.random()
                .toString(36)
                .substr(2, 9)}`,
              name: msg.file.name,
              type: msg.file.type,
              content: msg.file.content,
              folderId: msg.file.folderId || null,
              uploadedBy: msg.senderName,
              uploadedAt: msg.file.uploadedAt || new Date().toISOString(),
            };

            files.push(newFile);

            // 更新消息中的文件ID
            msg.file.id = newFile.id;

            console.log(
              `✅ [群文件] AI上传文件: ${newFile.name} (${msg.senderName})`
            );
          }

          await xDb.xAccountProfiles.put({
            handle: filesId,
            name: "fanGroupFiles",
            data: files,
            updatedAt: new Date().toISOString(),
          });

          console.log(
            `✅ [第11情景] 已保存${fileMessages.length}个AI生成的群文件到数据库`
          );
        } catch (error) {
          console.error("❌ [第11情景] 保存AI生成的群文件失败:", error);
        }
      }

      // 18. 头像修正
      const avatarCorrectedData = await StringBuilders.enforceAvatarRules({
        messages: generatedMessages,
      });
      return avatarCorrectedData.messages || generatedMessages;
    } catch (error) {
      console.error("❌ [第11情景] 生成粉丝群对话失败:", error);
      showXToast("生成对话失败: " + error.message, "error");
      return [];
    }
  }
  // 触发粉丝群自反应（成员自发交流）
  window.triggerFanGroupAutoReaction = async function () {
    console.log("🎭 [粉丝群自反应] 开始触发");
    if (!currentMessageConversation) {
      showXToast("会话数据丢失", "error");
      return;
    }
    // 检查是否是粉丝群
    const isFanGroup =
      currentMessageConversation.type === "fangroup" ||
      (currentMessageConversation.id &&
        currentMessageConversation.id.startsWith("fangroup_"));
    if (!isFanGroup) {
      showXToast("只有粉丝群支持自反应功能", "info");
      return;
    }
    // 保存当前会话引用
    const conversationRef = currentMessageConversation; // 禁用按钮
    const autoReactionBtn = document.getElementById(
      "fangroup-auto-reaction-btn"
    );
    const sendBtn = document.getElementById("message-send-btn");
    if (autoReactionBtn) {
      autoReactionBtn.disabled = true;
      autoReactionBtn.style.opacity = "0.5";
    }
    if (sendBtn) {
      sendBtn.disabled = true;
      sendBtn.style.opacity = "0.5";
    }
    try {
      // 显示"正在输入中"气泡
      console.log("📤 [粉丝群自反应] 显示输入气泡");
      showTypingIndicator(); // 显示提示
      showXToast("群成员正在交流中...", "info"); // 调用第11个情景生成器（自反应模式）
      console.log("📤 [粉丝群自反应] 调用第11个情景生成器");
      const aiMessages = await generateFanGroupConversation(
        conversationRef,
        true,
        {
          isAutoReaction: true, // 自反应模式标记
        }
      );
      console.log(
        `📤 [粉丝群自反应] AI返回了 ${
          aiMessages ? aiMessages.length : 0
        } 条消息`
      ); // 隐藏"正在输入中"气泡
      hideTypingIndicator();
      if (!aiMessages || aiMessages.length === 0) {
        showXToast("群成员暂时没有发言", "info");
        return;
      }
      // 读取现有对话数据
      const xDb = getXDB();
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${conversationRef.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      let allMessages = [];
      if (
        savedConversation &&
        savedConversation.data &&
        savedConversation.data.messages
      ) {
        allMessages = savedConversation.data.messages;
      }
      // 追加AI生成的消息
      allMessages.push(...aiMessages); // 保存到数据库
      await xDb.xAccountProfiles.put({
        handle: conversationId,
        name: "conversation",
        data: {
          messages: allMessages,
        },
        updatedAt: new Date().toISOString(),
      });
      console.log("📤 [粉丝群自反应] 消息已保存到数据库"); // 更新私信列表的预览
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const messagesList = await xDb.xAccountProfiles.get(dataId);
      if (messagesList && messagesList.data) {
        const groupIndex = messagesList.data.findIndex(
          (msg) => msg.id === conversationRef.id
        );
        if (groupIndex !== -1) {
          const lastMsg = aiMessages[aiMessages.length - 1];
          const lastMsgContent =
            lastMsg.content ||
            lastMsg.voiceText ||
            lastMsg.imageDescription ||
            "[消息]";
          messagesList.data[
            groupIndex
          ].lastMessage = `${lastMsg.senderName}: ${lastMsgContent}`;
          messagesList.data[groupIndex].timestamp = new Date().toISOString();
          await xDb.xAccountProfiles.put(messagesList);
          console.log("📤 [粉丝群自反应] 私信列表预览已更新");
        }
      }
      // 渲染AI消息到页面（带动画）
      const contentContainer = document.getElementById(
        "message-detail-content"
      );
      if (contentContainer) {
        const messageElements = [];
        aiMessages.forEach((msg, index) => {
          const msgEl = renderMessageItem(
            msg,
            false,
            allMessages.length - aiMessages.length + index,
            true,
            true
          );
          contentContainer.appendChild(msgEl);
          messageElements.push(msgEl);
        }); // 逐条弹出动画
        await animateMessagesOneByOne(messageElements, 300);
      }
      showXToast(`群内产生了 ${aiMessages.length} 条新对话`, "success");
    } catch (error) {
      console.error("❌ [粉丝群自反应] 生成失败:", error);
      hideTypingIndicator();
      showXToast("生成失败: " + error.message, "error");
    } finally {
      // 恢复按钮状态
      if (autoReactionBtn) {
        autoReactionBtn.disabled = false;
        autoReactionBtn.style.opacity = "1";
      }
      if (sendBtn) {
        sendBtn.disabled = false;
        sendBtn.style.opacity = "1";
      }
    }
  }; // 粉丝群成员数自动触发机制
  async function checkAndTriggerFanGroupAutoChat(groupId, newMemberCount) {
    console.log("🔍 [粉丝群] 检查自动触发条件", { groupId, newMemberCount }); // 触发条件：5、15、25、35...（每10人一次）
    const triggerPoints = [5, 15, 25, 35, 45, 55, 65, 75, 85, 95];
    const shouldTrigger = triggerPoints.includes(newMemberCount);
    if (!shouldTrigger) {
      console.log("⏸️ [粉丝群] 未达到触发条件");
      return;
    }
    console.log(`🎉 [粉丝群] 成员数达到${newMemberCount}人，触发自动群聊！`);
    try {
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      const messagesList = savedData?.data || [];
      const fanGroup = messagesList.find((msg) => msg.id === groupId);
      if (!fanGroup) {
        console.error("❌ [粉丝群] 未找到粉丝群数据");
        return;
      }
      // 调用第11情景生成器
      const aiMessages = await generateFanGroupConversation(fanGroup, true, {
        isAutoTrigger: true,
        newMemberCount: newMemberCount,
      });
      if (!aiMessages || aiMessages.length === 0) {
        console.error("❌ [粉丝群] AI未生成任何消息");
        return;
      }
      // 保存到数据库
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${groupId}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (!savedConversation || !savedConversation.data) {
        // 初始化对话
        await xDb.xAccountProfiles.put({
          handle: conversationId,
          name: "conversation",
          data: {
            messages: aiMessages,
          },
          updatedAt: new Date().toISOString(),
        });
      } else {
        // 追加消息
        savedConversation.data.messages.push(...aiMessages);
        await xDb.xAccountProfiles.put(savedConversation);
      }
      console.log(`✅ [粉丝群] 已保存${aiMessages.length}条自动生成的群聊消息`); // 更新私信列表预览
      if (savedData && savedData.data) {
        const groupIndex = savedData.data.findIndex(
          (msg) => msg.id === groupId
        );
        if (groupIndex !== -1) {
          const lastMsg = aiMessages[aiMessages.length - 1];
          savedData.data[groupIndex].lastMessage =
            lastMsg.content ||
            lastMsg.voiceText ||
            lastMsg.imageDescription ||
            "[消息]";
          savedData.data[groupIndex].timestamp = new Date().toISOString();
          savedData.data[groupIndex].unread = true;
          await xDb.xAccountProfiles.put(savedData);
          sampleMessagesData = savedData.data;
        }
      }
      // 刷新私信列表
      await loadMessagesList(); // 显示通知
      showPhoneNotification({
        title: fanGroup.userName || fanGroup.groupName,
        message: `群成员达到${newMemberCount}人啦！大家都在庆祝呢~`,
        avatar:
          fanGroup.userAvatar ||
          "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
        leftIcon: "custom",
        leftIconHtml: `
 <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: var(--x-accent);">
 <g><path d="M17.5 4.5c-1.95-1.96-5.11-1.96-7.07 0-1.96 1.96-1.96 5.11 0 7.07 1.95 1.96 5.11 1.96 7.07 0 1.96-1.96 1.96-5.11 0-7.07zM14 9c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z M12 14H6c-1.1 0-2 .9-2 2v5h16v-5c0-1.1-.9-2-2-2h-6z"></path></g>
 </svg>
 `,
        duration: 5000,
        onClick: () => {
          window.openMessageDetail(fanGroup);
        },
      });
      showXToast(`粉丝群达到${newMemberCount}人！`, "success");
    } catch (error) {
      console.error("❌ [粉丝群] 自动触发失败:", error);
    }
  }

  // ============================================
  // 粉丝群公告功能
  // ============================================
  // 打开群公告弹窗
  window.openFanGroupAnnouncementModal = async function () {
    // 检查是否是粉丝群
    const isFanGroup =
      currentMessageConversation &&
      (currentMessageConversation.type === "fangroup" ||
        (currentMessageConversation.id &&
          currentMessageConversation.id.startsWith("fangroup_")));

    if (!isFanGroup) {
      showXToast("当前不是粉丝群聊天", "error");
      return;
    }

    console.log("📢 [群公告] 打开群公告弹窗", currentMessageConversation.id);

    try {
      // 显示弹窗
      const modal = document.getElementById("fangroup-announcement-modal");
      if (modal) {
        modal.style.display = "flex";
      }

      // 加载公告列表
      await loadFanGroupAnnouncements();
    } catch (error) {
      console.error("❌ [群公告] 打开弹窗失败:", error);
      showXToast("打开失败: " + error.message, "error");
    }
  };

  // 关闭群公告弹窗
  window.closeFanGroupAnnouncementModal = function () {
    const modal = document.getElementById("fangroup-announcement-modal");
    if (modal) {
      modal.style.display = "none";
    }
  };

  // 打开创建公告对话框
  window.openCreateAnnouncementDialog = function () {
    const dialog = document.getElementById("create-announcement-dialog");
    const contentInput = document.getElementById("announcement-content-input");
    const mentionCheckbox = document.getElementById("mention-all-checkbox");
    const counter = document.getElementById("announcement-counter");

    if (dialog) {
      dialog.style.display = "flex";
    }

    // 重置表单
    if (contentInput) {
      contentInput.value = "";
    }
    if (mentionCheckbox) {
      mentionCheckbox.checked = false;
    }
    if (counter) {
      counter.textContent = "0 / 500";
    }
  };

  // 关闭创建公告对话框
  window.closeCreateAnnouncementDialog = function () {
    const dialog = document.getElementById("create-announcement-dialog");
    if (dialog) {
      dialog.style.display = "none";
    }
  };

  // 更新公告内容字符计数
  window.updateAnnouncementCounter = function () {
    const contentInput = document.getElementById("announcement-content-input");
    const counter = document.getElementById("announcement-counter");
    if (contentInput && counter) {
      const length = contentInput.value.length;
      counter.textContent = `${length} / 500`;
    }
  };

  // 加载粉丝群公告列表
  async function loadFanGroupAnnouncements() {
    if (!currentMessageConversation) return;

    const groupId = currentMessageConversation.id;
    const container = document.getElementById(
      "fangroup-announcements-container"
    );
    if (!container) return;

    try {
      const xDb = getXDB();
      const announcementsId = `fanGroupAnnouncements_${
        currentAccountId || "main"
      }_${groupId}`;
      const savedData = await xDb.xAccountProfiles.get(announcementsId);
      const announcements = savedData?.data || [];

      console.log("📢 [群公告] 加载公告列表", {
        groupId,
        count: announcements.length,
      });

      // 清空容器
      container.innerHTML = "";

      if (announcements.length === 0) {
        // 显示空状态
        container.innerHTML = `
 <div style="width: 100%; text-align: center; color:var(--x-text-secondary); font-size: 14px; padding: 40px 20px; grid-column: 1 / -1;">
 📌 暂无公告，点击下方按钮创建第一条公告
 </div>
 `;
        return;
      }

      // 渲染公告卡片（便利贴风格）
      announcements.forEach((announcement, index) => {
        const card = renderAnnouncementCard(announcement, index);
        container.appendChild(card);
      });
    } catch (error) {
      console.error("❌ [群公告] 加载失败:", error);
      container.innerHTML = `
 <div style="width: 100%; text-align: center; color: #ef4444; font-size: 14px; padding: 40px 20px; grid-column: 1 / -1;">
 ❌ 加载失败，请重试
 </div>
 `;
    }
  }

  // 颜色辅助函数：加深颜色
  function darkenColor(hex, percent) {
    const num = parseInt(hex.replace("#", ""), 16);
    const amt = Math.round(2.55 * percent);
    const R = Math.max((num >> 16) - amt, 0);
    const G = Math.max(((num >> 8) & 0x00ff) - amt, 0);
    const B = Math.max((num & 0x0000ff) - amt, 0);
    return (
      "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1)
    );
  }

  // 颜色辅助函数：减淡颜色
  function lightenColor(hex, percent) {
    const num = parseInt(hex.replace("#", ""), 16);
    const amt = Math.round(2.55 * percent);
    const R = Math.min((num >> 16) + amt, 255);
    const G = Math.min(((num >> 8) & 0x00ff) + amt, 255);
    const B = Math.min((num & 0x0000ff) + amt, 255);
    return (
      "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1)
    );
  }

  // 颜色辅助函数：根据背景色计算对比色（自动选择黑或白）
  function getContrastColor(hex, opacity = 1) {
    const num = parseInt(hex.replace("#", ""), 16);
    const R = (num >> 16) & 0xff;
    const G = (num >> 8) & 0xff;
    const B = num & 0xff;
    // 计算亮度（感知亮度公式）
    const brightness = (R * 299 + G * 587 + B * 114) / 1000;
    // 根据亮度返回黑色或白色
    if (brightness > 128) {
      // 背景较亮，使用深色文字
      return opacity === 1 ? "#1f2937" : `rgba(31, 41, 55, ${opacity})`;
    } else {
      // 背景较暗，使用浅色文字
      return opacity === 1 ? "#f9fafb" : `rgba(249, 250, 251, ${opacity})`;
    }
  }

  // 渲染便利贴风格的公告卡片
  function renderAnnouncementCard(announcement, index) {
    const card = document.createElement("div");

    // 便利贴颜色池（统一使用用户提供的色系）
    const xSocialScreen = document.getElementById("x-social-screen");
    const isLightMode = xSocialScreen?.classList.contains("x-theme-light");

    const allColors = [
      "#EB9FAA",
      "#F7D2D5",
      "#FCEFF0",
      "#C0CEE4",
      "#F2E4E9",
      "#A0A0A3",
      "#BFBBBE",
      "#5F5F60",
      "#67B3DB",
      "#9EDAF1",
      "#CDEEF8",
      "#FFFBDD",
      "#D40D3E",
      "#FDF5DC",
      "#C9EAF8",
      "#DA2E53",
      "#FFEBD5",
      "#FFC4AF",
      "#FF8D65",
      "#8FDBE0",
    ];

    // 🎲 随机选择颜色（而不是按索引顺序）
    const randomColorIndex = Math.floor(Math.random() * allColors.length);
    const bgColor = allColors[randomColorIndex];
    const color = {
      bg: bgColor,
      border: isLightMode
        ? darkenColor(bgColor, 15)
        : lightenColor(bgColor, 15),
    };

    // 随机旋转角度（移动端减少旋转，避免偏移）
    const isMobile = window.innerWidth <= 640;
    const rotationRange = isMobile ? 1.5 : 3; // 移动端旋转范围 -1.5 到 1.5 度
    const rotation = (
      Math.random() * rotationRange * 2 -
      rotationRange
    ).toFixed(2);

    // 随机决定装饰元素类型
    const decorationType = Math.random();
    const hasClip = decorationType < 0.3; // 30% 概率显示回形针
    const hasTape = decorationType >= 0.3 && decorationType < 0.6; // 30% 概率显示胶带
    const hasTear = decorationType >= 0.6; // 40% 概率显示撕边效果

    // 随机回形针位置和颜色
    const clipPosition = Math.random() > 0.5 ? "left" : "right";
    const clipColors = ["#c0c0c0", "#ffd700", "#ff6b6b", "#4ecdc4"];
    const clipColor = clipColors[Math.floor(Math.random() * clipColors.length)];

    // 随机添加褶皱效果
    const hasCrinkle = Math.random() > 0.5;
    const crinklePosition = `${Math.random() * 60 + 20}%`;
    const crinkleRotation = Math.random() > 0.5 ? "45deg" : "-45deg";

    // 格式化时间
    const createdDate = new Date(announcement.createdAt);
    const formattedDate = `${createdDate.getFullYear()}/${String(
      createdDate.getMonth() + 1
    ).padStart(2, "0")}/${String(createdDate.getDate()).padStart(
      2,
      "0"
    )} ${String(createdDate.getHours()).padStart(2, "0")}:${String(
      createdDate.getMinutes()
    ).padStart(2, "0")}`;

    // 撕边效果的 clip-path
    const tearEffect = hasTear
      ? `polygon(
 0% 2%, 3% 0%, 6% 2%, 9% 0%, 12% 1%, 15% 0%, 18% 2%, 21% 0%, 24% 1%, 27% 0%,
 30% 2%, 33% 0%, 36% 1%, 39% 0%, 42% 2%, 45% 0%, 48% 1%, 51% 0%, 54% 2%,
 57% 0%, 60% 1%, 63% 0%, 66% 2%, 69% 0%, 72% 1%, 75% 0%, 78% 2%, 81% 0%,
 84% 1%, 87% 0%, 90% 2%, 93% 0%, 96% 1%, 100% 0%, 100% 100%, 0% 100%
 )`
      : "none";

    card.style.cssText = `
 width: 100%;
 max-width: 400px;
 min-height: 180px;
 margin: 0 auto;
 background-color: ${color.bg};
 background-image:
 repeating-linear-gradient(
 0deg,
 transparent,
 transparent 2px,
 rgba(0, 0, 0, 0.025) 2px,
 rgba(0, 0, 0, 0.025) 3px
 );
 border: none;
 border-radius: ${hasTear ? "0" : "3px"};
 padding: ${isMobile ? "16px" : "20px"};
 box-shadow:
 0 1px 3px rgba(0, 0, 0, 0.12),
 0 3px 6px rgba(0, 0, 0, 0.08),
 inset 0 1px 0 rgba(255, 255, 255, 0.15),
 inset 0 0 30px rgba(255, 255, 255, 0.05);
 cursor: pointer;
 transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
 transform: rotate(${rotation}deg);
 position: relative;
 overflow: visible;
 animation: announceCardFadeIn 0.5s ease-out ${index * 0.12}s both;
 clip-path: ${tearEffect};
 filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
 `;

    // 根据背景颜色亮度决定文字颜色
    const textColor = getContrastColor(bgColor);
    const secondaryTextColor = getContrastColor(bgColor, 0.65);

    card.innerHTML = `
 ${
   hasTape
     ? `

 <div style="position: absolute; top: ${Math.random() * 10 - 5}px; left: ${
         Math.random() * 20 + 40
       }%; transform: translateX(-50%) rotate(${
         Math.random() * 6 - 3
       }deg); width: 80px; height: 25px; background: rgba(255, 255, 255, ${
         isLightMode ? "0.5" : "0.15"
       }); opacity: 0.7; border-left: 1px solid rgba(0, 0, 0, 0.05); border-right: 1px solid rgba(0, 0, 0, 0.05); z-index: 1;"></div>
 `
     : ""
 }

 ${
   hasClip
     ? `

 <div style="position: absolute; top: 8px; ${clipPosition}: 12px; width: 8px; height: 24px; border: 2px solid ${clipColor}; border-radius: 8px 8px 4px 4px; transform: rotate(${
         Math.random() * 20 - 10
       }deg); opacity: 0.8; box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.2);"></div>
 `
     : ""
 }

 ${
   hasCrinkle
     ? `

 <div style="position: absolute; top: 0; left: ${crinklePosition}; width: 1px; height: 100%; background: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.06) 20%, rgba(0, 0, 0, 0.06) 80%, transparent); transform: rotate(${crinkleRotation}); pointer-events: none;"></div>
 `
     : ""
 }

 <div style="position: absolute; inset: 0; background: repeating-linear-gradient(90deg, transparent, transparent 1px, rgba(0,0,0,0.015) 1px, rgba(0,0,0,0.015) 2px), repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(0,0,0,0.015) 1px, rgba(0,0,0,0.015) 2px); pointer-events: none; opacity: 0.6;"></div>

 <div style="position: relative; z-index: 2; color: ${textColor}; font-size: 14px; line-height: 1.8; margin-bottom: 16px; word-wrap: break-word; white-space: pre-wrap; font-family: 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif; text-shadow: 0 1px 0 rgba(255, 255, 255, 0.1);">
 ${announcement.content}
 </div>

 <div style="position: relative; z-index: 2; display: flex; align-items: center; justify-content: space-between; margin-top: 16px; padding-top: 12px; border-top: 1px dashed ${
   color.border
 };">
 <div style="font-size: 11px; color: ${secondaryTextColor}; font-style: italic; opacity: 0.8;">
 ${formattedDate}
 </div>
 <button onclick="event.stopPropagation(); deleteFanGroupAnnouncement('${
   announcement.id
 }')" style="background: rgba(0, 0, 0, 0.05); border: 1px solid ${
      color.border
    }; color: ${textColor}; cursor: pointer; padding: 5px 10px; border-radius: 6px; font-size: 12px; font-weight: 600; transition: all 0.2s;" onmouseover="this.style.backgroundColor='rgba(0, 0, 0, 0.15)'; this.style.transform='scale(1.05)'" onmouseout="this.style.backgroundColor='rgba(0, 0, 0, 0.05)'; this.style.transform='scale(1)'">
 🗑️
 </button>
 </div>
 `;

    // Hover效果 - 更自然的便利贴拿起效果
    card.addEventListener("mouseenter", () => {
      card.style.transform = `rotate(${
        parseFloat(rotation) * 0.5
      }deg) translateY(-12px) scale(1.03)`;
      card.style.filter = "drop-shadow(0 8px 16px rgba(0, 0, 0, 0.2))";
      card.style.zIndex = "100";
    });

    card.addEventListener("mouseleave", () => {
      card.style.transform = `rotate(${rotation}deg) translateY(0) scale(1)`;
      card.style.filter = "drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1))";
      card.style.zIndex = "auto";
    });

    return card;
  }

  // 添加动画样式（如果尚未添加）
  if (!document.getElementById("announcement-card-animation-style")) {
    const style = document.createElement("style");
    style.id = "announcement-card-animation-style";
    style.textContent = `
 @keyframes announceCardFadeIn {
 0% {
 opacity: 0;
 transform: translateY(-40px) translateX(-20px) rotate(-5deg) scale(0.9);
 filter: drop-shadow(0 0 0 rgba(0, 0, 0, 0));
 }
 60% {
 opacity: 1;
 transform: translateY(5px) translateX(2px) rotate(2deg) scale(1.02);
 }
 100% {
 opacity: 1;
 transform: translateY(0) translateX(0) rotate(var(--rotation, 0deg)) scale(1);
 filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
 }
 }

 /* 移动端优化 */
 @media (max-width: 640px) {
 #fangroup-announcements-container {
 padding: 16px 12px !important;
 gap: 20px 12px !important;
 }
 }
 `;
    document.head.appendChild(style);
  }

  // 保存粉丝群公告
  window.saveFanGroupAnnouncement = async function () {
    // 检查是否是粉丝群
    const isFanGroup =
      currentMessageConversation &&
      (currentMessageConversation.type === "fangroup" ||
        (currentMessageConversation.id &&
          currentMessageConversation.id.startsWith("fangroup_")));

    if (!isFanGroup) {
      showXToast("当前不是粉丝群聊天", "error");
      return;
    }

    const contentInput = document.getElementById("announcement-content-input");
    const mentionCheckbox = document.getElementById("mention-all-checkbox");
    const content = contentInput?.value?.trim();

    if (!content) {
      showXToast("请输入公告内容", "warning");
      return;
    }

    const groupId = currentMessageConversation.id;
    const shouldMentionAll = mentionCheckbox?.checked || false;

    console.log("📢 [群公告] 保存新公告", {
      groupId,
      content,
      shouldMentionAll,
    });

    try {
      const xDb = getXDB();
      const announcementsId = `fanGroupAnnouncements_${
        currentAccountId || "main"
      }_${groupId}`;

      // 获取现有公告
      const savedData = await xDb.xAccountProfiles.get(announcementsId);
      const announcements = savedData?.data || [];

      // 创建新公告
      const newAnnouncement = {
        id: `announcement_${Date.now()}`,
        groupId: groupId,
        content: content,
        createdAt: new Date().toISOString(),
        createdBy: "admin",
      };

      // 添加到列表开头（最新的在前）
      announcements.unshift(newAnnouncement);

      // 保存到数据库
      await xDb.xAccountProfiles.put({
        handle: announcementsId,
        name: "fanGroupAnnouncements",
        data: announcements,
        updatedAt: new Date().toISOString(),
      });

      console.log("✅ [群公告] 公告已保存");

      // 在粉丝群聊天中添加系统通知
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${groupId}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (
        savedConversation &&
        savedConversation.data &&
        savedConversation.data.messages
      ) {
        const systemMessage = {
          type: "system",
          systemType: "announcement",
          content: `📢 群主发布了新公告：${content}`,
          timestamp: new Date().toISOString(),
          time: "刚刚",
        };
        savedConversation.data.messages.push(systemMessage);
        await xDb.xAccountProfiles.put(savedConversation);

        console.log("✅ [群公告] 已添加系统通知");

        // 如果当前正在查看该粉丝群聊天，刷新消息显示
        if (
          currentMessageConversation &&
          currentMessageConversation.id === groupId
        ) {
          const contentContainer = document.getElementById(
            "message-detail-content"
          );
          if (contentContainer) {
            const msgEl = renderMessageItem(
              systemMessage,
              false,
              savedConversation.data.messages.length - 1,
              true
            );
            contentContainer.appendChild(msgEl);
            // 滚动到底部
            const scrollableContainer = document.getElementById(
              "message-detail-scrollable"
            );
            if (scrollableContainer) {
              scrollableContainer.scrollTop = scrollableContainer.scrollHeight;
            }
          }
        }
      }

      // 关闭创建对话框
      closeCreateAnnouncementDialog();

      // 刷新公告列表
      await loadFanGroupAnnouncements();

      showXToast("公告发布成功", "success");

      // 如果选择了@全员，触发AI反应
      if (shouldMentionAll) {
        console.log("📢 [群公告] @全员，触发AI反应");
        closeFanGroupAnnouncementModal();

        // 延迟触发AI反应，让用户看到公告已发布
        setTimeout(async () => {
          try {
            // 调用自反应按钮的触发函数
            await window.triggerFanGroupAutoReaction();
            showXToast("已通知所有成员", "success");
          } catch (error) {
            console.error("❌ [群公告] 触发AI反应失败:", error);
            showXToast("通知失败: " + error.message, "error");
          }
        }, 500);
      }
    } catch (error) {
      console.error("❌ [群公告] 保存失败:", error);
      showXToast("保存失败: " + error.message, "error");
    }
  };

  // 删除粉丝群公告
  window.deleteFanGroupAnnouncement = async function (announcementId) {
    // 检查是否是粉丝群
    const isFanGroup =
      currentMessageConversation &&
      (currentMessageConversation.type === "fangroup" ||
        (currentMessageConversation.id &&
          currentMessageConversation.id.startsWith("fangroup_")));

    if (!isFanGroup) {
      return;
    }

    if (!confirm("确定要删除这条公告吗？")) {
      return;
    }

    const groupId = currentMessageConversation.id;

    console.log("🗑️ [群公告] 删除公告", { groupId, announcementId });

    try {
      const xDb = getXDB();
      const announcementsId = `fanGroupAnnouncements_${
        currentAccountId || "main"
      }_${groupId}`;

      // 获取现有公告
      const savedData = await xDb.xAccountProfiles.get(announcementsId);
      let announcements = savedData?.data || [];

      // 过滤掉要删除的公告
      announcements = announcements.filter((a) => a.id !== announcementId);

      // 保存更新后的列表
      await xDb.xAccountProfiles.put({
        handle: announcementsId,
        name: "fanGroupAnnouncements",
        data: announcements,
        updatedAt: new Date().toISOString(),
      });

      console.log("✅ [群公告] 公告已删除");

      // 刷新公告列表
      await loadFanGroupAnnouncements();

      showXToast("公告已删除", "success");
    } catch (error) {
      console.error("❌ [群公告] 删除失败:", error);
      showXToast("删除失败: " + error.message, "error");
    }
  };

  // ============================================
  // 群文件管理功能
  // ============================================

  let currentFanGroupFolder = null; // 当前打开的文件夹

  // 动态创建群文件模态窗口
  function createFanGroupFilesModal() {
    // 如果已存在则先删除
    const existingModal = document.getElementById("fangroup-files-modal");
    if (existingModal) {
      existingModal.remove();
    }

    const modal = document.createElement("div");
    modal.id = "fangroup-files-modal";
    modal.style.cssText = `
position: fixed;
top: 0;
left: 0;
width: 100vw;
height: 100vh;
background-color: rgba(0, 0, 0, 0.7);
display: flex;
align-items: center;
justify-content: center;
z-index: 35;
backdrop-filter: blur(10px);
padding: 0 8px;
box-sizing: border-box;
`;

    modal.innerHTML = `
<div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 100%; max-width: 800px; max-height: 85vh; display: flex; flex-direction: column; box-shadow: 0 25px 50px rgba(0,0,0,0.3); overflow: hidden;" onclick="event.stopPropagation()">
<div style="padding: 16px; border-bottom: 1px solid var(--x-border-color); flex-shrink: 0;">
<div style="display: flex; align-items: center; justify-content: space-between;">
<div style="display: flex; align-items: center; gap: 10px;">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width: 22px; height: 22px; fill: none; stroke: var(--x-accent); stroke-width: 2; stroke-linecap: round; stroke-linejoin: round;">
<path d="M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2" />
</svg>
<h3 style="margin: 0; color:var(--x-text-primary); font-size: 18px; font-weight: 700;" id="fangroup-files-header-title">群文件</h3>
</div>
<button onclick="closeFanGroupFilesModal()" style="background: transparent; border: none; color:var(--x-text-secondary); cursor: pointer; padding: 6px; border-radius: 50%; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center;" onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'">
<svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
<g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
</svg>
</button>
</div>
</div>
<div id="fangroup-files-container" style="flex: 1; overflow-y: auto; overflow-x: hidden; padding: 12px; display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; align-content: flex-start; justify-content: center; min-height: 200px; background-color: var(--x-bg-secondary);">
<div style="width: 100%; text-align: center; color:var(--x-text-secondary); font-size: 13px; padding: 30px 16px; grid-column: 1 / -1;">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width: 32px; height: 32px; fill: none; stroke: var(--x-text-secondary); stroke-width: 1.5; stroke-linecap: round; stroke-linejoin: round; margin: 0 auto 12px; display: block; opacity: 0.7;">
<path d="M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2" />
</svg>
暂无文件，点击下方按钮创建文件夹或上传文件
</div>
</div>
<div style="padding: 12px 16px; border-top: 1px solid var(--x-border-color); flex-shrink: 0; display: flex; gap: 8px; flex-wrap: wrap;">
<div style="display: flex; gap: 8px; flex: 1;">
<button id="fangroup-files-back-btn" onclick="backToFilesList()" style="display: none; background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 18px; padding: 8px 16px; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
<svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: currentColor; margin-right: 4px; vertical-align: text-bottom;">
<path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"></path>
</svg>
返回
</button>
<button id="fangroup-files-batch-btn" onclick="toggleBatchMode()" style="display: none; background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: 1px solid var(--x-border-color); border-radius: 18px; padding: 8px 12px; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
批量管理
</button>
<button id="fangroup-files-cancel-batch-btn" onclick="toggleBatchMode()" style="display: none; background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 18px; padding: 8px 12px; font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
取消
</button>
<button id="fangroup-files-delete-batch-btn" onclick="batchDeleteFiles()" style="display: none; background-color: rgba(220, 38, 38, 0.9); color: #fff; border: none; border-radius: 18px; padding: 8px 12px; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
删除选中 (0)
</button>
</div>
<div style="display: flex; gap: 8px; flex-wrap: nowrap;">
<button id="fangroup-files-create-folder-btn" onclick="openCreateFolderDialog()" style="background-color: var(--x-bg-secondary); color: var(--x-text-primary); border: 1px solid var(--x-border-color); border-radius: 18px; padding: 8px 12px; font-size: 13px; font-weight: 500; cursor: pointer; white-space: nowrap; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 4px;" onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='var(--x-bg-secondary)'">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round;">
<path d="M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2" />
</svg>
<span>新建文件夹</span>
</button>
<button id="fangroup-files-upload-btn" onclick="openUploadFileDialog()" style="background-color: #2a2a2a; color: #fff; border: none; border-radius: 18px; padding: 8px 12px; font-size: 13px; font-weight: 500; white-space: nowrap; cursor: pointer; transition: all 0.2s; box-shadow: 0 1px 3px rgba(0,0,0,0.2); display: flex; align-items: center; justify-content: center; gap: 4px;" onmouseover="this.style.backgroundColor='#3a3a3a'" onmouseout="this.style.backgroundColor='#2a2a2a'">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round;">
<path d="M12 5v10M7 9l5-5 5 5M19 15v4H5v-4"></path>
</svg>
<span>上传文件</span>
</button>
</div>
</div>
</div>
`;

    modal.onclick = () => closeFanGroupFilesModal();

    // 添加到x-social-screen容器内以确保主题样式正确应用
    const xSocialScreen = document.getElementById("x-social-screen");
    if (xSocialScreen) {
      xSocialScreen.appendChild(modal);
    } else {
      document.body.appendChild(modal);
    }
    return modal;
  }

  // 打开群文件弹窗
  window.openFanGroupFilesModal = async function () {
    const isFanGroup =
      currentMessageConversation &&
      (currentMessageConversation.type === "fangroup" ||
        (currentMessageConversation.id &&
          currentMessageConversation.id.startsWith("fangroup_")));

    if (!isFanGroup) {
      showXToast("当前不是粉丝群聊天", "error");
      return;
    }

    console.log("📁 [群文件] 打开群文件弹窗");
    const modal = createFanGroupFilesModal();
    currentFanGroupFolder = null; // 重置当前文件夹
    await loadFanGroupFiles();
  };

  // 关闭群文件弹窗
  window.closeFanGroupFilesModal = function () {
    const modal = document.getElementById("fangroup-files-modal");
    if (modal) {
      modal.remove();
      currentFanGroupFolder = null;
    }
  };

  // 加载群文件列表
  async function loadFanGroupFiles() {
    const groupId = currentMessageConversation.id;
    const container = document.getElementById("fangroup-files-container");
    const backBtn = document.getElementById("fangroup-files-back-btn");
    const headerTitle = document.getElementById("fangroup-files-header-title");

    if (!container) return;

    try {
      const xDb = getXDB();

      // 加载文件夹
      const foldersId = `fanGroupFolders_${
        currentAccountId || "main"
      }_${groupId}`;
      const foldersData = await xDb.xAccountProfiles.get(foldersId);
      const folders = foldersData?.data || [];

      // 加载文件
      const filesId = `fanGroupFiles_${currentAccountId || "main"}_${groupId}`;
      const filesData = await xDb.xAccountProfiles.get(filesId);
      const allFiles = filesData?.data || [];

      let filesToShow = [];
      let foldersToShow = [];

      if (currentFanGroupFolder) {
        // 当前在某个文件夹内，显示该文件夹的文件
        filesToShow = allFiles.filter(
          (f) => f.folderId === currentFanGroupFolder.id
        );
        backBtn.style.display = "flex";
        headerTitle.textContent = currentFanGroupFolder.name;
      } else {
        // 显示所有文件夹和未分类文件
        foldersToShow = folders;
        filesToShow = allFiles.filter((f) => !f.folderId);
        backBtn.style.display = "none";
        headerTitle.textContent = "群文件";
      }

      // 清空容器
      container.innerHTML = "";

      // 渲染文件夹
      foldersToShow.forEach((folder) => {
        container.appendChild(createFolderCard(folder, allFiles));
      });

      // 渲染文件
      filesToShow.forEach((file) => {
        container.appendChild(createFileCard(file));
      });

      // 如果没有内容，显示空状态
      if (foldersToShow.length === 0 && filesToShow.length === 0) {
        container.innerHTML = `
 <div style="width: 100%; text-align: center; color:var(--x-text-secondary); font-size: 13px; padding: 30px 16px; grid-column: 1 / -1;">
 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width: 28px; height: 28px; fill: none; stroke: var(--x-text-secondary); stroke-width: 1.5; stroke-linecap: round; stroke-linejoin: round; margin: 0 auto 12px; display: block; opacity: 0.6;">
 <path d="M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2" />
 ${currentFanGroupFolder ? '<path d="M9 13h6" />' : ""}
 </svg>
 ${
   currentFanGroupFolder
     ? "文件夹为空"
     : "暂无文件，点击下方按钮创建文件夹或上传文件"
 }
 </div>
 `;
      }

      // 显示/隐藏批量管理按钮
      const batchBtn = document.getElementById("fangroup-files-batch-btn");
      if (batchBtn) {
        // 只有在有文件时才显示批量管理按钮
        if (filesToShow.length > 0 && !isBatchMode) {
          batchBtn.style.display = "flex";
        } else {
          batchBtn.style.display = "none";
        }
      }

      console.log(
        `✅ [群文件] 已加载 ${foldersToShow.length} 个文件夹，${filesToShow.length} 个文件`
      );
    } catch (error) {
      console.error("❌ [群文件] 加载失败:", error);
      showXToast("加载失败", "error");
    }
  }

  // 创建文件夹卡片 - 精确仿照第三张参考图片的立体效果
  function createFolderCard(folder, allFiles) {
    const filesInFolder = allFiles.filter((f) => f.folderId === folder.id);
    const fileCount = filesInFolder.length;

    const card = document.createElement("div");
    card.style.cssText = `
 position: relative;
 width: 100%;
 cursor: pointer;
 transition: transform 0.2s ease, filter 0.2s ease, box-shadow 0.2s ease;
 margin-bottom: 6px;
 `;

    // 完全重新设计的文件夹，严格参照第三张图片
    card.innerHTML = `
 <div style="
 position: relative;
 padding-bottom: 100%;
 width: 100%;
 ">
 <div style="
 position: absolute;
 top: 0;
 left: 0;
 right: 0;
 bottom: 0;
 ">
 <!-- 文件夹整体容器 -->
 <div style="
 position: relative;
 width: 100%;
 height: 100%;
 ">
 <!-- 主文件夹 -->
 <div style="
 position: absolute;
 top: 20%;
 left: 0;
 width: 100%;
 height: 80%;
 background: #222222;
 border-radius: 8px;
 box-shadow: 0 4px 10px rgba(0,0,0,0.25);
 z-index: 1;
 ">
 <!-- 文件夹内部纹理 -->
 <div style="
 position: absolute;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 border-radius: 8px;
 background: linear-gradient(180deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0) 100%);
 opacity: 0.5;
 "></div>

 <!-- 文件夹图标 -->
 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translate(-50%, -50%);
 width: 22px;
 height: 22px;
 fill: none;
 stroke: rgba(255,255,255,0.5);
 stroke-width: 1.5;
 stroke-linecap: round;
 stroke-linejoin: round;
 ">
 <path d="M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2" />
 </svg>
 </div>

 <!-- 堆叠文档1 - 最下层 -->
 <div style="
 position: absolute;
 top: 10%;
 left: 8%;
 width: 84%;
 height: 25%;
 background: #fafafa;
 border-radius: 4px 4px 0 0;
 transform: rotate(-3deg);
 z-index: 2;
 box-shadow: 0 2px 6px rgba(0,0,0,0.1);
 overflow: hidden;
 ">
 <!-- 文档内容线条 -->
 <div style="
 position: absolute;
 top: 30%;
 left: 10%;
 width: 80%;
 height: 2px;
 background-color: rgba(0,0,0,0.06);
 "></div>
 <div style="
 position: absolute;
 top: 50%;
 left: 10%;
 width: 60%;
 height: 2px;
 background-color: rgba(0,0,0,0.06);
 "></div>
 <div style="
 position: absolute;
 top: 70%;
 left: 10%;
 width: 70%;
 height: 2px;
 background-color: rgba(0,0,0,0.06);
 "></div>
 </div>

 <!-- 堆叠文档2 - 中层 -->
 <div style="
 position: absolute;
 top: 5%;
 left: 10%;
 width: 80%;
 height: 25%;
 background: #f5f5f5;
 border-radius: 4px 4px 0 0;
 z-index: 3;
 box-shadow: 0 1px 3px rgba(0,0,0,0.1);
 overflow: hidden;
 ">
 <!-- 文档内容线条 -->
 <div style="
 position: absolute;
 top: 30%;
 left: 10%;
 width: 80%;
 height: 2px;
 background-color: rgba(0,0,0,0.06);
 "></div>
 <div style="
 position: absolute;
 top: 50%;
 left: 10%;
 width: 70%;
 height: 2px;
 background-color: rgba(0,0,0,0.06);
 "></div>
 <div style="
 position: absolute;
 top: 70%;
 left: 10%;
 width: 60%;
 height: 2px;
 background-color: rgba(0,0,0,0.06);
 "></div>
 </div>

 <!-- 堆叠文档3 - 顶层 -->
 <div style="
 position: absolute;
 top: 2%;
 left: 13%;
 width: 74%;
 height: 25%;
 background: white;
 border-radius: 4px 4px 0 0;
 transform: rotate(2deg);
 z-index: 4;
 box-shadow: 0 1px 4px rgba(0,0,0,0.1);
 overflow: hidden;
 ">
 <!-- 文档内容线条 -->
 <div style="
 position: absolute;
 top: 30%;
 left: 10%;
 width: 75%;
 height: 2px;
 background-color: rgba(0,0,0,0.06);
 "></div>
 <div style="
 position: absolute;
 top: 50%;
 left: 10%;
 width: 55%;
 height: 2px;
 background-color: rgba(0,0,0,0.06);
 "></div>
 <div style="
 position: absolute;
 top: 70%;
 left: 10%;
 width: 65%;
 height: 2px;
 background-color: rgba(0,0,0,0.06);
 "></div>
 </div>

 <!-- 删除按钮 -->
 <div onclick="deleteFanGroupFolder('${folder.id}'); event.stopPropagation();" style="
 position: absolute;
 top: 0;
 right: 0;
 width: 18px;
 height: 18px;
 border-radius: 50%;
 background-color: rgba(0,0,0,0.4);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 opacity: 0;
 transition: opacity 0.2s, background-color 0.2s;
 z-index: 5;
 " onmouseover="this.style.backgroundColor='rgba(200,50,50,0.9)'; this.style.opacity='1';"
 onmouseout="this.style.backgroundColor='rgba(0,0,0,0.4)'; this.style.opacity='0';">
 <svg viewBox="0 0 24 24" style="width: 10px; height: 10px; fill: white;">
 <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
 </svg>
 </div>
 </div>
 </div>
 </div>

 <!-- 文件夹名称 -->
 <div style="
 text-align: center;
 margin-top: 2px;
 padding: 0 2px;
 ">
 <div style="
 color: var(--x-text-primary);
 font-size: 11px;
 font-weight: 500;
 overflow: hidden;
 text-overflow: ellipsis;
 white-space: nowrap;
 ">${folder.name}</div>
 <div style="
 color: var(--x-text-secondary);
 font-size: 9px;
 margin-top: 1px;
 ">${fileCount}个文件</div>
 </div>
 `;

    // 精细的hover效果
    card.onmouseenter = () => {
      card.style.transform = "translateY(-5px)";
      card.style.filter = "brightness(1.1)";
      card.style.boxShadow = "0 5px 15px rgba(0,0,0,0.2)";
    };
    card.onmouseleave = () => {
      card.style.transform = "translateY(0)";
      card.style.filter = "brightness(1)";
      card.style.boxShadow = "none";
    };

    // 点击打开文件夹
    card.onclick = () => openFolder(folder);

    return card;
  }

  // 创建文件卡片 - 与文件夹风格统一
  function createFileCard(file) {
    const card = document.createElement("div");
    card.style.cssText = `
 position: relative;
 width: 100%;
 cursor: pointer;
 transition: transform 0.2s ease, filter 0.2s ease, box-shadow 0.2s ease;
 margin-bottom: 6px;
 `;

    // 获取文件类型图标
    const fileIconSvg = getFileIcon(file.type);

    // 文件类型对应的底色 - 使用更柔和的颜色
    const bgColors = {
      text: "#2b303b",
      image: "#2e3440",
      video: "#262b36",
      link: "#272c36",
      default: "#252933",
    };

    const bgColor = bgColors[file.type] || bgColors.default;

    // 复选框 HTML (批量模式下显示) - 更小更紧凑
    const checkboxHtml = isBatchMode
      ? `
 <div id="file-checkbox-${file.id}" onclick="toggleFileSelection('${file.id}'); event.stopPropagation();" style="
 position: absolute;
 top: 6px;
 left: 6px;
 width: 16px;
 height: 16px;
 border-radius: 3px;
 border: 1px solid rgba(255,255,255,0.7);
 background-color: transparent;
 display: flex;
 align-items: center;
 justify-content: center;
 z-index: 10;
 transition: all 0.2s;
 "></div>
 `
      : "";

    card.innerHTML = `
 <div style="
 position: relative;
 padding-bottom: 100%;
 width: 100%;
 ">
 <div style="
 position: absolute;
 top: 0;
 left: 0;
 right: 0;
 bottom: 0;
 ">
 <!-- 文件卡片主体 -->
 <div style="
 position: relative;
 width: 100%;
 height: 100%;
 border-radius: 8px;
 background-color: ${bgColor};
 box-shadow: 0 2px 6px rgba(0,0,0,0.15);
 overflow: hidden;
 ">
 <!-- 背景纹理效果 -->
 <div style="
 position: absolute;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background: linear-gradient(145deg, rgba(255,255,255,0.03) 0%, rgba(255,255,255,0) 70%);
 "></div>

 <!-- 文件类型角标 -->
 <div style="
 position: absolute;
 top: 0;
 right: 0;
 width: 0;
 height: 0;
 border-style: solid;
 border-width: 0 20px 20px 0;
 border-color: transparent rgba(255,255,255,0.1) transparent transparent;
 "></div>

 <!-- 文件图标 -->
 <div style="
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translate(-50%, -50%);
 width: 34%;
 height: 34%;
 display: flex;
 align-items: center;
 justify-content: center;
 opacity: 0.85;
 ">
 ${fileIconSvg.replace("currentColor", "rgba(255,255,255,0.7)")}
 </div>

 ${checkboxHtml}

 <!-- 删除按钮 - 非批量模式下显示 -->
 ${
   !isBatchMode
     ? `
 <div onclick="deleteFanGroupFile('${file.id}'); event.stopPropagation();" style="
 position: absolute;
 top: 4px;
 right: 4px;
 width: 18px;
 height: 18px;
 border-radius: 50%;
 background-color: rgba(0,0,0,0.3);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 opacity: 0;
 transition: opacity 0.2s, background-color 0.2s;
 z-index: 2;
 " onmouseover="this.style.backgroundColor='rgba(200,50,50,0.9)'; this.style.opacity='1';"
 onmouseout="this.style.backgroundColor='rgba(0,0,0,0.3)'; this.style.opacity='0';">
 <svg viewBox="0 0 24 24" style="width: 10px; height: 10px; fill: white;">
 <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
 </svg>
 </div>
 `
     : ""
 }
 </div>
 </div>
 </div>

 <!-- 文件名称 -->
 <div style="
 text-align: center;
 margin-top: 2px;
 padding: 0 2px;
 ">
 <div style="
 color: var(--x-text-primary);
 font-size: 11px;
 font-weight: 500;
 overflow: hidden;
 text-overflow: ellipsis;
 white-space: nowrap;
 ">${file.name}</div>
 <div style="
 color: var(--x-text-secondary);
 font-size: 9px;
 margin-top: 1px;
 ">${file.uploadedBy}</div>
 </div>
 `;

    // 与文件夹一致的hover效果
    card.onmouseenter = () => {
      card.style.transform = "translateY(-5px)";
      card.style.filter = "brightness(1.1)";
      card.style.boxShadow = "0 5px 15px rgba(0,0,0,0.2)";
    };
    card.onmouseleave = () => {
      card.style.transform = "translateY(0)";
      card.style.filter = "brightness(1)";
      card.style.boxShadow = "none";
    };

    // 批量模式：点击选择，非批量模式：打开详情
    card.onclick = () => {
      if (isBatchMode) {
        toggleFileSelection(file.id);
      } else {
        openFileDetail(file);
      }
    };

    // 如果文件已被选中，更新复选框状态
    if (isBatchMode && selectedFiles.has(file.id)) {
      setTimeout(() => {
        toggleFileSelection(file.id);
      }, 10);
    }

    return card;
  }

  // 获取文件图标 (SVG图标，不使用emoji)
  function getFileIcon(type) {
    const icons = {
      text: `<svg viewBox="0 0 24 24" style="fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round">
 <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
 <polyline points="14 2 14 8 20 8"></polyline>
 <line x1="16" y1="13" x2="8" y2="13"></line>
 <line x1="16" y1="17" x2="8" y2="17"></line>
 <polyline points="10 9 9 9 8 9"></polyline>
 </svg>`,
      image: `<svg viewBox="0 0 24 24" style="fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round">
 <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
 <circle cx="8.5" cy="8.5" r="1.5"></circle>
 <polyline points="21 15 16 10 5 21"></polyline>
 </svg>`,
      video: `<svg viewBox="0 0 24 24" style="fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round">
 <rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect>
 <line x1="7" y1="2" x2="7" y2="22"></line>
 <line x1="17" y1="2" x2="17" y2="22"></line>
 <line x1="2" y1="12" x2="22" y2="12"></line>
 <line x1="2" y1="7" x2="7" y2="7"></line>
 <line x1="2" y1="17" x2="7" y2="17"></line>
 <line x1="17" y1="17" x2="22" y2="17"></line>
 <line x1="17" y1="7" x2="22" y2="7"></line>
 </svg>`,
      link: `<svg viewBox="0 0 24 24" style="fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round">
 <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
 <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
 </svg>`,
      default: `<svg viewBox="0 0 24 24" style="fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round">
 <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path>
 <polyline points="13 2 13 9 20 9"></polyline>
 </svg>`,
    };
    return icons[type] || icons.default;
  }

  // 打开文件夹
  function openFolder(folder) {
    console.log("📂 [群文件] 打开文件夹:", folder.name);
    currentFanGroupFolder = folder;
    loadFanGroupFiles();
  }

  // 返回文件列表
  window.backToFilesList = function () {
    console.log("📁 [群文件] 返回文件列表");
    currentFanGroupFolder = null;
    loadFanGroupFiles();
  };

  // 动态创建文件夹对话框
  function createFolderDialog() {
    // 如果已存在则先删除
    const existingDialog = document.getElementById("create-folder-dialog");
    if (existingDialog) {
      existingDialog.remove();
    }

    const dialog = document.createElement("div");
    dialog.id = "create-folder-dialog";
    dialog.style.cssText = `
position: fixed;
top: 0;
left: 0;
width: 100vw;
height: 100vh;
background-color: rgba(0, 0, 0, 0.7);
display: flex;
align-items: center;
justify-content: center;
z-index: 36;
backdrop-filter: blur(4px);
`;

    dialog.innerHTML = `
<div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 450px; box-shadow: 0 12px 40px rgba(0,0,0,0.4); overflow: hidden;" onclick="event.stopPropagation()">
<div style="padding: 20px 24px; border-bottom: 1px solid var(--x-border-color);">
<h3 style="margin: 0; color:var(--x-text-primary); font-size: 20px; font-weight: 700;">新建文件夹</h3>
</div>
<div style="padding: 24px;">
<label style="display: block; font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 8px;">
文件夹名称 <span style="color: #ef4444;">*</span>
</label>
<input type="text" id="folder-name-input" placeholder="例如：学习资料、项目文档..." maxlength="50" style="width: 100%; padding: 12px; background-color:var(--x-bg-secondary); border: 2px solid var(--x-border-color); border-radius: 12px; color:var(--x-text-primary); font-size: 14px; outline: none; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'">
</div>
<div style="padding: 16px 24px; border-top: 1px solid var(--x-border-color); display: flex; gap: 12px; justify-content: flex-end;">
<button onclick="closeCreateFolderDialog()" style="background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer;">取消</button>
<button onclick="saveFanGroupFolder()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 10px 24px; font-size: 14px; font-weight: 700; cursor: pointer;">创建</button>
</div>
</div>
`;

    dialog.onclick = () => closeCreateFolderDialog();

    // 添加到x-social-screen容器内以确保主题样式正确应用
    const xSocialScreen = document.getElementById("x-social-screen");
    if (xSocialScreen) {
      xSocialScreen.appendChild(dialog);
    } else {
      document.body.appendChild(dialog);
    }
    return dialog;
  }

  // 打开创建文件夹对话框
  window.openCreateFolderDialog = function () {
    const dialog = createFolderDialog();
    const input = document.getElementById("folder-name-input");
    if (input) {
      input.value = "";
      setTimeout(() => input.focus(), 100);
    }
  };

  // 关闭创建文件夹对话框
  window.closeCreateFolderDialog = function () {
    const dialog = document.getElementById("create-folder-dialog");
    if (dialog) {
      dialog.remove();
    }
  };

  // 保存文件夹
  window.saveFanGroupFolder = async function () {
    const input = document.getElementById("folder-name-input");
    const name = input?.value?.trim();

    if (!name) {
      showXToast("请输入文件夹名称", "warning");
      return;
    }

    const groupId = currentMessageConversation.id;

    try {
      const xDb = getXDB();
      const foldersId = `fanGroupFolders_${
        currentAccountId || "main"
      }_${groupId}`;

      const savedData = await xDb.xAccountProfiles.get(foldersId);
      const folders = savedData?.data || [];

      const newFolder = {
        id: `folder_${Date.now()}`,
        name: name,
        createdAt: new Date().toISOString(),
      };

      folders.push(newFolder);

      await xDb.xAccountProfiles.put({
        handle: foldersId,
        name: "fanGroupFolders",
        data: folders,
        updatedAt: new Date().toISOString(),
      });

      console.log("✅ [群文件] 文件夹已创建:", name);
      closeCreateFolderDialog();
      await loadFanGroupFiles();
      showXToast("文件夹创建成功", "success");
    } catch (error) {
      console.error("❌ [群文件] 创建失败:", error);
      showXToast("创建失败", "error");
    }
  };

  // 动态创建上传文件对话框
  async function createUploadFileDialog() {
    // 如果已存在则先删除
    const existingDialog = document.getElementById("upload-file-dialog");
    if (existingDialog) {
      existingDialog.remove();
    }

    const dialog = document.createElement("div");
    dialog.id = "upload-file-dialog";
    dialog.style.cssText = `
position: fixed;
top: 0;
left: 0;
width: 100vw;
height: 100vh;
background-color: rgba(0, 0, 0, 0.7);
display: flex;
align-items: center;
justify-content: center;
z-index: 36;
backdrop-filter: blur(4px);
`;

    dialog.innerHTML = `
<div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 550px; max-height: 85vh; overflow-y: auto; box-shadow: 0 12px 40px rgba(0,0,0,0.4);" onclick="event.stopPropagation()">
<div style="padding: 20px 24px; border-bottom: 1px solid var(--x-border-color);">
<h3 style="margin: 0; color:var(--x-text-primary); font-size: 20px; font-weight: 700;">上传文件</h3>
</div>
<div style="padding: 24px;">
<div style="margin-bottom: 20px;">
<label style="display: block; font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 8px;">
文件名称 <span style="color: #ef4444;">*</span>
</label>
<input type="text" id="file-name-input" placeholder="例如：项目文档.pdf、教程视频.mp4..." maxlength="100" style="width: 100%; padding: 12px; background-color:var(--x-bg-secondary); border: 2px solid var(--x-border-color); border-radius: 12px; color:var(--x-text-primary); font-size: 14px; outline: none; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'">
<div style="font-size: 12px; color:var(--x-text-secondary); margin-top: 4px;">提示：文件名需包含后缀（如 .pdf、.mp4、.jpg等）</div>
</div>
<div style="margin-bottom: 20px;">
<label style="display: block; font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 8px;">
文件类型 <span style="color: #ef4444;">*</span>
</label>
<select id="file-type-select" style="width: 100%; padding: 12px; background-color:var(--x-bg-secondary); border: 2px solid var(--x-border-color); border-radius: 12px; color:var(--x-text-primary); font-size: 14px; outline: none; cursor: pointer;" onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'">
<option value="text">文字/文档</option>
<option value="image">图片</option>
<option value="video">视频</option>
<option value="link">链接</option>
</select>
</div>
<div style="margin-bottom: 20px;">
<label style="display: block; font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 8px;">
文件内容/链接 <span style="color: #ef4444;">*</span>
</label>
<textarea id="file-content-input" placeholder="输入文件内容、描述或链接地址..." maxlength="5000" style="width: 100%; min-height: 150px; padding: 12px; background-color:var(--x-bg-secondary); border: 2px solid var(--x-border-color); border-radius: 12px; color:var(--x-text-primary); font-size: 14px; outline: none; resize: vertical; font-family: inherit; line-height: 1.6; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'" oninput="updateFileContentCounter()"></textarea>
<div style="text-align: right; margin-top: 6px;">
<span id="file-content-counter" style="font-size: 12px; color:var(--x-text-secondary);">0 / 5000</span>
</div>
</div>
<div id="file-folder-select-container" style="margin-bottom: 20px; display: none;">
<label style="display: block; font-size: 14px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 8px;">
选择文件夹（可选）
</label>
<select id="file-folder-select" style="width: 100%; padding: 12px; background-color:var(--x-bg-secondary); border: 2px solid var(--x-border-color); border-radius: 12px; color:var(--x-text-primary); font-size: 14px; outline: none; cursor: pointer;">
<option value="">不放入文件夹（散落显示）</option>
</select>
</div>
</div>
<div style="padding: 16px 24px; border-top: 1px solid var(--x-border-color); display: flex; gap: 12px; justify-content: flex-end;">
<button onclick="closeUploadFileDialog()" style="background-color:var(--x-bg-secondary); color:var(--x-text-primary); border: none; border-radius: 20px; padding: 10px 20px; font-size: 14px; font-weight: 600; cursor: pointer;">取消</button>
<button onclick="saveFanGroupFile()" style="background-color: var(--x-accent); color: #fff; border: none; border-radius: 20px; padding: 10px 24px; font-size: 14px; font-weight: 700; cursor: pointer;">上传</button>
</div>
</div>
`;

    dialog.onclick = () => closeUploadFileDialog();

    // 添加到x-social-screen容器内以确保主题样式正确应用
    const xSocialScreen = document.getElementById("x-social-screen");
    if (xSocialScreen) {
      xSocialScreen.appendChild(dialog);
    } else {
      document.body.appendChild(dialog);
    }
    return dialog;
  }

  // 打开上传文件对话框
  window.openUploadFileDialog = async function () {
    const dialog = await createUploadFileDialog();
    const nameInput = document.getElementById("file-name-input");
    const typeSelect = document.getElementById("file-type-select");
    const contentInput = document.getElementById("file-content-input");
    const folderSelectContainer = document.getElementById(
      "file-folder-select-container"
    );
    const folderSelect = document.getElementById("file-folder-select");

    // 重置输入
    if (nameInput) nameInput.value = "";
    if (typeSelect) typeSelect.value = "text";
    if (contentInput) contentInput.value = "";

    // 加载文件夹选项
    const groupId = currentMessageConversation.id;
    const xDb = getXDB();
    const foldersId = `fanGroupFolders_${
      currentAccountId || "main"
    }_${groupId}`;
    const foldersData = await xDb.xAccountProfiles.get(foldersId);
    const folders = foldersData?.data || [];

    if (folderSelect) {
      folderSelect.innerHTML =
        '<option value="">不放入文件夹（散落显示）</option>';
      folders.forEach((folder) => {
        const option = document.createElement("option");
        option.value = folder.id;
        option.textContent = folder.name;
        if (currentFanGroupFolder && currentFanGroupFolder.id === folder.id) {
          option.selected = true;
        }
        folderSelect.appendChild(option);
      });
    }

    if (folderSelectContainer && folders.length > 0) {
      folderSelectContainer.style.display = "block";
    }

    setTimeout(() => nameInput?.focus(), 100);
  };

  // 关闭上传文件对话框
  window.closeUploadFileDialog = function () {
    const dialog = document.getElementById("upload-file-dialog");
    if (dialog) {
      dialog.remove();
    }
  };

  // 更新文件内容计数器
  window.updateFileContentCounter = function () {
    const input = document.getElementById("file-content-input");
    const counter = document.getElementById("file-content-counter");
    if (input && counter) {
      counter.textContent = `${input.value.length} / 5000`;
    }
  };

  // 保存群文件
  window.saveFanGroupFile = async function () {
    const nameInput = document.getElementById("file-name-input");
    const typeSelect = document.getElementById("file-type-select");
    const contentInput = document.getElementById("file-content-input");
    const folderSelect = document.getElementById("file-folder-select");

    const name = nameInput?.value?.trim();
    const type = typeSelect?.value;
    const content = contentInput?.value?.trim();
    const folderId = folderSelect?.value || null;

    if (!name) {
      showXToast("请输入文件名称", "warning");
      return;
    }
    if (!content) {
      showXToast("请输入文件内容", "warning");
      return;
    }

    const groupId = currentMessageConversation.id;
    const uploadedBy = window.userProfileData?.name || "用户";

    try {
      const xDb = getXDB();
      const filesId = `fanGroupFiles_${currentAccountId || "main"}_${groupId}`;

      const savedData = await xDb.xAccountProfiles.get(filesId);
      const files = savedData?.data || [];

      const newFile = {
        id: `file_${Date.now()}`,
        name: name,
        type: type,
        content: content,
        folderId: folderId,
        uploadedBy: uploadedBy,
        uploadedAt: new Date().toISOString(),
      };

      files.push(newFile);

      await xDb.xAccountProfiles.put({
        handle: filesId,
        name: "fanGroupFiles",
        data: files,
        updatedAt: new Date().toISOString(),
      });

      console.log("✅ [群文件] 文件已上传:", name);

      // 在粉丝群聊天中添加文件消息（不是系统通知）
      await addFileMessageToConversation(groupId, newFile);

      closeUploadFileDialog();
      await loadFanGroupFiles();
      showXToast("文件上传成功", "success");
    } catch (error) {
      console.error("❌ [群文件] 上传失败:", error);
      showXToast("上传失败", "error");
    }
  };

  // 将文件消息添加到对话中
  async function addFileMessageToConversation(groupId, file) {
    try {
      const xDb = getXDB();
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${groupId}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);

      if (
        savedConversation &&
        savedConversation.data &&
        savedConversation.data.messages
      ) {
        const fileMessage = {
          type: "groupFile",
          file: {
            id: file.id,
            name: file.name,
            type: file.type,
            content: file.content,
            uploadedBy: file.uploadedBy,
            uploadedAt: file.uploadedAt,
            folderId: file.folderId || null,
          },
          timestamp: new Date().toISOString(),
          time: "刚刚",
          isOwn: true, // 用户上传
        };

        savedConversation.data.messages.push(fileMessage);
        await xDb.xAccountProfiles.put(savedConversation);

        console.log("[群文件] 文件消息已添加到对话");

        // 更新粉丝群的文件列表数据
        try {
          // 查找messagesList中的粉丝群数据
          const dataId = `messagesList_${currentAccountId || "main"}`;
          const messagesData = await xDb.xAccountProfiles.get(dataId);
          if (messagesData && messagesData.data) {
            const messagesList = messagesData.data;
            const fanGroupIndex = messagesList.findIndex(
              (msg) => msg.id === groupId
            );

            if (fanGroupIndex !== -1) {
              // 获取最新的文件列表
              const files = await getFanGroupFiles(groupId);

              // 更新群数据中的文件列表
              messagesList[fanGroupIndex].files = files;

              // 保存回数据库
              await xDb.xAccountProfiles.put({
                ...messagesData,
                data: messagesList,
              });

              console.log(
                "[群文件] 已更新粉丝群文件数据，文件总数:",
                files.length
              );
            }
          }
        } catch (err) {
          console.error("[群文件] 更新粉丝群文件列表失败:", err);
        }

        // 如果当前正在查看该粉丝群聊天，刷新消息显示
        if (
          currentMessageConversation &&
          currentMessageConversation.id === groupId
        ) {
          const contentContainer = document.getElementById(
            "message-detail-content"
          );
          if (contentContainer) {
            const msgEl = renderMessageItem(
              fileMessage,
              false,
              savedConversation.data.messages.length - 1,
              true
            );
            contentContainer.appendChild(msgEl);
            // 滚动到底部
            const scrollableContainer = document.getElementById(
              "message-detail-scrollable"
            );
            if (scrollableContainer) {
              scrollableContainer.scrollTop = scrollableContainer.scrollHeight;
            }
          }
        }
      }
    } catch (error) {
      console.error("[群文件] 添加文件消息失败:", error);
    }
  }

  // 动态创建文件详情模态窗口
  function createFileDetailModal() {
    // 如果已存在则先删除
    const existingModal = document.getElementById("file-detail-modal");
    if (existingModal) {
      existingModal.remove();
    }

    const modal = document.createElement("div");
    modal.id = "file-detail-modal";
    modal.style.cssText = `
position: fixed;
top: 0;
left: 0;
width: 100vw;
height: 100vh;
background-color: rgba(0, 0, 0, 0.7);
display: flex;
align-items: center;
justify-content: center;
z-index: 37;
backdrop-filter: blur(4px);
`;

    modal.innerHTML = `
<div style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 600px; max-height: 85vh; overflow-y: auto; box-shadow: 0 12px 40px rgba(0,0,0,0.4);" onclick="event.stopPropagation()">
<div style="padding: 20px 24px; border-bottom: 1px solid var(--x-border-color); display: flex; align-items: center; justify-content: space-between;">
<h3 style="margin: 0; color:var(--x-text-primary); font-size: 20px; font-weight: 700;" id="file-detail-title">文件详情</h3>
<button onclick="closeFileDetailModal()" style="background: transparent; border: none; color:var(--x-text-secondary); cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'">
<svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
<g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
</svg>
</button>
</div>
<div id="file-detail-content" style="padding: 24px;">
</div>
</div>
`;

    modal.onclick = () => closeFileDetailModal();

    // 添加到x-social-screen容器内以确保主题样式正确应用
    const xSocialScreen = document.getElementById("x-social-screen");
    if (xSocialScreen) {
      xSocialScreen.appendChild(modal);
    } else {
      document.body.appendChild(modal);
    }
    return modal;
  }

  // 打开文件详情 - 重新设计
  function openFileDetail(file) {
    console.log("[群文件] 打开文件详情:", file.name);

    const modal = createFileDetailModal();
    const title = document.getElementById("file-detail-title");
    const content = document.getElementById("file-detail-content");

    if (!title || !content) return;

    title.textContent = file.name;

    // 获取适合详情页的SVG图标
    const fileIconSvg = getFileIcon(file.type);

    // 文件类型对应的颜色
    const typeColors = {
      text: "#3b4252",
      image: "#2e3440",
      video: "#434c5e",
      link: "#4c566a",
      default: "#3b4252",
    };

    const typeColor = typeColors[file.type] || typeColors.default;

    // 格式化上传日期
    const uploadDate = new Date(file.uploadedAt);
    const formattedDate = `${uploadDate.getFullYear()}.${String(
      uploadDate.getMonth() + 1
    ).padStart(2, "0")}.${String(uploadDate.getDate()).padStart(
      2,
      "0"
    )} ${String(uploadDate.getHours()).padStart(2, "0")}:${String(
      uploadDate.getMinutes()
    ).padStart(2, "0")}`;

    content.innerHTML = `
 <div style="display: flex; flex-direction: column; gap: 14px;">
 <!-- 文件信息头部 -->
 <div style="display: flex; align-items: flex-start; gap: 12px; padding-bottom: 12px; border-bottom: 1px solid var(--x-border-color);">
 <!-- 文件图标 -->
 <div style="
 width: 46px;
 height: 46px;
 border-radius: 6px;
 background-color: ${typeColor};
 display: flex;
 align-items: center;
 justify-content: center;
 flex-shrink: 0;
 box-shadow: 0 3px 6px rgba(0,0,0,0.12);
 ">
 <div style="width: 22px; height: 22px; color: #fff;">
 ${fileIconSvg.replace("currentColor", "#fff")}
 </div>
 </div>

 <!-- 文件信息 -->
 <div style="flex: 1; min-width: 0;">
 <div style="color:var(--x-text-primary); font-size: 15px; font-weight: 600; margin-bottom: 3px; line-height: 1.3;">
 ${file.name}
 </div>
 <div style="color:var(--x-text-secondary); font-size: 12px; margin-bottom: 4px;">
 上传者：${file.uploadedBy}
 </div>
 <div style="color:var(--x-text-secondary); font-size: 11px; display: flex; align-items: center; gap: 3px;">
 <svg viewBox="0 0 24 24" style="width: 11px; height: 11px; fill: var(--x-text-secondary);">
 <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.2 3.2.8-1.3-4.5-2.7V7z"></path>
 </svg>
 <span>${formattedDate}</span>
 </div>
 </div>
 </div>

 <!-- 文件内容 -->
 <div>
 <div style="
 display: flex;
 justify-content: space-between;
 align-items: center;
 margin-bottom: 8px;
 ">
 <div style="color:var(--x-text-primary); font-size: 13px; font-weight: 600;">文件内容</div>
 <div style="
 color: var(--x-text-secondary);
 font-size: 11px;
 padding: 1px 6px;
 border: 1px solid var(--x-border-color);
 border-radius: 10px;
 ">
 ${
   file.type === "text"
     ? "文本文档"
     : file.type === "image"
     ? "图片文件"
     : file.type === "video"
     ? "视频文件"
     : file.type === "link"
     ? "链接"
     : "文件"
 }
 </div>
 </div>

 <div style="
 padding: 12px;
 background-color:var(--x-bg-secondary);
 border-radius: 6px;
 color:var(--x-text-primary);
 font-size: 13px;
 line-height: 1.5;
 max-height: 250px;
 overflow-y: auto;
 white-space: pre-wrap;
 word-wrap: break-word;
 border: 1px solid var(--x-border-color);
 ">${file.content}</div>
 </div>

 <!-- 操作按钮 -->
 <div style="display: flex; justify-content: flex-end; gap: 8px; margin-top: 2px;">
 <button onclick="deleteFanGroupFile('${
   file.id
 }'); closeFileDetailModal();" style="
 padding: 6px 12px;
 border-radius: 12px;
 border: none;
 background-color: rgba(0,0,0,0.12);
 color: #ff5252;
 font-size: 12px;
 font-weight: 500;
 cursor: pointer;
 transition: all 0.2s;
 " onmouseover="this.style.backgroundColor='rgba(0,0,0,0.2)'"
 onmouseout="this.style.backgroundColor='rgba(0,0,0,0.12)'">
 删除文件
 </button>
 </div>
 </div>
 `;

    // 模态窗口已动态创建并显示
  }

  // 关闭文件详情弹窗
  window.closeFileDetailModal = function () {
    const modal = document.getElementById("file-detail-modal");
    if (modal) {
      modal.remove();
    }
  };

  // 删除文件夹
  window.deleteFanGroupFolder = async function (folderId) {
    if (!confirm("确定要删除这个文件夹吗？文件夹内的文件将会散落显示。")) {
      return;
    }

    const groupId = currentMessageConversation.id;

    try {
      const xDb = getXDB();
      const foldersId = `fanGroupFolders_${
        currentAccountId || "main"
      }_${groupId}`;
      const filesId = `fanGroupFiles_${currentAccountId || "main"}_${groupId}`;

      // 删除文件夹
      const foldersData = await xDb.xAccountProfiles.get(foldersId);
      let folders = foldersData?.data || [];
      folders = folders.filter((f) => f.id !== folderId);

      await xDb.xAccountProfiles.put({
        handle: foldersId,
        name: "fanGroupFolders",
        data: folders,
        updatedAt: new Date().toISOString(),
      });

      // 将文件夹内的文件设为未分类
      const filesData = await xDb.xAccountProfiles.get(filesId);
      let files = filesData?.data || [];
      files.forEach((file) => {
        if (file.folderId === folderId) {
          file.folderId = null;
        }
      });

      await xDb.xAccountProfiles.put({
        handle: filesId,
        name: "fanGroupFiles",
        data: files,
        updatedAt: new Date().toISOString(),
      });

      console.log("✅ [群文件] 文件夹已删除");
      await loadFanGroupFiles();
      showXToast("文件夹已删除", "success");
    } catch (error) {
      console.error("❌ [群文件] 删除失败:", error);
      showXToast("删除失败", "error");
    }
  };

  // 删除文件
  window.deleteFanGroupFile = async function (fileId) {
    if (!confirm("确定要删除这个文件吗？")) {
      return;
    }

    const groupId = currentMessageConversation.id;

    try {
      const xDb = getXDB();
      const filesId = `fanGroupFiles_${currentAccountId || "main"}_${groupId}`;

      const savedData = await xDb.xAccountProfiles.get(filesId);
      let files = savedData?.data || [];
      files = files.filter((f) => f.id !== fileId);

      await xDb.xAccountProfiles.put({
        handle: filesId,
        name: "fanGroupFiles",
        data: files,
        updatedAt: new Date().toISOString(),
      });

      console.log("✅ [群文件] 文件已删除");
      await loadFanGroupFiles();
      showXToast("文件已删除", "success");
    } catch (error) {
      console.error("❌ [群文件] 删除失败:", error);
      showXToast("删除失败", "error");
    }
  };

  // 获取粉丝群文件
  async function getFanGroupFiles(groupId) {
    try {
      const xDb = getXDB();
      const filesId = `fanGroupFiles_${currentAccountId || "main"}_${groupId}`;
      const foldersId = `fanGroupFolders_${
        currentAccountId || "main"
      }_${groupId}`;

      // 获取所有文件
      const filesData = await xDb.xAccountProfiles.get(filesId);
      const files = filesData?.data || [];

      // 获取所有文件夹
      const foldersData = await xDb.xAccountProfiles.get(foldersId);
      const folders = foldersData?.data || [];

      // 给文件添加文件夹名称
      const filesWithFolderNames = files.map((file) => {
        if (file.folderId) {
          const folder = folders.find((f) => f.id === file.folderId);
          if (folder) {
            return {
              ...file,
              folderName: folder.name,
            };
          }
        }
        return {
          ...file,
          folderName: "未分类",
        };
      });

      return filesWithFolderNames;
    } catch (error) {
      console.error("[群文件] 获取文件列表失败:", error);
      return [];
    }
  }

  // 批量管理模式
  let isBatchMode = false;
  let selectedFiles = new Set();

  // 切换批量管理模式
  window.toggleBatchMode = function () {
    isBatchMode = !isBatchMode;
    selectedFiles.clear();

    // 更新按钮显示
    const batchBtn = document.getElementById("fangroup-files-batch-btn");
    const cancelBatchBtn = document.getElementById(
      "fangroup-files-cancel-batch-btn"
    );
    const deleteBatchBtn = document.getElementById(
      "fangroup-files-delete-batch-btn"
    );
    const createFolderBtn = document.getElementById(
      "fangroup-files-create-folder-btn"
    );
    const uploadBtn = document.getElementById("fangroup-files-upload-btn");

    if (isBatchMode) {
      // 进入批量模式
      if (batchBtn) batchBtn.style.display = "none";
      if (cancelBatchBtn) {
        cancelBatchBtn.style.display = "flex";
        cancelBatchBtn.style.backgroundColor = "var(--x-bg-secondary)";
        cancelBatchBtn.style.color = "var(--x-text-primary)";
      }
      if (deleteBatchBtn) {
        deleteBatchBtn.style.display = "flex";
        deleteBatchBtn.textContent = "删除选中 (0)";
        deleteBatchBtn.style.backgroundColor = "rgba(0,0,0,0.12)";
        deleteBatchBtn.style.color = "#ff5252";
      }
      if (createFolderBtn) createFolderBtn.style.display = "none";
      if (uploadBtn) uploadBtn.style.display = "none";
    } else {
      // 退出批量模式
      if (batchBtn) batchBtn.style.display = "flex";
      if (cancelBatchBtn) cancelBatchBtn.style.display = "none";
      if (deleteBatchBtn) deleteBatchBtn.style.display = "none";
      if (createFolderBtn) createFolderBtn.style.display = "flex";
      if (uploadBtn) uploadBtn.style.display = "flex";
    }

    // 重新加载文件列表以更新显示
    loadFanGroupFiles();
  };

  // 切换文件选择
  function toggleFileSelection(fileId) {
    if (selectedFiles.has(fileId)) {
      selectedFiles.delete(fileId);
    } else {
      selectedFiles.add(fileId);
    }

    // 更新删除按钮文本
    const deleteBatchBtn = document.getElementById(
      "fangroup-files-delete-batch-btn"
    );
    if (deleteBatchBtn) {
      deleteBatchBtn.textContent = `删除选中 (${selectedFiles.size})`;
    }

    // 更新复选框状态
    const checkbox = document.getElementById(`file-checkbox-${fileId}`);
    if (checkbox) {
      if (selectedFiles.has(fileId)) {
        checkbox.style.backgroundColor = "rgba(255,255,255,0.9)";
        checkbox.style.borderColor = "rgba(255,255,255,0.9)";
        checkbox.innerHTML = `
 <svg viewBox="0 0 24 24" style="width: 10px; height: 10px; fill: #333;">
 <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path>
 </svg>
 `;
      } else {
        checkbox.style.backgroundColor = "transparent";
        checkbox.style.borderColor = "rgba(255,255,255,0.7)";
        checkbox.innerHTML = "";
      }
    }
  }

  // 批量删除文件
  window.batchDeleteFiles = async function () {
    if (selectedFiles.size === 0) {
      showXToast("请选择要删除的文件", "warning");
      return;
    }

    if (!confirm(`确定要删除选中的 ${selectedFiles.size} 个文件吗？`)) {
      return;
    }

    const groupId = currentMessageConversation.id;

    try {
      const xDb = getXDB();
      const filesId = `fanGroupFiles_${currentAccountId || "main"}_${groupId}`;

      const savedData = await xDb.xAccountProfiles.get(filesId);
      let files = savedData?.data || [];

      // 过滤掉选中的文件
      files = files.filter((f) => !selectedFiles.has(f.id));

      await xDb.xAccountProfiles.put({
        handle: filesId,
        name: "fanGroupFiles",
        data: files,
        updatedAt: new Date().toISOString(),
      });

      console.log(`✅ [群文件] 已批量删除 ${selectedFiles.size} 个文件`);
      showXToast(`已删除 ${selectedFiles.size} 个文件`, "success");

      selectedFiles.clear();
      await loadFanGroupFiles();
    } catch (error) {
      console.error("❌ [群文件] 批量删除失败:", error);
      showXToast("批量删除失败", "error");
    }
  };

  // 暴露粉丝群函数到全局
  window.createFanGroup = createFanGroup;
  window.openFanGroupSettings = openFanGroupSettings;
  window.closeFanGroupSettings = closeFanGroupSettings;
  window.updateFanGroupAvatarPreview = updateFanGroupAvatarPreview;
  window.saveFanGroupAvatar = saveFanGroupAvatar;
  window.saveFanGroupSettings = saveFanGroupSettings;
  window.toggleFanGroupAutoMessage = toggleFanGroupAutoMessage;
  window.updateFanGroupInterval = updateFanGroupInterval;
  window.handleMessageDetailAvatarClick = handleMessageDetailAvatarClick;
  window.openFanGroupShareModal = openFanGroupShareModal;
  window.closeFanGroupShareModal = closeFanGroupShareModal;
  window.shareFanGroupToContact = shareFanGroupToContact;
  window.shareFanGroupToPost = shareFanGroupToPost;
  window.openFanGroupApplicationsModal = openFanGroupApplicationsModal;
  window.generateFanGroupConversation = generateFanGroupConversation;
  window.checkAndTriggerFanGroupAutoChat = checkAndTriggerFanGroupAutoChat; // 触发粉丝群申请生成器
  async function triggerFanGroupApplicationGenerator(tweetData) {
    console.log("🎯 [粉丝群申请生成器] 开始生成申请", {
      tweetId: tweetData.id,
      fanGroupId: tweetData.quotedFanGroup.id,
      fanGroupName: tweetData.quotedFanGroup.name,
    });
    try {
      // 🔧 使用统一的API配置加载工具
      const { apiConfig, xSettings, xDb } =
        await APIUtils.loadConfigAndSettings();
      const { userPrompt, worldSetting, boundCharacters } = xSettings;
      // 3. 获取粉丝群详细信息
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      const messagesList = savedData?.data || [];
      const fanGroup = messagesList.find(
        (msg) => msg.id === tweetData.quotedFanGroup.id
      );
      if (!fanGroup) {
        showXToast("未找到粉丝群数据", "error");
        return;
      }
      // 4. 构建用户资料信息
      const userXProfileInfo = StringBuilders.buildUserXProfileInfo(
        window.userProfileData
      ); // 4.5. 读取用户最近的3条推文
      const userTweetsId = `userTweets_${currentAccountId || "main"}`;
      const userTweetsData = await xDb.xUserTweets.get(userTweetsId);
      const recentUserTweets = userTweetsData?.tweets?.slice(0, 3) || [];
      console.log("📋 [粉丝群申请生成器] 用户完整资料:", userXProfileInfo);
      console.log(
        "📋 [粉丝群申请生成器] 最近推文数量:",
        recentUserTweets.length
      ); // Token计数器
      let tokenCount = 0; // 5. 构建基础系统提示词
      let systemPrompt = StringBuilders.buildBaseSystemPrompt({
        userPrompt,
        worldSetting,
      });
      tokenCount = TokenUtils.logTokenUsage(
        "粉丝群申请生成器",
        "基础系统提示词",
        systemPrompt,
        tokenCount
      ); // 6. 获取适用的世界书内容
      const worldBooksContent = await StringBuilders.getApplicableWorldBooks(
        "fanGroupApplication",
        {
          boundCharacters,
        }
      );
      if (worldBooksContent) {
        systemPrompt += worldBooksContent;
        tokenCount = TokenUtils.logTokenUsage(
          "粉丝群申请生成器",
          "世界书内容",
          worldBooksContent,
          tokenCount
        );
      }
      // 7. 添加核心任务说明
      const hasMoneyThreshold =
        fanGroup.groupThreshold &&
        /钱|价|元|￥|\$|费|付/.test(fanGroup.groupThreshold);
      systemPrompt += `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 核心任务：粉丝群入群申请生成器 🎯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
你是X社交平台的粉丝群申请生成器。用户 ${userXProfileInfo.name} (${
        userXProfileInfo.handle
      }) 发布了一条推文，转发了自己的粉丝群链接：
**推文内容**：
"${tweetData.content}"
**粉丝群信息**：
- 群名：${fanGroup.userName || fanGroup.groupName}
- 当前成员数：${fanGroup.memberCount || 0}
- 入群门槛：${fanGroup.groupThreshold || "无"}
**用户X平台完整资料**：
- 用户名：${userXProfileInfo.name}
- 用户句柄：${userXProfileInfo.handle}
- 认证状态：${userXProfileInfo.verified ? "已认证" : "未认证"}
${
  userXProfileInfo.verificationType &&
  userXProfileInfo.verificationType !== "none"
    ? `- 认证类型：${
        userXProfileInfo.verificationType === "verified"
          ? "蓝色勾标认证"
          : userXProfileInfo.verificationType === "couple"
          ? "情侣认证"
          : userXProfileInfo.verificationType === "married"
          ? "已婚认证"
          : userXProfileInfo.verificationType === "vip"
          ? "VIP认证"
          : "无"
      }`
    : ""
}
${
  userXProfileInfo.publicIdentity
    ? `- 公众身份：${userXProfileInfo.publicIdentity}`
    : ""
}
${userXProfileInfo.bio ? `- 个人简介：${userXProfileInfo.bio}` : ""}
${
  userXProfileInfo.verificationType === "couple" &&
  userXProfileInfo.coupleCharacterName
    ? `- 情侣关系：与${userXProfileInfo.coupleCharacterName}为公开情侣`
    : ""
}
- 影响力等级：${
        userXProfileInfo.publicIdentity ? "公众人物/有影响力" : "普通用户"
      }
${
  recentUserTweets.length > 0
    ? `**用户最近推文**（了解用户风格和影响力）：
${recentUserTweets
  .map(
    (tweet, i) => `${i + 1}. "${tweet.content}"
- 发布时间：${tweet.time || "最近"}
- 互动数据：${tweet.stats?.likes || 0}喜欢，${
      tweet.stats?.retweets || 0
    }转发，${tweet.stats?.comments || 0}评论，${tweet.stats?.views || 0}浏览`
  )
  .join("\n")}`
    : "**用户最近推文**：暂无推文（新用户或较少发帖）"
}
你的任务是生成 5-15个入群申请。
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 申请生成规则 📋
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
**申请者类型分布**（必须多样化）：
1. 真诚粉丝（60-70%）：
- 真心喜欢用户，想加入粉丝群
- 申请理由真诚、具体
- 如果有门槛要求，会认真满足
2. 普通路人（20-30%）：
- 看到推文好奇想加入
- 申请理由较简单
- 可能不完全符合门槛要求
3. 恶意/骚扰者（10-20%）：
- 故意发送不当内容
- 申请理由奇怪、无礼、或包含骚扰内容
- 明显不符合门槛要求
- 可能是为了恶作剧或骚扰
**真实感要求**：
- 申请理由要多样化，不要千篇一律
- 恶意申请要自然，不要太过明显
- 申请者姓名要真实感，不要太夸张
${
  hasMoneyThreshold
    ? `
**金钱门槛特殊处理**：
⚠️ 检测到入群门槛与金钱相关："${fanGroup.groupThreshold}"
- 70-80% 的申请者会附带金额
- 金额范围：根据门槛要求决定（建议 $10-$100）
- 申请理由中要提到支付意愿
- 恶意申请者可能故意出价过低或过高来捣乱
- 真诚粉丝会出合理的价格
`
    : ""
}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📝 JSON返回格式 📝
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
\`\`\`json
{
"applications": [
{
 "applicantName": "申请者姓名",
 "applicantHandle": "@handle",
 "applicantAvatar": "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
 "reason": "申请理由（要具体、真实）",
 "type": "sincere/normal/malicious",
 "amount": 50.00
}
]
}
\`\`\`
**字段说明**：
- applicantName: 申请者X姓名（真实感）
- applicantHandle: 申请者X句柄（格式：@username）
- applicantAvatar: 统一使用默认头像
- reason: 申请理由（20-80字，要真实、多样化）
- type: 申请类型（sincere真诚/normal普通/malicious恶意）
- amount: 附带金额（仅在有金钱门槛时需要，数字类型，保留两位小数）${
        !hasMoneyThreshold ? "，无金钱门槛时设为0" : ""
      }
**重要规则**：
1. 生成3-8个申请（根据用户影响力决定）
2. 申请理由要多样化，不要重复
3. 恶意申请要自然，不要太明显
4. type字段必须准确反映申请意图
5. 如果有金钱门槛，70-80%申请要带金额
6. 金额合理性：真诚粉丝出价合理，恶意者可能出价异常`;
      const taskSection = systemPrompt.substring(
        systemPrompt.lastIndexOf("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
      );
      tokenCount = TokenUtils.logTokenUsage(
        "粉丝群申请生成器",
        "核心任务说明",
        taskSection,
        tokenCount
      ); // 8. 添加用户资料约束
      const userConstraintsStart = systemPrompt.length;
      systemPrompt +=
        StringBuilders.buildUniversalConstraints(userXProfileInfo);
      const userConstraints = systemPrompt.substring(userConstraintsStart);
      tokenCount = TokenUtils.logTokenUsage(
        "粉丝群申请生成器",
        "用户资料约束",
        userConstraints,
        tokenCount
      );
      const messages = [{ role: "user", content: "请生成粉丝群入群申请" }]; // 最终统计
      TokenUtils.logFinalPrompt(
        "粉丝群申请生成器",
        systemPrompt,
        messages[0].content
      );
      // 🔧 使用统一的API请求工具
      const aiResponseContent = await APIUtils.sendAIRequest({
        apiConfig,
        systemPrompt,
        messages,
        temperature: 0.8,
      });
      console.log("🎯 [粉丝群申请生成器] AI响应:", aiResponseContent);
      // 🔧 使用统一的JSON解析工具
      let applicationData = APIUtils.parseJSONResponse(aiResponseContent);
      if (
        !applicationData.applications ||
        !Array.isArray(applicationData.applications)
      ) {
        throw new Error("AI返回的数据格式不正确");
      }
      // 11. 为申请添加ID和时间戳
      const timestamp = Date.now();
      applicationData.applications.forEach((app, index) => {
        app.id = `fangroup_app_${timestamp}_${index}`;
        app.timestamp = new Date().toISOString();
        app.status = "pending"; // pending, approved, rejected
      }); // 12. 保存申请到数据库
      await saveFanGroupApplications(fanGroup.id, applicationData.applications);
      console.log(
        `✅ [粉丝群申请生成器] 成功生成${applicationData.applications.length}个申请`
      ); // 13. 显示手机通知（使用X logo）
      setTimeout(() => {
        showPhoneNotification({
          title: `${fanGroup.userName || fanGroup.groupName}`,
          message: `有 ${applicationData.applications.length} 人申请加入粉丝群`,
          avatar:
            fanGroup.userAvatar ||
            "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
          leftIcon: "custom",
          leftIconHtml: `
 <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: var(--x-accent);">
 <g><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path></g>
 </svg>
 `,
          duration: 5000,
          onClick: () => {
            openFanGroupApplicationsModal(fanGroup.id);
          },
        });
      }, 1000);
    } catch (error) {
      console.error("❌ [粉丝群申请生成器] 生成失败:", error);
      showXToast("生成申请失败: " + error.message, "error");
    }
  }
  // 保存粉丝群申请到数据库
  async function saveFanGroupApplications(groupId, applications) {
    try {
      const xDb = getXDB();
      const dataId = `fanGroupApplications_${
        currentAccountId || "main"
      }_${groupId}`;
      await xDb.xAccountProfiles.put({
        handle: dataId,
        name: "fanGroupApplications",
        data: applications,
        updatedAt: new Date().toISOString(),
      });
      console.log("✅ [粉丝群申请] 申请数据已保存到数据库");
    } catch (error) {
      console.error("❌ [粉丝群申请] 保存申请失败:", error);
      throw error;
    }
  }
  // 读取粉丝群申请
  async function loadFanGroupApplications(groupId) {
    try {
      const xDb = getXDB();
      const dataId = `fanGroupApplications_${
        currentAccountId || "main"
      }_${groupId}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      return savedData?.data || [];
    } catch (error) {
      console.error("❌ [粉丝群申请] 读取申请失败:", error);
      return [];
    }
  }
  // 刷新粉丝群入群申请（查找最新帖子并触发生成器）
  window.refreshFanGroupApplications = async function (groupId) {
    console.log("🔄 [粉丝群申请] 开始刷新申请", groupId);

    // 禁用刷新按钮，防止重复点击
    const refreshBtn = document.getElementById("refresh-applications-btn");
    if (refreshBtn) {
      refreshBtn.disabled = true;
      refreshBtn.style.opacity = "0.5";
      refreshBtn.style.cursor = "not-allowed";
    }

    try {
      showXToast("正在查找相关帖子...", "info");

      // 1. 查找用户最新的、引用该粉丝群的推文
      const xDb = getXDB();
      const userTweetsId = `userTweets_${currentAccountId || "main"}`;
      const userTweetsData = await xDb.xUserTweets.get(userTweetsId);

      if (
        !userTweetsData ||
        !userTweetsData.tweets ||
        userTweetsData.tweets.length === 0
      ) {
        showXToast("请先发布引用该粉丝群的帖子", "warning");
        return;
      }

      // 2. 查找最新的引用该粉丝群的推文
      const tweets = userTweetsData.tweets;
      let latestFanGroupTweet = null;

      for (const tweet of tweets) {
        // 检查是否引用了该粉丝群
        if (tweet.quotedFanGroup && tweet.quotedFanGroup.id === groupId) {
          latestFanGroupTweet = tweet;
          break; // 找到最新的就停止
        }
      }

      if (!latestFanGroupTweet) {
        showXToast("未找到引用该粉丝群的帖子，请先发布相关帖子", "warning");
        return;
      }

      console.log("✅ [粉丝群申请] 找到相关帖子:", latestFanGroupTweet.id);
      showXToast("正在生成新的入群申请...", "info");

      // 3. 调用生成器
      await triggerFanGroupApplicationGenerator(latestFanGroupTweet);

      showXToast("成功生成新申请！", "success");

      // 4. 关闭当前弹窗
      closeFanGroupApplicationsModal();

      // 5. 延迟一下再重新打开弹窗（显示新的申请）
      setTimeout(() => {
        openFanGroupApplicationsModal(groupId);
      }, 500);
    } catch (error) {
      console.error("❌ [粉丝群申请] 刷新失败:", error);
      showXToast("刷新失败: " + error.message, "error");
    } finally {
      // 恢复按钮状态
      if (refreshBtn) {
        refreshBtn.disabled = false;
        refreshBtn.style.opacity = "1";
        refreshBtn.style.cursor = "pointer";
      }
    }
  };

  // 打开粉丝群申请弹窗
  async function openFanGroupApplicationsModal(groupId) {
    console.log("📋 [粉丝群申请] 打开申请弹窗", groupId);
    try {
      // 读取申请数据
      const applications = await loadFanGroupApplications(groupId);
      const pendingApplications = applications.filter(
        (app) => app.status === "pending"
      );
      if (pendingApplications.length === 0) {
        showXToast("暂无待处理的申请", "info");
        return;
      }
      // 读取粉丝群信息
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      const messagesList = savedData?.data || [];
      const fanGroup = messagesList.find((msg) => msg.id === groupId);
      if (!fanGroup) {
        showXToast("未找到粉丝群数据", "error");
        return;
      }
      // 检测主题
      const xSocialScreen = document.getElementById("x-social-screen");
      const isLightMode =
        xSocialScreen && xSocialScreen.classList.contains("x-theme-light"); // 创建弹窗
      const modal = document.createElement("div");
      modal.id = "fangroup-applications-modal";
      modal.style.cssText = `
 position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: ${
   isLightMode ? "rgba(255, 255, 255, 0.85)" : "rgba(0, 0, 0, 0.85)"
 }; display: flex; align-items: center; justify-content: center; z-index: 26; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); `;
      modal.innerHTML = `
 <div style="background-color: ${
   isLightMode ? "rgba(255, 255, 255, 0.95)" : "rgba(0, 0, 0, 0.95)"
 }; backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 24px; width: 90%; max-width: 500px; max-height: 80vh; position: relative; overflow: hidden; box-shadow: ${
        isLightMode
          ? "0 20px 60px rgba(0, 0, 0, 0.15)"
          : "0 20px 60px rgba(0, 0, 0, 0.8)"
      }; border: 2px solid ${
        isLightMode ? "rgba(0, 0, 0, 0.1)" : "rgba(255, 255, 255, 0.1)"
      }; " onclick="event.stopPropagation()">

 <div style="background: linear-gradient(135deg, ${
   isLightMode ? "rgba(0, 0, 0, 0.03)" : "rgba(255, 255, 255, 0.05)"
 } 0%, ${
        isLightMode ? "rgba(0, 0, 0, 0.01)" : "rgba(255, 255, 255, 0.02)"
      } 100%); padding: 24px; text-align: center; border-bottom: 1px dashed ${
        isLightMode ? "rgba(0, 0, 0, 0.15)" : "rgba(255, 255, 255, 0.15)"
      }; position: relative; ">

 <div style="position: absolute; left: -10px; bottom: -10px; width: 20px; height: 20px; border-radius: 50%; background-color: ${
   isLightMode ? "rgba(255, 255, 255, 0.85)" : "rgba(0, 0, 0, 0.85)"
 }; "></div>
 <div style="position: absolute; right: -10px; bottom: -10px; width: 20px; height: 20px; border-radius: 50%; background-color: ${
   isLightMode ? "rgba(255, 255, 255, 0.85)" : "rgba(0, 0, 0, 0.85)"
 }; "></div>

  <button onclick="refreshFanGroupApplications('${groupId}')" id="refresh-applications-btn" style="position: absolute; top: 16px; right: 56px; background: transparent; border: none; color:var(--x-text-secondary); cursor: pointer; padding: 8px; border-radius: 50%; transition: all 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'" onmouseout="this.style.backgroundColor='transparent'" title="刷新申请">
<svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor;">
<g><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></g>
</svg>
</button>

 <button onclick="closeFanGroupApplicationsModal()" style="position: absolute; top: 16px; right: 16px; background: transparent; border: none; color:var(--x-text-secondary); cursor: pointer; padding: 8px; border-radius: 50%; transition: all 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: currentColor;">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </button>

 <div style="color:var(--x-text-primary); font-size: 20px; font-weight: 700; margin-bottom: 8px; ">入群申请</div>
 <div style="color:var(--x-text-secondary); font-size: 13px; margin-bottom: 12px; ">${
   fanGroup.userName || fanGroup.groupName
 }</div>
 <div style="color: var(--x-accent); font-size: 12px; font-weight: 700; letter-spacing: 1px; ">${
   pendingApplications.length
 } 人待审核</div>
 </div>

 <div id="applications-list-container" style="max-height: 50vh; overflow-y: auto; padding: 16px 24px; ">
 ${pendingApplications
   .map((app, index) => renderApplicationCard(app, index, groupId, isLightMode))
   .join("")}
 </div>
 </div>
 `;
      document.body.appendChild(modal);
      document.body.style.overflow = "hidden"; // 点击背景关闭
      modal.onclick = (e) => {
        if (e.target === modal) {
          closeFanGroupApplicationsModal();
        }
      }; // 入场动画
      const card = modal.querySelector("div");
      card.style.transform = "scale(0.8) translateY(20px)";
      card.style.opacity = "0";
      requestAnimationFrame(() => {
        card.style.transition = "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)";
        card.style.transform = "scale(1) translateY(0)";
        card.style.opacity = "1";
      });
    } catch (error) {
      console.error("❌ [粉丝群申请] 打开弹窗失败:", error);
      showXToast("打开申请列表失败", "error");
    }
  }
  // 渲染单个申请卡片
  function renderApplicationCard(app, index, groupId, isLightMode = false) {
    const typeColor =
      {
        sincere: "#22c55e",
        normal: "#3b82f6",
        malicious: "#ef4444",
      }[app.type] || "#71767b";
    const typeText =
      {
        sincere: "真诚粉丝",
        normal: "普通申请",
        malicious: "可疑申请",
      }[app.type] || "未知";
    return `
 <div id="app-card-${app.id}" style="margin-bottom: 14px; background-color: ${
      isLightMode ? "rgba(0, 0, 0, 0.03)" : "rgba(255, 255, 255, 0.04)"
    }; border: 1px solid ${
      isLightMode ? "rgba(0, 0, 0, 0.08)" : "rgba(255, 255, 255, 0.08)"
    }; border-radius: 12px; padding: 14px; position: relative; overflow: hidden; transition: all 0.2s; ">

 <div style="position: absolute; bottom: 8px; right: 8px; font-size: 28px; color: ${
   isLightMode ? "rgba(0, 0, 0, 0.03)" : "rgba(255, 255, 255, 0.03)"
 }; font-weight: 700; pointer-events: none; transform: rotate(-15deg); ">#${
      index + 1
    }</div>

 <div style="display: flex; align-items: flex-start; gap: 12px; margin-bottom: 12px;">
 <img src="${
   app.applicantAvatar
 }" style="width: 38px; height: 38px; border-radius: 50%; object-fit: cover; ">
 <div style="flex: 1; min-width: 0;">
 <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 3px; flex-wrap: wrap;">
 <span style="color: ${
   isLightMode ? "#0f1419" : "#e7e9ea"
 }; font-size: 14px; font-weight: 700; ">${app.applicantName}</span>
 <span style="padding: 2px 7px; background-color: ${typeColor}${
      isLightMode ? "20" : "18"
    }; color: ${typeColor}; font-size: 10px; font-weight: 700; border-radius: 4px; border: 1px solid ${typeColor}${
      isLightMode ? "50" : "35"
    }; ">${typeText}</span>
 </div>
 <div style="color: ${
   isLightMode ? "#536471" : "#8b98a5"
 }; font-size: 12px; ">${app.applicantHandle}</div>
 </div>
 ${
   app.amount > 0
     ? `<div style="padding: 5px 11px; background-color: #22c55e${
         isLightMode ? "20" : "18"
       }; color: #22c55e; font-size: 13px; font-weight: 700; border-radius: 7px; border: 1px solid #22c55e${
         isLightMode ? "50" : "35"
       }; white-space: nowrap; ">$${app.amount.toFixed(2)}</div>`
     : ""
 }
 </div>

 <div style="color: ${
   isLightMode ? "#0f1419" : "#e7e9ea"
 }; font-size: 13px; line-height: 1.5; margin-bottom: 12px; padding: 11px; background-color: ${
      isLightMode ? "rgba(0, 0, 0, 0.04)" : "rgba(255, 255, 255, 0.05)"
    }; border-radius: 8px; border-left: 3px solid ${typeColor}; ">${
      app.reason
    }</div>

 <div style="display: flex; gap: 7px;">
 <button onclick="approveFanGroupApplication('${groupId}', '${
      app.id
    }')" style="flex: 1; background-color: ${
      isLightMode ? "#1d9bf0" : "var(--x-accent)"
    }; color: #ffffff; border: none; border-radius: 8px; padding: 9px; font-size: 13px; font-weight: 700; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.opacity='0.9'"
 onmouseout="this.style.opacity='1'">
 ✓ 通过
 </button>
 <button onclick="rejectFanGroupApplication('${groupId}', '${
      app.id
    }')" style="flex: 1; background-color: transparent; color: #ef4444; border: 1px solid #ef4444; border-radius: 8px; padding: 9px; font-size: 13px; font-weight: 700; cursor: pointer; transition: all 0.2s; " onmouseover="this.style.backgroundColor='${
      isLightMode ? "#ef444415" : "#ef444412"
    }'"
 onmouseout="this.style.backgroundColor='transparent'">
 ✗ 拒绝
 </button>
 </div>
 </div>
`;
  }
  // 关闭粉丝群申请弹窗
  window.closeFanGroupApplicationsModal = function () {
    const modal = document.getElementById("fangroup-applications-modal");
    if (modal) {
      const card = modal.querySelector("div");
      card.style.transform = "scale(0.9) translateY(20px)";
      card.style.opacity = "0";
      setTimeout(() => {
        modal.remove();
        document.body.style.overflow = "auto";
      }, 200);
    }
  }; // 通过申请
  window.approveFanGroupApplication = async function (groupId, appId) {
    console.log("✅ [粉丝群申请] 通过申请", groupId, appId);
    try {
      const xDb = getXDB(); // 1. 读取申请数据
      const applications = await loadFanGroupApplications(groupId);
      const app = applications.find((a) => a.id === appId);
      if (!app) {
        showXToast("未找到申请数据", "error");
        return;
      }
      // 2. 更新申请状态
      app.status = "approved";
      app.approvedAt = new Date().toISOString();
      await saveFanGroupApplications(groupId, applications); // 3. 如果有金额，添加到钱包
      if (app.amount && app.amount > 0) {
        await loadWalletData();
        if (!walletData.isActivated) {
          showXToast("请先激活钱包", "error");
          return;
        }
        walletData.balance += app.amount;
        const transaction = {
          id: "fangroup_" + Date.now(),
          description: `${app.applicantName} 的入群费用`,
          amount: app.amount,
          timestamp: new Date().toISOString(),
          type: "fan_group_fee",
          applicant: {
            name: app.applicantName,
            handle: app.applicantHandle,
          },
        };
        walletData.transactions.unshift(transaction);
        await saveWalletData();
        console.log(
          `💰 [粉丝群申请] 入群费用已入账: +$${app.amount.toFixed(2)}`
        );
      }
      // 4. 添加到粉丝群成员列表
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      const messagesList = savedData?.data || [];
      const fanGroup = messagesList.find((msg) => msg.id === groupId);
      if (fanGroup) {
        // 初始化members数组（如果不存在）
        if (!fanGroup.members) {
          fanGroup.members = [];
        }
        // 添加新成员
        const newMember = {
          id: app.id,
          name: app.applicantName,
          handle: app.applicantHandle,
          avatar: app.applicantAvatar,
          joinedAt: new Date().toISOString(),
        };
        fanGroup.members.push(newMember); // 更新成员数
        fanGroup.memberCount = fanGroup.members.length; // 保存
        await xDb.xAccountProfiles.put({
          handle: dataId,
          name: "messagesList",
          data: messagesList,
          updatedAt: new Date().toISOString(),
        });
        console.log(
          "✅ [粉丝群申请] 成员已添加，当前成员数:",
          fanGroup.memberCount
        ); // 5. 在粉丝群私信中添加系统通知
        const conversationId = `messageConversation_${
          currentAccountId || "main"
        }_${groupId}`;
        const savedConversation = await xDb.xAccountProfiles.get(
          conversationId
        );
        if (
          savedConversation &&
          savedConversation.data &&
          savedConversation.data.messages
        ) {
          const systemMessage = {
            type: "system",
            systemType: "memberJoined",
            content: `${app.applicantName} 加入了粉丝群`,
            timestamp: new Date().toISOString(),
            time: "刚刚",
          };
          savedConversation.data.messages.push(systemMessage);
          await xDb.xAccountProfiles.put(savedConversation);
          console.log("✅ [粉丝群申请] 已添加入群系统通知");
        }
      }
      // 6. 如果当前正在查看该粉丝群聊天，刷新消息显示
      if (
        currentMessageConversation &&
        currentMessageConversation.id === groupId
      ) {
        const dataId = `messagesList_${currentAccountId || "main"}`;
        const savedData = await xDb.xAccountProfiles.get(dataId);
        const messagesList = savedData?.data || [];
        const updatedFanGroup = messagesList.find((msg) => msg.id === groupId);
        if (updatedFanGroup) {
          await window.openMessageDetail(updatedFanGroup);
        }
      }
      // 7. 移除卡片（动画）
      const card = document.getElementById(`app-card-${appId}`);
      if (card) {
        card.style.transform = "translateX(100%)";
        card.style.opacity = "0";
        setTimeout(() => card.remove(), 300);
      }
      // 8. 检查是否还有待处理申请
      const remainingPending = applications.filter(
        (a) => a.status === "pending" && a.id !== appId
      );
      if (remainingPending.length === 0) {
        setTimeout(() => {
          closeFanGroupApplicationsModal();
          showXToast("所有申请已处理完毕", "success");
        }, 500);
      } else {
        showXToast(
          app.amount > 0
            ? `已通过申请，收到 $${app.amount.toFixed(2)}`
            : "已通过申请",
          "success"
        );
      }
      // 9. 检查并触发自动群聊（5、15、25人等）
      if (fanGroup && fanGroup.members && fanGroup.members.length > 0) {
        setTimeout(() => {
          checkAndTriggerFanGroupAutoChat(groupId, fanGroup.members.length);
        }, 1000);
      }
    } catch (error) {
      console.error("❌ [粉丝群申请] 通过申请失败:", error);
      showXToast("操作失败: " + error.message, "error");
    }
  }; // 拒绝申请
  window.rejectFanGroupApplication = async function (groupId, appId) {
    console.log("❌ [粉丝群申请] 拒绝申请", groupId, appId);
    try {
      // 1. 读取申请数据
      const applications = await loadFanGroupApplications(groupId);
      const app = applications.find((a) => a.id === appId);
      if (!app) {
        showXToast("未找到申请数据", "error");
        return;
      }
      // 2. 更新申请状态
      app.status = "rejected";
      app.rejectedAt = new Date().toISOString();
      await saveFanGroupApplications(groupId, applications); // 3. 移除卡片（动画）
      const card = document.getElementById(`app-card-${appId}`);
      if (card) {
        card.style.transform = "translateX(-100%)";
        card.style.opacity = "0";
        setTimeout(() => card.remove(), 300);
      }
      // 4. 检查是否还有待处理申请
      const remainingPending = applications.filter(
        (a) => a.status === "pending" && a.id !== appId
      );
      if (remainingPending.length === 0) {
        setTimeout(() => {
          closeFanGroupApplicationsModal();
          showXToast("所有申请已处理完毕", "success");
        }, 500);
      } else {
        showXToast("已拒绝申请", "info");
      }
    } catch (error) {
      console.error("❌ [粉丝群申请] 拒绝申请失败:", error);
      showXToast("操作失败: " + error.message, "error");
    }
  }; // 包装原始的 openMessageDetail 函数，添加粉丝群特殊处理
  const originalOpenMessageDetail = window.openMessageDetail;
  window.openMessageDetail = async function (messageData, isFromNotifications) {
    console.log("🎯 [粉丝群] 拦截器：检测消息类型", messageData); // 调用原始函数
    if (originalOpenMessageDetail) {
      await originalOpenMessageDetail(messageData, isFromNotifications);
    }
    // 延迟执行以确保页面已渲染
    setTimeout(() => {
      const isFanGroup = messageData.type === "fangroup";
      adjustFanGroupDetailPage(isFanGroup);
    }, 100);
  }; // ============================================
  // 私信多选删除功能
  // ============================================
  // 切换消息选择状态
  function toggleMessageSelection(messageId) {
    if (selectedMessages.has(messageId)) {
      selectedMessages.delete(messageId);
    } else {
      selectedMessages.add(messageId);
    }
    updateMessageSelectionUI();
    updateMessageDeleteUI();
  }
  // 进入多选模式
  function enterMessageMultiSelectMode() {
    messageMultiSelectMode = true;
    selectedMessages.clear();
    showMessageDeleteToolbar();
    reloadMessageDetailView();
  }
  // 退出多选模式
  window.exitMessageMultiSelectMode = function () {
    messageMultiSelectMode = false;
    selectedMessages.clear();
    hideMessageDeleteToolbar();
    reloadMessageDetailView();
  }; // 重新加载消息详情视图
  async function reloadMessageDetailView() {
    if (!currentMessageConversation) return;
    try {
      const xDb = getXDB(); // 🔧 多账户隔离：包含账户ID
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${currentMessageConversation.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (
        savedConversation &&
        savedConversation.data &&
        savedConversation.data.messages
      ) {
        const contentContainer = document.getElementById(
          "message-detail-content"
        );
        if (!contentContainer) return; // 清空并重新渲染所有消息
        const dateElements = contentContainer.querySelectorAll(
          '.message-item, div[style*="text-align: center"]'
        );
        dateElements.forEach((el) => {
          // 只移除消息项，保留日期分隔符
          if (el.classList.contains("message-item")) {
            el.remove();
          }
        }); // 使用分组渲染消息
        const messages = savedConversation.data.messages;
        const groups = groupMessagesBySender(messages);
        const allMessageElements = [];
        groups.forEach((group) => {
          const isOwn = group[0].message.isOwn === true;
          group.forEach((item, indexInGroup) => {
            const isLastInGroup = indexInGroup === group.length - 1;
            const messageEl = renderMessageItem(
              item.message,
              isOwn,
              item.index,
              isLastInGroup
            );
            contentContainer.appendChild(messageEl);
            allMessageElements.push(messageEl);
          });
        }); // 立即显示所有消息（不需要动画）
        allMessageElements.forEach((el) => {
          el.style.opacity = "1";
          el.style.transform = "translateY(0)";
        });
      }
    } catch (error) {
      console.error("重新加载消息视图失败:", error);
    }
  }
  // 更新消息选择UI
  function updateMessageSelectionUI() {
    selectedMessages.forEach((messageId) => {
      const messageEl = document.querySelector(
        `[data-message-id="${messageId}"]`
      );
      if (messageEl) {
        messageEl.style.opacity = selectedMessages.has(messageId) ? "0.7" : "1";
        const indicator = messageEl.querySelector(".message-select-indicator");
        if (indicator) {
          const isSelected = selectedMessages.has(messageId);
          indicator.style.borderColor = isSelected
            ? "var(--x-accent)"
            : "var(--x-border-color)";
          indicator.style.backgroundColor = isSelected
            ? "var(--x-accent)"
            : "var(--x-bg-primary)";
          if (isSelected) {
            indicator.innerHTML = `
 <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: #fff;">
 <g><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></g>
 </svg>
 `;
          } else {
            indicator.innerHTML = "";
          }
        }
      }
    });
  }
  // 显示删除工具栏
  function showMessageDeleteToolbar() {
    // 隐藏底部输入栏
    const inputToolbar = document.getElementById("message-input-toolbar");
    if (inputToolbar) {
      inputToolbar.style.display = "none";
    }
    // 创建删除工具栏
    let deleteToolbar = document.getElementById("message-delete-toolbar");
    if (!deleteToolbar) {
      deleteToolbar = document.createElement("div");
      deleteToolbar.id = "message-delete-toolbar";
      deleteToolbar.style.cssText = `
 position: fixed; bottom: 0; left: 0; right: 0; height: 56px; background-color:var(--x-bg-primary); border-top: 1px solid var(--x-border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 16px; z-index: 100; `;
      deleteToolbar.innerHTML = `
 <div style="display: flex; align-items: center; gap: 16px;">
 <button onclick="exitMessageMultiSelectMode()" style="background: none; border: none; color: var(--x-accent); font-size: 15px; font-weight: 600; cursor: pointer; padding: 8px 0; ">取消</button>
 <button onclick="selectAllMessages()" style="background: none; border: none; color: var(--x-accent); font-size: 15px; font-weight: 600; cursor: pointer; padding: 8px 0; ">全选</button>
 </div>
 <div style="color:var(--x-text-secondary); font-size: 14px; ">
 已选择 <span id="message-selected-count">0</span> 条
 </div>
 <button onclick="deleteSelectedMessages()" id="message-delete-btn" style="background-color: #f4212e; border: none; color: #fff; font-size: 15px; font-weight: 600; cursor: pointer; padding: 8px 16px; border-radius: 18px; opacity: 0.5; pointer-events: none; ">删除</button>
 `;
      const detailPage = document.getElementById("x-message-detail-page");
      if (detailPage) {
        detailPage.appendChild(deleteToolbar);
      }
    }
    deleteToolbar.style.display = "flex";
  }
  // 隐藏删除工具栏
  function hideMessageDeleteToolbar() {
    const deleteToolbar = document.getElementById("message-delete-toolbar");
    if (deleteToolbar) {
      deleteToolbar.remove();
    }
    // 显示输入栏
    const inputToolbar = document.getElementById("message-input-toolbar");
    if (inputToolbar) {
      inputToolbar.style.display = "flex";
    }
  }
  // 更新删除UI
  function updateMessageDeleteUI() {
    const countEl = document.getElementById("message-selected-count");
    const deleteBtn = document.getElementById("message-delete-btn");
    if (countEl) {
      countEl.textContent = selectedMessages.size;
    }
    if (deleteBtn) {
      if (selectedMessages.size > 0) {
        deleteBtn.style.opacity = "1";
        deleteBtn.style.pointerEvents = "auto";
      } else {
        deleteBtn.style.opacity = "0.5";
        deleteBtn.style.pointerEvents = "none";
      }
    }
  }
  // 全选消息
  window.selectAllMessages = function () {
    const messageElements = document.querySelectorAll(
      ".message-item[data-message-id]"
    );
    messageElements.forEach((el) => {
      const messageId = el.getAttribute("data-message-id");
      if (messageId) {
        selectedMessages.add(messageId);
      }
    });
    updateMessageSelectionUI();
    updateMessageDeleteUI();
  }; // 删除选中的消息
  window.deleteSelectedMessages = async function () {
    if (selectedMessages.size === 0) {
      showXToast("请先选择要删除的消息", "error");
      return;
    }
    const isEnglish = currentLanguage === "en";
    const confirmMessage = isEnglish
      ? `Delete ${selectedMessages.size} message(s)?`
      : `确定删除选中的 ${selectedMessages.size} 条消息吗？`;
    if (!confirm(confirmMessage)) {
      return;
    }
    try {
      const xDb = getXDB(); // 🔧 多账户隔离：包含账户ID
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${currentMessageConversation.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (
        savedConversation &&
        savedConversation.data &&
        savedConversation.data.messages
      ) {
        // 收集要删除的消息索引
        const indicesToDelete = new Set();
        selectedMessages.forEach((messageId) => {
          // 从 messageId 中提取索引（格式：msg_idx_0, msg_idx_1, etc.）
          const match = messageId.match(/^msg_idx_(\d+)$/);
          if (match) {
            indicesToDelete.add(parseInt(match[1], 10));
          }
        }); // 过滤掉选中的消息
        const updatedMessages = savedConversation.data.messages.filter(
          (msg, index) => {
            return !indicesToDelete.has(index);
          }
        );
        console.log(
          `🗑️ 准备删除索引: ${Array.from(indicesToDelete).join(", ")}`
        );
        console.log(
          `📝 删除前消息数: ${savedConversation.data.messages.length}, 删除后: ${updatedMessages.length}`
        ); // 更新数据库
        savedConversation.data.messages = updatedMessages;
        savedConversation.updatedAt = new Date().toISOString();
        await xDb.xAccountProfiles.put(savedConversation);
        console.log(`✅ 已删除 ${indicesToDelete.size} 条消息`); // 退出多选模式
        exitMessageMultiSelectMode(); // 刷新视图
        const contentContainer = document.getElementById(
          "message-detail-content"
        );
        if (contentContainer) {
          // 清空并重新渲染
          contentContainer.innerHTML = ""; // 添加日期分隔符
          const today = new Date();
          const dateStr =
            currentLanguage === "en"
              ? today.toLocaleDateString("en-US", {
                  year: "numeric",
                  month: "long",
                  day: "numeric",
                })
              : `${today.getFullYear()}年${today.getMonth() + 1}月${String(
                  today.getDate()
                ).padStart(2, "0")}日`;
          contentContainer.appendChild(renderDateSeparator(dateStr)); // 使用分组渲染消息
          const groups = groupMessagesBySender(updatedMessages);
          const allMessageElements = [];
          groups.forEach((group) => {
            const isOwn = group[0].message.isOwn === true;
            group.forEach((item, indexInGroup) => {
              const isLastInGroup = indexInGroup === group.length - 1;
              const messageEl = renderMessageItem(
                item.message,
                isOwn,
                item.index,
                isLastInGroup
              );
              contentContainer.appendChild(messageEl);
              allMessageElements.push(messageEl);
            });
          }); // 立即显示所有消息（不需要动画）
          allMessageElements.forEach((el) => {
            el.style.opacity = "1";
            el.style.transform = "translateY(0)";
          }); // 滚动到底部
          setTimeout(() => {
            const scrollable = document.getElementById(
              "message-detail-scrollable"
            );
            if (scrollable) {
              scrollable.scrollTop = scrollable.scrollHeight;
            }
          }, 100);
        }
        const successMessage = isEnglish
          ? `Deleted ${indicesToDelete.size} message(s)`
          : `已删除 ${indicesToDelete.size} 条消息`;
        showXToast(successMessage, "success");
      }
    } catch (error) {
      console.error("删除消息失败:", error);
      const errorMessage = isEnglish
        ? "Failed to delete messages"
        : "删除消息失败";
      showXToast(errorMessage, "error");
    }
  }; // ============================================
  // 拉黑解除检测系统
  // ============================================
  /**
   * 检测用户是否通过@或评论触发拉黑解除
   * @param {string} userHandle - 用户句柄
   * @param {string} targetHandle - 被拉黑对方的句柄
   * @param {string} triggerSource - 触发来源：'mention' | 'comment'
   * @param {string} content - 触发内容（推文内容或评论内容）
   */
  async function checkUnblockTrigger(
    userHandle,
    targetHandle,
    triggerSource,
    content
  ) {
    try {
      const xDb = getXDB(); // 清理句柄
      const cleanUserHandle = userHandle.replace("@", "").toLowerCase();
      const cleanTargetHandle = targetHandle.replace("@", "").toLowerCase();
      console.log(
        `🔓 [拉黑解除] 检测触发: 用户=${cleanUserHandle}, 对方=${cleanTargetHandle}, 来源=${triggerSource}`
      ); // 查找对方的资料，确定消息ID
      let messageId = null;
      let messageData = null; // 尝试查找角色
      const allXProfiles = await xDb.xCharacterProfiles.toArray();
      const targetProfile = allXProfiles.find(
        (p) =>
          p.xHandle &&
          p.xHandle.replace("@", "").toLowerCase() === cleanTargetHandle
      );
      if (targetProfile) {
        messageId = `msg_${targetProfile.characterId}`;
        const messagesListId = `messagesList_${currentAccountId || "main"}`;
        const messagesListData = await xDb.xAccountProfiles.get(messagesListId);
        if (messagesListData && messagesListData.data) {
          messageData = messagesListData.data.find((m) => m.id === messageId);
        }
      } else {
        // 尝试查找账户
        const accountProfile = await xDb.xAccountProfiles.get(
          cleanTargetHandle
        );
        if (accountProfile) {
          messageId = `msg_account_${cleanTargetHandle}`;
          const messagesListId = `messagesList_${currentAccountId || "main"}`;
          const messagesListData = await xDb.xAccountProfiles.get(
            messagesListId
          );
          if (messagesListData && messagesListData.data) {
            messageData = messagesListData.data.find((m) => m.id === messageId);
          }
        } else {
          // 陌生人
          const messagesListId = `messagesList_${currentAccountId || "main"}`;
          const messagesListData = await xDb.xAccountProfiles.get(
            messagesListId
          );
          if (messagesListData && messagesListData.data) {
            messageData = messagesListData.data.find(
              (m) =>
                m.userHandle &&
                m.userHandle.replace("@", "").toLowerCase() ===
                  cleanTargetHandle
            );
            if (messageData) {
              messageId = messageData.id;
            }
          }
        }
      }
      if (!messageId || !messageData) {
        console.log(`⚠️ [拉黑解除] 未找到对应的私信记录`);
        return;
      }
      // 检查是否被拉黑
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${messageId}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (!savedConversation || !savedConversation.isBlocked) {
        console.log(`ℹ️ [拉黑解除] 对方并未拉黑用户，无需解除`);
        return;
      }
      console.log(`✅ [拉黑解除] 检测到拉黑状态，准备生成AI回复评估是否解除`); // 使用统一AI回复生成器，传入特殊上下文
      const unblockContext = {
        triggerSource: triggerSource, // 'mention' | 'comment'
        triggerContent: content,
        isUnblockTrigger: true, // 标记为拉黑解除触发
      }; // 生成AI回复（带拉黑解除上下文）
      const aiMessages = await generateMessageConversation(messageData, true, {
        isUnblockRequest: true,
        unblockContext: unblockContext,
      }); // 检查是否包含解除拉黑系统提示
      const hasUnblockedMessage =
        aiMessages &&
        aiMessages.some(
          (msg) => msg.type === "system" && msg.systemType === "unblocked"
        );
      if (hasUnblockedMessage) {
        console.log(`🎉 [拉黑解除] AI决定解除拉黑！`); // 解除拉黑状态
        savedConversation.isBlocked = false;
        delete savedConversation.blockedAt;
        savedConversation.updatedAt = new Date().toISOString(); // 添加AI回复到对话记录
        if (!savedConversation.data) {
          savedConversation.data = { messages: [] };
        }
        if (!savedConversation.data.messages) {
          savedConversation.data.messages = [];
        }
        // 添加上下文系统通知（说明用户通过何种方式触发）
        const contextNotification = {
          type: "system",
          systemType: "unblockContext",
          content:
            triggerSource === "mention"
              ? `用户在推文中@了你: "${content.substring(0, 100)}..."`
              : `用户在评论区提到了你: "${content.substring(0, 100)}..."`,
          timestamp: new Date().toISOString(),
          time: "刚刚",
        };
        savedConversation.data.messages.push(contextNotification); // 添加AI消息
        aiMessages.forEach((msg) => {
          if (!msg.timestamp) {
            msg.timestamp = new Date().toISOString();
          }
          if (!msg.time) {
            msg.time = "刚刚";
          }
          savedConversation.data.messages.push(msg);
        }); // 保存到数据库
        await xDb.xAccountProfiles.put(savedConversation); // 🔔 显示手机样式通知
        showPhoneNotification({
          title: messageData.userName || messageData.user?.name || "未知用户",
          message: "已解除拉黑",
          avatar:
            messageData.userAvatar ||
            messageData.user?.avatar ||
            "https://i.postimg.cc/4xmx7V4R/mmexport1759081128356.jpg",
          onClick: () => {
            // 点击通知打开私信详情
            openMessageDetail(messageData);
          },
        }); // 如果当前正在查看该私信详情，刷新界面
        const detailPage = document.getElementById("x-message-detail-page");
        if (detailPage && detailPage.style.display === "flex") {
          const currentMessageData = window.currentViewingMessage;
          if (currentMessageData && currentMessageData.id === messageId) {
            console.log(`🔄 [拉黑解除] 刷新当前私信详情页`); // 解除输入框禁用
            const messageInput = document.getElementById("message-input");
            const sendBtn = document.getElementById("message-send-btn");
            if (messageInput) {
              messageInput.disabled = false;
              messageInput.placeholder = "发送私信";
            }
            if (sendBtn) {
              sendBtn.disabled = false;
            }
            // 重新加载对话
            loadMessageConversation(messageData, savedConversation.data);
          }
        }
        console.log(`✅ [拉黑解除] 拉黑已解除，AI消息已发送`);
      } else {
        console.log(`❌ [拉黑解除] AI决定不解除拉黑`);
      }
    } catch (error) {
      console.error("❌ [拉黑解除] 检测失败:", error);
    }
  }
  // ============================================
  // 后台自动发消息系统
  // ============================================
  let autoMessageCheckInterval = null;
  const AUTO_MESSAGE_CHECK_FREQUENCY = 5000; // 每5秒检查一次
  const lastAutoMessageTrigger = {}; // 记录每个角色上次触发私信时间，防止重复触发
  const lastAutoTweetTrigger = {}; // 🔧 新增：记录每个角色上次触发发推时间，防止频繁发推

  // 暴露到window以便其他函数访问
  window.lastAutoMessageTrigger = lastAutoMessageTrigger; // 🔧 暴露到window供x-core.js访问
  window.lastAutoTweetTrigger = lastAutoTweetTrigger; // 🔧 暴露到window

  window.resetAutoMessageTrigger = function (characterId) {
    if (characterId && lastAutoMessageTrigger[characterId]) {
      delete lastAutoMessageTrigger[characterId];
      console.log(`🔄 已重置角色 ${characterId} 的自动发消息触发记录`);
    }
    // 🔧 同时重置发推触发记录
    if (characterId && lastAutoTweetTrigger[characterId]) {
      delete lastAutoTweetTrigger[characterId];
      console.log(`🔄 已重置角色 ${characterId} 的自动发推触发记录`);
    }
  }; // 启动后台自动发消息检查
  function startAutoMessageSystem() {
    if (autoMessageCheckInterval) {
      clearInterval(autoMessageCheckInterval);
    }
    console.log("🤖 启动后台自动发消息系统");
    autoMessageCheckInterval = setInterval(async () => {
      await checkAndTriggerAutoMessages();
    }, AUTO_MESSAGE_CHECK_FREQUENCY);
  }
  // 停止后台自动发消息检查
  function stopAutoMessageSystem() {
    if (autoMessageCheckInterval) {
      clearInterval(autoMessageCheckInterval);
      autoMessageCheckInterval = null;
      console.log("🤖 停止后台自动发消息系统");
    }
  }
  // 检查并触发自动发消息
  async function checkAndTriggerAutoMessages() {
    try {
      const db = getDB();
      const xDb = getXDB(); // 获取私信列表数据
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      const messagesList = savedData?.data || [];
      const now = Date.now(); // === 第一部分：检查绑定角色 ===
      const settingsId = `xSettings_${currentAccountId || "main"}`;
      const xSettings = await xDb.xSettings.get(settingsId);
      const boundCharacters = xSettings?.boundCharacters || []; // 获取所有角色的X资料
      const characterProfiles = await Promise.all(
        boundCharacters.map((id) => xDb.xCharacterProfiles.get(id))
      ); // 遍历每个启用了自动发消息的角色
      for (const profile of characterProfiles) {
        if (!profile || !profile.autoMessageEnabled) {
          continue;
        }
        // 检查该角色是否在私信列表中
        const characterId = profile.characterId;
        const messageId = `msg_${characterId}`;
        const messageItem = messagesList.find((msg) => msg.id === messageId);
        if (!messageItem) {
          continue; // 角色不在私信列表，跳过
        }
        // 检查最后一次互动时间
        // 🔧 多账户隔离：包含账户ID
        const conversationId = `messageConversation_${
          currentAccountId || "main"
        }_${messageId}`;
        const savedConversation = await xDb.xAccountProfiles.get(
          conversationId
        );
        if (
          !savedConversation ||
          !savedConversation.data ||
          !savedConversation.data.messages
        ) {
          continue;
        }
        const messages = savedConversation.data.messages;
        const intervalSeconds = profile.autoMessageInterval || 60; // 检查是否最近已经触发过（防止重复触发）
        const lastTriggerTime = lastAutoMessageTrigger[characterId] || 0;
        const timeSinceLastTrigger = (now - lastTriggerTime) / 1000; // 情况1：没有任何聊天记录，触发初次主动消息
        if (messages.length === 0) {
          // 检查距离上次触发的时间，防止频繁触发
          if (timeSinceLastTrigger >= intervalSeconds) {
            console.log(`🤖 触发自动发消息（无聊天记录）: ${profile.xName}`); // 记录触发时间
            lastAutoMessageTrigger[characterId] = now; // 触发自动发消息
            await triggerAutoMessage(messageItem, profile, 0);
          }
          continue;
        }
        // 获取最后一条消息
        const lastMessage = messages[messages.length - 1];
        const lastMessageTime = lastMessage.timestamp
          ? new Date(lastMessage.timestamp).getTime()
          : 0;
        const timeSinceLastMessage = (now - lastMessageTime) / 1000; // 转换为秒
        // 情况2：最后一条消息是角色发送的（用户没有回复），且超过设定时间
        // 如果最后一条消息不是用户发的（!isOwn），说明是角色发的，用户还没回复
        if (
          timeSinceLastMessage >= intervalSeconds &&
          !lastMessage.isOwn &&
          timeSinceLastTrigger >= intervalSeconds / 2
        ) {
          console.log(
            `🤖 触发自动发消息（用户未回复）: ${
              profile.xName
            }, 距离上次互动 ${Math.floor(timeSinceLastMessage)}秒`
          ); // 记录触发时间
          lastAutoMessageTrigger[characterId] = now; // 触发自动发消息
          await triggerAutoMessage(messageItem, profile, timeSinceLastMessage);
        }
        // 🎲 随机触发自动发推（20%概率）
        // 🔧 修复：增加发推触发时间检查，防止频繁发推
        const lastTweetTriggerTime = lastAutoTweetTrigger[characterId] || 0;
        const timeSinceLastTweetTrigger = (now - lastTweetTriggerTime) / 1000;

        // 只有距离上次发推触发超过间隔时间，才有机会再次触发
        if (
          messages.length > 0 &&
          timeSinceLastTweetTrigger >= intervalSeconds
        ) {
          // 20%概率触发
          if (Math.random() < 0.2) {
            const lastMessageTime = lastMessage.timestamp
              ? new Date(lastMessage.timestamp).getTime()
              : 0;
            const timeSinceLastMsg = (now - lastMessageTime) / 1000;

            // 只有在有聊天记录且距离上次聊天超过间隔时间才触发
            if (timeSinceLastMsg >= intervalSeconds) {
              console.log(
                `🎲 [角色自动发推] 触发: ${
                  profile.xName
                }, 距离上次聊天 ${Math.floor(timeSinceLastMsg)}秒`
              );

              // 🔧 记录本次发推触发时间
              lastAutoTweetTrigger[characterId] = now;

              await triggerAutoTweet(
                messageItem,
                profile,
                timeSinceLastMsg,
                "character"
              );
            }
          }
        }
      }
      // === 第二部分：检查账户/NPC/陌生人 ===
      for (const messageItem of messagesList) {
        // 🔧 只跳过绑定角色（msg_xxx格式但不是 msg_account_/msg_npc_/msg_relationship_ 等）
        // 绑定角色的ID格式：msg_chatId（纯数字或字母组合，不带下划线前缀）
        const isCharacterMessage =
          messageItem.id.startsWith("msg_") &&
          messageItem.id !== "msg_001" &&
          !messageItem.id.startsWith("msg_account_") &&
          !messageItem.id.startsWith("msg_npc_") &&
          !messageItem.id.startsWith("msg_relationship_");
        if (isCharacterMessage) {
          continue; // 跳过绑定角色（它们在第一部分已经处理了）
        }
        // 检查该账户/NPC/陌生人是否启用了自动发消息
        const strangerSettingsId = `strangerSettings_${
          currentAccountId || "main"
        }_${messageItem.id}`;
        const strangerSettings = await xDb.xAccountProfiles.get(
          strangerSettingsId
        );
        if (!strangerSettings || !strangerSettings.autoMessageEnabled) {
          continue;
        }
        // 获取自定义的时间间隔（默认60秒）
        const intervalSeconds = strangerSettings.autoMessageInterval || 60; // 确定账户类型用于日志
        const accountType =
          messageItem._accountType ||
          (messageItem.id.startsWith("msg_account_")
            ? "账户"
            : messageItem.id.startsWith("msg_npc_")
            ? "NPC"
            : messageItem.id.startsWith("msg_relationship_")
            ? "关系NPC"
            : "陌生人");
        console.log(
          `⏰ [${accountType}自动发消息] ${
            messageItem.userName || messageItem.user?.name
          } 间隔: ${intervalSeconds}秒`
        ); // 检查最后一次互动时间
        const conversationId = `messageConversation_${
          currentAccountId || "main"
        }_${messageItem.id}`;
        const savedConversation = await xDb.xAccountProfiles.get(
          conversationId
        );
        if (
          !savedConversation ||
          !savedConversation.data ||
          !savedConversation.data.messages
        ) {
          continue;
        }
        const messages = savedConversation.data.messages; // 检查是否最近已经触发过
        const lastTriggerTime = lastAutoMessageTrigger[messageItem.id] || 0;
        const timeSinceLastTrigger = (now - lastTriggerTime) / 1000; // 情况1：没有任何聊天记录，触发初次主动消息
        if (messages.length === 0) {
          if (timeSinceLastTrigger >= intervalSeconds) {
            console.log(
              `🤖 触发${accountType}自动发消息（无聊天记录）: ${
                messageItem.userName || messageItem.user?.name
              }`
            );
            lastAutoMessageTrigger[messageItem.id] = now;
            await triggerStrangerAutoMessage(messageItem, strangerSettings, 0);
          }
          continue;
        }
        // 获取最后一条消息
        const lastMessage = messages[messages.length - 1];
        const lastMessageTime = lastMessage.timestamp
          ? new Date(lastMessage.timestamp).getTime()
          : 0;
        const timeSinceLastMessage = (now - lastMessageTime) / 1000; // 情况2：最后一条消息是对方发送的，且超过设定时间
        if (
          timeSinceLastMessage >= intervalSeconds &&
          !lastMessage.isOwn &&
          timeSinceLastTrigger >= intervalSeconds / 2
        ) {
          console.log(
            `🤖 触发${accountType}自动发消息（用户未回复）: ${
              messageItem.userName || messageItem.user?.name
            }, 距离上次互动 ${Math.floor(timeSinceLastMessage)}秒`
          );
          lastAutoMessageTrigger[messageItem.id] = now;
          await triggerStrangerAutoMessage(
            messageItem,
            strangerSettings,
            timeSinceLastMessage
          );
        }
        // 🎲 随机触发自动发推（10%概率）
        // 🔧 修复：增加发推触发时间检查，防止频繁发推
        const lastTweetTriggerTime = lastAutoTweetTrigger[messageItem.id] || 0;
        const timeSinceLastTweetTrigger = (now - lastTweetTriggerTime) / 1000;

        // 只有距离上次发推触发超过间隔时间，才有机会再次触发
        if (
          messages.length > 0 &&
          timeSinceLastTweetTrigger >= intervalSeconds
        ) {
          // 10%概率触发
          if (Math.random() < 0.1) {
            const lastMessageTime = lastMessage.timestamp
              ? new Date(lastMessage.timestamp).getTime()
              : 0;
            const timeSinceLastMsg = (now - lastMessageTime) / 1000;

            // 只有在有聊天记录且距离上次聊天超过间隔时间才触发
            if (timeSinceLastMsg >= intervalSeconds) {
              console.log(
                `🎲 [${accountType}自动发推] 触发: ${
                  messageItem.userName || messageItem.user?.name
                }, 距离上次聊天 ${Math.floor(timeSinceLastMsg)}秒`
              );

              // 🔧 记录本次发推触发时间
              lastAutoTweetTrigger[messageItem.id] = now;

              await triggerAutoTweet(
                messageItem,
                strangerSettings,
                timeSinceLastMsg,
                "stranger"
              );
            }
          }
        }
      }
      // === 第三部分：检查粉丝群 ===
      for (const messageItem of messagesList) {
        // 检查是否为粉丝群
        if (messageItem.type !== "fangroup") {
          continue;
        }
        // 检查该粉丝群是否启用了自动发消息
        const fanGroupSettingsId = `fanGroupSettings_${
          currentAccountId || "main"
        }_${messageItem.id}`;
        const fanGroupSettings = await xDb.xAccountProfiles.get(
          fanGroupSettingsId
        );
        if (
          !fanGroupSettings ||
          !fanGroupSettings.data ||
          !fanGroupSettings.data.autoMessageEnabled
        ) {
          continue;
        }
        // 获取自定义的时间间隔（默认120秒）
        const intervalSeconds =
          fanGroupSettings.data.autoMessageInterval || 120;
        console.log(
          `⏰ [粉丝群自动发消息] ${
            messageItem.userName || messageItem.groupName
          } 间隔: ${intervalSeconds}秒`
        );
        // 检查最后一次互动时间
        const conversationId = `messageConversation_${
          currentAccountId || "main"
        }_${messageItem.id}`;
        const savedConversation = await xDb.xAccountProfiles.get(
          conversationId
        );
        if (
          !savedConversation ||
          !savedConversation.data ||
          !savedConversation.data.messages
        ) {
          // 如果没有对话记录，初始化一个
          await xDb.xAccountProfiles.put({
            handle: conversationId,
            name: "conversation",
            data: {
              messages: [],
            },
            updatedAt: new Date().toISOString(),
          });
          continue;
        }
        const messages = savedConversation.data.messages;
        // 检查是否最近已经触发过
        const lastTriggerTime = lastAutoMessageTrigger[messageItem.id] || 0;
        const timeSinceLastTrigger = (now - lastTriggerTime) / 1000;
        // 获取最后一条非系统消息
        const lastNonSystemMessage = messages
          .slice()
          .reverse()
          .find((msg) => msg.type !== "system");
        if (!lastNonSystemMessage) {
          // 如果没有非系统消息，触发初次群聊
          if (timeSinceLastTrigger >= intervalSeconds) {
            console.log(
              `🤖 触发粉丝群自动交流（无聊天记录）: ${
                messageItem.userName || messageItem.groupName
              }`
            );
            lastAutoMessageTrigger[messageItem.id] = now;
            await triggerFanGroupAutoReaction(messageItem);
          }
          continue;
        }
        const lastMessageTime = lastNonSystemMessage.timestamp
          ? new Date(lastNonSystemMessage.timestamp).getTime()
          : 0;
        const timeSinceLastMessage = (now - lastMessageTime) / 1000;
        // 触发条件：距离上次非系统消息超过设定时间
        if (
          timeSinceLastMessage >= intervalSeconds &&
          timeSinceLastTrigger >= intervalSeconds / 2
        ) {
          console.log(
            `🤖 触发粉丝群自动交流: ${
              messageItem.userName || messageItem.groupName
            }, 距离上次互动 ${Math.floor(timeSinceLastMessage)}秒`
          );
          lastAutoMessageTrigger[messageItem.id] = now;
          await triggerFanGroupAutoReaction(messageItem);
        }
      }
    } catch (error) {
      console.error("❌ 检查自动发消息失败:", error);
    }
  }
  // 触发粉丝群自动交流（调用第11情景的自反应模式）
  async function triggerFanGroupAutoReaction(fanGroupData) {
    try {
      console.log("🎭 [粉丝群自反应] 后台自动触发");
      // 调用第11个情景生成器（自反应模式）
      const aiMessages = await generateFanGroupConversation(
        fanGroupData,
        true,
        {
          isAutoReaction: true, // 自反应模式标记
        }
      );
      if (!aiMessages || aiMessages.length === 0) {
        console.log("📭 [粉丝群自反应] AI未生成任何消息");
        return;
      }
      // 读取现有对话数据
      const xDb = getXDB();
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${fanGroupData.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      let allMessages = [];
      if (
        savedConversation &&
        savedConversation.data &&
        savedConversation.data.messages
      ) {
        allMessages = savedConversation.data.messages;
      }
      // 追加AI生成的消息
      allMessages.push(...aiMessages);
      // 保存到数据库
      await xDb.xAccountProfiles.put({
        handle: conversationId,
        name: "conversation",
        data: {
          messages: allMessages,
        },
        updatedAt: new Date().toISOString(),
      });
      console.log(`✅ [粉丝群自反应] 后台生成了${aiMessages.length}条群聊消息`);
      // 更新私信列表的预览
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const messagesList = await xDb.xAccountProfiles.get(dataId);
      if (messagesList && messagesList.data) {
        const groupIndex = messagesList.data.findIndex(
          (msg) => msg.id === fanGroupData.id
        );
        if (groupIndex !== -1) {
          const lastMsg = aiMessages[aiMessages.length - 1];
          const lastMsgContent =
            lastMsg.content ||
            lastMsg.voiceText ||
            lastMsg.imageDescription ||
            "[消息]";
          messagesList.data[
            groupIndex
          ].lastMessage = `${lastMsg.senderName}: ${lastMsgContent}`;
          messagesList.data[groupIndex].timestamp = new Date().toISOString();
          messagesList.data[groupIndex].unread = true; // 标记为未读
          await xDb.xAccountProfiles.put(messagesList);
          // 更新全局数据
          sampleMessagesData = messagesList.data;
        }
      }
      // 如果用户正在私信页面，刷新列表
      if (
        document.getElementById("x-messages-page")?.style.display === "block"
      ) {
        await loadMessagesList();
      }
    } catch (error) {
      console.error("❌ [粉丝群自反应] 后台触发失败:", error);
    }
  }
  // 触发自动发推（角色/账户/NPC/关系NPC/陌生人）
  async function triggerAutoTweet(
    messageData,
    settings,
    timeSinceLastMessage,
    type = "character"
  ) {
    try {
      // 确定账户类型和名称
      let accountType, accountName, accountHandle, accountAvatar;
      if (type === "character") {
        accountType = "角色";
        accountName = settings.xName;
        accountHandle = settings.xHandle;
        accountAvatar = settings.xAvatar;
      } else {
        // 非角色：账户/NPC/关系NPC/陌生人
        accountType =
          messageData._accountType ||
          (messageData.id.startsWith("msg_account_")
            ? "账户"
            : messageData.id.startsWith("msg_npc_")
            ? "NPC"
            : messageData.id.startsWith("msg_relationship_")
            ? "关系NPC"
            : "陌生人");
        accountName =
          messageData.userName || messageData.user?.name || messageData.name;
        accountHandle =
          messageData.userHandle ||
          messageData.user?.handle ||
          messageData.handle;
        accountAvatar =
          messageData.userAvatar ||
          messageData.user?.avatar ||
          messageData.avatar;
      }
      console.log(`📨 ${accountType} ${accountName} 正在自动发推...`); // 获取聊天记录
      const xDb = getXDB();
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${messageData.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (
        !savedConversation ||
        !savedConversation.data ||
        !savedConversation.data.messages
      ) {
        console.warn("自动发推失败，无聊天记录");
        return;
      }
      const messages = savedConversation.data.messages;
      const contextMessages = messages.slice(-20); // 最近20条消息
      // 调用新推生成器，传入时间信息
      const tweetData = await generateTweetFromConversation(
        messageData,
        contextMessages,
        {
          isAutoTweet: true,
          timeSinceLastMessage: Math.floor(timeSinceLastMessage),
          type: type,
        }
      );
      if (!tweetData) {
        console.warn("自动发推生成失败，无推文内容");
        return;
      }
      // 创建 New Tweet 通知
      const timestamp = Date.now();
      const newTweetNotification = {
        id: `mention_newtweet_auto_${timestamp}`,
        type: "newTweet",
        user: {
          name: accountName,
          handle: accountHandle,
          avatar: accountAvatar,
        },
        content: `New Tweet from ${accountName}`,
        time: "刚刚",
        timestamp: timestamp,
        tweet: tweetData,
      }; // 保存到 Mentions 数据库
      const mentionsDataId = `mentions_${currentAccountId || "main"}`;
      let savedMentions = await xDb.xAccountProfiles.get(mentionsDataId);
      if (!savedMentions) {
        savedMentions = {
          handle: mentionsDataId,
          id: mentionsDataId,
          data: [],
        };
      }
      savedMentions.data.unshift(newTweetNotification);
      await xDb.xAccountProfiles.put(savedMentions);
      console.log(`✅ ${accountType}自动发推成功: ${accountName}`); // 将推文添加到发推者的账户主页
      await addTweetToAccountProfile(accountHandle, tweetData); // 显示手机样式通知
      const isEnglish = currentLanguage === "en";
      showPhoneNotification({
        title: "X",
        message: isEnglish
          ? `${accountName} posted a new tweet!`
          : `${accountName} 发布了新推文！`,
        avatar: accountAvatar,
        leftIcon: "x",
      }); // 如果当前在 Mentions 页面，刷新显示
      const mentionsPage = document.getElementById("x-notifications-page");
      if (mentionsPage && mentionsPage.style.display === "flex") {
        await loadNotifications();
      } else {
        showNavNotificationDot("notifications");
      }
    } catch (error) {
      console.error("❌ 触发自动发推失败:", error);
    }
  }
  // 触发非角色账户自动发消息（账户/NPC/关系NPC/陌生人）
  async function triggerStrangerAutoMessage(
    messageData,
    strangerSettings,
    timeSinceLastMessage
  ) {
    try {
      // 确定账户类型用于日志
      const accountType =
        messageData._accountType ||
        (messageData.id.startsWith("msg_account_")
          ? "账户"
          : messageData.id.startsWith("msg_npc_")
          ? "NPC"
          : messageData.id.startsWith("msg_relationship_")
          ? "关系NPC"
          : "陌生人");
      const accountName =
        messageData.userName || messageData.user?.name || messageData.name;
      console.log(`📨 ${accountType} ${accountName} 正在自动发消息...`); // 调用生成器，使用自动模式
      const newMessages = await generateMessageConversation(messageData, true, {
        isAutoMessage: true,
        timeSinceLastMessage: Math.floor(timeSinceLastMessage),
      });
      if (!newMessages || newMessages.length === 0) {
        console.warn(`${accountType}自动发消息生成失败，无新消息`);
        return;
      }
      // 保存自动发送的消息到数据库
      const xDb = getXDB();
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${messageData.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (savedConversation && savedConversation.data) {
        // 添加自动消息（添加时间戳）
        newMessages.forEach((msg) => {
          if (!msg.timestamp) {
            msg.timestamp = new Date().toISOString();
          }
        });
        savedConversation.data.messages.push(...newMessages);
        savedConversation.updatedAt = new Date().toISOString();
        await xDb.xAccountProfiles.put(savedConversation);
        console.log(`✅ ${accountType}自动消息已保存: ${newMessages.length}条`); // 显示顶部提醒
        const isEnglish = currentLanguage === "en";
        const toastMessage = isEnglish
          ? `${accountName} sent you ${newMessages.length} message(s)`
          : `${accountName} 向你发送了 ${newMessages.length} 条私信`;
        showXToast(toastMessage, "info"); // 如果当前正在查看该私信详情，刷新显示
        if (
          currentMessageConversation &&
          currentMessageConversation.id === messageData.id
        ) {
          const contentContainer = document.getElementById(
            "message-detail-content"
          );
          if (contentContainer) {
            let currentMessageCount =
              contentContainer.querySelectorAll(".message-item").length;
            newMessages.forEach((msg) => {
              const msgElement = renderMessageItem(
                msg,
                false,
                currentMessageCount
              );
              contentContainer.appendChild(msgElement);
              currentMessageCount++;
            });
          }
        }
        // 更新私信列表中该陌生人的未读状态
        try {
          const dataId = `messagesList_${currentAccountId || "main"}`;
          const savedData = await xDb.xAccountProfiles.get(dataId);
          if (savedData && savedData.data) {
            const messagesList = savedData.data;
            const messageIndex = messagesList.findIndex(
              (msg) => msg.id === messageData.id
            );
            if (messageIndex !== -1) {
              messagesList[messageIndex].unread = true;
              messagesList[messageIndex].unreadCount =
                (messagesList[messageIndex].unreadCount || 0) +
                newMessages.length;
              await xDb.xAccountProfiles.put({
                handle: dataId,
                name: "messagesList",
                data: messagesList,
                updatedAt: new Date().toISOString(),
              });
              sampleMessagesData = messagesList;
              console.log(`✅ 已标记${accountType}私信为未读`);
            }
          }
        } catch (error) {
          console.error("更新未读状态失败:", error);
        }
        // 更新私信列表
        const messagesPage = document.getElementById("x-messages-page");
        if (messagesPage && messagesPage.style.display !== "none") {
          await loadMessagesList();
        } else {
          showNavNotificationDot("messages");
        }
      }
    } catch (error) {
      console.error("❌ 触发陌生人自动发消息失败:", error);
    }
  }
  // 触发自动发消息
  async function triggerAutoMessage(
    messageData,
    characterProfile,
    timeSinceLastMessage
  ) {
    try {
      console.log(`📨 角色 ${characterProfile.xName} 正在自动发消息...`); // 调用生成器，使用自动模式
      const newMessages = await generateMessageConversation(messageData, true, {
        isAutoMessage: true,
        timeSinceLastMessage: Math.floor(timeSinceLastMessage),
      });
      if (!newMessages || newMessages.length === 0) {
        console.warn("自动发消息生成失败，无新消息");
        return;
      }
      // 保存自动发送的消息到数据库
      const xDb = getXDB(); // 🔧 多账户隔离：包含账户ID
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${messageData.id}`;
      const savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (savedConversation && savedConversation.data) {
        // 添加自动消息（添加时间戳）
        newMessages.forEach((msg) => {
          if (!msg.timestamp) {
            msg.timestamp = new Date().toISOString();
          }
        });
        savedConversation.data.messages.push(...newMessages);
        savedConversation.updatedAt = new Date().toISOString();
        await xDb.xAccountProfiles.put(savedConversation);
        console.log(`✅ 自动消息已保存: ${newMessages.length}条`); // 智能检测是否需要生成 New Tweet 通知
        try {
          await detectAndGenerateNewTweetNotification(
            messageData,
            savedConversation.data.messages
          );
        } catch (error) {
          console.error("New Tweet 检测失败:", error);
        }
        // 显示顶部提醒
        const isEnglish = currentLanguage === "en";
        const toastMessage = isEnglish
          ? `${characterProfile.xName} sent you ${newMessages.length} message(s)`
          : `${characterProfile.xName} 向你发送了 ${newMessages.length} 条私信`;
        showXToast(toastMessage, "info"); // 如果当前正在查看该私信详情，刷新显示
        if (
          currentMessageConversation &&
          currentMessageConversation.id === messageData.id
        ) {
          const contentContainer = document.getElementById(
            "message-detail-content"
          );
          if (contentContainer) {
            // 获取当前消息总数
            let currentMessageCount =
              contentContainer.querySelectorAll(".message-item").length;
            newMessages.forEach((msg) => {
              const msgElement = renderMessageItem(
                msg,
                false,
                currentMessageCount
              );
              contentContainer.appendChild(msgElement);
              currentMessageCount++;
            });
          }
        }
        // 更新私信列表中该角色的未读状态
        try {
          const xDb = getXDB();
          const dataId = `messagesList_${currentAccountId || "main"}`;
          const savedData = await xDb.xAccountProfiles.get(dataId);
          if (savedData && savedData.data) {
            const messagesList = savedData.data;
            const messageIndex = messagesList.findIndex(
              (msg) => msg.id === messageData.id
            );
            if (messageIndex !== -1) {
              // 标记为未读
              messagesList[messageIndex].unread = true;
              messagesList[messageIndex].unreadCount =
                (messagesList[messageIndex].unreadCount || 0) +
                newMessages.length; // 保存回数据库
              await xDb.xAccountProfiles.put({
                handle: dataId,
                name: "messagesList",
                data: messagesList,
                updatedAt: new Date().toISOString(),
              }); // 同步更新全局数据
              sampleMessagesData = messagesList;
              console.log("✅ 已标记私信为未读");
            }
          }
        } catch (error) {
          console.error("更新未读状态失败:", error);
        }
        // 更新私信列表的最后一条消息预览（如果在私信列表页面）
        const messagesPage = document.getElementById("x-messages-page");
        if (messagesPage && messagesPage.style.display !== "none") {
          // 重新加载私信列表以显示最新消息
          await loadMessagesList();
        } else {
          // 如果不在私信页面，显示提醒点
          showNavNotificationDot("messages");
        }
      }
    } catch (error) {
      console.error("❌ 触发自动发消息失败:", error);
    }
  }

  // 🗑️ 从账户主页删除推文
  async function deleteTweetsFromAccountProfile(userHandle, tweetIdsToDelete) {
    try {
      if (!tweetIdsToDelete || tweetIdsToDelete.length === 0) {
        return;
      }

      const xDB = getXDB();
      const cleanHandle = userHandle.replace("@", "");

      console.log(
        `🗑️ [推文删除] 开始从 ${cleanHandle} 的主页删除 ${tweetIdsToDelete.length} 条推文`
      );

      // 获取账户主页数据
      let accountProfile = await xDB.xAccountProfiles.get(cleanHandle);

      if (!accountProfile || !accountProfile.tweets) {
        console.log(`⏭️ [推文删除] 账户主页不存在或无推文，跳过删除`);
        return;
      }

      // 删除前的推文数量
      const beforeCount = accountProfile.tweets.length;

      // 过滤掉要删除的推文
      accountProfile.tweets = accountProfile.tweets.filter(
        (tweet) => !tweetIdsToDelete.includes(tweet.id)
      );

      // 删除后的推文数量
      const afterCount = accountProfile.tweets.length;
      const deletedCount = beforeCount - afterCount;

      if (deletedCount > 0) {
        // 更新时间
        accountProfile.updatedAt = new Date().toISOString();

        // 保存到数据库
        await xDB.xAccountProfiles.put(accountProfile);

        console.log(
          `✅ [推文删除] 成功删除 ${deletedCount} 条推文，当前推文总数: ${afterCount}`
        );
      } else {
        console.log(`⏭️ [推文删除] 未找到要删除的推文ID，可能已被删除`);
      }
    } catch (error) {
      console.error("❌ [推文删除] 删除推文失败:", error);
    }
  }

  // 暴露私信相关函数到全局
  window.loadMessagesList = loadMessagesList;
  window.openNewMessageModal = openNewMessageModal;
  window.startAutoMessageSystem = startAutoMessageSystem;
  window.stopAutoMessageSystem = stopAutoMessageSystem;
  window.closeNewMessageModal = closeNewMessageModal;
  window.selectCharacterForMessage = selectCharacterForMessage;
  console.log("✅ 全局接口已暴露"); // ============================================
  // 文章查看页面功能
  // ============================================
  // 封面图链接数组
  const articleCoverImages = [
    "https://i.postimg.cc/CLJM9Wgg/4af1071dfec6baab460e61e9eeb280f2.jpg",
    "https://i.postimg.cc/fyNThsyJ/ff606a3597bbf3eaab3f0dbc4366cfac.jpg",
    "https://i.postimg.cc/C5LX8r6c/90502cdcef619816182a5e03e7de5592.jpg",
    "https://i.postimg.cc/QxCvxPTn/53551999bb82fecf909ea84947dd008c.jpg",
    "https://i.postimg.cc/y8S50Znm/f26c037c7785d0cdd3e371ebdce85df7.jpg",
    "https://i.postimg.cc/sDKfbtrD/4e7fc081056f2f475ed481e27ddfcd4a.jpg",
    "https://i.postimg.cc/65z6FDX6/27fce0a614e984e577264e58b25b0da5.jpg",
    "https://i.postimg.cc/65z6FDXp/931f9cc4c1bf7a0f1ee7b4fdfa334c5d.jpg",
    "https://i.postimg.cc/hPM4NHBS/5747a13122e4366828c95e673bcefba6.jpg",
    "https://i.postimg.cc/yYn62wHN/8700fba519fec2eccbeaa00e3b8996a9.jpg",
  ]; // 打开文章查看页面
  window.openArticlePage = function (articleData) {
    console.log("📰 [文章查看] 打开文章页面", articleData); // 保存当前文章数据供转发使用
    currentArticleData = articleData; // 设置封面图（随机选择）
    const randomCover =
      articleCoverImages[Math.floor(Math.random() * articleCoverImages.length)];
    document.getElementById(
      "article-cover"
    ).style.backgroundImage = `url('${randomCover}')`; // 设置标题
    const titleEl = document.getElementById("article-title");
    titleEl.textContent = articleData.title || "无标题"; // 检测标题是否包含英文（简单判断：是否有英文字母）
    const hasEnglish = /[a-zA-Z]/.test(articleData.title);
    if (hasEnglish) {
      titleEl.classList.add("article-title-en");
    } else {
      titleEl.classList.remove("article-title-en");
    }
    // 设置作者
    document.getElementById("article-author").textContent =
      articleData.author || "佚名"; // 设置来源
    document.getElementById("article-source").textContent =
      articleData.source || "未知来源"; // 设置正文（处理强调和下划线）
    const bodyEl = document.getElementById("article-body");
    let bodyHtml = articleData.body || articleData.description || ""; // 将**text**转换为<strong>
    bodyHtml = bodyHtml.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");
    // 将__text__转换为<em>（下划线重点）
    bodyHtml = bodyHtml.replace(/__(.*?)__/g, "<em>$1</em>");
    bodyEl.innerHTML = bodyHtml; // 显示文章页面
    document.getElementById("x-article-page").style.display = "flex";
    console.log("✅ [文章查看] 文章页面已打开");
  }; // 关闭文章查看页面
  window.closeArticlePage = function () {
    document.getElementById("x-article-page").style.display = "none";
    console.log("✅ [文章查看] 文章页面已关闭");
  }; // 当前正在查看的文章数据
  let currentArticleData = null; // 转发文章
  window.shareArticle = function () {
    console.log("📤 [文章转发] 打开转发弹窗");
    if (!currentArticleData) {
      showXToast("无法获取文章信息", "error");
      return;
    }
    showShareArticleModal();
  }; // 显示转发文章弹窗
  async function showShareArticleModal() {
    try {
      // 获取私信列表
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      const messagesList = savedData?.data || [];
      if (messagesList.length === 0) {
        showXToast("暂无私信联系人", "info");
        return;
      }
      // 创建弹窗
      const modal = document.createElement("div");
      modal.id = "share-article-modal";
      modal.style.cssText = `
 display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--x-modal-overlay); z-index: 22; align-items: center; justify-content: center; backdrop-filter: blur(4px); `;
      modal.innerHTML = `
 <div class="modal-content" onclick="event.stopPropagation()" style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 500px; max-height: 80vh; overflow: hidden; border: 1px solid var(--x-border-color); display: flex; flex-direction: column; ">

 <div class="modal-header" style="display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid var(--x-border-color); background-color:var(--x-bg-primary); ">
 <div style="display: flex; align-items: center; gap: 20px;">

 <div class="modal-close-btn" onclick="closeShareArticleModal()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>

 <h2 style="color:var(--x-text-primary); font-size: 20px; font-weight: 700; margin: 0; ">转发文章</h2>
 </div>
 </div>

 <div class="modal-body" style="padding: 16px 20px; overflow-y: auto; flex: 1; ">

 <div style="padding: 12px; background-color:var(--x-bg-secondary); border-radius: 12px; margin-bottom: 16px; border: 1px solid var(--x-border-color); ">
 <div style="font-size: 15px; font-weight: 600; color:var(--x-text-primary); margin-bottom: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">${
   currentArticleData?.title || "无标题"
 }</div>
 <div style="font-size: 13px; color:var(--x-text-secondary); overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; ">${
   currentArticleData?.description || ""
 }</div>
 </div>

 <div style="margin-bottom: 16px;">
 <label style="display: block; color:var(--x-text-secondary); font-size: 13px; margin-bottom: 8px; ">附加文字（可选）</label>
 <textarea id="share-article-message" placeholder="添加一些说明..." style="width: 100%; min-height: 80px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 12px; color:var(--x-text-primary); padding: 12px; font-size: 15px; resize: vertical; outline: none; box-sizing: border-box; font-family: inherit; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'"></textarea>
 </div>

 <div style="color:var(--x-text-secondary); font-size: 13px; margin-bottom: 12px; ">选择要转发到的联系人</div>

 <div id="share-article-contacts-list" style="display: flex; flex-direction: column; gap: 0; ">
 ${messagesList
   .map(
     (contact) => `
 <div class="contact-select-item" data-contact-id="${contact.id}" onclick="selectContactForShare('${contact.id}')" style="display: flex; align-items: center; gap: 12px; padding: 12px; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">

 <img src="${contact.userAvatar}"
 alt="${contact.userName}"
 style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0; object-fit: cover; ">

 <div style="flex: 1; min-width: 0;">
 <div style="font-size: 15px; font-weight: 700; color:var(--x-text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">${contact.userName}</div>
 <div style="font-size: 13px; color:var(--x-text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">@${contact.userHandle}</div>
 </div>
 </div>
 `
   )
   .join("")}
 </div>
 </div>
 </div>
 `; // 将弹窗添加到X应用容器内
      const xSocialScreen = document.getElementById("x-social-screen");
      if (xSocialScreen) {
        xSocialScreen.appendChild(modal);
      } else {
        document.body.appendChild(modal);
      }
      // 点击背景关闭弹窗
      modal.addEventListener("click", (e) => {
        if (e.target === modal) {
          closeShareArticleModal();
        }
      });
    } catch (error) {
      console.error("显示转发弹窗失败:", error);
      showXToast("打开转发失败", "error");
    }
  }
  // 关闭转发文章弹窗
  window.closeShareArticleModal = function () {
    const modal = document.getElementById("share-article-modal");
    if (modal) {
      modal.remove();
    }
  }; // 选择联系人转发文章
  window.selectContactForShare = async function (contactId) {
    console.log("📤 [文章转发] 转发到联系人:", contactId);
    try {
      const xDb = getXDB(); // 获取附加文字
      const messageInput = document.getElementById("share-article-message");
      const additionalMessage = messageInput ? messageInput.value.trim() : ""; // 获取当前时间
      const now = new Date();
      const hours = now.getHours();
      const minutes = String(now.getMinutes()).padStart(2, "0");
      const period = hours >= 12 ? "下午" : "上午";
      const timeStr = `${hours > 12 ? hours - 12 : hours}:${minutes} ${period}`; // 创建文章链接消息
      const articleMessage = {
        type: "link",
        url: currentArticleData.source || "",
        title: currentArticleData.title,
        description: currentArticleData.description || "",
        author: currentArticleData.author,
        source: currentArticleData.source,
        body: currentArticleData.body,
        time: timeStr,
        timestamp: now.toISOString(),
        isOwn: true,
      }; // 读取现有对话数据
      // 🔧 多账户隔离：包含账户ID
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${contactId}`;
      let savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (!savedConversation) {
        // 创建新的对话记录
        savedConversation = {
          handle: conversationId,
          name: "messageConversation",
          data: {
            messages: [],
          },
          messageId: contactId,
          accountId: currentAccountId || "main", // 添加账户ID
          updatedAt: new Date().toISOString(),
        };
      }
      // 确保messages数组存在
      if (!savedConversation.data.messages) {
        savedConversation.data.messages = [];
      }
      // 添加文章消息
      savedConversation.data.messages.push(articleMessage); // 如果有附加文字，也添加文字消息
      if (additionalMessage) {
        const textMessage = {
          type: "text",
          content: additionalMessage,
          time: timeStr,
          timestamp: now.toISOString(),
          isOwn: true,
        };
        savedConversation.data.messages.push(textMessage);
      }
      // 标记最后一条消息为等待AI回复
      const lastMessageIndex = savedConversation.data.messages.length - 1;
      if (lastMessageIndex >= 0) {
        savedConversation.data.messages[
          lastMessageIndex
        ].waitingForAIResponse = true;
      }
      // 保存到数据库
      savedConversation.updatedAt = new Date().toISOString();
      await xDb.xAccountProfiles.put(savedConversation); // 更新私信列表的最后消息和时间
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      if (savedData && savedData.data) {
        const messagesList = savedData.data;
        const contactIndex = messagesList.findIndex(
          (msg) => msg.id === contactId
        );
        if (contactIndex !== -1) {
          messagesList[contactIndex].lastMessage =
            additionalMessage || "[链接]";
          messagesList[contactIndex].timestamp = now.toISOString(); // 将该联系人移到列表顶部
          const contact = messagesList.splice(contactIndex, 1)[0];
          messagesList.unshift(contact); // 保存更新后的列表
          await xDb.xAccountProfiles.put({
            handle: dataId,
            name: "messagesList",
            data: messagesList,
            updatedAt: new Date().toISOString(),
          }); // 更新全局变量
          sampleMessagesData = messagesList;
        }
      }
      // 关闭弹窗
      closeShareArticleModal(); // 关闭文章查看页面
      closeArticlePage(); // 如果用户当前正在查看这个聊天详情页，重新加载页面
      const detailPage = document.getElementById("x-message-detail-page");
      if (detailPage && detailPage.style.display !== "none") {
        // 检查当前打开的是否是这个联系人的聊天
        const currentConversationId = detailPage.dataset.conversationId;
        if (currentConversationId === contactId) {
          // 重新加载聊天详情页
          const dataId = `messagesList_${currentAccountId || "main"}`;
          const messageData = await xDb.xAccountProfiles.get(dataId);
          if (messageData && messageData.data) {
            const contact = messageData.data.find(
              (msg) => msg.id === contactId
            );
            if (contact) {
              await loadMessageDetail({
                id: contact.id,
                user: {
                  name: contact.userName,
                  handle: contact.userHandle,
                  avatar: contact.userAvatar,
                },
              });
            }
          }
        }
      }
      // 显示成功提示
      showXToast("文章已转发", "success");
      console.log("✅ [文章转发] 转发成功");
    } catch (error) {
      console.error("转发文章失败:", error);
      showXToast("转发失败", "error");
    }
  }; // ============================================
  // 推文/评论转发功能
  // ============================================
  // 当前要转发的内容数据
  let currentShareContentData = null; // 显示转发推文/评论弹窗
  window.showShareContentModal = async function (contentData, contentType) {
    console.log("📤 [内容转发] 准备转发:", contentType, contentData);
    currentShareContentData = { ...contentData, contentType };
    try {
      // 获取私信列表
      const xDb = getXDB();
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      const messagesList = savedData?.data || [];
      if (messagesList.length === 0) {
        showXToast("暂无私信联系人", "info");
        return;
      }
      // 创建弹窗
      const modal = document.createElement("div");
      modal.id = "share-content-modal";
      modal.style.cssText = `
 display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--x-modal-overlay); z-index: 22; align-items: center; justify-content: center; backdrop-filter: blur(4px); `; // 根据内容类型生成预览内容
      let previewHTML = "";
      if (contentType === "tweet") {
        previewHTML = `
 <div style="padding: 12px; background-color:var(--x-bg-secondary); border-radius: 12px; margin-bottom: 16px; border: 1px solid var(--x-border-color); ">
 <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
 <img src="${
   contentData.user.avatar
 }" style="width: 32px; height: 32px; border-radius: 50%;" alt="${
          contentData.user.name
        }">
 <div>
 <div style="font-size: 14px; font-weight: 600; color:var(--x-text-primary);">${
   contentData.user.name
 }</div>
 <div style="font-size: 12px; color:var(--x-text-secondary);">${
   contentData.user.handle
 }</div>
 </div>
 </div>
 <div style="font-size: 14px; color:var(--x-text-primary); overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; line-height: 1.4; ">${
   contentData.content || "无内容"
 }</div>
 </div>
 `;
      } else if (contentType === "comment") {
        previewHTML = `
 <div style="padding: 12px; background-color:var(--x-bg-secondary); border-radius: 12px; margin-bottom: 16px; border: 1px solid var(--x-border-color); ">
 <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
 <img src="${
   contentData.user.avatar
 }" style="width: 32px; height: 32px; border-radius: 50%;" alt="${
          contentData.user.name
        }">
 <div>
 <div style="font-size: 14px; font-weight: 600; color:var(--x-text-primary);">${
   contentData.user.name
 }</div>
 <div style="font-size: 12px; color:var(--x-text-secondary);">${
   contentData.user.handle
 }</div>
 </div>
 </div>
 <div style="font-size: 14px; color:var(--x-text-primary); overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; line-height: 1.4; ">${
   contentData.content || "无内容"
 }</div>
 </div>
 `;
      }
      modal.innerHTML = `
 <div class="modal-content" onclick="event.stopPropagation()" style="background-color:var(--x-bg-primary); border-radius: 16px; width: 90%; max-width: 500px; max-height: 80vh; overflow: hidden; border: 1px solid var(--x-border-color); display: flex; flex-direction: column; ">

 <div class="modal-header" style="display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid var(--x-border-color); background-color:var(--x-bg-primary); ">
 <div style="display: flex; align-items: center; gap: 20px;">

 <div class="modal-close-btn" onclick="closeShareContentModal()" style="cursor: pointer; padding: 8px; border-radius: 50%; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">
 <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: var(--x-text-primary);">
 <g><path d="M10.59 12L4.54 5.96l1.42-1.42L12 10.59l6.04-6.05 1.42 1.42L13.41 12l6.05 6.04-1.42 1.42L12 13.41l-6.04 6.05-1.42-1.42L10.59 12z"></path></g>
 </svg>
 </div>

 <h2 style="color:var(--x-text-primary); font-size: 20px; font-weight: 700; margin: 0; ">转发${
   contentType === "tweet" ? "推文" : "评论"
 }</h2>
 </div>
 </div>

 <div class="modal-body" style="padding: 16px 20px; overflow-y: auto; flex: 1; ">

 ${previewHTML}

 <div style="margin-bottom: 16px;">
 <label style="display: block; color:var(--x-text-secondary); font-size: 13px; margin-bottom: 8px; ">附加文字（可选）</label>
 <textarea id="share-content-message" placeholder="添加一些说明..." style="width: 100%; min-height: 80px; background-color:var(--x-bg-secondary); border: 1px solid var(--x-border-color); border-radius: 12px; color:var(--x-text-primary); padding: 12px; font-size: 15px; resize: vertical; outline: none; box-sizing: border-box; font-family: inherit; " onfocus="this.style.borderColor='var(--x-accent)'" onblur="this.style.borderColor='var(--x-border-color)'"></textarea>
 </div>

 <div style="color:var(--x-text-secondary); font-size: 13px; margin-bottom: 12px; ">选择要转发到的联系人</div>

 <div id="share-content-contacts-list" style="display: flex; flex-direction: column; gap: 0; ">
 ${messagesList
   .map(
     (contact) => `
 <div class="contact-select-item" data-contact-id="${contact.id}" onclick="selectContactForContentShare('${contact.id}')" style="display: flex; align-items: center; gap: 12px; padding: 12px; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; " onmouseover="this.style.backgroundColor='var(--x-bg-hover)'"
 onmouseout="this.style.backgroundColor='transparent'">

 <img src="${contact.userAvatar}"
 alt="${contact.userName}"
 style="width: 40px; height: 40px; border-radius: 50%; flex-shrink: 0; object-fit: cover; ">

 <div style="flex: 1; min-width: 0;">
 <div style="font-size: 15px; font-weight: 700; color:var(--x-text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">${contact.userName}</div>
 <div style="font-size: 13px; color:var(--x-text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ">@${contact.userHandle}</div>
 </div>
 </div>
 `
   )
   .join("")}
 </div>
 </div>
 </div>
 `; // 将弹窗添加到X应用容器内
      const xSocialScreen = document.getElementById("x-social-screen");
      if (xSocialScreen) {
        xSocialScreen.appendChild(modal);
      } else {
        document.body.appendChild(modal);
      }
      // 点击背景关闭弹窗
      modal.addEventListener("click", (e) => {
        if (e.target === modal) {
          closeShareContentModal();
        }
      });
    } catch (error) {
      console.error("显示转发弹窗失败:", error);
      showXToast("打开转发失败", "error");
    }
  }; // 关闭转发推文/评论弹窗
  window.closeShareContentModal = function () {
    const modal = document.getElementById("share-content-modal");
    if (modal) {
      modal.remove();
    }
    currentShareContentData = null;
  }; // 选择联系人转发推文/评论
  window.selectContactForContentShare = async function (contactId) {
    if (!currentShareContentData) {
      showXToast("转发数据丢失", "error");
      return;
    }
    console.log("📤 [内容转发] 转发到联系人:", contactId); // 保存数据的本地副本，因为后续会关闭弹窗并清空 currentShareContentData
    const contentData = { ...currentShareContentData };
    try {
      const xDb = getXDB(); // 获取附加文字
      const messageInput = document.getElementById("share-content-message");
      const additionalMessage = messageInput ? messageInput.value.trim() : ""; // 获取当前时间
      const now = new Date();
      const hours = now.getHours();
      const minutes = String(now.getMinutes()).padStart(2, "0");
      const period = hours >= 12 ? "下午" : "上午";
      const timeStr = `${hours > 12 ? hours - 12 : hours}:${minutes} ${period}`; // 创建转发消息对象
      const forwardMessage = {
        type: "forward",
        forwardType: contentData.contentType, // 'tweet' 或 'comment'
        forwardContent: {
          user: contentData.user,
          content: contentData.content,
          time: contentData.time,
          image: contentData.image || null,
        },
        // 包含完整上下文信息
        fullContext: {},
        time: timeStr,
        timestamp: now.toISOString(),
        isOwn: true,
      }; // 根据类型添加完整上下文
      if (contentData.contentType === "tweet") {
        // 转发推文：包含完整推文和所有评论
        forwardMessage.fullContext = {
          tweet: contentData.fullTweet || {
            user: contentData.user,
            content: contentData.content,
            time: contentData.time,
            image: contentData.image,
          },
          comments: contentData.comments || [],
        };
      } else if (contentData.contentType === "comment") {
        // 转发评论：包含评论和所属推文
        forwardMessage.fullContext = {
          comment: {
            user: contentData.user,
            content: contentData.content,
            time: contentData.time,
            image: contentData.image,
          },
          parentTweet: contentData.parentTweet || null,
        };
      }
      // 读取现有对话数据
      // 🔧 多账户隔离：包含账户ID
      const conversationId = `messageConversation_${
        currentAccountId || "main"
      }_${contactId}`;
      let savedConversation = await xDb.xAccountProfiles.get(conversationId);
      if (!savedConversation) {
        // 创建新的对话记录
        savedConversation = {
          handle: conversationId,
          name: "messageConversation",
          data: {
            messages: [],
          },
          messageId: contactId,
          accountId: currentAccountId || "main", // 添加账户ID
          updatedAt: new Date().toISOString(),
        };
      }
      // 确保messages数组存在
      if (!savedConversation.data.messages) {
        savedConversation.data.messages = [];
      }
      // 添加转发消息
      savedConversation.data.messages.push(forwardMessage); // 如果有附加文字，也添加文字消息
      if (additionalMessage) {
        const textMessage = {
          type: "text",
          content: additionalMessage,
          time: timeStr,
          timestamp: now.toISOString(),
          isOwn: true,
        };
        savedConversation.data.messages.push(textMessage);
      }
      // 标记最后一条消息为等待AI回复
      const lastMessageIndex = savedConversation.data.messages.length - 1;
      if (lastMessageIndex >= 0) {
        savedConversation.data.messages[
          lastMessageIndex
        ].waitingForAIResponse = true;
      }
      // 保存到数据库
      savedConversation.updatedAt = new Date().toISOString();
      await xDb.xAccountProfiles.put(savedConversation); // 更新私信列表的最后消息和时间
      const dataId = `messagesList_${currentAccountId || "main"}`;
      const savedData = await xDb.xAccountProfiles.get(dataId);
      if (savedData && savedData.data) {
        const messagesList = savedData.data;
        const contactIndex = messagesList.findIndex(
          (msg) => msg.id === contactId
        );
        if (contactIndex !== -1) {
          messagesList[contactIndex].lastMessage =
            additionalMessage ||
            `[转发了${contentData.contentType === "tweet" ? "推文" : "评论"}]`;
          messagesList[contactIndex].timestamp = now.toISOString(); // 将该联系人移到列表顶部
          const contact = messagesList.splice(contactIndex, 1)[0];
          messagesList.unshift(contact); // 保存更新后的列表
          await xDb.xAccountProfiles.put({
            handle: dataId,
            name: "messagesList",
            data: messagesList,
            updatedAt: new Date().toISOString(),
          }); // 更新全局变量
          sampleMessagesData = messagesList;
        }
      }
      // 关闭弹窗
      closeShareContentModal(); // 如果用户当前正在查看这个聊天详情页，重新加载页面
      const detailPage = document.getElementById("x-message-detail-page");
      if (detailPage && detailPage.style.display !== "none") {
        // 检查当前打开的是否是这个联系人的聊天
        const currentConversationId = detailPage.dataset.conversationId;
        if (currentConversationId === contactId) {
          // 重新加载聊天详情页
          const dataId = `messagesList_${currentAccountId || "main"}`;
          const messageData = await xDb.xAccountProfiles.get(dataId);
          if (messageData && messageData.data) {
            const contact = messageData.data.find(
              (msg) => msg.id === contactId
            );
            if (contact) {
              await loadMessageDetail({
                id: contact.id,
                user: {
                  name: contact.userName,
                  handle: contact.userHandle,
                  avatar: contact.userAvatar,
                },
              });
            }
          }
        }
      }
      // 显示成功提示
      showXToast(
        `${contentData.contentType === "tweet" ? "推文" : "评论"}已转发`,
        "success"
      );
      console.log("✅ [内容转发] 转发成功");
    } catch (error) {
      console.error("转发失败:", error);
      showXToast("转发失败", "error");
    }
  }; // ============================================

  // 第五部分: 暴露全局接口
  // ============================================
  // 将必要的函数暴露到全局作用域
  window.renderXSocialScreenProxy = renderXSocialScreen;
  window.switchXPage = switchXPage;
  window.switchHomeTab = switchHomeTab;
  window.refreshXTweets = refreshXTweets;
  window.showTweetComments = showTweetComments;
  window.submitComment = submitComment;
  window.handleCommentInput = handleCommentInput;
  window.autoResize = autoResize;
  window.showReplyInput = showReplyInput;
  window.cancelReply = cancelReply;
  window.submitReply = submitReply;
  window.handleReplyInput = handleReplyInput;
  window.autoResizeReply = autoResizeReply;
  window.toggleLike = toggleLike;
  window.toggleCommentLike = toggleCommentLike;
  window.deleteUserComment = deleteUserComment;
  window.showSensitiveContent = showSensitiveContent;
  window.handleQuotedTweetClick = handleQuotedTweetClick;
  window.handleQuoteRetweetFromData = handleQuoteRetweetFromData;
  window.openComposeTweetModal = openComposeTweetModal;
  window.closeComposeTweetModal = closeComposeTweetModal;
  window.publishTweet = publishTweet;
  window.handleComposeInput = handleComposeInput;
  window.processHashtagsAndMentions = processHashtagsAndMentions;
  window.toggleImageSection = toggleImageSection;
  window.selectImageMethod = selectImageMethod;
  window.triggerImageUpload = triggerImageUpload;
  window.handleImageUpload = handleImageUpload;
  window.saveImageData = saveImageData;
  window.removeImage = removeImage;
  window.toggleLocationSection = toggleLocationSection;
  window.saveLocationData = saveLocationData;
  window.removeLocation = removeLocation;
  window.toggleLinkSection = toggleLinkSection;
  window.saveLinkData = saveLinkData;
  window.removeLink = removeLink;
  window.triggerLinkImageUpload = triggerLinkImageUpload;
  window.handleLinkImageUpload = handleLinkImageUpload;
  window.removeQuoteContent = removeQuoteContent;
  window.togglePrivacySettings = togglePrivacySettings;
  window.editProfile = editProfile;
  window.openEditProfileModal = openEditProfileModal;
  window.closeEditProfileModal = closeEditProfileModal;
  window.saveProfileChanges = saveProfileChanges;
  window.switchProfileTab = switchProfileTab;
  window.toggleProfileMenu = toggleProfileMenu;
  window.openAccountManager = openAccountManager;
  window.openAccountWallet = openAccountWallet;
  window.closeWalletModal = closeWalletModal;
  window.activateWallet = activateWallet;
  window.addFunds = addFunds;
  window.sendMoney = sendMoney;
  window.shareWallet = shareWallet;
  window.exportWallet = exportWallet;
  window.copyWalletInfo = copyWalletInfo;
  window.updateCharacterCounts = updateCharacterCounts;
  window.toggleRealNameInput = toggleRealNameInput;
  window.updateTag1ColorFromText = updateTag1ColorFromText;
  window.updateTag1ColorFromPicker = updateTag1ColorFromPicker;
  window.updateTag2ColorFromText = updateTag2ColorFromText;
  window.updateTag2ColorFromPicker = updateTag2ColorFromPicker;
  window.editCoverImage = editCoverImage;
  window.removeCoverImage = removeCoverImage;
  window.editAvatarImage = editAvatarImage;
  window.updateVerificationTypeUI = updateVerificationTypeUI;
  window.toggleCharacterBinding = toggleCharacterBinding;
  window.toggleCharacterSelection = toggleCharacterSelection;
  window.openCharacterXProfile = openCharacterXProfile;
  window.closeCharacterXProfileModal = closeCharacterXProfileModal;
  window.saveCharacterXProfile = saveCharacterXProfile;
  window.updateCharacterXAvatar = updateCharacterXAvatar;
  window.updateCharacterBioCount = updateCharacterBioCount;
  window.toggleCharacterRealNameInput = toggleCharacterRealNameInput;
  window.openAddRelationshipModal = openAddRelationshipModal;
  window.editRelationship = editRelationship;
  window.deleteRelationship = deleteRelationship;
  window.closeRelationshipModal = closeRelationshipModal;
  window.updateRelationshipDescCount = updateRelationshipDescCount;
  window.saveRelationshipForm = saveRelationshipForm;
  window.saveXSettings = saveXSettings;
  window.saveXPreset = saveXPreset;
  window.loadXPreset = loadXPreset;
  window.deleteXPreset = deleteXPreset;
  window.exportXData = exportXData;
  window.importXData = importXData;
  window.toggleXTheme = toggleXTheme;
  window.showTweetDetail = showTweetDetail;
  window.handleDetailCommentInput = handleDetailCommentInput;
  window.autoResizeDetail = autoResizeDetail;
  window.submitDetailComment = submitDetailComment;
  window.toggleDetailLike = toggleDetailLike;
  window.rerollAIReplies = rerollAIReplies;
  window.toggleTweetSelection = toggleTweetSelection;
  window.enterMultiSelectMode = enterMultiSelectMode;
  window.exitMultiSelectMode = exitMultiSelectMode;
  window.selectAllTweets = selectAllTweets;
  window.deleteSelectedTweets = deleteSelectedTweets;
  window.showXToast = showXToast;
  window.toggleIdentityCharacter = toggleIdentityCharacter;
  window.closeAccountManager = closeAccountManager;
  window.switchAccount = switchAccount;
  window.createNewAccount = createNewAccount;
  window.deleteAccount = deleteAccount;
  window.triggerCommentImageUpload = triggerCommentImageUpload;
  window.handleCommentImageUpload = handleCommentImageUpload;
  window.removeCommentImage = removeCommentImage;
  window.triggerDetailCommentImageUpload = triggerDetailCommentImageUpload;
  window.handleDetailCommentImageUpload = handleDetailCommentImageUpload;
  window.removeDetailCommentImage = removeDetailCommentImage;
  window.openCommentStickers = openCommentStickers; // 角色关系册相关函数
  window.toggleCharacterRelationship = toggleCharacterRelationship;
  window.openCharacterRelationshipGraph = openCharacterRelationshipGraph;
  window.closeCharacterRelationshipGraph = closeCharacterRelationshipGraph;
  window.addRelationshipLink = addRelationshipLink;
  window.openEditRelationshipDetailModal = openEditRelationshipDetailModal;
  window.closeEditRelationshipDetail = closeEditRelationshipDetail;
  window.saveRelationshipDetail = saveRelationshipDetail;
  window.deleteRelationshipLink = deleteRelationshipLink;
  window.clearAllRelationships = clearAllRelationships;
  window.saveRelationshipGraph = saveRelationshipGraph;
  window.characterRelationshipData = characterRelationshipData; // NPC绑定相关函数
  window.toggleNPCBinding = toggleNPCBinding;
  window.openCreateNPCModal = openCreateNPCModal;
  window.editNPC = editNPC;
  window.saveNPC = saveNPC;
  window.deleteNPC = deleteNPC;
  window.closeNPCEditModal = closeNPCEditModal; // 提问箱相关函数
  window.loadAskboxData = loadAskboxData;
  window.changeAskboxAvatar = changeAskboxAvatar;
  window.saveAskboxNickname = saveAskboxNickname;
  window.saveAskboxPrompt = saveAskboxPrompt;
  window.openAskboxSettings = openAskboxSettings;
  window.getNewQuestion = getNewQuestion;
  window.saveQuestionAnswer = saveQuestionAnswer; // 提问箱多选删除相关函数
  window.startQuestionLongPress = startQuestionLongPress;
  window.endQuestionLongPress = endQuestionLongPress;
  window.toggleQuestionSelection = toggleQuestionSelection;
  window.enterAskboxMultiSelectMode = enterAskboxMultiSelectMode;
  window.exitAskboxMultiSelectMode = exitAskboxMultiSelectMode;
  window.selectAllQuestions = selectAllQuestions;
  window.deleteSelectedQuestions = deleteSelectedQuestions; // 搜索页面相关函数
  window.switchSearchTab = switchSearchTab;
  window.handleTrendingClick = handleTrendingClick;
  window.handleTrendingMore = handleTrendingMore;
  window.openAddCategoryModal = openAddCategoryModal;
  window.closeCategoryModal = closeCategoryModal;
  window.addNewCategory = addNewCategory;
  window.deleteCategory = deleteCategory;
  window.toggleCategory = toggleCategory;
  window.updateCategoryName = updateCategoryName;
  window.updateCategoryDescription = updateCategoryDescription;
  window.saveCustomCategories = saveCustomCategories;
  window.refreshTrends = refreshTrends;
  window.toggleSearchButton = toggleSearchButton;
  window.performSearch = performSearch;
  window.switchSearchResultTab = switchSearchResultTab;
  window.backToTrending = backToTrending; // 账户主页相关函数
  window.openAccountProfile = openAccountProfile;
  window.closeAccountProfile = closeAccountProfile;
  window.showAccountTweetDetail = showAccountTweetDetail;
  window.toggleAccountFollow = toggleAccountFollow;
  window.toggleAccountNotifications = toggleAccountNotifications;
  window.sendMessageToAccount = sendMessageToAccount;
  window.switchAccountTab = switchAccountTab;
  window.refreshAccountProfile = refreshAccountProfile;
  window.toggleProgressMode = toggleProgressMode;
  window.handleRefreshButtonMouseDown = handleRefreshButtonMouseDown;
  window.handleRefreshButtonMouseUp = handleRefreshButtonMouseUp;
  window.goBackFromTweetDetail = goBackFromTweetDetail; // 主题切换相关函数
  window.toggleXTheme = toggleXTheme; // 语言切换相关函数
  window.toggleXLanguage = toggleXLanguage;
  // 🔧 添加主题色相关函数导出
  window.openAccentColorPicker = openAccentColorPicker;
  window.closeAccentColorPicker = closeAccentColorPicker;
  window.applyAccentColor = applyAccentColor;
  // 直播相关函数
  window.switchLiveTab = switchLiveTab;
  window.joinLiveStream = joinLiveStream;
  window.initLivePage = initLivePage;
  window.renderLiveStreams = renderLiveStreams;
  // 直播自定义分类函数
  window.openLiveCategoryModal = openLiveCategoryModal;
  window.closeLiveCategoryModal = closeLiveCategoryModal;
  window.addNewLiveCategory = addNewLiveCategory;
  window.deleteLiveCategory = deleteLiveCategory;
  window.toggleLiveCategory = toggleLiveCategory;
  window.updateLiveCategoryName = updateLiveCategoryName;
  window.updateLiveCategoryDescription = updateLiveCategoryDescription;
  window.saveLiveCustomCategories = saveLiveCustomCategories;
  window.syncLivePageAvatar = syncLivePageAvatar;
  // 直播收纳按钮功能函数
  window.toggleLiveActionButtons = toggleLiveActionButtons;
  window.refreshLiveStreams = refreshLiveStreams;
  window.startLiveStream = startLiveStream;
  window.syncLiveCharacterAvatars = syncLiveCharacterAvatars;
  window.handleLiveCharacterClick = handleLiveCharacterClick;
  window.loadSavedLiveData = loadSavedLiveData;
  window.loadLiveCharacterStatus = loadLiveCharacterStatus;
  window.saveLiveCharacterStatus = saveLiveCharacterStatus;
  // 直播按钮事件处理函数
  window.handleLiveMainBtnMouseOver = handleLiveMainBtnMouseOver;
  window.handleLiveMainBtnMouseOut = handleLiveMainBtnMouseOut;
  window.handleLiveMainBtnTouchStart = handleLiveMainBtnTouchStart;
  window.handleLiveMainBtnTouchEnd = handleLiveMainBtnTouchEnd;
  window.handleLiveSubBtnMouseOver = handleLiveSubBtnMouseOver;
  window.handleLiveSubBtnMouseOut = handleLiveSubBtnMouseOut;
  window.handleLiveSubBtnTouchStart = handleLiveSubBtnTouchStart;
  window.handleLiveSubBtnTouchEnd = handleLiveSubBtnTouchEnd;
  // 直播按钮状态变量
  if (typeof window.liveBtnExpanded === "undefined") {
    window.liveBtnExpanded = false;
  }
  // 直播间相关函数
  window.closeLiveRoom = closeLiveRoom;
  window.toggleLiveInfo = toggleLiveInfo;
  window.sendDanmaku = sendDanmaku;
  window.sendLike = sendLike;
  window.showLiveRoomMenu = showLiveRoomMenu;
  // 道具系统相关函数
  window.openToolModal = openToolModal;
  window.closeToolModal = closeToolModal;
  window.rollOne = rollOne;
  window.rollTen = rollTen;
  window.shakeBall = shakeBall;
  window.previousPage = previousPage;
  window.nextPage = nextPage;
  window.openCoinExchange = openCoinExchange;
  // 创建 XSocialApp 对象以兼容HTML检查
  window.XSocialApp = {
    init: initXSocialApp,
    render: renderXSocialScreen,
    version: "1.0",
    isLoaded: true,
  }; // 自动初始化（如果DOM已加载）
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initXSocialApp);
  } else {
    // 延迟初始化，确保其他脚本先加载
    setTimeout(initXSocialApp, 100);
  }
  console.log("📦 X Social App 模块已加载，版本: 1.0");
  // 清空当前账户的钱包数据（调试用）
  window.clearCurrentWalletData = async function () {
    try {
      const db = getXDB();
      const accountId = currentAccountId || "main";
      const walletId = `wallet_${accountId}`; // 删除钱包数据
      await db.xAccountProfiles.delete(walletId); // 重新加载空的钱包数据
      await loadWalletData();
      console.log("✅ 已清空账户钱包数据:", accountId);
      showXToast("钱包数据已清空", "success");
    } catch (error) {
      console.error("❌ 清空钱包数据失败:", error);
      showXToast("清空失败: " + error.message, "error");
    }
  };
})(window); // ==========================================
// 使用说明:

// 1. 在HTML中引入此文件:
// <script src="x-social-app.js" defer></script>

// 2. 系统会自动初始化,创建X社交页面HTML结构

// 3. 通过以下方式调用:
// - 显示X社交页面: showScreen('x-social-screen')
// - 渲染代理: window.renderXSocialScreenProxy()

// 4. 需要的依赖:
// - Dexie.js (数据库)
// - 确保有 showScreen() 全局函数
